const std = @import("std");
const Allocator = std.mem.Allocator;

const root = @import("root");
const XmlDatabase = @import("vk_database.zig").XmlDatabase;
const TypeDatabase = @import("vk_database.zig").TypeDatabase;

const IN_PATH = "thirdparty/vulkan-object/src/vulkan_object/vk.xml";
const OUT_PATH = "src/vk_utils.zig";
const HEADER =
    \\// This file is auto generated by gen/{s}
    \\
    \\const std = @import("std");
    \\const vk = @import("vk.zig");
    \\const log = @import("log.zig");
    \\
    \\
;

pub fn main() !void {
    var arena: std.heap.ArenaAllocator = .init(std.heap.page_allocator);
    const alloc = arena.allocator();

    const xml_file = try std.fs.cwd().openFile(IN_PATH, .{});
    const buffer = try alloc.alloc(u8, (try xml_file.stat()).size);
    _ = try xml_file.readAll(buffer);

    const xml_db: XmlDatabase = try .init(alloc, buffer);
    var type_db: TypeDatabase = try .from_xml_database(alloc, &xml_db);

    std.fs.cwd().deleteFile(OUT_PATH) catch {};
    const file = try std.fs.cwd().createFile(OUT_PATH, .{});
    defer file.close();

    const header = std.fmt.comptimePrint(HEADER, .{@src().file});
    _ = try file.write(header);

    var tmp_arena: std.heap.ArenaAllocator = .init(std.heap.page_allocator);
    const tmp_alloc = tmp_arena.allocator();

    try write_print_struct(tmp_alloc, &file, &type_db);
    _ = tmp_arena.reset(.retain_capacity);
}

const Writer = struct {
    alloc: Allocator,
    file: *const std.fs.File,

    const Self = @This();

    fn write(self: *Self, comptime fmt: []const u8, args: anytype) void {
        const line = std.fmt.allocPrint(self.alloc, fmt, args) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
        _ = self.file.write(line) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
    }
};

fn write_print_struct(
    alloc: Allocator,
    file: *const std.fs.File,
    type_db: *const TypeDatabase,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    for (type_db.structs.items) |*s| {
        w.write(
            \\pub fn print_{[name]s}(name: []const u8, value: *const vk.{[name]s}, offset: u32) void {{
            \\    for (0..offset) |_| log.output("    ", .{{}});
            \\    log.output("{{s}}: {[name]s} = .{{{{\n", .{{ name }});
            \\
        , .{ .name = s.name });
        var packed_fields: u32 = 0;
        for (s.fields) |field| {
            if (field == .single_field) {
                const sf = field.single_field;
                if (std.mem.eql(u8, sf.name, "pNext"))
                    continue;
                const field_type = type_db.get_type_follow_alias(sf.type_idx);
                const type_str = try type_db.type_string(alloc, sf.type_idx);
                switch (field_type.*) {
                    .base => |base| {
                        switch (base) {
                            .builtin => |builtin| {
                                if (builtin != .void and builtin != .anyopaque) {
                                    if (std.mem.endsWith(u8, sf.name, "Version")) {
                                        w.write(
                                            \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                                            \\    log.output("    {[field_name]s}: {[field_type]s} = {{any}},\n", .{{value.{[field_name]s}}});
                                            \\
                                        , .{ .field_name = sf.name, .field_type = type_str });
                                    } else {
                                        w.write(
                                            \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                                            \\    log.output("    {[field_name]s}: {[field_type]s} = {{d}},\n", .{{value.{[field_name]s}}});
                                            \\
                                        , .{ .field_name = sf.name, .field_type = type_str });
                                    }
                                }
                            },
                            .constant_idx => |_| {},
                            .handle_idx => |_| {
                                w.write(
                                    \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                                    \\    log.output("    {[field_name]s}: {[field_type]s} = {{}},\n", .{{value.{[field_name]s}}});
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                            },
                            .struct_idx => |_| {
                                w.write(
                                    \\    print_{[field_type]s}("{[field_name]s}", &value.{[field_name]s}, offset + 1);
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                            },
                            .bitfield_idx => |_| {
                                w.write(
                                    \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                                    \\    log.output("    {[field_name]s}: {[field_type]s} = {{any}},\n", .{{value.{[field_name]s}}});
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                            },
                            .enum_idx => |_| {
                                w.write(
                                    \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                                    \\    log.output("    {[field_name]s}: {[field_type]s} = {{t}},\n", .{{value.{[field_name]s}}});
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                            },
                            .union_idx => |union_idx| {
                                const union_type = type_db.get_union(union_idx);
                                if (sf.selector) |selector| {
                                    w.write(
                                        \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                                        \\    switch (value.{s}) {{
                                        \\
                                    , .{selector});
                                    const selector_field = s.single_field_by_name(selector).?;
                                    const selector_type = type_db.get_type(selector_field.type_idx);
                                    const selector_enum_idx = selector_type.enum_idx();
                                    const selector_enum = type_db.get_enum(selector_enum_idx);
                                    for (selector_enum.values) |sv| {
                                        if (union_type.member_by_selection(sv.name)) |m| {
                                            w.write(
                                                \\        .{[enum_value_name]s} => log.output("    {[field_name]s}: {[field_type]s} = {{any}},\n", .{{value.{[field_name]s}.{[union_member_name]s}}}),
                                                \\
                                            , .{
                                                .enum_value_name = sv.name,
                                                .field_name = sf.name,
                                                .field_type = type_str,
                                                .union_member_name = m.name,
                                            });
                                        }
                                    }
                                    w.write(
                                        \\        else => log.output("    {[field_name]s}: {[field_type]s} = ???,\n", .{{}}),
                                        \\
                                    , .{ .field_name = sf.name, .field_type = type_str });
                                    w.write(
                                        \\    }}
                                        \\
                                    , .{});
                                } else {
                                    w.write(
                                        \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                                        \\    log.output("    {[field_name]s}: {[field_type]s} = {{any}},\n", .{{value.{[field_name]s}}});
                                        \\
                                    , .{ .field_name = sf.name, .field_type = type_str });
                                }
                            },
                            .function_idx => |_| {},
                        }
                    },
                    .pointer => |pointer| {
                        const pointer_type = type_db.get_type(pointer.base_type_idx);
                        w.write(
                            \\    if (value.{[field_name]s}) |v| {{
                            \\
                        , .{ .field_name = sf.name });
                        if (pointer.is_slice) {
                            if (pointer.is_zero_terminated) {
                                if (pointer_type.* == .base and
                                    pointer_type.base == .builtin and
                                    pointer_type.base.builtin == .u8)
                                {
                                    w.write(
                                        \\        for (0..offset + 1) |_| log.output("    ", .{{}});
                                        \\        log.output("    {[field_name]s}: {[field_type]s} = {{s}}n", .{{v}});
                                        \\    }}
                                        \\
                                    , .{ .field_name = sf.name, .field_type = type_str });
                                    continue;
                                }
                                w.write(
                                    \\        for (std.mem.span(v)) |*vv| {{
                                    \\
                                , .{});
                            } else if (sf.len_expression) |len| {
                                const Inner = struct {
                                    fn format_len(
                                        a: Allocator,
                                        td: *const TypeDatabase,
                                        ss: *const TypeDatabase.Struct,
                                        l: []const u8,
                                    ) []const u8 {
                                        const first_comma =
                                            std.mem.indexOfScalar(u8, l, ',') orelse l.len;
                                        var result = l[0..first_comma];
                                        if (result[0] == '(') {
                                            const space =
                                                std.mem.indexOfScalar(u8, result[1..], ' ') orelse
                                                unreachable;
                                            const f = result[1..][0..space];
                                            const ff = ss.single_field_by_name(f).?;
                                            const fft = td.get_type(ff.type_idx);
                                            if (fft.is_builtin()) {
                                                result = std.fmt.allocPrint(
                                                    a,
                                                    "(@as(u64, @intCast(value.{s})){s}",
                                                    .{ f, result[1 + space ..] },
                                                ) catch unreachable;
                                            } else {
                                                result = std.fmt.allocPrint(
                                                    a,
                                                    "(@as(u32, @bitCast(value.{s})){s}",
                                                    .{ f, result[1 + space ..] },
                                                ) catch unreachable;
                                            }
                                        } else if (std.mem.eql(u8, result, "2*VK_UUID_SIZE")) {
                                            result = "2 * vk.VK_UUID_SIZE";
                                        } else {
                                            result = std.fmt.allocPrint(
                                                a,
                                                "value.{s}",
                                                .{result},
                                            ) catch unreachable;
                                        }
                                        return result;
                                    }
                                };
                                const l = Inner.format_len(alloc, type_db, s, len);
                                w.write(
                                    \\        for (v[0..{[len]s}]) |*vv| {{
                                    \\
                                , .{ .len = l });
                            } else {
                                w.write(
                                    \\            for (0..offset + 1) |_| log.output("    ", .{{}});
                                    \\            log.output("    {[field_name]s}: {[field_type]s} = ???,\n", .{{}});
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                                continue;
                            }
                            if (pointer_type.struct_idx() != .none) {
                                const base_type_str = try type_db.type_string(
                                    alloc,
                                    pointer.base_type_idx,
                                );
                                w.write(
                                    \\            print_{[base_type]s}("{[field_name]s}", vv, offset + 1);
                                    \\
                                , .{
                                    .field_name = sf.name,
                                    .base_type = base_type_str,
                                });
                            } else {
                                w.write(
                                    \\            for (0..offset + 1) |_| log.output("    ", .{{}});
                                    \\            log.output("    {[field_name]s}: {[field_type]s} = {{any}},\n", .{{vv}});
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                            }
                            w.write(
                                \\        }}
                                \\
                            , .{});
                        } else {
                            if (pointer_type.struct_idx() != .none) {
                                const base_type_str = try type_db.type_string(
                                    alloc,
                                    pointer.base_type_idx,
                                );
                                w.write(
                                    \\        print_{[base_type]s}("{[field_name]s}", v, offset + 1);
                                    \\
                                , .{ .field_name = sf.name, .base_type = base_type_str });
                            } else if (pointer_type.* == .array) {
                                w.write(
                                    \\        for (0..offset + 1) |_| log.output("    ", .{{}});
                                    \\        log.output("    {[field_name]s}: {[field_type]s} = {{any}},\n", .{{v}});
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                            } else if (pointer_type.is_builtin()) {
                                const b = pointer_type.base.builtin;
                                if (b == .anyopaque) {
                                    w.write(
                                        \\        for (0..offset + 1) |_| log.output("    ", .{{}});
                                        \\        log.output("    {[field_name]s}: {[field_type]s} = {{*}},\n", .{{v}});
                                        \\
                                    , .{ .field_name = sf.name, .field_type = type_str });
                                } else {
                                    w.write(
                                        \\        for (0..offset + 1) |_| log.output("    ", .{{}});
                                        \\        log.output("    {[field_name]s}: {[field_type]s} = {{d}},\n", .{{v.*}});
                                        \\
                                    , .{ .field_name = sf.name, .field_type = type_str });
                                }
                            } else {
                                w.write(
                                    \\        for (0..offset + 1) |_| log.output("    ", .{{}});
                                    \\        log.output("    {[field_name]s}: {[field_type]s} = {{*}},\n", .{{v}});
                                    \\
                                , .{ .field_name = sf.name, .field_type = type_str });
                            }
                        }
                        w.write(
                            \\    }} else {{
                            \\        for (0..offset + 1) |_| log.output("    ", .{{}});
                            \\        log.output("    {[field_name]s}: {[field_type]s} = null,\n", .{{}});
                            \\    }}
                            \\
                        , .{ .field_name = sf.name, .field_type = type_str });
                    },
                    .array => |_| {
                        w.write(
                            \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                            \\    log.output("    {[field_name]s}: {[field_type]s} = {{any}},\n", .{{value.{[field_name]s}}});
                            \\
                        , .{ .field_name = sf.name, .field_type = type_str });
                    },
                    else => {},
                }
            } else {
                const field_name = try std.fmt.allocPrint(
                    alloc,
                    "packed_field{d}",
                    .{packed_fields},
                );
                w.write(
                    \\    for (0..offset + 1) |_| log.output("    ", .{{}});
                    \\    log.output("    {[field_name]s}: <packed> = {{any}},\n", .{{value.{[field_name]s}}});
                    \\
                , .{ .field_name = field_name });
                packed_fields += 1;
            }
        }
        w.write(
            \\    for (0..offset) |_| log.output("    ", .{{}});
            \\    log.output("}}}}\n", .{{}});
            \\}}
            \\
        , .{});
    }
    w.write(
        \\pub fn print_struct(value: anytype, follow_pnext: bool) void {{
        \\    var base: *const vk.VkBaseOutStructure = @ptrCast(value);
        \\    blk: switch (base.sType) {{
        \\
    , .{});
    for (type_db.structs.items) |s| {
        for (s.fields) |field| {
            if (field == .single_field) {
                const sf = field.single_field;
                if (std.mem.eql(u8, sf.name, "sType")) {
                    if (sf.stype_value) |stype|
                        w.write(
                            \\        .{[stype]s} => {{
                            \\            print_{[name]s}("", @ptrCast(base), 0);
                            \\            if (follow_pnext) {{
                            \\                if (base.pNext) |pnext| {{
                            \\                    base = pnext;
                            \\                    continue :blk base.sType;
                            \\                }}
                            \\            }}
                            \\        }},
                            \\
                        , .{ .stype = stype, .name = s.name });
                }
            }
        }
    }
    w.write(
        \\        else => {{
        \\            log.output("Unknown type: {{t}}", .{{base.sType}});
        \\        }},
        \\    }}
        \\}}
        \\
    , .{});
}
