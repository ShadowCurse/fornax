const std = @import("std");
const Allocator = std.mem.Allocator;

const root = @import("root");
const XmlDatabase = @import("vk_database.zig").XmlDatabase;

const PATH = "src/vulkan_utils.zig";
const HEADER =
    \\// This file is auto generated by gen/{s}
    \\
    \\const std = @import("std");
    \\const vk = @import("vk.zig");
    \\const log = @import("log.zig");
    \\
    \\const Allocator = std.mem.Allocator;
    \\
;

pub fn gen(db: *const XmlDatabase) !void {
    std.fs.cwd().deleteFile(PATH) catch {};
    const file = try std.fs.cwd().createFile(PATH, .{});
    defer file.close();

    _ = try file.write(root.NOTE);
    const header = std.fmt.comptimePrint(HEADER, .{@src().file});
    _ = try file.write(header);

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const alloc = arena.allocator();

    _ = try file.write(PRINT_STRUCT);

    try write_print_chain(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_stype_to_name(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
}

const PRINT_STRUCT =
    \\pub fn print_struct(@"struct": anytype) void {
    \\    print_struct_inner("", @"struct", 0);
    \\}
    \\
    \\fn print_offset_output(offset: u32, comptime format: []const u8, args: anytype) void {
    \\    for (0..offset) |_| log.output("    ", .{});
    \\    log.output(format, args);
    \\}
    \\
    \\fn print_offset_struct(offset: u32, field_name: []const u8, @"struct": anytype) void {
    \\    for (0..offset) |_| log.output("    ", .{});
    \\    print_struct_inner(
    \\        field_name,
    \\        @"struct",
    \\        offset,
    \\    );
    \\}
    \\
    \\fn print_offset_slice(
    \\    offset: u32,
    \\    field_name: []const u8,
    \\    type_name: []const u8,
    \\    comptime T: type,
    \\    elements: []const T,
    \\) void {
    \\    print_offset_output(offset, "{s}: []{s} = [\n", .{ field_name, type_name });
    \\    defer print_offset_output(offset, "]\n", .{});
    \\    for (elements) |*binding| {
    \\        for (0..offset + 1) |_| log.output("    ", .{});
    \\        print_struct_inner(&.{}, binding, offset + 1);
    \\    }
    \\}
    \\
    \\fn print_struct_inner(name: []const u8, @"struct": anytype, base_offset: u32) void {
    \\    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    \\    const type_name = @typeName(t)["cimport.struct_".len..];
    \\    log.output("{s}: {s} = .{{\n", .{ name, type_name });
    \\    const fields = @typeInfo(t).@"struct".fields;
    \\    const fields_base_offset = base_offset + 1;
    \\    inline for (fields) |field| {
    \\        switch (field.type) {
    \\            i16, i32, u32, u64, usize, vk.VkStructureType => {
    \\                print_offset_output(fields_base_offset, "{s}: {s} = {d},\n", .{
    \\                    field.name,
    \\                    @typeName(field.type),
    \\                    @field(@"struct", field.name),
    \\                });
    \\            },
    \\            f32, f64 => {
    \\                print_offset_output(
    \\                    fields_base_offset,
    \\                    "{s}: {d},\n",
    \\                    .{ field.name, @field(@"struct", field.name) },
    \\                );
    \\            },
    \\            vk.VkOffset2D,
    \\            vk.VkExtent2D,
    \\            vk.VkOffset3D,
    \\            vk.VkExtent3D,
    \\            vk.VkPhysicalDeviceFeatures,
    \\            => print_offset_struct(
    \\                fields_base_offset,
    \\                field.name,
    \\                &@field(@"struct", field.name),
    \\            ),
    \\            ?*anyopaque,
    \\            ?*const anyopaque,
    \\            vk.VkBuffer,
    \\            vk.VkImage,
    \\            vk.VkInstance,
    \\            vk.VkPhysicalDevice,
    \\            vk.VkDevice,
    \\            vk.VkQueue,
    \\            vk.VkSemaphore,
    \\            vk.VkCommandBuffer,
    \\            vk.VkFence,
    \\            vk.VkDeviceMemory,
    \\            vk.VkEvent,
    \\            vk.VkQueryPool,
    \\            vk.VkBufferView,
    \\            vk.VkImageView,
    \\            vk.VkShaderModule,
    \\            vk.VkPipelineCache,
    \\            vk.VkPipelineLayout,
    \\            vk.VkPipeline,
    \\            vk.VkRenderPass,
    \\            vk.VkDescriptorSetLayout,
    \\            vk.VkSampler,
    \\            vk.VkDescriptorSet,
    \\            vk.VkDescriptorPool,
    \\            vk.VkFramebuffer,
    \\            vk.VkCommandPool,
    \\            => print_offset_output(
    \\                fields_base_offset,
    \\                "{s}: {?},\n",
    \\                .{ field.name, @field(@"struct", field.name) },
    \\            ),
    \\            [*c]const u8 => print_offset_output(
    \\                fields_base_offset,
    \\                "{s}: {s},\n",
    \\                .{ field.name, @field(@"struct", field.name) },
    \\            ),
    \\            [*c]const u32 => {
    \\                if (@hasField(t, "codeSize")) {
    \\                    const len = @field(@"struct", "codeSize") / @sizeOf(u32);
    \\                    print_offset_output(
    \\                        fields_base_offset,
    \\                        "{s}: {d} instructions,\n",
    \\                        .{ field.name, len },
    \\                    );
    \\                }
    \\            },
    \\            [*c]const vk.VkDescriptorSetLayoutBinding => {
    \\                const len = @field(@"struct", "bindingCount");
    \\                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                print_offset_slice(
    \\                    fields_base_offset,
    \\                    field.name,
    \\                    type_name,
    \\                    vk.VkDescriptorSetLayoutBinding,
    \\                    elements,
    \\                );
    \\            },
    \\            [*c]const vk.VkDescriptorSetLayout => {
    \\                const len = if (@hasField(t, "descriptorSetCount"))
    \\                    @field(@"struct", "descriptorSetCount")
    \\                else if (@hasField(t, "setLayoutCount"))
    \\                    @field(@"struct", "setLayoutCount");
    \\                var elements: []const *anyopaque = undefined;
    \\                elements.ptr = @ptrCast(@field(@"struct", field.name));
    \\                elements.len = len;
    \\                print_offset_output(
    \\                    fields_base_offset,
    \\                    "{s}: {any},\n",
    \\                    .{ field.name, elements },
    \\                );
    \\            },
    \\            [*c]const vk.VkPushConstantRange => {
    \\                const len = @field(@"struct", "pushConstantRangeCount");
    \\                var elements: []const vk.VkPushConstantRange = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                print_offset_slice(
    \\                    fields_base_offset,
    \\                    field.name,
    \\                    type_name,
    \\                    vk.VkPushConstantRange,
    \\                    elements,
    \\                );
    \\            },
    \\            [*c]const vk.VkAttachmentDescription => {
    \\                const len = @field(@"struct", "attachmentCount");
    \\                var elements: []const vk.VkAttachmentDescription = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                print_offset_slice(
    \\                    fields_base_offset,
    \\                    field.name,
    \\                    type_name,
    \\                    vk.VkAttachmentDescription,
    \\                    elements,
    \\                );
    \\            },
    \\            [*c]const vk.VkSubpassDescription => {
    \\                const len = @field(@"struct", "subpassCount");
    \\                var elements: []const vk.VkSubpassDescription = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                print_offset_slice(
    \\                    fields_base_offset,
    \\                    field.name,
    \\                    type_name,
    \\                    vk.VkSubpassDescription,
    \\                    elements,
    \\                );
    \\            },
    \\            [*c]const vk.VkAttachmentReference => {
    \\                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
    \\                    @field(@"struct", "inputAttachmentCount")
    \\                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
    \\                    @field(@"struct", "colorAttachmentCount")
    \\                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
    \\                    if (@field(@"struct", field.name) != null)
    \\                        break :blk @field(@"struct", "colorAttachmentCount")
    \\                    else
    \\                        break :blk 0;
    \\                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
    \\                    @intFromBool(@field(@"struct", field.name) != null)
    \\                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
    \\                    @field(@"struct", "preserveAttachmentCount")
    \\                else
    \\                    @panic("Cannot find length for the VkAttachmentReference array");
    \\
    \\                if (len != 0) {
    \\                    var elements: []const vk.VkAttachmentReference = undefined;
    \\                    elements.ptr = @field(@"struct", field.name);
    \\                    elements.len = len;
    \\                    print_offset_slice(
    \\                        fields_base_offset,
    \\                        field.name,
    \\                        type_name,
    \\                        vk.VkAttachmentReference,
    \\                        elements,
    \\                    );
    \\                }
    \\            },
    \\            [*c]const vk.VkSubpassDependency => {
    \\                const len = @field(@"struct", "dependencyCount");
    \\                var elements: []const vk.VkSubpassDependency = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                print_offset_slice(
    \\                    fields_base_offset,
    \\                    field.name,
    \\                    type_name,
    \\                    vk.VkSubpassDependency,
    \\                    elements,
    \\                );
    \\            },
    \\            [*c]const vk.VkPipelineShaderStageCreateInfo => {
    \\                const len = @field(@"struct", "stageCount");
    \\                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                print_offset_slice(
    \\                    fields_base_offset,
    \\                    field.name,
    \\                    type_name,
    \\                    vk.VkPipelineShaderStageCreateInfo,
    \\                    elements,
    \\                );
    \\            },
    \\            [*c]const vk.VkSpecializationMapEntry => {
    \\                const len = @field(@"struct", "mapEntryCount");
    \\                var elements: []const vk.VkSpecializationMapEntry = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                print_offset_slice(
    \\                    fields_base_offset,
    \\                    field.name,
    \\                    type_name,
    \\                    vk.VkSpecializationMapEntry,
    \\                    elements,
    \\                );
    \\            },
    \\            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
    \\            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
    \\            [*c]const vk.VkPipelineTessellationStateCreateInfo,
    \\            [*c]const vk.VkPipelineViewportStateCreateInfo,
    \\            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
    \\            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
    \\            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
    \\            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
    \\            [*c]const vk.VkPipelineDynamicStateCreateInfo,
    \\            [*c]const vk.VkSpecializationInfo,
    \\            [*c]const vk.VkViewport,
    \\            [*c]const vk.VkRect2D,
    \\            => {
    \\                const element_type = @typeInfo(field.type).pointer.child;
    \\                const element: ?*const element_type = @field(@"struct", field.name);
    \\                if (element) |e|
    \\                    print_offset_struct(fields_base_offset, field.name, e)
    \\                else
    \\                    print_offset_output(
    \\                        fields_base_offset,
    \\                        "{s}: {?},\n",
    \\                        .{ field.name, element },
    \\                    );
    \\            },
    \\            else => log.warn(
    \\                @src(),
    \\                "Cannot format field {s} of type {s}",
    \\                .{ field.name, @typeName(field.type) },
    \\            ),
    \\        }
    \\    }
    \\    for (0..base_offset) |_|
    \\        log.output("    ", .{});
    \\    log.output("}},\n", .{});
    \\}
    \\
    \\
;

const Writer = struct {
    alloc: Allocator,
    file: *const std.fs.File,

    const Self = @This();

    fn write(self: *Self, comptime fmt: []const u8, args: anytype) void {
        const line = std.fmt.allocPrint(self.alloc, fmt, args) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
        _ = self.file.write(line) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
    }
};

fn eql(s1: []const u8, s2: []const u8) bool {
    return std.mem.eql(u8, s1, s2);
}

fn write_print_chain(alloc: Allocator, file: *const std.fs.File, db: *const XmlDatabase) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\pub fn print_chain(chain: anytype) void {{
        \\    var current: ?*const anyopaque = chain;
        \\    while (current) |c| {{
        \\        const base_struct: *const vk.VkBaseInStructure = @ptrCast(@alignCast(c));
        \\        switch (base_struct.sType) {{
        \\
    , .{});

    outer: for (db.types.structs) |@"struct"| {
        for (db.extensions.items) |ext| {
            if (ext.unlocks_type(@"struct".name)) {
                // Filter out structs enabled by disabled extensions
                if (ext.supported == .disabled)
                    continue :outer;
            }
        }
        if (@"struct".stype()) |stype| {
            w.write(
                \\            vk.VkStructureType.{[stype]s} => {{
                \\                const nn: *const vk.{[type]s} = @ptrCast(@alignCast(c));
                \\                print_struct(nn);
                \\                current = nn.pNext;
                \\            }},
                \\
            , .{ .stype = stype, .type = @"struct".name });
        }
    }
    w.write(
        \\            else => {{
        \\                log.warn(@src(), "Unknown struct sType: {{d}}", .{{base_struct.sType}});
        \\                current = base_struct.pNext;
        \\            }},
        \\        }}
        \\    }}
        \\}}
        \\
    , .{});
}

fn write_stype_to_name(alloc: Allocator, file: *const std.fs.File, db: *const XmlDatabase) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\pub fn stype_to_name(stype: vk.VkStructureType) []const u8 {{
        \\    return switch (stype) {{
        \\
    , .{});
    outer: for (db.types.structs) |@"struct"| {
        for (db.extensions.items) |ext| {
            if (ext.unlocks_type(@"struct".name)) {
                // Filter out structs enabled by disabled extensions
                if (ext.supported == .disabled)
                    continue :outer;
            }
        }
        if (@"struct".stype()) |stype| {
            w.write(
                \\        vk.VkStructureType.{s} => "{s}",
                \\
            , .{ stype, @"struct".name });
        }
    }
    w.write(
        \\        else => "Unknown",
        \\    }};
        \\}}
        \\
    , .{});
}
