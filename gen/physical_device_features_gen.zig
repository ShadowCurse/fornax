const std = @import("std");

const Allocator = std.mem.Allocator;

const PATH = "src/physical_device_features.zig";
const NOTE =
    \\// Copyright (c) 2025 Egor Lazarchuk
    \\// SPDX-License-Identifier: MIT
    \\//
    \\// This file is auto generated by src/vulkan_features.zig
    \\
    \\const std = @import("std");
    \\const log = @import("log.zig");
    \\const vk = @import("volk.zig");
    \\
    \\
;
const TAB = "    ";

pub fn main() !void {
    std.fs.cwd().deleteFile(PATH) catch {};
    const file = try std.fs.cwd().createFile(PATH, .{});
    defer file.close();

    _ = try file.write(NOTE);
    try write_physical_device_struct(&file, &.{
        "VkPhysicalDevice16BitStorageFeatures",
        "VkPhysicalDeviceMultiviewFeatures",
        "VkPhysicalDeviceVariablePointersFeatures",
        "VkPhysicalDeviceSamplerYcbcrConversionFeatures",
        "VkPhysicalDeviceShaderDrawParametersFeatures",
        "VkPhysicalDevice8BitStorageFeatures",
        "VkPhysicalDeviceShaderAtomicInt64Features",
        "VkPhysicalDeviceShaderFloat16Int8Features",
        "VkPhysicalDeviceDescriptorIndexingFeatures",
        "VkPhysicalDeviceVulkanMemoryModelFeatures",
        "VkPhysicalDeviceUniformBufferStandardLayoutFeatures",
        "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures",
        "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures",
        "VkPhysicalDeviceBufferDeviceAddressFeatures",
        "VkPhysicalDeviceShaderClockFeaturesKHR",
        "VkPhysicalDeviceFragmentShadingRateFeaturesKHR",
        "VkPhysicalDeviceRayQueryFeaturesKHR",
        "VkPhysicalDeviceRayTracingPipelineFeaturesKHR",
        "VkPhysicalDeviceAccelerationStructureFeaturesKHR",
        "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR",
        "VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR",
        "VkPhysicalDeviceSynchronization2FeaturesKHR",
        "VkPhysicalDeviceDynamicRenderingFeaturesKHR",
        "VkPhysicalDeviceMaintenance4FeaturesKHR",
        "VkPhysicalDeviceMaintenance5FeaturesKHR",
        "VkPhysicalDeviceMaintenance7FeaturesKHR",
        "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR",
        "VkPhysicalDeviceTransformFeedbackFeaturesEXT",
        "VkPhysicalDeviceDepthClipEnableFeaturesEXT",
        "VkPhysicalDeviceInlineUniformBlockFeaturesEXT",
        "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT",
        "VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR",
        "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT",
        "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT",
        "VkPhysicalDeviceFragmentDensityMapFeaturesEXT",
        "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT",
        "VkPhysicalDeviceLineRasterizationFeaturesKHR",
        "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT",
        "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT",
        "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT",
        "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT",
        "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT",
        "VkPhysicalDeviceColorWriteEnableFeaturesEXT",
        "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT",
        "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT",
        "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT",
        "VkPhysicalDeviceProvokingVertexFeaturesEXT",
        "VkPhysicalDeviceCustomBorderColorFeaturesEXT",
        "VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR",
        "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR",
        "VkPhysicalDeviceShaderImageFootprintFeaturesNV",
        "VkPhysicalDeviceShadingRateImageFeaturesNV",
        "VkPhysicalDeviceCooperativeMatrixFeaturesNV",
        "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV",
        "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL",
        "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT",
        "VkPhysicalDeviceRobustness2FeaturesEXT",
        "VkPhysicalDeviceImageRobustnessFeaturesEXT",
        "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT",
        "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV",
        "VkPhysicalDeviceDepthClipControlFeaturesEXT",
        "VkPhysicalDeviceMeshShaderFeaturesNV",
        "VkPhysicalDeviceMeshShaderFeaturesEXT",
        "VkPhysicalDeviceDescriptorBufferFeaturesEXT",
        "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT",
        "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT",
        "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT",
        "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR",
        "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV",
        "VkPhysicalDeviceImageProcessingFeaturesQCOM",
        "VkPhysicalDeviceImageProcessing2FeaturesQCOM",
        "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM",
        "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR",
        "VkPhysicalDeviceShaderTileImageFeaturesEXT",
        "VkPhysicalDeviceCooperativeMatrixFeaturesKHR",
        "VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR",
        "VkPhysicalDeviceShaderExpectAssumeFeaturesKHR",
        "VkPhysicalDeviceShaderFloatControls2FeaturesKHR",
        "VkPhysicalDeviceShaderQuadControlFeaturesKHR",
        "VkPhysicalDeviceRawAccessChainsFeaturesNV",
        "VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT",
        "VkPhysicalDevicePipelineRobustnessFeaturesEXT",
        "VkPhysicalDeviceConditionalRenderingFeaturesEXT",
        "VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR",
        "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT",
        "VkPhysicalDeviceOpacityMicromapFeaturesEXT",
        "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV",
        "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV",
        "VkPhysicalDeviceOpticalFlowFeaturesNV",
        "VkPhysicalDeviceLegacyDitheringFeaturesEXT",
        "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT",
        "VkPhysicalDevicePerStageDescriptorSetFeaturesNV",
        "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT",
        "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT",
        "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT",
        "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT",
        "VkPhysicalDeviceDepthBiasControlFeaturesEXT",
        "VkPhysicalDeviceDepthClampControlFeaturesEXT",
        "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT",
        "VkPhysicalDeviceShaderObjectFeaturesEXT",
        "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT",
        "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT",
        "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT",
        "VkPhysicalDeviceShaderBfloat16FeaturesKHR",
        "VkPhysicalDeviceCooperativeMatrix2FeaturesNV",
        "VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV",
        "VkPhysicalDeviceClusterAccelerationStructureFeaturesNV",
        "VkPhysicalDeviceCooperativeVectorFeaturesNV",
        "VkPhysicalDeviceTileShadingFeaturesQCOM",
        "VkPhysicalDeviceShaderFloat8FeaturesEXT",
        "VkPhysicalDeviceTensorFeaturesARM",
        "VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT",
        "VkPhysicalDevicePipelineOpacityMicromapFeaturesARM",
        "VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV",
        "VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE",
    });
}

const REPLACEMENTS: []const struct { []const u8, []const u8 } = &.{
    .{ "SM", "SM" },
    .{ "2D", "2D" },
    .{ "3D", "3D" },
    .{ "Int8", "INT8" },
    .{ "Int16", "INT16" },
    .{ "Int64", "INT64" },
    .{ "Bfloat16", "BFLOAT16" },
    .{ "Float2", "FLOAT_2" },
    .{ "Float8", "FLOAT8" },
    .{ "Float16", "FLOAT16" },
    .{ "Functions2", "FUNCTIONS_2" },
    .{ "8Bit", "8BIT" },
    .{ "16Bit", "16BIT" },
};

fn replace_beginning(
    alloc: Allocator,
    n: *[]const u8,
    result: *std.ArrayListUnmanaged(u8),
) !bool {
    for (REPLACEMENTS) |r| {
        const search, const replace = r;
        if (std.mem.startsWith(u8, n.*, search)) {
            try result.appendSlice(alloc, replace);
            n.* = n.*[search.len..];
            return true;
        }
    }
    return false;
}

const ENDINGS: []const []const u8 = &.{
    "INTEL",
    "VALVE",
    "QCOM",
    "KHR",
    "EXT",
    "ARM",
    "NV",
};

fn replace_ending(
    alloc: Allocator,
    n: []const u8,
    result: *std.ArrayListUnmanaged(u8),
) !bool {
    inline for (ENDINGS) |end| {
        if (std.mem.startsWith(u8, n, end)) {
            try result.appendSlice(alloc, end);
            return true;
        }
    }
    return false;
}

fn format_name(
    alloc: Allocator,
    name: []const u8,
    comptime upper: bool,
) ![]const u8 {
    var result: std.ArrayListUnmanaged(u8) = .empty;
    var n: []const u8 = name;
    if (!try replace_beginning(alloc, &n, &result)) {
        try result.append(alloc, n[0]);
        n = n[1..];
    }
    while (n.len != 0) {
        if (std.ascii.isDigit(n[0]))
            try result.append(alloc, '_');
        if (std.ascii.isUpper(n[0]))
            try result.append(alloc, '_');
        if (try replace_beginning(alloc, &n, &result))
            continue;
        if (try replace_ending(alloc, n, &result))
            break;
        try result.append(alloc, n[0]);
        n = n[1..];
    }

    const conversion_fn = if (upper) std.ascii.toUpper else std.ascii.toLower;
    for (result.items) |*r|
        r.* = conversion_fn(r.*);

    return result.items;
}

fn get_provider(name: []const u8) []const u8 {
    var e: u32 = 0;
    for (0..name.len) |i| {
        const index = name.len - i - 1;
        if (std.ascii.isUpper(name[index]))
            e += 1
        else
            break;
    }
    var provider = name[name.len - e ..];
    if (provider.len == 0)
        provider = "KHR";
    return provider;
}

fn get_extension(alloc: Allocator, name: []const u8) ![]const u8 {
    var provider = get_provider(name);

    const n = name["VkPhysicalDevice".len..];
    const i = std.mem.indexOf(u8, n, "Features") orelse @panic("No `Features` in struct name");
    const s = n[0..i];

    var upper = try format_name(alloc, s, true);
    if (std.mem.eql(u8, upper, "TENSOR"))
        upper = "TENSORS";
    if (std.mem.eql(u8, upper, "DESCRIPTOR_INDEXING"))
        provider = "EXT";
    const result = std.fmt.allocPrint(alloc, "VK_{s}_{s}_EXTENSION_NAME", .{ provider, upper });
    return result;
}

fn get_field_name(alloc: Allocator, name: []const u8) ![]const u8 {
    var result: std.ArrayListUnmanaged(u8) = .empty;
    try result.append(alloc, std.ascii.toLower(name[2]));
    for (name[3..]) |c| {
        if (std.ascii.isUpper(c))
            try result.append(alloc, '_');
        try result.append(alloc, std.ascii.toLower(c));
    }
    return result.items;
}

fn get_stype(alloc: Allocator, name: []const u8) ![]const u8 {
    const upper = try format_name(alloc, name["Vk".len..], true);
    const result = std.fmt.allocPrint(alloc, "VK_STRUCTURE_TYPE_{s}", .{upper});
    return result;
}
fn write_physical_device_struct(file: *const std.fs.File, types: []const []const u8) !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const alloc = arena.allocator();

    for (types) |t| {
        defer _ = arena.reset(.retain_capacity);

        const name = try format_name(alloc, t, false);
        // const name = try get_field_name(alloc, t);
        const stype = try get_stype(alloc, t);
        const line = try std.fmt.allocPrint(alloc,
            \\{s}: vk.{s} =
            \\{s}.{{ .sType = vk.{s} }},
            \\
        , .{ name, t, TAB, stype });
        _ = try file.write(line);
    }
    _ = try file.write("\n");

    _ = try file.write(
        \\pub fn chain_supported(features: *@This(), extensions: [][*c]const u8) ?*anyopaque {
        \\    var pnext: ?*anyopaque = null;
        \\    for (extensions) |ext| {
        \\        const e = std.mem.span(ext);
        \\
    );
    for (0..types.len) |i| {
        defer _ = arena.reset(.retain_capacity);

        const t = types[types.len - i - 1];
        const name = try format_name(alloc, t, false);
        const extension = try get_extension(alloc, t);
        const line = try std.fmt.allocPrint(
            alloc,
            \\        if (std.mem.eql(u8, e, vk.{s})) {{
            \\            log.debug(@src(), "Adding {{s}} extension to the physical device features pnext chain", .{{vk.{s}}});
            \\            features.{s}.pNext = pnext;
            \\            pnext = &features.{s};
            \\            continue;
            \\        }}
            \\
        ,
            .{ extension, extension, name, name },
        );
        _ = try file.write(line);
    }
    _ = try file.write(
        \\    }
        \\    return pnext;
        \\}
        \\
    );
}
