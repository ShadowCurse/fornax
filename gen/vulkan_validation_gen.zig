const std = @import("std");
const Allocator = std.mem.Allocator;

const root = @import("root");
const vk = @import("volk");
const vkp = @import("vulkan_parsing.zig");
const xml = @import("xml.zig");

const PATH = "src/vulkan_validation.zig";
const HEADER =
    \\// This file is auto generated by gen/{s}
    \\
    \\const std = @import("std");
    \\const vk = @import("volk");
    \\const log = @import("log.zig");
    \\
    \\const Allocator = std.mem.Allocator;
    \\
;

pub fn gen(db: *const vkp.Database) !void {
    std.fs.cwd().deleteFile(PATH) catch {};
    const file = try std.fs.cwd().createFile(PATH, .{});
    defer file.close();

    _ = try file.write(root.NOTE);
    const header = std.fmt.comptimePrint(HEADER, .{@src().file});
    _ = try file.write(header);

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const alloc = arena.allocator();

    try write_check_result(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_extension_type(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_types_validation(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_spirv_validation(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
}

const Writer = struct {
    alloc: Allocator,
    file: *const std.fs.File,

    const Self = @This();

    fn write(self: *Self, comptime fmt: []const u8, args: anytype) void {
        const line = std.fmt.allocPrint(self.alloc, fmt, args) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
        _ = self.file.write(line) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
    }
};

fn eql(s1: []const u8, s2: []const u8) bool {
    return std.mem.eql(u8, s1, s2);
}

fn write_check_result(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\pub fn check_result(result: vk.VkResult) !void {{
        \\    switch (result) {{
        \\        vk.VK_SUCCESS => return,
        \\
    , .{});
    const e = db.enum_by_name("VkResult").?;
    for (e.items) |*item| {
        if (eql(item.name, "VK_SUCCESS")) continue;
        w.write(
            \\        vk.{[name]s} => {{
            \\            log.err(@src(), "Vulkan error: {[name]s} ({[comment]s})", .{{}});
            \\            return error.{s};
            \\        }},
            \\
        ,
            .{ .name = item.name, .comment = item.comment },
        );
    }
    var used_enums: std.StringArrayHashMapUnmanaged(void) = .empty;
    var iter = db.all_extensions();
    while (iter.next()) |tuple| {
        const ext, _ = tuple;
        for (ext.require) |*req| {
            for (req.items) |item| {
                switch (item) {
                    .@"enum" => |ee| {
                        const enum_name = if (ee.alias) |a| a else ee.name;
                        if (eql(ee.extends, "VkResult")) {
                            if (used_enums.getPtr(enum_name) != null) continue;
                            try used_enums.put(alloc, enum_name, {});
                            w.write(
                                \\        vk.{[name]s} => {{
                                \\            log.err(@src(), "Vulkan error: {[name]s} ({[extension]s})", .{{}});
                                \\            return error.{s};
                                \\        }},
                                \\
                            ,
                                .{ .name = enum_name, .extension = ext.name },
                            );
                        }
                    },
                    else => {},
                }
            }
        }
    }
    w.write(
        \\        else => {{
        \\            log.err(@src(), "Vulkan error: UNKNOWN {{}}", .{{result}});
        \\            return error.UNKNOWN;
        \\        }},
        \\    }}
        \\}}
        \\
    , .{});
}

fn vk_version_to_api_version(s: []const u8) ?[]const u8 {
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_1")) return "VK_API_VERSION_1_1";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_2")) return "VK_API_VERSION_1_2";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_3")) return "VK_API_VERSION_1_3";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_4")) return "VK_API_VERSION_1_4";
    return null;
}

// Converst:
// ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// into:
// ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version
fn write_depends(
    alloc: Allocator,
    file: *const std.fs.File,
    instance_extensions: []const vkp.Extension,
    depends: []const u8,
) !void {
    _ = try file.write(" and (");
    var output: std.ArrayListUnmanaged(u8) = .empty;
    var writer = output.writer(alloc);
    var i: usize = 0;
    while (i < depends.len) : (i += 1) {
        const c = depends[i];
        switch (c) {
            '(' => _ = try writer.write("("),
            ')' => _ = try writer.write(")"),
            ',' => _ = try writer.write(" or "),
            '+' => _ = try writer.write(" and "),
            else => {
                if (vk_version_to_api_version(depends[i..])) |version| {
                    try writer.print("vk.{s} <= api_version", .{version});
                    i += "VK_VERSION_1_1".len - 1;
                } else {
                    if (std.mem.indexOfAny(u8, depends[i..], ",+)")) |index| {
                        const name = depends[i .. i + index];
                        var t: []const u8 = "device";
                        for (instance_extensions) |*ext| {
                            if (eql(name, ext.name)) {
                                t = "instance";
                                break;
                            }
                        }
                        try writer.print("self.{s}.{s}", .{ t, name });
                        i += index - 1;
                    } else {
                        const name = depends[i..];
                        var t: []const u8 = "device";
                        for (instance_extensions) |*ext| {
                            if (eql(name, ext.name)) {
                                t = "instance";
                                break;
                            }
                        }
                        try writer.print("self.{s}.{s}", .{ t, name });
                        i += depends[i..].len - 1;
                    }
                }
            },
        }
    }
    _ = try file.write(output.items);
    _ = try file.write(")");
}

fn write_extension_type(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\pub const Extensions = struct {{
        \\    instance: packed struct(u{d}) {{
        \\
    , .{db.extensions.instance.len});
    for (db.extensions.instance) |*ext|
        w.write(
            \\        {s}: bool = false,
            \\
        , .{ext.name});
    w.write(
        \\    }} = .{{}},
        \\    device: packed struct(u{d}) {{
        \\
    , .{db.extensions.device.len});

    for (db.extensions.device) |*ext| {
        w.write(
            \\        {s}: bool = false,
            \\
        , .{ext.name});
    }
    w.write(
        \\    }} = .{{}},
        \\
        \\    const Self = @This();
        \\
    , .{});

    w.write(
        \\
        \\    pub fn init(
        \\        tmp_alloc: Allocator,
        \\        api_version: u32,
        \\        instance_extensions: []const [*c]const u8,
        \\        device_extensions: []const [*c]const u8,
        \\    ) !Self {{
        \\        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        \\        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        \\        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        \\        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        \\        var self: Self = .{{}};
        \\
    , .{});
    {
        for (&[_]struct { []const u8, []const u8 }{
            .{ "VK_API_VERSION_1_1", "VK_VERSION_1_1" },
            .{ "VK_API_VERSION_1_2", "VK_VERSION_1_2" },
            .{ "VK_API_VERSION_1_3", "VK_VERSION_1_3" },
            .{ "VK_API_VERSION_1_4", "VK_VERSION_1_4" },
        }) |tuple| {
            const api_version, const promoted_to = tuple;
            w.write(
                \\        if (vk.{s} <= api_version) {{
                \\
            , .{api_version});
            for (db.extensions.instance) |*ext| {
                if (!eql(ext.promoted_to, promoted_to)) continue;
                w.write(
                    \\            self.instance.{s} = true;
                    \\
                , .{ext.name});
            }
            for (db.extensions.device) |*ext| {
                if (!eql(ext.promoted_to, promoted_to)) continue;
                w.write(
                    \\            self.device.{s} = true;
                    \\
                , .{ext.name});
            }
            w.write(
                \\        }}
                \\
            , .{});
        }
    }
    w.write(
        \\        // Instance extensions
        \\
    , .{});
    {
        for (db.extensions.instance) |*ext| {
            w.write(
                \\        for (ie) |ext| {{
                \\            if (std.mem.eql(u8, ext, "{s}")
            , .{ext.name});
            if (ext.depends.len != 0) try write_depends(
                alloc,
                file,
                db.extensions.instance,
                ext.depends,
            );
            w.write(
                \\) {{
                \\                self.instance.{s} = true;
                \\                break;
                \\            }}
                \\        }}
                \\
            , .{ext.name});
        }
    }
    w.write(
        \\        // Device extensions
        \\
    , .{});
    {
        for (db.extensions.device) |*ext| {
            w.write(
                \\        for (de) |ext| {{
                \\            if (std.mem.eql(u8, ext, "{s}")
            , .{ext.name});
            if (ext.depends.len != 0) try write_depends(
                alloc,
                file,
                db.extensions.instance,
                ext.depends,
            );
            w.write(
                \\) {{
                \\                self.device.{s} = true;
                \\                break;
                \\            }}
                \\        }}
                \\
            , .{ext.name});
        }
    }

    w.write(
        \\        return self;
        \\    }}
        \\}};
        \\
    , .{});
}

fn write_types_validation(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };

    for (db.types.structs) |*@"struct"| {
        w.write(
            \\
            \\pub fn validate_{s}(extensions: *const Extensions, item: *const vk.{s}, validate_pnext: bool) bool {{
            \\
        , .{ @"struct".name, @"struct".name });
        var checked_members: u32 = 0;
        var has_pnext: bool = false;
        for (@"struct".members) |*member| {
            if (eql(member.name, "pNext")) has_pnext = true;
            for (db.enums.items) |*@"enum"| {
                if (eql(@"enum".name, member.type)) {
                    checked_members += 1;
                    if (member.len) |len| {
                        switch (len) {
                            .null => {
                                w.write(
                                    \\    for (std.mem.span(item.{[member]s})) |*i| {{
                                    \\        if (!validate_{[type]t}_{[name]s}(extensions, @ptrCast(i)))
                                    \\            return false;
                                    \\    }}
                                    \\
                                , .{
                                    .member = member.name,
                                    .type = @"enum".type,
                                    .name = @"enum".name,
                                });
                            },
                            .member => |m| {
                                if (@"struct".has_member(m)) {
                                    w.write(
                                        \\    for (0..item.{s}) |i| {{
                                        \\        if (!validate_{t}_{s}(extensions, @ptrCast(&item.{s}[i])))
                                        \\            return false;
                                        \\    }}
                                        \\
                                    , .{ m, @"enum".type, @"enum".name, member.name });
                                }
                            },
                        }
                        break;
                    } else {
                        w.write(
                            \\    if (!validate_{t}_{s}(extensions, @ptrCast(&item.{s})))
                            \\        return false;
                            \\
                        , .{ @"enum".type, @"enum".name, member.name });
                        break;
                    }
                }
            }
            for (db.types.bitmasks) |*bitmask| {
                if (eql(member.type, bitmask.type_name)) {
                    checked_members += 1;
                    if (member.len) |len| {
                        switch (len) {
                            .null => {
                                w.write(
                                    \\    for (std.mem.span(item.{s})) |*i| {{
                                    \\        if (!validate_bitmask_{s}(extensions, @ptrCast(i))) 
                                    \\            return false;
                                    \\    }}
                                    \\
                                , .{ bitmask.enum_name, member.name });
                            },
                            .member => |m| {
                                if (@"struct".has_member(m)) {
                                    w.write(
                                        \\    for (0..item.{s}) |i| {{
                                        \\        if (!validate_bitmask_{s}(extensions, @ptrCast(&item.{s}[i]))) 
                                        \\            return false;
                                        \\    }}
                                        \\
                                    , .{ m, bitmask.enum_name, member.name });
                                }
                            },
                        }
                        break;
                    } else {
                        w.write(
                            \\    if (!validate_bitmask_{s}(extensions, @ptrCast(&item.{s})))
                            \\        return false;
                            \\
                        , .{ bitmask.enum_name, member.name });
                        break;
                    }
                }
            }
        }
        if (checked_members == 0)
            w.write(
                \\    _ = extensions;
                \\    _ = item;
                \\
            , .{});
        if (has_pnext) {
            w.write(
                \\    if (!validate_pnext) return true;
                \\
                \\    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
                \\    while (pnext) |next| {{
                \\        pnext = next.pNext;
                \\        switch (next.sType) {{
                \\
            , .{});
            for (db.types.structs) |*ss| {
                if (ss.extends) |extends| {
                    if (ss.stype()) |stype| {
                        if (std.mem.indexOf(u8, extends, @"struct".name) != null) {
                            w.write(
                                \\            vk.{[stype]s},
                                \\            => if (!validate_{[type]s}(extensions, @ptrCast(next), false))
                                \\                return false,
                                \\
                            , .{ .stype = stype, .type = ss.name });
                        }
                    }
                }
            }
            w.write(
                \\            else => |v| {{
                \\                log.debug(@src(), "Invalid pNext chain item for {[name]s}: {{d}}", .{{v}});
                \\                return false;
                \\            }},
                \\        }}
                \\    }}
                \\    return true;
                \\}}
                \\
            , .{ .name = @"struct".name });
        } else {
            w.write(
                \\    _ = validate_pnext;
                \\    return true;
                \\}}
                \\
            , .{});
        }
    }
    for (db.enums.items) |@"enum"| {
        if (std.mem.indexOfScalar(u8, @"enum".name, ' ') != null) continue;
        w.write(
            \\
            \\pub fn validate_{[type]t}_{[name]s}(extensions: *const Extensions, item: *const vk.{[name]s}) bool {{
            \\
        , .{ .type = @"enum".type, .name = @"enum".name });
        switch (@"enum".type) {
            .bitmask => {
                var tmp: std.ArrayListUnmanaged(u8) = .empty;
                var writer = tmp.writer(alloc);
                for (@"enum".items) |i| {
                    try writer.print(
                        \\ |
                        \\        vk.{s}
                    , .{i.name});
                }
                try writer.print(
                    \\;
                    \\
                , .{});

                var extensions_used: u32 = 0;
                var iter = db.all_extensions();
                while (iter.next()) |tuple| {
                    const ext, const ext_type = tuple;
                    for (ext.require) |req| {
                        for (req.items) |item| {
                            switch (item) {
                                .@"enum" => |ee| {
                                    if (eql(ee.extends, @"enum".name)) {
                                        extensions_used += 1;
                                        try writer.print(
                                            \\    if (extensions.{t}.{s})
                                            \\        valid_bits |= vk.{s};
                                            \\
                                        , .{ ext_type, ext.name, ee.name });
                                    }
                                },
                                else => {},
                            }
                        }
                    }
                }
                if (extensions_used != 0)
                    w.write(
                        \\    var valid_bits: u{d} = 0{s}
                    , .{ @"enum".bitwidth, tmp.items })
                else
                    w.write(
                        \\    _ = extensions;
                        \\    const valid_bits: u{d} = 0{s}
                    , .{ @"enum".bitwidth, tmp.items });

                w.write(
                    \\    return (item.* & ~valid_bits) == 0;
                    \\}}
                    \\
                , .{});
            },
            .@"enum" => {
                if (@"enum".items.len != 1) {
                    w.write(
                        \\    const min = @min(
                    , .{});
                    for (@"enum".items) |i| {
                        w.write(
                            \\
                            \\        vk.{s},
                        , .{i.name});
                    }
                    w.write(
                        \\
                        \\    );
                        \\
                    , .{});
                } else {
                    w.write(
                        \\    const min = vk.{s};
                        \\
                    , .{@"enum".items[0].name});
                }

                if (@"enum".items.len != 1) {
                    w.write(
                        \\    const max = @max(
                    , .{});
                    for (@"enum".items) |i| {
                        w.write(
                            \\
                            \\        vk.{s},
                        , .{i.name});
                    }
                    w.write(
                        \\
                        \\    );
                        \\
                    , .{});
                } else {
                    w.write(
                        \\    const max = vk.{s};
                        \\
                    , .{@"enum".items[0].name});
                }

                w.write(
                    \\    if (min <= item.* and item.* <= max)
                    \\        return true;
                    \\
                , .{});
                var extensions_used: u32 = 0;
                var iter = db.all_extensions();
                while (iter.next()) |tuple| {
                    const ext, const ext_type = tuple;
                    for (ext.require) |req| {
                        for (req.items) |item| {
                            switch (item) {
                                .@"enum" => |ee| {
                                    if (eql(ee.extends, @"enum".name)) {
                                        extensions_used += 1;
                                        w.write(
                                            \\    if (extensions.{t}.{s} and item.* == vk.{s})
                                            \\        return true;
                                            \\
                                        , .{ ext_type, ext.name, ee.name });
                                    }
                                },
                                else => {},
                            }
                        }
                    }
                }
                if (extensions_used == 0)
                    w.write(
                        \\    _ = extensions;
                        \\
                    , .{});

                w.write(
                    \\    return false;
                    \\}}
                    \\
                , .{});
            },
        }
    }
}

fn write_spirv_validation(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\
        \\pub fn validate_spirv_extension(api_version: u32, extensions: *const Extensions, extension_name: []const u8) bool {{
        \\
    , .{});
    for (db.spirv.extensions) |sext| {
        var iter = db.all_extensions();
        while (iter.next()) |tuple| {
            const ext, const t = tuple;
            if (eql(sext.extension, ext.name)) {
                if (sext.version) |v| {
                    w.write(
                        \\    if (std.mem.eql(u8, extension_name, "{[name]s}"))
                        \\        return extensions.{[type]t}.{[name]s} and vk.{[version]s} <= api_version;
                        \\
                    , .{ .name = ext.name, .type = t, .version = vk_version_to_api_version(v).? });
                } else {
                    w.write(
                        \\    if (std.mem.eql(u8, extension_name, "{[name]s}"))
                        \\        return extensions.{[type]t}.{[name]s};
                        \\
                    , .{ .name = ext.name, .type = t });
                }
            }
        }
    }
    w.write(
        \\}}
        \\
    , .{});
}
