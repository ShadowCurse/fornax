const std = @import("std");
const Allocator = std.mem.Allocator;

const root = @import("root");
const vk = @import("volk");
const vkp = @import("vulkan_parsing.zig");
const xml = @import("xml.zig");

const PATH = "src/vulkan_validation.zig";
const HEADER =
    \\// This file is auto generated by gen/{s}
    \\
    \\const std = @import("std");
    \\const vk = @import("volk");
    \\const spirv = @import("spirv");
    \\const log = @import("log.zig");
    \\const Allocator = std.mem.Allocator;
    \\
    \\
;

pub fn gen(db: *const vkp.Database) !void {
    std.fs.cwd().deleteFile(PATH) catch {};
    const file = try std.fs.cwd().createFile(PATH, .{});
    defer file.close();

    _ = try file.write(root.NOTE);
    const header = std.fmt.comptimePrint(HEADER, .{@src().file});
    _ = try file.write(header);

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const alloc = arena.allocator();

    try write_check_result(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_extension_type(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_types_validation(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_physical_device_type(alloc, &file, db);
    _ = arena.reset(.retain_capacity);
    try write_spirv_validation(alloc, &file, db);
    _ = arena.reset(.retain_capacity);

    _ = try file.write(VALIDATE_SHADER_CODE);
    _ = try file.write(VALIDATION_STRUCT);
}

const Writer = struct {
    alloc: Allocator,
    file: *const std.fs.File,

    const Self = @This();

    fn write(self: *Self, comptime fmt: []const u8, args: anytype) void {
        const line = std.fmt.allocPrint(self.alloc, fmt, args) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
        _ = self.file.write(line) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
    }
};

fn eql(s1: []const u8, s2: []const u8) bool {
    return std.mem.eql(u8, s1, s2);
}

const VALIDATE_SHADER_CODE =
    \\pub fn validate_shader_code(
    \\    validation: *const Validation,
    \\    create_info: *const vk.VkShaderModuleCreateInfo,
    \\) bool {
    \\    var code: []const u32 = undefined;
    \\    code.ptr = create_info.pCode;
    \\    code.len = create_info.codeSize / @sizeOf(u32);
    \\
    \\    // Impossibly small shader
    \\    if (code.len < 5) return false;
    \\    if (code[0] != spirv.SpvMagicNumber) return false;
    \\
    \\    const version = code[1];
    \\    if (spirv.SPV_VERSION < version) return false;
    \\    if (version == 0x10600 and validation.api_version < vk.VK_API_VERSION_1_3) return false;
    \\    if (version == 0x10500 and validation.api_version < vk.VK_API_VERSION_1_2) return false;
    \\    if (0x10400 <= version and
    \\        (validation.api_version < vk.VK_API_VERSION_1_2 and
    \\            !validation.extensions.device.VK_KHR_spirv_1_4)) return false;
    \\    if (0x10300 <= version and validation.api_version < vk.VK_API_VERSION_1_1) return false;
    \\    if (0x10000 < version and validation.api_version < vk.VK_API_VERSION_1_1) return false;
    \\
    \\    var offset: usize = 5;
    \\    while (offset < code.len) {
    \\        const op: spirv.SpvCapability = code[offset] & 0xffff;
    \\        const count = (code[offset] >> 16) & 0xffff;
    \\
    \\        if (count == 0) return false;
    \\        if (code.len < offset + count) return false;
    \\
    \\        if (op == spirv.SpvOpCapability) {
    \\            if (count != 2) return false;
    \\
    \\            const capability = code[offset + 1];
    \\            if (!validate_spirv_capability(validation, capability)) {
    \\                log.debug(@src(), "Invalid SPIR-V capability: {d}", .{capability});
    \\                return false;
    \\            }
    \\        } else if (op == spirv.SpvOpExtension) {
    \\            if (count < 2) return false;
    \\            const byte_slice: [*c]const u8 = @ptrCast(code[offset + 1..].ptr);
    \\            const name = std.mem.span(byte_slice);
    \\            if (!validate_spirv_extension(validation, name)) {
    \\                log.debug(@src(), "Invalid SPIR-V extension: {s}", .{name});
    \\                return false;
    \\            }
    \\        } else if (op == spirv.SpvOpFunction) {
    \\            // Code starts here, stop validation
    \\            break;
    \\        }
    \\        offset += count;
    \\    }
    \\
    \\    return true;
    \\}
    \\
;

const VALIDATION_STRUCT =
    \\pub const Validation = struct {
    \\    api_version: u32,
    \\    extensions: *const Extensions,
    \\    pdf: *const vk.VkPhysicalDeviceFeatures2,
    \\    additional_pdf: *const AdditionalPDF,
    \\};
    \\
;

fn write_check_result(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };

    const vk_result = db.enum_by_name("VkResult").?;
    var used_enums: std.StringArrayHashMapUnmanaged([]const u8) = .empty;
    {
        var iter = db.all_extensions();
        while (iter.next()) |tuple| {
            const ext, _ = tuple;
            for (ext.require) |*req| {
                for (req.items) |item| {
                    switch (item) {
                        .@"enum" => |ee| {
                            const enum_name = if (ee.alias) |a| a else ee.name;
                            if (eql(ee.extends, "VkResult")) {
                                if (used_enums.getPtr(enum_name) != null) continue;
                                try used_enums.put(alloc, enum_name, ext.name);
                            }
                        },
                        else => {},
                    }
                }
            }
        }
    }

    w.write(
        \\pub const Error = error {{
        \\
    , .{});
    for (vk_result.items) |*item| {
        if (eql(item.name, "VK_SUCCESS")) continue;
        w.write(
            \\        {[name]s},
            \\
        ,
            .{ .name = item.name },
        );
    }
    for (used_enums.keys()) |name| {
        w.write(
            \\        {[name]s},
            \\
        ,
            .{ .name = name },
        );
    }
    w.write(
        \\    VK_UNKNOWN,
        \\}};
        \\
        \\
    , .{});

    w.write(
        \\pub fn check_result(result: vk.VkResult) Error!void {{
        \\    switch (result) {{
        \\        vk.VK_SUCCESS => return,
        \\
    , .{});
    for (vk_result.items) |*item| {
        if (eql(item.name, "VK_SUCCESS")) continue;
        w.write(
            \\        vk.{[name]s} => {{
            \\            log.err(@src(), "Vulkan error: {[name]s} ({[comment]s})", .{{}});
            \\            return error.{s};
            \\        }},
            \\
        ,
            .{ .name = item.name, .comment = item.comment },
        );
    }
    var iter = used_enums.iterator();
    while (iter.next()) |entry| {
        if (eql(entry.key_ptr.*, "VK_SUCCESS")) continue;
        w.write(
            \\        vk.{[name]s} => {{
            \\            log.err(@src(), "Vulkan error: {[name]s} ({[extension]s})", .{{}});
            \\            return error.{s};
            \\        }},
            \\
        ,
            .{ .name = entry.key_ptr.*, .extension = entry.value_ptr.* },
        );
    }
    w.write(
        \\        else => {{
        \\            log.err(@src(), "Vulkan error: UNKNOWN {{}}", .{{result}});
        \\            return error.VK_UNKNOWN;
        \\        }},
        \\    }}
        \\}}
        \\
    , .{});
}

fn vk_version_to_api_version(s: []const u8) ?[]const u8 {
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_0")) return "VK_API_VERSION_1_0";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_1")) return "VK_API_VERSION_1_1";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_2")) return "VK_API_VERSION_1_2";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_3")) return "VK_API_VERSION_1_3";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_4")) return "VK_API_VERSION_1_4";
    return null;
}

// Converst:
// ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// into:
// ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version
fn write_depends(
    alloc: Allocator,
    file: *const std.fs.File,
    instance_extensions: []const vkp.Extension,
    depends: []const u8,
) !void {
    _ = try file.write(" and (");
    var output: std.ArrayListUnmanaged(u8) = .empty;
    var writer = output.writer(alloc);
    var i: usize = 0;
    while (i < depends.len) : (i += 1) {
        const c = depends[i];
        switch (c) {
            '(' => _ = try writer.write("("),
            ')' => _ = try writer.write(")"),
            ',' => _ = try writer.write(" or "),
            '+' => _ = try writer.write(" and "),
            else => {
                if (vk_version_to_api_version(depends[i..])) |version| {
                    try writer.print("vk.{s} <= api_version", .{version});
                    i += "VK_VERSION_1_1".len - 1;
                } else {
                    if (std.mem.indexOfAny(u8, depends[i..], ",+)")) |index| {
                        const name = depends[i .. i + index];
                        var t: []const u8 = "device";
                        for (instance_extensions) |*ext| {
                            if (eql(name, ext.name)) {
                                t = "instance";
                                break;
                            }
                        }
                        try writer.print("self.{s}.{s}", .{ t, name });
                        i += index - 1;
                    } else {
                        const name = depends[i..];
                        var t: []const u8 = "device";
                        for (instance_extensions) |*ext| {
                            if (eql(name, ext.name)) {
                                t = "instance";
                                break;
                            }
                        }
                        try writer.print("self.{s}.{s}", .{ t, name });
                        i += depends[i..].len - 1;
                    }
                }
            },
        }
    }
    _ = try file.write(output.items);
    _ = try file.write(")");
}

fn write_extension_type(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\pub const Extensions = struct {{
        \\    instance: packed struct(u{d}) {{
        \\
    , .{db.extensions.instance.len});
    for (db.extensions.instance) |*ext|
        w.write(
            \\        {s}: bool = false,
            \\
        , .{ext.name});
    w.write(
        \\    }} = .{{}},
        \\    device: packed struct(u{d}) {{
        \\
    , .{db.extensions.device.len});

    for (db.extensions.device) |*ext| {
        w.write(
            \\        {s}: bool = false,
            \\
        , .{ext.name});
    }
    w.write(
        \\    }} = .{{}},
        \\
        \\    const Self = @This();
        \\
    , .{});

    w.write(
        \\
        \\    pub fn init(
        \\        tmp_alloc: Allocator,
        \\        api_version: u32,
        \\        instance_extensions: []const [*c]const u8,
        \\        device_extensions: []const [*c]const u8,
        \\    ) !Self {{
        \\        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        \\        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        \\        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        \\        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        \\        var self: Self = .{{}};
        \\
    , .{});
    {
        for (&[_]struct { []const u8, []const u8 }{
            .{ "VK_API_VERSION_1_1", "VK_VERSION_1_1" },
            .{ "VK_API_VERSION_1_2", "VK_VERSION_1_2" },
            .{ "VK_API_VERSION_1_3", "VK_VERSION_1_3" },
            .{ "VK_API_VERSION_1_4", "VK_VERSION_1_4" },
        }) |tuple| {
            const api_version, const promoted_to = tuple;
            w.write(
                \\        if (vk.{s} <= api_version) {{
                \\
            , .{api_version});
            for (db.extensions.instance) |*ext| {
                if (!eql(ext.promoted_to, promoted_to)) continue;
                w.write(
                    \\            self.instance.{s} = true;
                    \\
                , .{ext.name});
            }
            for (db.extensions.device) |*ext| {
                if (!eql(ext.promoted_to, promoted_to)) continue;
                w.write(
                    \\            self.device.{s} = true;
                    \\
                , .{ext.name});
            }
            w.write(
                \\        }}
                \\
            , .{});
        }
    }
    w.write(
        \\        // Instance extensions
        \\
    , .{});
    {
        for (db.extensions.instance) |*ext| {
            w.write(
                \\        for (ie) |ext| {{
                \\            if (std.mem.eql(u8, ext, "{s}")
            , .{ext.name});
            if (ext.depends.len != 0) try write_depends(
                alloc,
                file,
                db.extensions.instance,
                ext.depends,
            );
            w.write(
                \\) {{
                \\                self.instance.{s} = true;
                \\                break;
                \\            }}
                \\        }}
                \\
            , .{ext.name});
        }
    }
    w.write(
        \\        // Device extensions
        \\
    , .{});
    {
        for (db.extensions.device) |*ext| {
            w.write(
                \\        for (de) |ext| {{
                \\            if (std.mem.eql(u8, ext, "{s}")
            , .{ext.name});
            if (ext.depends.len != 0) try write_depends(
                alloc,
                file,
                db.extensions.instance,
                ext.depends,
            );
            w.write(
                \\) {{
                \\                self.device.{s} = true;
                \\                break;
                \\            }}
                \\        }}
                \\
            , .{ext.name});
        }
    }

    w.write(
        \\        return self;
        \\    }}
        \\}};
        \\
    , .{});
}

fn write_types_validation(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };

    for (db.types.structs) |*@"struct"| {
        w.write(
            \\
            \\pub fn validate_{s}(extensions: *const Extensions, item: *const vk.{s}, validate_pnext: bool) bool {{
            \\
        , .{ @"struct".name, @"struct".name });
        var checked_members: u32 = 0;
        var has_pnext: bool = false;
        for (@"struct".members) |*member| {
            if (eql(member.name, "pNext")) has_pnext = true;
            for (db.enums.items) |*@"enum"| {
                if (eql(@"enum".name, member.type)) {
                    checked_members += 1;
                    if (member.len) |len| {
                        switch (len) {
                            .null => {
                                w.write(
                                    \\    for (std.mem.span(item.{[member]s})) |*i| {{
                                    \\        if (!validate_{[type]t}_{[name]s}(extensions, @ptrCast(i)))
                                    \\            return false;
                                    \\    }}
                                    \\
                                , .{
                                    .member = member.name,
                                    .type = @"enum".type,
                                    .name = @"enum".name,
                                });
                            },
                            .member => |m| {
                                if (@"struct".has_member(m)) {
                                    w.write(
                                        \\    for (0..item.{s}) |i| {{
                                        \\        if (!validate_{t}_{s}(extensions, @ptrCast(&item.{s}[i])))
                                        \\            return false;
                                        \\    }}
                                        \\
                                    , .{ m, @"enum".type, @"enum".name, member.name });
                                }
                            },
                        }
                        break;
                    } else {
                        w.write(
                            \\    if (!validate_{t}_{s}(extensions, @ptrCast(&item.{s})))
                            \\        return false;
                            \\
                        , .{ @"enum".type, @"enum".name, member.name });
                        break;
                    }
                }
            }
            for (db.types.bitmasks) |*bitmask| {
                if (eql(member.type, bitmask.type_name)) {
                    checked_members += 1;
                    if (member.len) |len| {
                        switch (len) {
                            .null => {
                                w.write(
                                    \\    for (std.mem.span(item.{s})) |*i| {{
                                    \\        if (!validate_bitmask_{s}(extensions, @ptrCast(i)))
                                    \\            return false;
                                    \\    }}
                                    \\
                                , .{ bitmask.enum_name, member.name });
                            },
                            .member => |m| {
                                if (@"struct".has_member(m)) {
                                    w.write(
                                        \\    for (0..item.{s}) |i| {{
                                        \\        if (!validate_bitmask_{s}(extensions, @ptrCast(&item.{s}[i])))
                                        \\            return false;
                                        \\    }}
                                        \\
                                    , .{ m, bitmask.enum_name, member.name });
                                }
                            },
                        }
                        break;
                    } else {
                        w.write(
                            \\    if (!validate_bitmask_{s}(extensions, @ptrCast(&item.{s})))
                            \\        return false;
                            \\
                        , .{ bitmask.enum_name, member.name });
                        break;
                    }
                }
            }
        }
        if (checked_members == 0)
            w.write(
                \\    _ = extensions;
                \\    _ = item;
                \\
            , .{});
        if (has_pnext) {
            w.write(
                \\    if (!validate_pnext) return true;
                \\
                \\    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
                \\    while (pnext) |next| {{
                \\        pnext = next.pNext;
                \\        switch (next.sType) {{
                \\
            , .{});
            for (db.types.structs) |*ss| {
                if (ss.extends) |extends| {
                    if (ss.stype()) |stype| {
                        if (std.mem.indexOf(u8, extends, @"struct".name) != null) {
                            w.write(
                                \\            vk.{[stype]s},
                                \\            => if (!validate_{[type]s}(extensions, @ptrCast(next), false))
                                \\                return false,
                                \\
                            , .{ .stype = stype, .type = ss.name });
                        }
                    }
                }
            }
            w.write(
                \\            else => |v| {{
                \\                log.debug(@src(), "Invalid pNext chain item for {[name]s}: {{d}}", .{{v}});
                \\                return false;
                \\            }},
                \\        }}
                \\    }}
                \\    return true;
                \\}}
                \\
            , .{ .name = @"struct".name });
        } else {
            w.write(
                \\    _ = validate_pnext;
                \\    return true;
                \\}}
                \\
            , .{});
        }
    }
    for (db.enums.items) |@"enum"| {
        if (std.mem.indexOfScalar(u8, @"enum".name, ' ') != null) continue;
        w.write(
            \\
            \\pub fn validate_{[type]t}_{[name]s}(extensions: *const Extensions, item: *const vk.{[name]s}) bool {{
            \\
        , .{ .type = @"enum".type, .name = @"enum".name });
        switch (@"enum".type) {
            .bitmask => {
                var tmp: std.ArrayListUnmanaged(u8) = .empty;
                var writer = tmp.writer(alloc);
                for (@"enum".items) |i| {
                    try writer.print(
                        \\ |
                        \\        vk.{s}
                    , .{i.name});
                }
                try writer.print(
                    \\;
                    \\
                , .{});

                var extensions_used: u32 = 0;
                var iter = db.all_extensions();
                while (iter.next()) |tuple| {
                    const ext, const ext_type = tuple;
                    for (ext.require) |req| {
                        for (req.items) |item| {
                            switch (item) {
                                .@"enum" => |ee| {
                                    if (eql(ee.extends, @"enum".name)) {
                                        extensions_used += 1;
                                        try writer.print(
                                            \\    if (extensions.{t}.{s})
                                            \\        valid_bits |= vk.{s};
                                            \\
                                        , .{ ext_type, ext.name, ee.name });
                                    }
                                },
                                else => {},
                            }
                        }
                    }
                }
                if (extensions_used != 0)
                    w.write(
                        \\    var valid_bits: u{d} = 0{s}
                    , .{ @"enum".bitwidth, tmp.items })
                else
                    w.write(
                        \\    _ = extensions;
                        \\    const valid_bits: u{d} = 0{s}
                    , .{ @"enum".bitwidth, tmp.items });

                w.write(
                    \\    return (item.* & ~valid_bits) == 0;
                    \\}}
                    \\
                , .{});
            },
            .@"enum" => {
                if (@"enum".items.len != 1) {
                    w.write(
                        \\    const min = @min(
                    , .{});
                    for (@"enum".items) |i| {
                        w.write(
                            \\
                            \\        vk.{s},
                        , .{i.name});
                    }
                    w.write(
                        \\
                        \\    );
                        \\
                    , .{});
                } else {
                    w.write(
                        \\    const min = vk.{s};
                        \\
                    , .{@"enum".items[0].name});
                }

                if (@"enum".items.len != 1) {
                    w.write(
                        \\    const max = @max(
                    , .{});
                    for (@"enum".items) |i| {
                        w.write(
                            \\
                            \\        vk.{s},
                        , .{i.name});
                    }
                    w.write(
                        \\
                        \\    );
                        \\
                    , .{});
                } else {
                    w.write(
                        \\    const max = vk.{s};
                        \\
                    , .{@"enum".items[0].name});
                }

                w.write(
                    \\    if (min <= item.* and item.* <= max)
                    \\        return true;
                    \\
                , .{});
                var extensions_used: u32 = 0;
                var iter = db.all_extensions();
                while (iter.next()) |tuple| {
                    const ext, const ext_type = tuple;
                    for (ext.require) |req| {
                        for (req.items) |item| {
                            switch (item) {
                                .@"enum" => |ee| {
                                    if (eql(ee.extends, @"enum".name)) {
                                        extensions_used += 1;
                                        w.write(
                                            \\    if (extensions.{t}.{s} and item.* == vk.{s})
                                            \\        return true;
                                            \\
                                        , .{ ext_type, ext.name, ee.name });
                                    }
                                },
                                else => {},
                            }
                        }
                    }
                }
                if (extensions_used == 0)
                    w.write(
                        \\    _ = extensions;
                        \\
                    , .{});

                w.write(
                    \\    return false;
                    \\}}
                    \\
                , .{});
            },
        }
    }
}

const SpirvCapChecks = struct {
    cap: []const u8,
    checks: []const Check,

    const Check = union(enum) {
        pdf_check: PDFCheck,
        additional_pdf_check: AdditionalPDFCheck,
        version: []const u8,
        extension: []const u8,
    };

    const PDFCheck = struct {
        feature: []const u8,
    };

    const AdditionalPDFCheck = struct {
        field: []const u8,
        feature: []const u8,
    };
};

const StructExt = union(enum) {
    name: []const u8,
    vk: []const u8,
};
fn get_ext_for_struct(
    alloc: Allocator,
    db: *const vkp.Database,
    struct_name: []const u8,
) !StructExt {
    if (db.extension_which_adds_struct(struct_name)) |ext| {
        return .{ .name = ext.name };
    } else {
        return .{ .vk = try root.get_extension(alloc, struct_name) };
    }
}

fn get_spriv_types(
    alloc: Allocator,
    db: *const vkp.Database,
) !struct { [][]const u8, []SpirvCapChecks } {
    var cap_checks: std.ArrayListUnmanaged(SpirvCapChecks) = .empty;

    var spirv_pdfs: std.StringArrayHashMapUnmanaged(void) = .empty;
    for (db.spirv.capabilities) |cap| {
        var checks: std.ArrayListUnmanaged(SpirvCapChecks.Check) = .empty;
        for (cap.enable) |enable| {
            switch (enable) {
                .sfr => |sfr| {
                    if (eql(sfr.@"struct", "VkPhysicalDeviceFeatures")) {
                        try checks.append(alloc, .{ .pdf_check = .{ .feature = sfr.feature } });
                        continue;
                    }
                    if (std.mem.indexOf(u8, sfr.@"struct", "Vulkan1") != null) {
                        var iter = std.mem.splitScalar(u8, sfr.requires, ',');
                        while (iter.next()) |part| {
                            if (std.mem.startsWith(u8, part, "VK_VERSION_")) continue;

                            if (db.extension_by_name(part)) |tuple| {
                                const ext, _ = tuple;
                                outer: for (ext.require) |req| {
                                    for (req.items) |item| {
                                        switch (item) {
                                            .type => |t| {
                                                if (db.struct_by_name(t)) |s| {
                                                    if (s.has_member(sfr.feature)) {
                                                        if (spirv_pdfs.getPtr(s.name) == null) {
                                                            try spirv_pdfs.put(alloc, s.name, {});
                                                        }
                                                        try checks.append(
                                                            alloc,
                                                            .{
                                                                .additional_pdf_check = .{
                                                                    .field = s.name,
                                                                    .feature = sfr.feature,
                                                                },
                                                            },
                                                        );
                                                        break :outer;
                                                    }
                                                } else {
                                                    std.log.info(
                                                        "Extension {s} has non existing type: {s}",
                                                        .{ ext.name, t },
                                                    );
                                                }
                                            },
                                            else => {},
                                        }
                                    }
                                } else {
                                    std.log.info(
                                        "Cannot find replacement with field: {s}",
                                        .{sfr.feature},
                                    );
                                }
                            } else {
                                std.log.info("Cannot find extension: {s}", .{part});
                            }
                        }
                    } else {
                        if (db.struct_by_name(sfr.@"struct")) |s| {
                            if (spirv_pdfs.getPtr(s.name) == null)
                                try spirv_pdfs.put(alloc, s.name, {});
                            try checks.append(
                                alloc,
                                .{
                                    .additional_pdf_check = .{
                                        .field = s.name,
                                        .feature = sfr.feature,
                                    },
                                },
                            );
                        } else {
                            std.log.info("cannot find struct: {s}", .{sfr.@"struct"});
                        }
                    }
                },
                .extension => |e| {
                    try checks.append(alloc, .{ .extension = e });
                },
                .version => |v| {
                    try checks.append(alloc, .{ .version = v });
                },
                .property => |prop| {
                    _ = prop;
                },
            }
        }
        try cap_checks.append(alloc, .{ .cap = cap.name, .checks = checks.items });
    }
    return .{ spirv_pdfs.keys(), cap_checks.items };
}

const ADDITIONAL_PDFS: []const []const u8 = &.{
    "VkPhysicalDeviceRobustness2FeaturesKHR",
    "VkPhysicalDeviceImageRobustnessFeatures",
    "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV",
    "VkPhysicalDeviceFragmentShadingRateFeaturesKHR",
    "VkPhysicalDeviceMeshShaderFeaturesEXT",
    "VkPhysicalDeviceMeshShaderFeaturesNV",
    "VkPhysicalDeviceDescriptorBufferFeaturesEXT",
    "VkPhysicalDeviceShaderObjectFeaturesEXT",
    "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT",
    "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT",
};

fn write_physical_device_type(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var additional_pdfs: std.StringArrayHashMapUnmanaged(void) = .empty;
    const spirv_pdfs, _ = try get_spriv_types(alloc, db);
    for (spirv_pdfs) |spdf| try additional_pdfs.put(alloc, spdf, {});
    for (ADDITIONAL_PDFS) |apdf| try additional_pdfs.put(alloc, apdf, {});

    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\pub const AdditionalPDF = struct {{
        \\
    , .{});
    for (additional_pdfs.keys()) |pdf| {
        if (db.struct_by_name(pdf)) |s| {
            const stype = s.stype().?;
            w.write(
                \\    {[type]s}: vk.{[type]s} =
                \\        .{{ .sType = vk.{[stype]s} }},
                \\
            , .{ .type = s.name, .stype = stype });
        }
    }
    w.write(
        \\
        \\    pub fn chain_supported(pdf: *AdditionalPDF, extensions: [][*c]const u8) ?*anyopaque {{
        \\        var pnext: ?*anyopaque = null;
        \\        for (extensions) |ext| {{
        \\            const e = std.mem.span(ext);
        \\
    , .{});
    for (additional_pdfs.keys()) |pdf| {
        const ext = try get_ext_for_struct(alloc, db, pdf);
        switch (ext) {
            .name => |name| {
                w.write(
                    \\            if (std.mem.eql(u8, e, "{[ext]s}")) {{
                    \\                log.debug(@src(), "Adding {[ext]s} extension to the physical device features pnext chain", .{{}});
                    \\
                , .{ .ext = name });
            },
            .vk => |v| {
                w.write(
                    \\            if (std.mem.eql(u8, e, vk.{[ext]s})) {{
                    \\                log.debug(@src(), "Adding {[ext]s} extension to the physical device features pnext chain", .{{}});
                    \\
                , .{ .ext = v });
            },
        }
        w.write(
            \\                pdf.{[type]s}.pNext = pnext;
            \\                pnext = &pdf.{[type]s};
            \\                continue;
            \\            }}
            \\
        , .{ .type = pdf });
    }
    w.write(
        \\        }}
        \\        return pnext;
        \\    }}
        \\}};
        \\
    , .{});
}

fn write_spirv_validation(
    alloc: Allocator,
    file: *const std.fs.File,
    db: *const vkp.Database,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\
        \\pub fn validate_spirv_extension(validation: *const Validation, extension_name: []const u8) bool {{
        \\
    , .{});
    for (db.spirv.extensions) |*sext| {
        if (db.extension_by_name(sext.extension)) |tuple| {
            const ext, const t = tuple;
            if (sext.version) |v| {
                w.write(
                    \\    if (std.mem.eql(u8, extension_name, "{[sname]s}"))
                    \\        return validation.extensions.{[type]t}.{[name]s} or vk.{[version]s} <= validation.api_version;
                    \\
                , .{
                    .sname = sext.name,
                    .name = ext.name,
                    .type = t,
                    .version = vk_version_to_api_version(v).?,
                });
            } else {
                w.write(
                    \\    if (std.mem.eql(u8, extension_name, "{[sname]s}"))
                    \\        return validation.extensions.{[type]t}.{[name]s};
                    \\
                , .{ .sname = sext.name, .name = ext.name, .type = t });
            }
        }
    }
    w.write(
        \\    return false;
        \\}}
        \\
    , .{});

    _, const cap_checks = try get_spriv_types(alloc, db);
    w.write(
        \\
        \\pub fn validate_spirv_capability(validation: *const Validation, capability: spirv.SpvCapability) bool {{
        \\    switch (capability) {{
        \\
    , .{});
    for (cap_checks) |*cc| {
        w.write(
            \\        spirv.SpvCapability{[cap]s} => {{
            \\
        , .{ .cap = cc.cap });
        if (cc.checks.len == 0) {
            w.write(
                \\            return true;
                \\
            , .{});
        } else {
            for (cc.checks) |check| {
                switch (check) {
                    .pdf_check => |pdf_check| {
                        w.write(
                            \\            if (validation.pdf.features.{[feature]s} == vk.VK_TRUE) return true;
                            \\
                        , .{ .feature = pdf_check.feature });
                    },
                    .additional_pdf_check => |additional_pdf_check| {
                        w.write(
                            \\            if (validation.additional_pdf.{[field]s}.{[feature]s} == vk.VK_TRUE) return true;
                            \\
                        , .{
                            .field = additional_pdf_check.field,
                            .feature = additional_pdf_check.feature,
                        });
                    },
                    .version => |v| {
                        w.write(
                            \\            if (vk.{[version]s} <= validation.api_version) return true;
                            \\
                        , .{ .version = vk_version_to_api_version(v).? });
                    },
                    .extension => |e| {
                        if (db.extension_by_name(e)) |tuple| {
                            const ext, const t = tuple;
                            w.write(
                                \\            if (validation.extensions.{[type]t}.{[extension]s}) return true;
                                \\
                            , .{ .type = t, .extension = ext.name });
                        } else {
                            std.log.info("cannot find extension: {s}", .{e});
                        }
                    },
                }
            }
        }
        w.write(
            \\        }},
            \\
        , .{});
    }
    w.write(
        \\        else => |other| {{
        \\            log.debug(@src(), "Uknown SPRIV capability: {{d}}", .{{other}});
        \\            return false;
        \\        }}
        \\    }}
        \\    return false;
        \\}}
        \\
    , .{});
}
