const std = @import("std");
const Allocator = std.mem.Allocator;

const root = @import("root");
const XmlDatabase = @import("vk_database.zig").XmlDatabase;
const TypeDatabase = @import("vk_database.zig").TypeDatabase;

const vk = @import("volk");

const IN_PATH = "thirdparty/vulkan-object/src/vulkan_object/vk.xml";
const OUT_PATH = "src/vk_validation.zig";
const HEADER =
    \\// This file is auto generated by gen/{s}
    \\
    \\const std = @import("std");
    \\const vk = @import("vk.zig");
    \\const spirv = @import("spirv");
    \\const log = @import("log.zig");
    \\const Allocator = std.mem.Allocator;
    \\
    \\
;

pub fn main() !void {
    var arena: std.heap.ArenaAllocator = .init(std.heap.page_allocator);
    const alloc = arena.allocator();

    const xml_file = try std.fs.cwd().openFile(IN_PATH, .{});
    const buffer = try alloc.alloc(u8, (try xml_file.stat()).size);
    _ = try xml_file.readAll(buffer);

    const xml_db: XmlDatabase = try .init(alloc, buffer);
    const type_db: TypeDatabase = try .from_xml_database(alloc, &xml_db);

    std.fs.cwd().deleteFile(OUT_PATH) catch {};
    const file = try std.fs.cwd().createFile(OUT_PATH, .{});
    defer file.close();

    const header = std.fmt.comptimePrint(HEADER, .{@src().file});
    _ = try file.write(header);

    var tmp_arena: std.heap.ArenaAllocator = .init(std.heap.page_allocator);
    const tmp_alloc = tmp_arena.allocator();

    try write_extension_type(tmp_alloc, &file, &xml_db);
    _ = tmp_arena.reset(.retain_capacity);
    try write_types_validation(tmp_alloc, &file, &type_db);
    _ = tmp_arena.reset(.retain_capacity);
    try write_physical_device_type(tmp_alloc, &file, &type_db);
    _ = tmp_arena.reset(.retain_capacity);
    try write_spirv_validation(tmp_alloc, &file, &xml_db);
    _ = tmp_arena.reset(.retain_capacity);
    _ = try file.write(VALIDATE_SHADER_CODE);
    _ = try file.write(VALIDATION_STRUCT);
}

const Writer = struct {
    alloc: Allocator,
    file: *const std.fs.File,

    const Self = @This();

    fn write(self: *Self, comptime fmt: []const u8, args: anytype) void {
        const line = std.fmt.allocPrint(self.alloc, fmt, args) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
        _ = self.file.write(line) catch |e| {
            std.log.err("Err: {t}", .{e});
            unreachable;
        };
    }
};

fn eql(s1: []const u8, s2: []const u8) bool {
    return std.mem.eql(u8, s1, s2);
}

const VALIDATE_SHADER_CODE =
    \\pub fn validate_shader_code(
    \\    validation: *const Validation,
    \\    create_info: *const vk.VkShaderModuleCreateInfo,
    \\) bool {
    \\    var code: []const u32 = undefined;
    \\    code.ptr = create_info.pCode;
    \\    code.len = create_info.codeSize / @sizeOf(u32);
    \\
    \\    // Impossibly small shader
    \\    if (code.len < 5) return false;
    \\    if (code[0] != spirv.SpvMagicNumber) return false;
    \\
    \\    const version = code[1];
    \\    if (spirv.SPV_VERSION < version) return false;
    \\    if (version == 0x10600 and validation.api_version < vk.VK_API_VERSION_1_3) return false;
    \\    if (version == 0x10500 and validation.api_version < vk.VK_API_VERSION_1_2) return false;
    \\    if (0x10400 <= version and
    \\        (validation.api_version < vk.VK_API_VERSION_1_2 and
    \\            !validation.extensions.device.VK_KHR_spirv_1_4)) return false;
    \\    if (0x10300 <= version and validation.api_version < vk.VK_API_VERSION_1_1) return false;
    \\    if (0x10000 < version and validation.api_version < vk.VK_API_VERSION_1_1) return false;
    \\
    \\    var offset: usize = 5;
    \\    while (offset < code.len) {
    \\        const op: spirv.SpvCapability = code[offset] & 0xffff;
    \\        const count = (code[offset] >> 16) & 0xffff;
    \\
    \\        if (count == 0) return false;
    \\        if (code.len < offset + count) return false;
    \\
    \\        if (op == spirv.SpvOpCapability) {
    \\            if (count != 2) return false;
    \\
    \\            const capability = code[offset + 1];
    \\            if (!validate_spirv_capability(validation, capability)) {
    \\                log.debug(@src(), "Invalid SPIR-V capability: {d}", .{capability});
    \\                return false;
    \\            }
    \\        } else if (op == spirv.SpvOpExtension) {
    \\            if (count < 2) return false;
    \\            const byte_slice: [*c]const u8 = @ptrCast(code[offset + 1 ..].ptr);
    \\            const name = std.mem.span(byte_slice);
    \\            if (!validate_spirv_extension(validation, name)) {
    \\                log.debug(@src(), "Invalid SPIR-V extension: {s}", .{name});
    \\                return false;
    \\            }
    \\        } else if (op == spirv.SpvOpFunction) {
    \\            // Code starts here, stop validation
    \\            break;
    \\        }
    \\        offset += count;
    \\    }
    \\
    \\    return true;
    \\}
    \\
;

const VALIDATION_STRUCT =
    \\pub const Validation = struct {
    \\    api_version: u32 = 0,
    \\    extensions: Extensions = .{},
    \\    pdf: vk.VkPhysicalDeviceFeatures2 = .{},
    \\    additional_pdf: AdditionalPDF = .{},
    \\};
    \\
;

fn vk_version_to_api_version(s: []const u8) ?[]const u8 {
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_0")) return "VK_API_VERSION_1_0";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_1")) return "VK_API_VERSION_1_1";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_2")) return "VK_API_VERSION_1_2";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_3")) return "VK_API_VERSION_1_3";
    if (std.mem.startsWith(u8, s, "VK_VERSION_1_4")) return "VK_API_VERSION_1_4";
    return null;
}

// Converst:
// ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// into:
// ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version
fn write_depends(
    alloc: Allocator,
    file: *const std.fs.File,
    instance_extensions: []*const XmlDatabase.Extension,
    depends: []const u8,
) !void {
    _ = try file.write(" and (");
    var output: std.ArrayListUnmanaged(u8) = .empty;
    var writer = output.writer(alloc);
    var i: usize = 0;
    while (i < depends.len) : (i += 1) {
        const c = depends[i];
        switch (c) {
            '(' => _ = try writer.write("("),
            ')' => _ = try writer.write(")"),
            ',' => _ = try writer.write(" or "),
            '+' => _ = try writer.write(" and "),
            else => {
                if (vk_version_to_api_version(depends[i..])) |version| {
                    try writer.print("vk.{s} <= api_version", .{version});
                    i += "VK_VERSION_1_1".len - 1;
                } else {
                    if (std.mem.indexOfAny(u8, depends[i..], ",+)")) |index| {
                        const name = depends[i .. i + index];
                        var t: []const u8 = "device";
                        for (instance_extensions) |ext| {
                            if (eql(name, ext.name)) {
                                t = "instance";
                                break;
                            }
                        }
                        try writer.print("self.{s}.{s}", .{ t, name });
                        i += index - 1;
                    } else {
                        const name = depends[i..];
                        var t: []const u8 = "device";
                        for (instance_extensions) |ext| {
                            if (eql(name, ext.name)) {
                                t = "instance";
                                break;
                            }
                        }
                        try writer.print("self.{s}.{s}", .{ t, name });
                        i += depends[i..].len - 1;
                    }
                }
            },
        }
    }
    _ = try file.write(output.items);
    _ = try file.write(")");
}

fn write_extension_type(
    alloc: Allocator,
    file: *const std.fs.File,
    xml_db: *const XmlDatabase,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    var instance_extensions: std.ArrayListUnmanaged(*const XmlDatabase.Extension) = .empty;
    var device_extensions: std.ArrayListUnmanaged(*const XmlDatabase.Extension) = .empty;
    for (xml_db.extensions.items) |*ext| {
        if (ext.type == .instance and ext.supported == .supported) {
            try instance_extensions.append(alloc, ext);
        } else if (ext.type == .device and ext.supported == .supported) {
            try device_extensions.append(alloc, ext);
        }
    }
    w.write(
        \\pub const Extensions = struct {{
        \\    instance: packed struct(u{d}) {{
        \\
    , .{instance_extensions.items.len});
    for (instance_extensions.items) |ext|
        w.write(
            \\        {s}: bool = false,
            \\
        , .{ext.name});
    w.write(
        \\    }} = .{{}},
        \\    device: packed struct(u{d}) {{
        \\
    , .{device_extensions.items.len});

    for (device_extensions.items) |ext| {
        w.write(
            \\        {s}: bool = false,
            \\
        , .{ext.name});
    }
    w.write(
        \\    }} = .{{}},
        \\
        \\    const Self = @This();
        \\
    , .{});

    w.write(
        \\
        \\    pub fn init(
        \\        tmp_alloc: Allocator,
        \\        api_version: u32,
        \\        instance_extensions: []const [*c]const u8,
        \\        device_extensions: []const [*c]const u8,
        \\    ) !Self {{
        \\        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        \\        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        \\        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        \\        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        \\        var self: Self = .{{}};
        \\
    , .{});
    {
        for (&[_]struct { []const u8, []const u8 }{
            .{ "VK_API_VERSION_1_1", "VK_VERSION_1_1" },
            .{ "VK_API_VERSION_1_2", "VK_VERSION_1_2" },
            .{ "VK_API_VERSION_1_3", "VK_VERSION_1_3" },
            .{ "VK_API_VERSION_1_4", "VK_VERSION_1_4" },
        }) |tuple| {
            const api_version, const promotedto = tuple;
            w.write(
                \\        if (vk.{s} <= api_version) {{
                \\
            , .{api_version});
            for (instance_extensions.items) |ext| {
                if (ext.promotedto) |pt| {
                    if (!eql(pt, promotedto)) continue;
                    w.write(
                        \\            self.instance.{s} = true;
                        \\
                    , .{ext.name});
                }
            }
            for (device_extensions.items) |ext| {
                if (ext.promotedto) |pt| {
                    if (!eql(pt, promotedto)) continue;
                    w.write(
                        \\            self.device.{s} = true;
                        \\
                    , .{ext.name});
                }
            }
            w.write(
                \\        }}
                \\
            , .{});
        }
    }
    w.write(
        \\        // Instance extensions
        \\
    , .{});
    {
        for (instance_extensions.items) |ext| {
            w.write(
                \\        for (ie) |ext| {{
                \\            if (std.mem.eql(u8, ext, "{s}")
            , .{ext.name});
            if (ext.depends) |depends| try write_depends(
                alloc,
                file,
                instance_extensions.items,
                depends,
            );
            w.write(
                \\) {{
                \\                self.instance.{s} = true;
                \\                break;
                \\            }}
                \\        }}
                \\
            , .{ext.name});
        }
    }
    w.write(
        \\        // Device extensions
        \\
    , .{});
    {
        for (device_extensions.items) |ext| {
            w.write(
                \\        for (de) |ext| {{
                \\            if (std.mem.eql(u8, ext, "{s}")
            , .{ext.name});
            if (ext.depends) |depends| try write_depends(
                alloc,
                file,
                instance_extensions.items,
                depends,
            );
            w.write(
                \\) {{
                \\                self.device.{s} = true;
                \\                break;
                \\            }}
                \\        }}
                \\
            , .{ext.name});
        }
    }

    w.write(
        \\        return self;
        \\    }}
        \\}};
        \\
    , .{});
}

fn write_types_validation(
    alloc: Allocator,
    file: *const std.fs.File,
    type_db: *const TypeDatabase,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };

    // Structs
    for (type_db.structs.items) |*@"struct"| {
        w.write(
            \\
            \\pub fn validate_{s}(extensions: *const Extensions, item: *const vk.{s}, validate_pnext: bool) bool {{
            \\
        , .{ @"struct".name, @"struct".name });

        var used_extensions: bool = false;
        var used_item: bool = false;
        var used_validate_pnext: bool = false;
        var has_pnext: bool = false;
        for (@"struct".fields) |field| {
            if (field != .single_field) continue;
            const sf = field.single_field;
            if (eql(sf.name, "pNext")) {
                has_pnext = true;
                continue;
            }
            const field_type = type_db.get_type_follow_alias(sf.type_idx);
            switch (field_type.*) {
                .base => |base| {
                    if (base == .struct_idx or
                        base == .bitfield_idx or
                        base == .enum_idx)
                    {
                        const name = try type_db.type_string(alloc, sf.type_idx);
                        w.write(
                            \\    if (!validate_{s}(extensions, &item.{s}))
                            \\        return false;
                            \\
                        , .{ name, sf.name });
                        used_extensions = true;
                        used_item = true;
                    }
                },
                .pointer => |pointer| {
                    const pointer_type = type_db.get_type(pointer.base_type_idx);
                    if (!(pointer_type.struct_idx() != .none) and
                        !(pointer_type.enum_idx() != .none) and
                        !(pointer_type.bitfield_idx() != .none))
                        continue;

                    w.write(
                        \\    if (item.{[field_name]s}) |v| {{
                        \\
                    , .{ .field_name = sf.name });
                    used_item = true;

                    const base_type_str = try type_db.type_string(
                        alloc,
                        pointer.base_type_idx,
                    );

                    if (pointer.is_slice) {
                        if (pointer.is_zero_terminated) {
                            w.write(
                                \\        for (std.mem.span(v)) |*vv| {{
                                \\
                            , .{});
                        } else if (sf.len_expression) |len| {
                            const Inner = struct {
                                fn format_len(
                                    a: Allocator,
                                    td: *const TypeDatabase,
                                    ss: *const TypeDatabase.Struct,
                                    l: []const u8,
                                ) []const u8 {
                                    const first_comma =
                                        std.mem.indexOfScalar(u8, l, ',') orelse l.len;
                                    var result = l[0..first_comma];
                                    if (result[0] == '(') {
                                        const space =
                                            std.mem.indexOfScalar(u8, result[1..], ' ') orelse
                                            unreachable;
                                        const f = result[1..][0..space];
                                        const ff = ss.single_field_by_name(f).?;
                                        const fft = td.get_type(ff.type_idx);
                                        if (fft.is_builtin()) {
                                            result = std.fmt.allocPrint(
                                                a,
                                                "(@as(u64, @intCast(item.{s})){s}",
                                                .{ f, result[1 + space ..] },
                                            ) catch unreachable;
                                        } else {
                                            result = std.fmt.allocPrint(
                                                a,
                                                "(@as(u32, @bitCast(item.{s})){s}",
                                                .{ f, result[1 + space ..] },
                                            ) catch unreachable;
                                        }
                                    } else if (std.mem.eql(u8, result, "2*VK_UUID_SIZE")) {
                                        result = "2 * vk.VK_UUID_SIZE";
                                    } else {
                                        result = std.fmt.allocPrint(
                                            a,
                                            "item.{s}",
                                            .{result},
                                        ) catch unreachable;
                                    }
                                    return result;
                                }
                            };
                            const l = Inner.format_len(alloc, type_db, @"struct", len);
                            w.write(
                                \\        for (v[0..{[len]s}]) |*vv| {{
                                \\
                            , .{ .len = l });
                        }
                        w.write(
                            \\            if (!validate_{s}(extensions, vv))
                            \\                return false;
                            \\
                        , .{base_type_str});
                        used_extensions = true;
                        w.write(
                            \\        }}
                            \\
                        , .{});
                    } else {
                        w.write(
                            \\        if (!validate_{s}(extensions, v))
                            \\            return false;
                            \\
                        , .{base_type_str});
                    }
                    w.write(
                        \\    }}
                        \\
                    , .{});
                },
                .array => |array| {
                    const array_type = type_db.get_type(array.base_type_idx);
                    if (!(array_type.struct_idx() != .none) and
                        !(array_type.enum_idx() != .none) and
                        !(array_type.bitfield_idx() != .none))
                        continue;
                    const base_type_str = try type_db.type_string(
                        alloc,
                        array.base_type_idx,
                    );
                    w.write(
                        \\        for (item.{s}) |v| {{
                        \\            if (!validate_{s}(extensions, v))
                        \\                return false;
                        \\        }}
                        \\
                    , .{ sf.name, base_type_str });
                    used_item = true;
                    used_extensions = true;
                },
                else => {},
            }
        }
        if (has_pnext) {
            w.write(
                \\    if (!validate_pnext) return true;
                \\
                \\    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
                \\    while (pnext) |next| {{
                \\        pnext = next.pNext;
                \\        switch (next.sType) {{
                \\
            , .{});
            used_validate_pnext = true;

            for (@"struct".extends) |type_idx| {
                const struct_idx = type_db.get_type(type_idx).base.struct_idx;
                const s = type_db.get_struct(struct_idx);
                const stype = s.stype().?;
                w.write(
                    \\            vk.VkStructType.{[stype]s},
                    \\            => if (!validate_{[type]s}(extensions, @ptrCast(next), false))
                    \\                return false,
                    \\
                , .{ .stype = stype, .type = s.name });
            }
            w.write(
                \\            else => |v| {{
                \\                log.debug(@src(), "Invalid pNext chain item for {[name]s}: {{d}}", .{{v}});
                \\                return false;
                \\            }},
                \\        }}
                \\    }}
                \\
            , .{ .name = @"struct".name });
        }
        if (!used_item) {
            w.write(
                \\    _ = item;
                \\
            , .{});
        }
        if (!used_extensions) {
            w.write(
                \\    _ = extensions;
                \\
            , .{});
        }
        if (!used_validate_pnext) {
            w.write(
                \\    _ = validate_pnext;
                \\
            , .{});
        }
        w.write(
            \\    return true;
            \\}}
            \\
        , .{});
    }

    // Enums
    for (type_db.enums.items) |*@"enum"| {
        w.write(
            \\
            \\pub fn validate_{[name]s}(extensions: *const Extensions, item: *const vk.{[name]s}) bool {{
            \\
        , .{ .name = @"enum".name });
        var used_extensions: bool = false;
        var min: i64 = std.math.maxInt(i64);
        var max: i64 = std.math.minInt(i64);
        for (@"enum".values) |value| {
            min = @min(min, value.value);
            max = @max(max, value.value);
        }
        w.write(
            \\    const min = {d};
            \\    const max = {d};
            \\    const v: i{d} = @bitCast(*item);
            \\    if (v < min or max < v)
            \\        return false;
            \\
        , .{ min, max, @"enum".backing_integer_width });
        for (@"enum".values, 0..) |value, i| {
            // Some extensions add same enum values, so check consecutive bits
            if (i < @"enum".values.len - 1) {
                if (value.value == @"enum".values[i + 1].value) continue;
            }

            if (value.enabled_by_extension) |ext| {
                if (!std.mem.startsWith(u8, ext, "VK_BASE") and
                    !std.mem.startsWith(u8, ext, "VK_GRAPHICS") and
                    !std.mem.startsWith(u8, ext, "VK_COMPUTE") and
                    !std.mem.startsWith(u8, ext, "VKSC"))
                {
                    w.write(
                        \\    if (extensions.device.{s} and item == .{s})
                        \\        return true;
                        \\
                    , .{ ext, value.name });
                    used_extensions = true;
                }
            }
        }
        if (!used_extensions) w.write(
            \\    _ = extensions;
            \\
        , .{});
        w.write(
            \\    return true;
            \\}}
            \\
        , .{});
    }

    // Bitfields
    for (type_db.bitfields.items) |*bitfield| {
        w.write(
            \\
            \\pub fn validate_{[name]s}(extensions: *const Extensions, item: *const vk.{[name]s}) bool {{
            \\    const valid_value: vk.{[name]s} = .{{
            \\
        , .{ .name = bitfield.name });
        var used_extensions: bool = false;
        for (bitfield.bits, 0..) |bit, i| {
            // Some extensions add same bits, so check consecutive bits
            if (i < bitfield.bits.len - 1) {
                if (bit.bit == bitfield.bits[i + 1].bit) {
                    continue;
                }
            }
            w.write(
                \\        .{s} = 
            , .{bit.name});
            if (bit.enabled_by_extension) |ext| {
                if (!std.mem.startsWith(u8, ext, "VK_BASE") and
                    !std.mem.startsWith(u8, ext, "VK_GRAPHICS") and
                    !std.mem.startsWith(u8, ext, "VK_COMPUTE") and
                    !std.mem.startsWith(u8, ext, "VKSC"))
                {
                    w.write(
                        \\extensions.device.{s},
                        \\
                    , .{ext});
                    used_extensions = true;
                } else {
                    w.write(
                        \\true,
                        \\
                    , .{});
                }
            } else {
                w.write(
                    \\true,
                    \\
                , .{});
            }
        }
        w.write(
            \\    }};
            \\
        , .{});
        if (!used_extensions) w.write(
            \\    _ = extensions;
            \\
        , .{});
        w.write(
            \\    const valid_bits: u{[bits]d} = @bitCast(valid_value);
            \\    const current_bits: u{[bits]d} = @bitCast(item.*);
            \\    return (current_bits & ~valid_bits) == 0;
            \\}}
            \\
        , .{ .bits = bitfield.backing_integer_width });
    }
}

fn write_physical_device_type(
    alloc: Allocator,
    file: *const std.fs.File,
    type_db: *const TypeDatabase,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\pub const AdditionalPDF = struct {{
        \\
    , .{});
    for (type_db.structs.items) |@"struct"| {
        if (std.mem.startsWith(u8, @"struct".name, "VkPhysicalDevice")) {
            if (@"struct".enabled_by_extension) |ext| {
                if (!std.mem.startsWith(u8, ext, "VK_BASE") and
                    !std.mem.startsWith(u8, ext, "VK_GRAPHICS") and
                    !std.mem.startsWith(u8, ext, "VK_COMPUTE") and
                    !std.mem.startsWith(u8, ext, "VKSC"))
                {
                    w.write(
                        \\    {[type]s}: vk.{[type]s} = .{{}},
                        \\
                    , .{ .type = @"struct".name });
                }
            }
        }
    }
    w.write(
        \\
        \\    pub fn chain_supported(pdf: *AdditionalPDF, extensions: [][*c]const u8) ?*anyopaque {{
        \\        var pnext: ?*anyopaque = null;
        \\        for (extensions) |ext| {{
        \\            const e = std.mem.span(ext);
        \\
    , .{});
    for (type_db.structs.items) |@"struct"| {
        if (std.mem.startsWith(u8, @"struct".name, "VkPhysicalDevice")) {
            if (@"struct".enabled_by_extension) |ext| {
                if (!std.mem.startsWith(u8, ext, "VK_BASE") and
                    !std.mem.startsWith(u8, ext, "VK_GRAPHICS") and
                    !std.mem.startsWith(u8, ext, "VK_COMPUTE") and
                    !std.mem.startsWith(u8, ext, "VKSC"))
                {
                    w.write(
                        \\            if (std.mem.eql(u8, e, "{[ext]s}")) {{
                        \\                pdf.{[type]s}.pNext = pnext;
                        \\                pnext = &pdf.{[type]s};
                        \\                continue;
                        \\            }}
                        \\
                    , .{ .type = @"struct".name, .ext = ext });
                }
            }
        }
    }
    w.write(
        \\        }}
        \\        return pnext;
        \\    }}
        \\}};
        \\
    , .{});
}

fn write_spirv_validation(
    alloc: Allocator,
    file: *const std.fs.File,
    xml_db: *const XmlDatabase,
) !void {
    var w: Writer = .{ .alloc = alloc, .file = file };
    w.write(
        \\
        \\pub fn validate_spirv_extension(validation: *const Validation, extension_name: []const u8) bool {{
        \\
    , .{});
    for (xml_db.spirv.extensions) |*sext| {
        if (xml_db.extension_by_name(sext.extension)) |ext| {
            if (sext.version) |v| {
                w.write(
                    \\    if (std.mem.eql(u8, extension_name, "{[sname]s}"))
                    \\        return validation.extensions.{[type]t}.{[name]s} or vk.{[version]s} <= validation.api_version;
                    \\
                , .{
                    .sname = sext.name,
                    .name = ext.name,
                    .type = ext.type,
                    .version = vk_version_to_api_version(v).?,
                });
            } else {
                w.write(
                    \\    if (std.mem.eql(u8, extension_name, "{[sname]s}"))
                    \\        return validation.extensions.{[type]t}.{[name]s};
                    \\
                , .{ .sname = sext.name, .name = ext.name, .type = ext.type });
            }
        }
    }
    w.write(
        \\    return false;
        \\}}
        \\
    , .{});

    w.write(
        \\
        \\pub fn validate_spirv_capability(validation: *const Validation, capability: spirv.SpvCapability) bool {{
        \\    switch (capability) {{
        \\
    , .{});
    for (xml_db.spirv.capabilities) |cap| {
        w.write(
            \\        spirv.SpvCapability{[name]s} => {{
            \\
        , .{ .name = cap.name });
        if (cap.enable.len == 0) {
            w.write(
                \\            return true;
                \\
            , .{});
        } else {
            for (cap.enable) |enable| {
                switch (enable) {
                    .sfr => |sfr| {
                        if (eql(sfr.@"struct", "VkPhysicalDeviceFeatures")) {
                            w.write(
                                \\            if (validation.pdf.features.{[feature]s} == vk.VK_TRUE) return true;
                                \\
                            , .{ .feature = sfr.feature });
                        } else {
                            w.write(
                                \\            if (validation.additional_pdf.{[str]s}.{[feature]s} == vk.VK_TRUE) return true;
                                \\
                            , .{ .str = sfr.@"struct", .feature = sfr.feature });
                        }
                    },
                    .property => |_| {},
                    .version => |v| {
                        w.write(
                            \\            if (vk.{[version]s} <= validation.api_version) return true;
                            \\
                        , .{ .version = vk_version_to_api_version(v).? });
                    },
                    .extension => |e| {
                        if (xml_db.extension_by_name(e)) |ext| {
                            w.write(
                                \\            if (validation.extensions.{[type]t}.{[extension]s}) return true;
                                \\
                            , .{ .type = ext.type, .extension = ext.name });
                        } else {
                            std.log.info("cannot find extension: {s}", .{e});
                        }
                    },
                }
            }
        }
        w.write(
            \\        }},
            \\
        , .{});
    }
    w.write(
        \\        else => |other| {{
        \\            log.debug(@src(), "Uknown SPRIV capability: {{d}}", .{{other}});
        \\            return false;
        \\        }},
        \\    }}
        \\    return false;
        \\}}
        \\
    , .{});
}
