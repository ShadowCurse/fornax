const std = @import("std");
const Allocator = std.mem.Allocator;

const root = @import("root");

const PATH = "src/vulkan_print.zig";
const HEADER =
    \\// This file is auto generated by gen/{s}
    \\
    \\const std = @import("std");
    \\const log = @import("log.zig");
    \\const vk = @import("volk.zig");
    \\
    \\
;

pub fn gen() !void {
    std.fs.cwd().deleteFile(PATH) catch {};
    const file = try std.fs.cwd().createFile(PATH, .{});
    defer file.close();

    _ = try file.write(root.NOTE);
    const header = std.fmt.comptimePrint(HEADER, .{@src().file});
    _ = try file.write(header);
    try write_vulkan_print(&file, &.{
        "VkPhysicalDevice16BitStorageFeatures",
        "VkPhysicalDevice8BitStorageFeatures",
        "VkPhysicalDeviceAccelerationStructureFeaturesKHR",
        "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT",
        "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT",
        "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT",
        "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT",
        "VkPhysicalDeviceBufferDeviceAddressFeatures",
        "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT",
        "VkPhysicalDeviceClusterAccelerationStructureFeaturesNV",
        "VkPhysicalDeviceColorWriteEnableFeaturesEXT",
        "VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR",
        "VkPhysicalDeviceConditionalRenderingFeaturesEXT",
        "VkPhysicalDeviceCooperativeMatrix2FeaturesNV",
        "VkPhysicalDeviceCooperativeMatrixFeaturesKHR",
        "VkPhysicalDeviceCooperativeMatrixFeaturesNV",
        "VkPhysicalDeviceCooperativeVectorFeaturesNV",
        "VkPhysicalDeviceCustomBorderColorFeaturesEXT",
        "VkPhysicalDeviceDepthBiasControlFeaturesEXT",
        "VkPhysicalDeviceDepthClampControlFeaturesEXT",
        "VkPhysicalDeviceDepthClipControlFeaturesEXT",
        "VkPhysicalDeviceDepthClipEnableFeaturesEXT",
        "VkPhysicalDeviceDescriptorBufferFeaturesEXT",
        "VkPhysicalDeviceDescriptorIndexingFeatures",
        "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV",
        "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT",
        "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV",
        "VkPhysicalDeviceDynamicRenderingFeaturesKHR",
        "VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR",
        "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT",
        "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT",
        "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT",
        "VkPhysicalDeviceFeatures2",
        "VkPhysicalDeviceFragmentDensityMapFeaturesEXT",
        "VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE",
        "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR",
        "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT",
        "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV",
        "VkPhysicalDeviceFragmentShadingRateFeaturesKHR",
        "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT",
        "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT",
        "VkPhysicalDeviceImageProcessing2FeaturesQCOM",
        "VkPhysicalDeviceImageProcessingFeaturesQCOM",
        "VkPhysicalDeviceImageRobustnessFeaturesEXT",
        "VkPhysicalDeviceInlineUniformBlockFeaturesEXT",
        "VkPhysicalDeviceLegacyDitheringFeaturesEXT",
        "VkPhysicalDeviceLineRasterizationFeaturesKHR",
        "VkPhysicalDeviceMaintenance4FeaturesKHR",
        "VkPhysicalDeviceMaintenance5FeaturesKHR",
        "VkPhysicalDeviceMaintenance7FeaturesKHR",
        "VkPhysicalDeviceMeshShaderFeaturesEXT",
        "VkPhysicalDeviceMeshShaderFeaturesNV",
        "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT",
        "VkPhysicalDeviceMultiviewFeatures",
        "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT",
        "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT",
        "VkPhysicalDeviceOpacityMicromapFeaturesEXT",
        "VkPhysicalDeviceOpticalFlowFeaturesNV",
        "VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV",
        "VkPhysicalDevicePerStageDescriptorSetFeaturesNV",
        "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR",
        "VkPhysicalDevicePipelineOpacityMicromapFeaturesARM",
        "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT",
        "VkPhysicalDevicePipelineRobustnessFeaturesEXT",
        "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT",
        "VkPhysicalDeviceProvokingVertexFeaturesEXT",
        "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT",
        "VkPhysicalDeviceRawAccessChainsFeaturesNV",
        "VkPhysicalDeviceRayQueryFeaturesKHR",
        "VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV",
        "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR",
        "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV",
        "VkPhysicalDeviceRayTracingPipelineFeaturesKHR",
        "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR",
        "VkPhysicalDeviceRobustness2FeaturesEXT",
        "VkPhysicalDeviceSamplerYcbcrConversionFeatures",
        "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT",
        "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures",
        "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT",
        "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT",
        "VkPhysicalDeviceShaderAtomicInt64Features",
        "VkPhysicalDeviceShaderBfloat16FeaturesKHR",
        "VkPhysicalDeviceShaderClockFeaturesKHR",
        "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM",
        "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT",
        "VkPhysicalDeviceShaderDrawParametersFeatures",
        "VkPhysicalDeviceShaderExpectAssumeFeaturesKHR",
        "VkPhysicalDeviceShaderFloat16Int8Features",
        "VkPhysicalDeviceShaderFloat8FeaturesEXT",
        "VkPhysicalDeviceShaderFloatControls2FeaturesKHR",
        "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT",
        "VkPhysicalDeviceShaderImageFootprintFeaturesNV",
        "VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR",
        "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL",
        "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT",
        "VkPhysicalDeviceShaderObjectFeaturesEXT",
        "VkPhysicalDeviceShaderQuadControlFeaturesKHR",
        "VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT",
        "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV",
        "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures",
        "VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR",
        "VkPhysicalDeviceShaderTileImageFeaturesEXT",
        "VkPhysicalDeviceShadingRateImageFeaturesNV",
        "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT",
        "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT",
        "VkPhysicalDeviceSynchronization2FeaturesKHR",
        "VkPhysicalDeviceTensorFeaturesARM",
        "VkPhysicalDeviceTileShadingFeaturesQCOM",
        "VkPhysicalDeviceTransformFeedbackFeaturesEXT",
        "VkPhysicalDeviceUniformBufferStandardLayoutFeatures",
        "VkPhysicalDeviceVariablePointersFeatures",
        "VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR",
        "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT",
        "VkPhysicalDeviceVulkanMemoryModelFeatures",
        "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR",
        "VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT",
        "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR",
    });
}

const PRINT_STRUCT =
    \\pub fn print_struct(@"struct": anytype) void {
    \\    print_struct_offset("", @"struct", 0);
    \\}
    \\
    \\fn print_struct_offset(name: []const u8, @"struct": anytype, base_offset: u32) void {
    \\    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    \\    const type_name = @typeName(t)["cimport.struct_".len..];
    \\    log.output("{s}: {s} = .{{\n", .{ name, type_name });
    \\    const fields = @typeInfo(t).@"struct".fields;
    \\    const fields_base_offset = base_offset + 1;
    \\    inline for (fields) |field| {
    \\        for (0..fields_base_offset) |_|
    \\            log.output("    ", .{});
    \\        switch (field.type) {
    \\            i16, i32, u32, u64, usize, vk.VkStructureType => {
    \\                log.output("{s}: {s} = {d},\n", .{
    \\                    field.name,
    \\                    @typeName(field.type),
    \\                    @field(@"struct", field.name),
    \\                });
    \\            },
    \\            f32, f64 => {
    \\                log.output("{s}: {d},\n", .{ field.name, @field(@"struct", field.name) });
    \\            },
    \\            [*c]const u8 => {
    \\                log.output("{s}: {s},\n", .{ field.name, @field(@"struct", field.name) });
    \\            },
    \\            [*c]const u32 => {
    \\                if (@hasField(t, "codeSize")) {
    \\                    const len = @field(@"struct", "codeSize");
    \\                    var code: []const u32 = undefined;
    \\                    code.ptr = @field(@"struct", field.name);
    \\                    code.len = len / @sizeOf(u32);
    \\                    log.output("{s}: {any},\n", .{ field.name, code });
    \\                }
    \\            },
    \\            ?*anyopaque,
    \\            ?*const anyopaque,
    \\            vk.VkPipelineLayout,
    \\            vk.VkRenderPass,
    \\            vk.VkPipeline,
    \\            => {
    \\                log.output("{s}: {?},\n", .{ field.name, @field(@"struct", field.name) });
    \\            },
    \\            [*c]const vk.VkDescriptorSetLayoutBinding => {
    \\                const len = @field(@"struct", "bindingCount");
    \\                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                for (elements) |*binding|
    \\                    print_struct_offset(field.name, binding, fields_base_offset);
    \\            },
    \\            [*c]const vk.VkDescriptorSetLayout => {
    \\                const len = @field(@"struct", "setLayoutCount");
    \\                var elements: []const *anyopaque = undefined;
    \\                elements.ptr = @ptrCast(@field(@"struct", field.name));
    \\                elements.len = len;
    \\                log.output("{s}: {any},\n", .{ field.name, elements });
    \\            },
    \\            [*c]const vk.VkPushConstantRange => {
    \\                const len = @field(@"struct", "pushConstantRangeCount");
    \\                var elements: []const vk.VkPushConstantRange = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                for (elements) |*binding|
    \\                    print_struct_offset(field.name, binding, fields_base_offset);
    \\            },
    \\            [*c]const vk.VkAttachmentDescription => {
    \\                const len = @field(@"struct", "attachmentCount");
    \\                var elements: []const vk.VkAttachmentDescription = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                for (elements) |*binding|
    \\                    print_struct_offset(field.name, binding, fields_base_offset);
    \\            },
    \\            [*c]const vk.VkSubpassDescription => {
    \\                const len = @field(@"struct", "subpassCount");
    \\                var elements: []const vk.VkSubpassDescription = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                for (elements) |*binding|
    \\                    print_struct_offset(field.name, binding, fields_base_offset);
    \\            },
    \\            [*c]const vk.VkAttachmentReference => {
    \\                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
    \\                    @field(@"struct", "inputAttachmentCount")
    \\                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
    \\                    @field(@"struct", "colorAttachmentCount")
    \\                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
    \\                    if (@field(@"struct", field.name) != null)
    \\                        break :blk @field(@"struct", "colorAttachmentCount")
    \\                    else
    \\                        break :blk 0;
    \\                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
    \\                    @intFromBool(@field(@"struct", field.name) != null)
    \\                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
    \\                    @field(@"struct", "preserveAttachmentCount")
    \\                else
    \\                    @panic("Cannot find length for the VkAttachmentReference array");
    \\
    \\                if (len != 0) {
    \\                    var elements: []const vk.VkAttachmentReference = undefined;
    \\                    elements.ptr = @field(@"struct", field.name);
    \\                    elements.len = len;
    \\                    for (elements) |*binding|
    \\                        print_struct_offset(field.name, binding, fields_base_offset);
    \\                }
    \\            },
    \\            [*c]const vk.VkSubpassDependency => {
    \\                const len = @field(@"struct", "dependencyCount");
    \\                var elements: []const vk.VkSubpassDependency = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                for (elements) |*binding|
    \\                    print_struct_offset(field.name, binding, fields_base_offset);
    \\            },
    \\            [*c]const vk.VkPipelineShaderStageCreateInfo => {
    \\                const len = @field(@"struct", "stageCount");
    \\                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                for (elements) |*binding|
    \\                    print_struct_offset(field.name, binding, fields_base_offset);
    \\            },
    \\            [*c]const vk.VkSpecializationMapEntry => {
    \\                const len = @field(@"struct", "mapEntryCount");
    \\                var elements: []const vk.VkSpecializationMapEntry = undefined;
    \\                elements.ptr = @field(@"struct", field.name);
    \\                elements.len = len;
    \\                for (elements) |*binding|
    \\                    print_struct_offset(field.name, binding, fields_base_offset);
    \\            },
    \\
    \\            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
    \\            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
    \\            [*c]const vk.VkPipelineTessellationStateCreateInfo,
    \\            [*c]const vk.VkPipelineViewportStateCreateInfo,
    \\            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
    \\            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
    \\            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
    \\            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
    \\            [*c]const vk.VkPipelineDynamicStateCreateInfo,
    \\            [*c]const vk.VkSpecializationInfo,
    \\            [*c]const vk.VkViewport,
    \\            [*c]const vk.VkRect2D,
    \\            => {
    \\                const element_type = @typeInfo(field.type).pointer.child;
    \\                const element: ?*const element_type = @field(@"struct", field.name);
    \\                if (element) |e|
    \\                    print_struct_offset(field.name, e, fields_base_offset)
    \\                else
    \\                    log.output("{s}: {?},\n", .{ field.name, element });
    \\            },
    \\            vk.VkPhysicalDeviceFeatures => print_struct_offset(
    \\                field.name,
    \\                &@field(@"struct", field.name),
    \\                fields_base_offset,
    \\            ),
    \\            else => log.warn(
    \\                @src(),
    \\                "Cannot format field {s} of type {s}",
    \\                .{ field.name, @typeName(field.type) },
    \\            ),
    \\        }
    \\    }
    \\    for (0..base_offset) |_|
    \\        log.output("    ", .{});
    \\    log.output("}},\n", .{});
    \\}
    \\
;

fn write_vulkan_print(file: *const std.fs.File, types: []const []const u8) !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const alloc = arena.allocator();

    _ = try file.write(
        \\pub fn print_chain(chain: anytype) void {
        \\    var current: ?*const anyopaque = chain;
        \\    while (current) |c| {
        \\        const base_struct: *const vk.VkBaseInStructure = @alignCast(@ptrCast(c));
        \\        switch (base_struct.sType) {
        \\
    );
    for (0..types.len) |i| {
        defer _ = arena.reset(.retain_capacity);

        const t = types[types.len - i - 1];
        const stype = try root.get_stype(alloc, t);
        const line = try std.fmt.allocPrint(
            alloc,
            \\            vk.{s} => {{
            \\                const nn: *const vk.{s} = @alignCast(@ptrCast(c));
            \\                print_struct(nn);
            \\                current = nn.pNext;
            \\            }},
            \\
        ,
            .{ stype, t },
        );
        _ = try file.write(line);
    }
    _ = try file.write(
        \\            else => {
        \\                log.warn(@src(), "Unknown struct sType: {d}", .{base_struct.sType});
        \\                current = base_struct.pNext;
        \\            },
        \\        }
        \\    }
        \\}
        \\
    );
    _ = try file.write(PRINT_STRUCT);
}
