// This file is auto generated by gen/gen_vk_utils.zig

const std = @import("std");
const vk = @import("vk.zig");
const log = @import("log.zig");

pub fn print_VkBaseOutStructure(name: []const u8, value: *const vk.VkBaseOutStructure, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBaseOutStructure = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBaseInStructure(name: []const u8, value: *const vk.VkBaseInStructure, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBaseInStructure = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOffset2D(name: []const u8, value: *const vk.VkOffset2D, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOffset2D = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    x: i32 = {d},\n", .{value.x});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    y: i32 = {d},\n", .{value.y});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOffset3D(name: []const u8, value: *const vk.VkOffset3D, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOffset3D = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    x: i32 = {d},\n", .{value.x});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    y: i32 = {d},\n", .{value.y});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    z: i32 = {d},\n", .{value.z});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExtent2D(name: []const u8, value: *const vk.VkExtent2D, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExtent2D = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: u32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: u32 = {d},\n", .{value.height});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExtent3D(name: []const u8, value: *const vk.VkExtent3D, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExtent3D = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: u32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: u32 = {d},\n", .{value.height});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depth: u32 = {d},\n", .{value.depth});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkViewport(name: []const u8, value: *const vk.VkViewport, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkViewport = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    x: f32 = {d},\n", .{value.x});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    y: f32 = {d},\n", .{value.y});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: f32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: f32 = {d},\n", .{value.height});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minDepth: f32 = {d},\n", .{value.minDepth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDepth: f32 = {d},\n", .{value.maxDepth});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRect2D(name: []const u8, value: *const vk.VkRect2D, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRect2D = .{{\n", .{ name });
    print_VkOffset2D("offset", &value.offset, offset + 1);
    print_VkExtent2D("extent", &value.extent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClearRect(name: []const u8, value: *const vk.VkClearRect, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClearRect = .{{\n", .{ name });
    print_VkRect2D("rect", &value.rect, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseArrayLayer: u32 = {d},\n", .{value.baseArrayLayer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layerCount: u32 = {d},\n", .{value.layerCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkComponentMapping(name: []const u8, value: *const vk.VkComponentMapping, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkComponentMapping = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    r: VkComponentSwizzle = {t},\n", .{value.r});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    g: VkComponentSwizzle = {t},\n", .{value.g});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    b: VkComponentSwizzle = {t},\n", .{value.b});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    a: VkComponentSwizzle = {t},\n", .{value.a});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceProperties(name: []const u8, value: *const vk.VkPhysicalDeviceProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    apiVersion: u32 = {any},\n", .{value.apiVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverVersion: u32 = {any},\n", .{value.driverVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorID: u32 = {d},\n", .{value.vendorID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceID: u32 = {d},\n", .{value.deviceID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceType: VkPhysicalDeviceType = {t},\n", .{value.deviceType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceName: [VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8 = {any},\n", .{value.deviceName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCacheUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.pipelineCacheUUID});
    print_VkPhysicalDeviceLimits("limits", &value.limits, offset + 1);
    print_VkPhysicalDeviceSparseProperties("sparseProperties", &value.sparseProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExtensionProperties(name: []const u8, value: *const vk.VkExtensionProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExtensionProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extensionName: [VK_MAX_EXTENSION_NAME_SIZE]u8 = {any},\n", .{value.extensionName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    specVersion: u32 = {any},\n", .{value.specVersion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLayerProperties(name: []const u8, value: *const vk.VkLayerProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLayerProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layerName: [VK_MAX_EXTENSION_NAME_SIZE]u8 = {any},\n", .{value.layerName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    specVersion: u32 = {any},\n", .{value.specVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    implementationVersion: u32 = {any},\n", .{value.implementationVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkApplicationInfo(name: []const u8, value: *const vk.VkApplicationInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkApplicationInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pApplicationName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pApplicationName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    applicationVersion: u32 = {any},\n", .{value.applicationVersion});
    if (value.pEngineName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pEngineName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    engineVersion: u32 = {any},\n", .{value.engineVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    apiVersion: u32 = {any},\n", .{value.apiVersion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAllocationCallbacks(name: []const u8, value: *const vk.VkAllocationCallbacks, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAllocationCallbacks = .{{\n", .{ name });
    if (value.pUserData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = null,\n", .{});
    }
    if (value.pfnAllocation) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnAllocation: *const vkAllocationFunction = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnAllocation: *const vkAllocationFunction = null,\n", .{});
    }
    if (value.pfnReallocation) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnReallocation: *const vkReallocationFunction = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnReallocation: *const vkReallocationFunction = null,\n", .{});
    }
    if (value.pfnFree) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnFree: *const vkFreeFunction = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnFree: *const vkFreeFunction = null,\n", .{});
    }
    if (value.pfnInternalAllocation) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnInternalAllocation: *const vkInternalAllocationNotification = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnInternalAllocation: *const vkInternalAllocationNotification = null,\n", .{});
    }
    if (value.pfnInternalFree) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnInternalFree: *const vkInternalFreeNotification = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnInternalFree: *const vkInternalFreeNotification = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceQueueCreateInfo(name: []const u8, value: *const vk.VkDeviceQueueCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceQueueCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDeviceQueueCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndex: u32 = {d},\n", .{value.queueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueCount: u32 = {d},\n", .{value.queueCount});
    if (value.pQueuePriorities) |v| {
        for (v[0..value.queueCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pQueuePriorities: [*]const f32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueuePriorities: [*]const f32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceCreateInfo(name: []const u8, value: *const vk.VkDeviceCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDeviceCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueCreateInfoCount: u32 = {d},\n", .{value.queueCreateInfoCount});
    if (value.pQueueCreateInfos) |v| {
        for (v[0..value.queueCreateInfoCount]) |*vv| {
            print_VkDeviceQueueCreateInfo("pQueueCreateInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueueCreateInfos: [*]const VkDeviceQueueCreateInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enabledLayerCount: u32 = {d},\n", .{value.enabledLayerCount});
    if (value.ppEnabledLayerNames) |v| {
        for (v[0..value.enabledLayerCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppEnabledLayerNames: [*]const [*:0]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppEnabledLayerNames: [*]const [*:0]const u8 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enabledExtensionCount: u32 = {d},\n", .{value.enabledExtensionCount});
    if (value.ppEnabledExtensionNames) |v| {
        for (v[0..value.enabledExtensionCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppEnabledExtensionNames: [*]const [*:0]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppEnabledExtensionNames: [*]const [*:0]const u8 = null,\n", .{});
    }
    if (value.pEnabledFeatures) |v| {
        print_VkPhysicalDeviceFeatures("pEnabledFeatures", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pEnabledFeatures: *const VkPhysicalDeviceFeatures = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkInstanceCreateInfo(name: []const u8, value: *const vk.VkInstanceCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkInstanceCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkInstanceCreateFlags = {any},\n", .{value.flags});
    if (value.pApplicationInfo) |v| {
        print_VkApplicationInfo("pApplicationInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pApplicationInfo: *const VkApplicationInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enabledLayerCount: u32 = {d},\n", .{value.enabledLayerCount});
    if (value.ppEnabledLayerNames) |v| {
        for (v[0..value.enabledLayerCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppEnabledLayerNames: [*]const [*:0]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppEnabledLayerNames: [*]const [*:0]const u8 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enabledExtensionCount: u32 = {d},\n", .{value.enabledExtensionCount});
    if (value.ppEnabledExtensionNames) |v| {
        for (v[0..value.enabledExtensionCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppEnabledExtensionNames: [*]const [*:0]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppEnabledExtensionNames: [*]const [*:0]const u8 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyProperties(name: []const u8, value: *const vk.VkQueueFamilyProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFlags: VkQueueFlags = {any},\n", .{value.queueFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueCount: u32 = {d},\n", .{value.queueCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timestampValidBits: u32 = {d},\n", .{value.timestampValidBits});
    print_VkExtent3D("minImageTransferGranularity", &value.minImageTransferGranularity, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMemoryProperties(name: []const u8, value: *const vk.VkPhysicalDeviceMemoryProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMemoryProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeCount: u32 = {d},\n", .{value.memoryTypeCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypes: [VK_MAX_MEMORY_TYPES]VkMemoryType = {any},\n", .{value.memoryTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryHeapCount: u32 = {d},\n", .{value.memoryHeapCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryHeaps: [VK_MAX_MEMORY_HEAPS]VkMemoryHeap = {any},\n", .{value.memoryHeaps});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryAllocateInfo(name: []const u8, value: *const vk.VkMemoryAllocateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryAllocateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    allocationSize: u64 = {d},\n", .{value.allocationSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeIndex: u32 = {d},\n", .{value.memoryTypeIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryRequirements(name: []const u8, value: *const vk.VkMemoryRequirements, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryRequirements = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alignment: u64 = {d},\n", .{value.alignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseImageFormatProperties(name: []const u8, value: *const vk.VkSparseImageFormatProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseImageFormatProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectMask: VkImageAspectFlags = {any},\n", .{value.aspectMask});
    print_VkExtent3D("imageGranularity", &value.imageGranularity, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSparseImageFormatFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseImageMemoryRequirements(name: []const u8, value: *const vk.VkSparseImageMemoryRequirements, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseImageMemoryRequirements = .{{\n", .{ name });
    print_VkSparseImageFormatProperties("formatProperties", &value.formatProperties, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageMipTailFirstLod: u32 = {d},\n", .{value.imageMipTailFirstLod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageMipTailSize: u64 = {d},\n", .{value.imageMipTailSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageMipTailOffset: u64 = {d},\n", .{value.imageMipTailOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageMipTailStride: u64 = {d},\n", .{value.imageMipTailStride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryType(name: []const u8, value: *const vk.VkMemoryType, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryType = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    propertyFlags: VkMemoryPropertyFlags = {any},\n", .{value.propertyFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    heapIndex: u32 = {d},\n", .{value.heapIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryHeap(name: []const u8, value: *const vk.VkMemoryHeap, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryHeap = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkMemoryHeapFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMappedMemoryRange(name: []const u8, value: *const vk.VkMappedMemoryRange, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMappedMemoryRange = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFormatProperties(name: []const u8, value: *const vk.VkFormatProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFormatProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    linearTilingFeatures: VkFormatFeatureFlags = {any},\n", .{value.linearTilingFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalTilingFeatures: VkFormatFeatureFlags = {any},\n", .{value.optimalTilingFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferFeatures: VkFormatFeatureFlags = {any},\n", .{value.bufferFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageFormatProperties(name: []const u8, value: *const vk.VkImageFormatProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageFormatProperties = .{{\n", .{ name });
    print_VkExtent3D("maxExtent", &value.maxExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMipLevels: u32 = {d},\n", .{value.maxMipLevels});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxArrayLayers: u32 = {d},\n", .{value.maxArrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleCounts: VkSampleCountFlags = {any},\n", .{value.sampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxResourceSize: u64 = {d},\n", .{value.maxResourceSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorBufferInfo(name: []const u8, value: *const vk.VkDescriptorBufferInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorBufferInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    range: u64 = {d},\n", .{value.range});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorImageInfo(name: []const u8, value: *const vk.VkDescriptorImageInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorImageInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampler: VkSampler = {},\n", .{value.sampler});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView: VkImageView = {},\n", .{value.imageView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageLayout: VkImageLayout = {t},\n", .{value.imageLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteDescriptorSet(name: []const u8, value: *const vk.VkWriteDescriptorSet, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteDescriptorSet = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstSet: VkDescriptorSet = {},\n", .{value.dstSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBinding: u32 = {d},\n", .{value.dstBinding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstArrayElement: u32 = {d},\n", .{value.dstArrayElement});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorCount: u32 = {d},\n", .{value.descriptorCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorType: VkDescriptorType = {t},\n", .{value.descriptorType});
    if (value.pImageInfo) |v| {
        for (v[0..value.descriptorCount]) |*vv| {
            print_VkDescriptorImageInfo("pImageInfo", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImageInfo: [*]const VkDescriptorImageInfo = null,\n", .{});
    }
    if (value.pBufferInfo) |v| {
        for (v[0..value.descriptorCount]) |*vv| {
            print_VkDescriptorBufferInfo("pBufferInfo", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBufferInfo: [*]const VkDescriptorBufferInfo = null,\n", .{});
    }
    if (value.pTexelBufferView) |v| {
        for (v[0..value.descriptorCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pTexelBufferView: [*]const VkBufferView = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTexelBufferView: [*]const VkBufferView = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyDescriptorSet(name: []const u8, value: *const vk.VkCopyDescriptorSet, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyDescriptorSet = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcSet: VkDescriptorSet = {},\n", .{value.srcSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcBinding: u32 = {d},\n", .{value.srcBinding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcArrayElement: u32 = {d},\n", .{value.srcArrayElement});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstSet: VkDescriptorSet = {},\n", .{value.dstSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBinding: u32 = {d},\n", .{value.dstBinding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstArrayElement: u32 = {d},\n", .{value.dstArrayElement});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorCount: u32 = {d},\n", .{value.descriptorCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferUsageFlags2CreateInfo(name: []const u8, value: *const vk.VkBufferUsageFlags2CreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferUsageFlags2CreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkBufferUsageFlags2 = {any},\n", .{value.usage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCreateInfo(name: []const u8, value: *const vk.VkBufferCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkBufferCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkBufferUsageFlags = {any},\n", .{value.usage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharingMode: VkSharingMode = {t},\n", .{value.sharingMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndexCount: u32 = {d},\n", .{value.queueFamilyIndexCount});
    if (value.pQueueFamilyIndices) |v| {
        for (v[0..value.queueFamilyIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pQueueFamilyIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueueFamilyIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferViewCreateInfo(name: []const u8, value: *const vk.VkBufferViewCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferViewCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkBufferViewCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    range: u64 = {d},\n", .{value.range});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageSubresource(name: []const u8, value: *const vk.VkImageSubresource, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageSubresource = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectMask: VkImageAspectFlags = {any},\n", .{value.aspectMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mipLevel: u32 = {d},\n", .{value.mipLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    arrayLayer: u32 = {d},\n", .{value.arrayLayer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageSubresourceLayers(name: []const u8, value: *const vk.VkImageSubresourceLayers, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageSubresourceLayers = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectMask: VkImageAspectFlags = {any},\n", .{value.aspectMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mipLevel: u32 = {d},\n", .{value.mipLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseArrayLayer: u32 = {d},\n", .{value.baseArrayLayer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layerCount: u32 = {d},\n", .{value.layerCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageSubresourceRange(name: []const u8, value: *const vk.VkImageSubresourceRange, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageSubresourceRange = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectMask: VkImageAspectFlags = {any},\n", .{value.aspectMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseMipLevel: u32 = {d},\n", .{value.baseMipLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    levelCount: u32 = {d},\n", .{value.levelCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseArrayLayer: u32 = {d},\n", .{value.baseArrayLayer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layerCount: u32 = {d},\n", .{value.layerCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryBarrier(name: []const u8, value: *const vk.VkMemoryBarrier, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryBarrier = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags = {any},\n", .{value.dstAccessMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferMemoryBarrier(name: []const u8, value: *const vk.VkBufferMemoryBarrier, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferMemoryBarrier = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags = {any},\n", .{value.dstAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcQueueFamilyIndex: u32 = {d},\n", .{value.srcQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstQueueFamilyIndex: u32 = {d},\n", .{value.dstQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageMemoryBarrier(name: []const u8, value: *const vk.VkImageMemoryBarrier, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageMemoryBarrier = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags = {any},\n", .{value.dstAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    oldLayout: VkImageLayout = {t},\n", .{value.oldLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    newLayout: VkImageLayout = {t},\n", .{value.newLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcQueueFamilyIndex: u32 = {d},\n", .{value.srcQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstQueueFamilyIndex: u32 = {d},\n", .{value.dstQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    print_VkImageSubresourceRange("subresourceRange", &value.subresourceRange, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageCreateInfo(name: []const u8, value: *const vk.VkImageCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImageCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageType: VkImageType = {t},\n", .{value.imageType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    print_VkExtent3D("extent", &value.extent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mipLevels: u32 = {d},\n", .{value.mipLevels});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    arrayLayers: u32 = {d},\n", .{value.arrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samples: VkSampleCountFlags = {any},\n", .{value.samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tiling: VkImageTiling = {t},\n", .{value.tiling});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkImageUsageFlags = {any},\n", .{value.usage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharingMode: VkSharingMode = {t},\n", .{value.sharingMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndexCount: u32 = {d},\n", .{value.queueFamilyIndexCount});
    if (value.pQueueFamilyIndices) |v| {
        for (v[0..value.queueFamilyIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pQueueFamilyIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueueFamilyIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialLayout: VkImageLayout = {t},\n", .{value.initialLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubresourceLayout(name: []const u8, value: *const vk.VkSubresourceLayout, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubresourceLayout = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rowPitch: u64 = {d},\n", .{value.rowPitch});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    arrayPitch: u64 = {d},\n", .{value.arrayPitch});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthPitch: u64 = {d},\n", .{value.depthPitch});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewCreateInfo(name: []const u8, value: *const vk.VkImageViewCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImageViewCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewType: VkImageViewType = {t},\n", .{value.viewType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    print_VkComponentMapping("components", &value.components, offset + 1);
    print_VkImageSubresourceRange("subresourceRange", &value.subresourceRange, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCopy(name: []const u8, value: *const vk.VkBufferCopy, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCopy = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcOffset: u64 = {d},\n", .{value.srcOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstOffset: u64 = {d},\n", .{value.dstOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseMemoryBind(name: []const u8, value: *const vk.VkSparseMemoryBind, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseMemoryBind = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resourceOffset: u64 = {d},\n", .{value.resourceOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSparseMemoryBindFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseImageMemoryBind(name: []const u8, value: *const vk.VkSparseImageMemoryBind, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseImageMemoryBind = .{{\n", .{ name });
    print_VkImageSubresource("subresource", &value.subresource, offset + 1);
    print_VkOffset3D("offset", &value.offset, offset + 1);
    print_VkExtent3D("extent", &value.extent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSparseMemoryBindFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseBufferMemoryBindInfo(name: []const u8, value: *const vk.VkSparseBufferMemoryBindInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseBufferMemoryBindInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindCount: u32 = {d},\n", .{value.bindCount});
    if (value.pBinds) |v| {
        for (v[0..value.bindCount]) |*vv| {
            print_VkSparseMemoryBind("pBinds", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBinds: [*]const VkSparseMemoryBind = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseImageOpaqueMemoryBindInfo(name: []const u8, value: *const vk.VkSparseImageOpaqueMemoryBindInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseImageOpaqueMemoryBindInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindCount: u32 = {d},\n", .{value.bindCount});
    if (value.pBinds) |v| {
        for (v[0..value.bindCount]) |*vv| {
            print_VkSparseMemoryBind("pBinds", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBinds: [*]const VkSparseMemoryBind = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseImageMemoryBindInfo(name: []const u8, value: *const vk.VkSparseImageMemoryBindInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseImageMemoryBindInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindCount: u32 = {d},\n", .{value.bindCount});
    if (value.pBinds) |v| {
        for (v[0..value.bindCount]) |*vv| {
            print_VkSparseImageMemoryBind("pBinds", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBinds: [*]const VkSparseImageMemoryBind = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindSparseInfo(name: []const u8, value: *const vk.VkBindSparseInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindSparseInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    waitSemaphoreCount: u32 = {d},\n", .{value.waitSemaphoreCount});
    if (value.pWaitSemaphores) |v| {
        for (v[0..value.waitSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pWaitSemaphores: [*]const VkSemaphore = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitSemaphores: [*]const VkSemaphore = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferBindCount: u32 = {d},\n", .{value.bufferBindCount});
    if (value.pBufferBinds) |v| {
        for (v[0..value.bufferBindCount]) |*vv| {
            print_VkSparseBufferMemoryBindInfo("pBufferBinds", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBufferBinds: [*]const VkSparseBufferMemoryBindInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageOpaqueBindCount: u32 = {d},\n", .{value.imageOpaqueBindCount});
    if (value.pImageOpaqueBinds) |v| {
        for (v[0..value.imageOpaqueBindCount]) |*vv| {
            print_VkSparseImageOpaqueMemoryBindInfo("pImageOpaqueBinds", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImageOpaqueBinds: [*]const VkSparseImageOpaqueMemoryBindInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageBindCount: u32 = {d},\n", .{value.imageBindCount});
    if (value.pImageBinds) |v| {
        for (v[0..value.imageBindCount]) |*vv| {
            print_VkSparseImageMemoryBindInfo("pImageBinds", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImageBinds: [*]const VkSparseImageMemoryBindInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    signalSemaphoreCount: u32 = {d},\n", .{value.signalSemaphoreCount});
    if (value.pSignalSemaphores) |v| {
        for (v[0..value.signalSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSignalSemaphores: [*]const VkSemaphore = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSignalSemaphores: [*]const VkSemaphore = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageCopy(name: []const u8, value: *const vk.VkImageCopy, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageCopy = .{{\n", .{ name });
    print_VkImageSubresourceLayers("srcSubresource", &value.srcSubresource, offset + 1);
    print_VkOffset3D("srcOffset", &value.srcOffset, offset + 1);
    print_VkImageSubresourceLayers("dstSubresource", &value.dstSubresource, offset + 1);
    print_VkOffset3D("dstOffset", &value.dstOffset, offset + 1);
    print_VkExtent3D("extent", &value.extent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageBlit(name: []const u8, value: *const vk.VkImageBlit, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageBlit = .{{\n", .{ name });
    print_VkImageSubresourceLayers("srcSubresource", &value.srcSubresource, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcOffsets: [2]VkOffset3D = {any},\n", .{value.srcOffsets});
    print_VkImageSubresourceLayers("dstSubresource", &value.dstSubresource, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstOffsets: [2]VkOffset3D = {any},\n", .{value.dstOffsets});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferImageCopy(name: []const u8, value: *const vk.VkBufferImageCopy, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferImageCopy = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferOffset: u64 = {d},\n", .{value.bufferOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferRowLength: u32 = {d},\n", .{value.bufferRowLength});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferImageHeight: u32 = {d},\n", .{value.bufferImageHeight});
    print_VkImageSubresourceLayers("imageSubresource", &value.imageSubresource, offset + 1);
    print_VkOffset3D("imageOffset", &value.imageOffset, offset + 1);
    print_VkExtent3D("imageExtent", &value.imageExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkStridedDeviceAddressRangeKHR(name: []const u8, value: *const vk.VkStridedDeviceAddressRangeKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkStridedDeviceAddressRangeKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    address: u64 = {d},\n", .{value.address});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u64 = {d},\n", .{value.stride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMemoryIndirectCommandKHR(name: []const u8, value: *const vk.VkCopyMemoryIndirectCommandKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMemoryIndirectCommandKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAddress: u64 = {d},\n", .{value.srcAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAddress: u64 = {d},\n", .{value.dstAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMemoryIndirectInfoKHR(name: []const u8, value: *const vk.VkCopyMemoryIndirectInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMemoryIndirectInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcCopyFlags: VkAddressCopyFlagsKHR = {any},\n", .{value.srcCopyFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstCopyFlags: VkAddressCopyFlagsKHR = {any},\n", .{value.dstCopyFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    copyCount: u32 = {d},\n", .{value.copyCount});
    print_VkStridedDeviceAddressRangeKHR("copyAddressRange", &value.copyAddressRange, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMemoryToImageIndirectCommandKHR(name: []const u8, value: *const vk.VkCopyMemoryToImageIndirectCommandKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMemoryToImageIndirectCommandKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAddress: u64 = {d},\n", .{value.srcAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferRowLength: u32 = {d},\n", .{value.bufferRowLength});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferImageHeight: u32 = {d},\n", .{value.bufferImageHeight});
    print_VkImageSubresourceLayers("imageSubresource", &value.imageSubresource, offset + 1);
    print_VkOffset3D("imageOffset", &value.imageOffset, offset + 1);
    print_VkExtent3D("imageExtent", &value.imageExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMemoryToImageIndirectInfoKHR(name: []const u8, value: *const vk.VkCopyMemoryToImageIndirectInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMemoryToImageIndirectInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcCopyFlags: VkAddressCopyFlagsKHR = {any},\n", .{value.srcCopyFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    copyCount: u32 = {d},\n", .{value.copyCount});
    print_VkStridedDeviceAddressRangeKHR("copyAddressRange", &value.copyAddressRange, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImage: VkImage = {},\n", .{value.dstImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImageLayout: VkImageLayout = {t},\n", .{value.dstImageLayout});
    if (value.pImageSubresources) |v| {
        for (v[0..value.copyCount]) |*vv| {
            print_VkImageSubresourceLayers("pImageSubresources", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImageSubresources: [*]const VkImageSubresourceLayers = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageResolve(name: []const u8, value: *const vk.VkImageResolve, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageResolve = .{{\n", .{ name });
    print_VkImageSubresourceLayers("srcSubresource", &value.srcSubresource, offset + 1);
    print_VkOffset3D("srcOffset", &value.srcOffset, offset + 1);
    print_VkImageSubresourceLayers("dstSubresource", &value.dstSubresource, offset + 1);
    print_VkOffset3D("dstOffset", &value.dstOffset, offset + 1);
    print_VkExtent3D("extent", &value.extent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkShaderModuleCreateInfo(name: []const u8, value: *const vk.VkShaderModuleCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkShaderModuleCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkShaderModuleCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    codeSize: u64 = {d},\n", .{value.codeSize});
    if (value.pCode) |v| {
        for (v[0..value.codeSize / 4]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCode: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCode: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetLayoutBinding(name: []const u8, value: *const vk.VkDescriptorSetLayoutBinding, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetLayoutBinding = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorType: VkDescriptorType = {t},\n", .{value.descriptorType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorCount: u32 = {d},\n", .{value.descriptorCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageFlags: VkShaderStageFlags = {any},\n", .{value.stageFlags});
    if (value.pImmutableSamplers) |v| {
        for (v[0..value.descriptorCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pImmutableSamplers: [*]const VkSampler = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImmutableSamplers: [*]const VkSampler = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetLayoutCreateInfo(name: []const u8, value: *const vk.VkDescriptorSetLayoutCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetLayoutCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDescriptorSetLayoutCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindingCount: u32 = {d},\n", .{value.bindingCount});
    if (value.pBindings) |v| {
        for (v[0..value.bindingCount]) |*vv| {
            print_VkDescriptorSetLayoutBinding("pBindings", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBindings: [*]const VkDescriptorSetLayoutBinding = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorPoolSize(name: []const u8, value: *const vk.VkDescriptorPoolSize, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorPoolSize = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkDescriptorType = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorCount: u32 = {d},\n", .{value.descriptorCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorPoolCreateInfo(name: []const u8, value: *const vk.VkDescriptorPoolCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorPoolCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDescriptorPoolCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSets: u32 = {d},\n", .{value.maxSets});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    poolSizeCount: u32 = {d},\n", .{value.poolSizeCount});
    if (value.pPoolSizes) |v| {
        for (v[0..value.poolSizeCount]) |*vv| {
            print_VkDescriptorPoolSize("pPoolSizes", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPoolSizes: [*]const VkDescriptorPoolSize = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetAllocateInfo(name: []const u8, value: *const vk.VkDescriptorSetAllocateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetAllocateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorPool: VkDescriptorPool = {},\n", .{value.descriptorPool});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetCount: u32 = {d},\n", .{value.descriptorSetCount});
    if (value.pSetLayouts) |v| {
        for (v[0..value.descriptorSetCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSpecializationMapEntry(name: []const u8, value: *const vk.VkSpecializationMapEntry, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSpecializationMapEntry = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    constantID: u32 = {d},\n", .{value.constantID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u32 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSpecializationInfo(name: []const u8, value: *const vk.VkSpecializationInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSpecializationInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mapEntryCount: u32 = {d},\n", .{value.mapEntryCount});
    if (value.pMapEntries) |v| {
        for (v[0..value.mapEntryCount]) |*vv| {
            print_VkSpecializationMapEntry("pMapEntries", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pMapEntries: [*]const VkSpecializationMapEntry = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u64 = {d},\n", .{value.dataSize});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineShaderStageCreateInfo(name: []const u8, value: *const vk.VkPipelineShaderStageCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineShaderStageCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineShaderStageCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stage: VkShaderStageFlags = {any},\n", .{value.stage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    module: VkShaderModule = {},\n", .{value.module});
    if (value.pName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pName: [*:0]const u8 = {s}n", .{v});
    }
    if (value.pSpecializationInfo) |v| {
        print_VkSpecializationInfo("pSpecializationInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSpecializationInfo: *const VkSpecializationInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkComputePipelineCreateInfo(name: []const u8, value: *const vk.VkComputePipelineCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkComputePipelineCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCreateFlags = {any},\n", .{value.flags});
    print_VkPipelineShaderStageCreateInfo("stage", &value.stage, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineHandle: VkPipeline = {},\n", .{value.basePipelineHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineIndex: i32 = {d},\n", .{value.basePipelineIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkComputePipelineIndirectBufferInfoNV(name: []const u8, value: *const vk.VkComputePipelineIndirectBufferInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkComputePipelineIndirectBufferInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceAddress: u64 = {d},\n", .{value.deviceAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineDeviceAddressCaptureReplay: u64 = {d},\n", .{value.pipelineDeviceAddressCaptureReplay});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCreateFlags2CreateInfo(name: []const u8, value: *const vk.VkPipelineCreateFlags2CreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCreateFlags2CreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCreateFlags2 = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVertexInputBindingDescription(name: []const u8, value: *const vk.VkVertexInputBindingDescription, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVertexInputBindingDescription = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u32 = {d},\n", .{value.stride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputRate: VkVertexInputRate = {t},\n", .{value.inputRate});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVertexInputAttributeDescription(name: []const u8, value: *const vk.VkVertexInputAttributeDescription, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVertexInputAttributeDescription = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    location: u32 = {d},\n", .{value.location});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u32 = {d},\n", .{value.offset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineVertexInputStateCreateInfo(name: []const u8, value: *const vk.VkPipelineVertexInputStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineVertexInputStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineVertexInputStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBindingDescriptionCount: u32 = {d},\n", .{value.vertexBindingDescriptionCount});
    if (value.pVertexBindingDescriptions) |v| {
        for (v[0..value.vertexBindingDescriptionCount]) |*vv| {
            print_VkVertexInputBindingDescription("pVertexBindingDescriptions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVertexBindingDescriptions: [*]const VkVertexInputBindingDescription = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexAttributeDescriptionCount: u32 = {d},\n", .{value.vertexAttributeDescriptionCount});
    if (value.pVertexAttributeDescriptions) |v| {
        for (v[0..value.vertexAttributeDescriptionCount]) |*vv| {
            print_VkVertexInputAttributeDescription("pVertexAttributeDescriptions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVertexAttributeDescriptions: [*]const VkVertexInputAttributeDescription = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineInputAssemblyStateCreateInfo(name: []const u8, value: *const vk.VkPipelineInputAssemblyStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineInputAssemblyStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineInputAssemblyStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    topology: VkPrimitiveTopology = {t},\n", .{value.topology});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveRestartEnable: u32 = {d},\n", .{value.primitiveRestartEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineTessellationStateCreateInfo(name: []const u8, value: *const vk.VkPipelineTessellationStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineTessellationStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineTessellationStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    patchControlPoints: u32 = {d},\n", .{value.patchControlPoints});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportStateCreateInfo(name: []const u8, value: *const vk.VkPipelineViewportStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineViewportStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportCount: u32 = {d},\n", .{value.viewportCount});
    if (value.pViewports) |v| {
        for (v[0..value.viewportCount]) |*vv| {
            print_VkViewport("pViewports", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewports: [*]const VkViewport = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scissorCount: u32 = {d},\n", .{value.scissorCount});
    if (value.pScissors) |v| {
        for (v[0..value.scissorCount]) |*vv| {
            print_VkRect2D("pScissors", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pScissors: [*]const VkRect2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRasterizationStateCreateInfo(name: []const u8, value: *const vk.VkPipelineRasterizationStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRasterizationStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineRasterizationStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClampEnable: u32 = {d},\n", .{value.depthClampEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizerDiscardEnable: u32 = {d},\n", .{value.rasterizerDiscardEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    polygonMode: VkPolygonMode = {t},\n", .{value.polygonMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cullMode: VkCullModeFlags = {any},\n", .{value.cullMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frontFace: VkFrontFace = {t},\n", .{value.frontFace});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasEnable: u32 = {d},\n", .{value.depthBiasEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasConstantFactor: f32 = {d},\n", .{value.depthBiasConstantFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasClamp: f32 = {d},\n", .{value.depthBiasClamp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasSlopeFactor: f32 = {d},\n", .{value.depthBiasSlopeFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineWidth: f32 = {d},\n", .{value.lineWidth});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineMultisampleStateCreateInfo(name: []const u8, value: *const vk.VkPipelineMultisampleStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineMultisampleStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineMultisampleStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationSamples: VkSampleCountFlags = {any},\n", .{value.rasterizationSamples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleShadingEnable: u32 = {d},\n", .{value.sampleShadingEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minSampleShading: f32 = {d},\n", .{value.minSampleShading});
    if (value.pSampleMask) |v| {
        for (v[0..(@as(u32, @bitCast(value.rasterizationSamples)) + 31) / 32]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSampleMask: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSampleMask: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alphaToCoverageEnable: u32 = {d},\n", .{value.alphaToCoverageEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alphaToOneEnable: u32 = {d},\n", .{value.alphaToOneEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineColorBlendAttachmentState(name: []const u8, value: *const vk.VkPipelineColorBlendAttachmentState, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineColorBlendAttachmentState = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blendEnable: u32 = {d},\n", .{value.blendEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcColorBlendFactor: VkBlendFactor = {t},\n", .{value.srcColorBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstColorBlendFactor: VkBlendFactor = {t},\n", .{value.dstColorBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorBlendOp: VkBlendOp = {t},\n", .{value.colorBlendOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAlphaBlendFactor: VkBlendFactor = {t},\n", .{value.srcAlphaBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAlphaBlendFactor: VkBlendFactor = {t},\n", .{value.dstAlphaBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alphaBlendOp: VkBlendOp = {t},\n", .{value.alphaBlendOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorWriteMask: VkColorComponentFlags = {any},\n", .{value.colorWriteMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineColorBlendStateCreateInfo(name: []const u8, value: *const vk.VkPipelineColorBlendStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineColorBlendStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineColorBlendStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    logicOpEnable: u32 = {d},\n", .{value.logicOpEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    logicOp: VkLogicOp = {t},\n", .{value.logicOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentCount: u32 = {d},\n", .{value.attachmentCount});
    if (value.pAttachments) |v| {
        for (v[0..value.attachmentCount]) |*vv| {
            print_VkPipelineColorBlendAttachmentState("pAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttachments: [*]const VkPipelineColorBlendAttachmentState = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blendConstants: [4]f32 = {any},\n", .{value.blendConstants});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineDynamicStateCreateInfo(name: []const u8, value: *const vk.VkPipelineDynamicStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineDynamicStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineDynamicStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicStateCount: u32 = {d},\n", .{value.dynamicStateCount});
    if (value.pDynamicStates) |v| {
        for (v[0..value.dynamicStateCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDynamicStates: [*]const VkDynamicState = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDynamicStates: [*]const VkDynamicState = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkStencilOpState(name: []const u8, value: *const vk.VkStencilOpState, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkStencilOpState = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    failOp: VkStencilOp = {t},\n", .{value.failOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    passOp: VkStencilOp = {t},\n", .{value.passOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthFailOp: VkStencilOp = {t},\n", .{value.depthFailOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compareOp: VkCompareOp = {t},\n", .{value.compareOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compareMask: u32 = {d},\n", .{value.compareMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    writeMask: u32 = {d},\n", .{value.writeMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    reference: u32 = {d},\n", .{value.reference});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineDepthStencilStateCreateInfo(name: []const u8, value: *const vk.VkPipelineDepthStencilStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineDepthStencilStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineDepthStencilStateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthTestEnable: u32 = {d},\n", .{value.depthTestEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthWriteEnable: u32 = {d},\n", .{value.depthWriteEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthCompareOp: VkCompareOp = {t},\n", .{value.depthCompareOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBoundsTestEnable: u32 = {d},\n", .{value.depthBoundsTestEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilTestEnable: u32 = {d},\n", .{value.stencilTestEnable});
    print_VkStencilOpState("front", &value.front, offset + 1);
    print_VkStencilOpState("back", &value.back, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minDepthBounds: f32 = {d},\n", .{value.minDepthBounds});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDepthBounds: f32 = {d},\n", .{value.maxDepthBounds});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGraphicsPipelineCreateInfo(name: []const u8, value: *const vk.VkGraphicsPipelineCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGraphicsPipelineCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageCount: u32 = {d},\n", .{value.stageCount});
    if (value.pStages) |v| {
        for (v[0..value.stageCount]) |*vv| {
            print_VkPipelineShaderStageCreateInfo("pStages", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStages: [*]const VkPipelineShaderStageCreateInfo = null,\n", .{});
    }
    if (value.pVertexInputState) |v| {
        print_VkPipelineVertexInputStateCreateInfo("pVertexInputState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVertexInputState: *const VkPipelineVertexInputStateCreateInfo = null,\n", .{});
    }
    if (value.pInputAssemblyState) |v| {
        print_VkPipelineInputAssemblyStateCreateInfo("pInputAssemblyState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo = null,\n", .{});
    }
    if (value.pTessellationState) |v| {
        print_VkPipelineTessellationStateCreateInfo("pTessellationState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTessellationState: *const VkPipelineTessellationStateCreateInfo = null,\n", .{});
    }
    if (value.pViewportState) |v| {
        print_VkPipelineViewportStateCreateInfo("pViewportState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewportState: *const VkPipelineViewportStateCreateInfo = null,\n", .{});
    }
    if (value.pRasterizationState) |v| {
        print_VkPipelineRasterizationStateCreateInfo("pRasterizationState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRasterizationState: *const VkPipelineRasterizationStateCreateInfo = null,\n", .{});
    }
    if (value.pMultisampleState) |v| {
        print_VkPipelineMultisampleStateCreateInfo("pMultisampleState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pMultisampleState: *const VkPipelineMultisampleStateCreateInfo = null,\n", .{});
    }
    if (value.pDepthStencilState) |v| {
        print_VkPipelineDepthStencilStateCreateInfo("pDepthStencilState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo = null,\n", .{});
    }
    if (value.pColorBlendState) |v| {
        print_VkPipelineColorBlendStateCreateInfo("pColorBlendState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorBlendState: *const VkPipelineColorBlendStateCreateInfo = null,\n", .{});
    }
    if (value.pDynamicState) |v| {
        print_VkPipelineDynamicStateCreateInfo("pDynamicState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDynamicState: *const VkPipelineDynamicStateCreateInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderPass: VkRenderPass = {},\n", .{value.renderPass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpass: u32 = {d},\n", .{value.subpass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineHandle: VkPipeline = {},\n", .{value.basePipelineHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineIndex: i32 = {d},\n", .{value.basePipelineIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCacheCreateInfo(name: []const u8, value: *const vk.VkPipelineCacheCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCacheCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCacheCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialDataSize: u64 = {d},\n", .{value.initialDataSize});
    if (value.pInitialData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInitialData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInitialData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCacheHeaderVersionOne(name: []const u8, value: *const vk.VkPipelineCacheHeaderVersionOne, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCacheHeaderVersionOne = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    headerSize: u32 = {d},\n", .{value.headerSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    headerVersion: VkPipelineCacheHeaderVersion = {t},\n", .{value.headerVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorID: u32 = {d},\n", .{value.vendorID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceID: u32 = {d},\n", .{value.deviceID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCacheUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.pipelineCacheUUID});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCacheStageValidationIndexEntry(name: []const u8, value: *const vk.VkPipelineCacheStageValidationIndexEntry, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCacheStageValidationIndexEntry = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    codeSize: u64 = {d},\n", .{value.codeSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    codeOffset: u64 = {d},\n", .{value.codeOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCacheSafetyCriticalIndexEntry(name: []const u8, value: *const vk.VkPipelineCacheSafetyCriticalIndexEntry, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCacheSafetyCriticalIndexEntry = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineIdentifier: [VK_UUID_SIZE]u8 = {any},\n", .{value.pipelineIdentifier});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineMemorySize: u64 = {d},\n", .{value.pipelineMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    jsonSize: u64 = {d},\n", .{value.jsonSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    jsonOffset: u64 = {d},\n", .{value.jsonOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageIndexCount: u32 = {d},\n", .{value.stageIndexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageIndexStride: u32 = {d},\n", .{value.stageIndexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageIndexOffset: u64 = {d},\n", .{value.stageIndexOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCacheHeaderVersionSafetyCriticalOne(name: []const u8, value: *const vk.VkPipelineCacheHeaderVersionSafetyCriticalOne, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCacheHeaderVersionSafetyCriticalOne = .{{\n", .{ name });
    print_VkPipelineCacheHeaderVersionOne("headerVersionOne", &value.headerVersionOne, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    validationVersion: VkPipelineCacheValidationVersion = {t},\n", .{value.validationVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    implementationData: u32 = {d},\n", .{value.implementationData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineIndexCount: u32 = {d},\n", .{value.pipelineIndexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineIndexStride: u32 = {d},\n", .{value.pipelineIndexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineIndexOffset: u64 = {d},\n", .{value.pipelineIndexOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCacheHeaderVersionDataGraphQCOM(name: []const u8, value: *const vk.VkPipelineCacheHeaderVersionDataGraphQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCacheHeaderVersionDataGraphQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    headerSize: u32 = {d},\n", .{value.headerSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    headerVersion: VkPipelineCacheHeaderVersion = {t},\n", .{value.headerVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cacheType: VkDataGraphModelCacheTypeQCOM = {t},\n", .{value.cacheType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cacheVersion: u32 = {any},\n", .{value.cacheVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    toolchainVersion: [VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM]u32 = {any},\n", .{value.toolchainVersion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPushConstantRange(name: []const u8, value: *const vk.VkPushConstantRange, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPushConstantRange = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageFlags: VkShaderStageFlags = {any},\n", .{value.stageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u32 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u32 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineBinaryCreateInfoKHR(name: []const u8, value: *const vk.VkPipelineBinaryCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineBinaryCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pKeysAndDataInfo) |v| {
        print_VkPipelineBinaryKeysAndDataKHR("pKeysAndDataInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pKeysAndDataInfo: *const VkPipelineBinaryKeysAndDataKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    if (value.pPipelineCreateInfo) |v| {
        print_VkPipelineCreateInfoKHR("pPipelineCreateInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineCreateInfo: *const VkPipelineCreateInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineBinaryHandlesInfoKHR(name: []const u8, value: *const vk.VkPipelineBinaryHandlesInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineBinaryHandlesInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinaryCount: u32 = {d},\n", .{value.pipelineBinaryCount});
    if (value.pPipelineBinaries) |v| {
        for (v[0..value.pipelineBinaryCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPipelineBinaries: [*]VkPipelineBinaryKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineBinaries: [*]VkPipelineBinaryKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineBinaryDataKHR(name: []const u8, value: *const vk.VkPipelineBinaryDataKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineBinaryDataKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u64 = {d},\n", .{value.dataSize});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineBinaryKeysAndDataKHR(name: []const u8, value: *const vk.VkPipelineBinaryKeysAndDataKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineBinaryKeysAndDataKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binaryCount: u32 = {d},\n", .{value.binaryCount});
    if (value.pPipelineBinaryKeys) |v| {
        for (v[0..value.binaryCount]) |*vv| {
            print_VkPipelineBinaryKeyKHR("pPipelineBinaryKeys", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineBinaryKeys: [*]const VkPipelineBinaryKeyKHR = null,\n", .{});
    }
    if (value.pPipelineBinaryData) |v| {
        for (v[0..value.binaryCount]) |*vv| {
            print_VkPipelineBinaryDataKHR("pPipelineBinaryData", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineBinaryData: [*]const VkPipelineBinaryDataKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineBinaryKeyKHR(name: []const u8, value: *const vk.VkPipelineBinaryKeyKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineBinaryKeyKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    keySize: u32 = {d},\n", .{value.keySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    key: [VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR]u8 = {any},\n", .{value.key});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineBinaryInfoKHR(name: []const u8, value: *const vk.VkPipelineBinaryInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineBinaryInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binaryCount: u32 = {d},\n", .{value.binaryCount});
    if (value.pPipelineBinaries) |v| {
        for (v[0..value.binaryCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPipelineBinaries: [*]const VkPipelineBinaryKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineBinaries: [*]const VkPipelineBinaryKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkReleaseCapturedPipelineDataInfoKHR(name: []const u8, value: *const vk.VkReleaseCapturedPipelineDataInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkReleaseCapturedPipelineDataInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineBinaryDataInfoKHR(name: []const u8, value: *const vk.VkPipelineBinaryDataInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineBinaryDataInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinary: VkPipelineBinaryKHR = {},\n", .{value.pipelineBinary});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCreateInfoKHR(name: []const u8, value: *const vk.VkPipelineCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineLayoutCreateInfo(name: []const u8, value: *const vk.VkPipelineLayoutCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineLayoutCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineLayoutCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    setLayoutCount: u32 = {d},\n", .{value.setLayoutCount});
    if (value.pSetLayouts) |v| {
        for (v[0..value.setLayoutCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushConstantRangeCount: u32 = {d},\n", .{value.pushConstantRangeCount});
    if (value.pPushConstantRanges) |v| {
        for (v[0..value.pushConstantRangeCount]) |*vv| {
            print_VkPushConstantRange("pPushConstantRanges", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPushConstantRanges: [*]const VkPushConstantRange = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerCreateInfo(name: []const u8, value: *const vk.VkSamplerCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSamplerCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    magFilter: VkFilter = {t},\n", .{value.magFilter});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minFilter: VkFilter = {t},\n", .{value.minFilter});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mipmapMode: VkSamplerMipmapMode = {t},\n", .{value.mipmapMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    addressModeU: VkSamplerAddressMode = {t},\n", .{value.addressModeU});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    addressModeV: VkSamplerAddressMode = {t},\n", .{value.addressModeV});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    addressModeW: VkSamplerAddressMode = {t},\n", .{value.addressModeW});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mipLodBias: f32 = {d},\n", .{value.mipLodBias});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    anisotropyEnable: u32 = {d},\n", .{value.anisotropyEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxAnisotropy: f32 = {d},\n", .{value.maxAnisotropy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compareEnable: u32 = {d},\n", .{value.compareEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compareOp: VkCompareOp = {t},\n", .{value.compareOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minLod: f32 = {d},\n", .{value.minLod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxLod: f32 = {d},\n", .{value.maxLod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    borderColor: VkBorderColor = {t},\n", .{value.borderColor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    unnormalizedCoordinates: u32 = {d},\n", .{value.unnormalizedCoordinates});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandPoolCreateInfo(name: []const u8, value: *const vk.VkCommandPoolCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandPoolCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkCommandPoolCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndex: u32 = {d},\n", .{value.queueFamilyIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferAllocateInfo(name: []const u8, value: *const vk.VkCommandBufferAllocateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferAllocateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPool: VkCommandPool = {},\n", .{value.commandPool});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    level: VkCommandBufferLevel = {t},\n", .{value.level});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferCount: u32 = {d},\n", .{value.commandBufferCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferInheritanceInfo(name: []const u8, value: *const vk.VkCommandBufferInheritanceInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferInheritanceInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderPass: VkRenderPass = {},\n", .{value.renderPass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpass: u32 = {d},\n", .{value.subpass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebuffer: VkFramebuffer = {},\n", .{value.framebuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    occlusionQueryEnable: u32 = {d},\n", .{value.occlusionQueryEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queryFlags: VkQueryControlFlags = {any},\n", .{value.queryFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineStatistics: VkQueryPipelineStatisticFlags = {any},\n", .{value.pipelineStatistics});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferBeginInfo(name: []const u8, value: *const vk.VkCommandBufferBeginInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferBeginInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkCommandBufferUsageFlags = {any},\n", .{value.flags});
    if (value.pInheritanceInfo) |v| {
        print_VkCommandBufferInheritanceInfo("pInheritanceInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInheritanceInfo: *const VkCommandBufferInheritanceInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassBeginInfo(name: []const u8, value: *const vk.VkRenderPassBeginInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassBeginInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderPass: VkRenderPass = {},\n", .{value.renderPass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebuffer: VkFramebuffer = {},\n", .{value.framebuffer});
    print_VkRect2D("renderArea", &value.renderArea, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clearValueCount: u32 = {d},\n", .{value.clearValueCount});
    if (value.pClearValues) |v| {
        for (v[0..value.clearValueCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pClearValues: [*]const VkClearValue = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pClearValues: [*]const VkClearValue = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClearDepthStencilValue(name: []const u8, value: *const vk.VkClearDepthStencilValue, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClearDepthStencilValue = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depth: f32 = {d},\n", .{value.depth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencil: u32 = {d},\n", .{value.stencil});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClearAttachment(name: []const u8, value: *const vk.VkClearAttachment, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClearAttachment = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectMask: VkImageAspectFlags = {any},\n", .{value.aspectMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachment: u32 = {d},\n", .{value.colorAttachment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clearValue: VkClearValue = {any},\n", .{value.clearValue});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentDescription(name: []const u8, value: *const vk.VkAttachmentDescription, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentDescription = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkAttachmentDescriptionFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samples: VkSampleCountFlags = {any},\n", .{value.samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    loadOp: VkAttachmentLoadOp = {t},\n", .{value.loadOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storeOp: VkAttachmentStoreOp = {t},\n", .{value.storeOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilLoadOp: VkAttachmentLoadOp = {t},\n", .{value.stencilLoadOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilStoreOp: VkAttachmentStoreOp = {t},\n", .{value.stencilStoreOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialLayout: VkImageLayout = {t},\n", .{value.initialLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    finalLayout: VkImageLayout = {t},\n", .{value.finalLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentReference(name: []const u8, value: *const vk.VkAttachmentReference, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentReference = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachment: u32 = {d},\n", .{value.attachment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkImageLayout = {t},\n", .{value.layout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassDescription(name: []const u8, value: *const vk.VkSubpassDescription, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassDescription = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSubpassDescriptionFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBindPoint: VkPipelineBindPoint = {t},\n", .{value.pipelineBindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputAttachmentCount: u32 = {d},\n", .{value.inputAttachmentCount});
    if (value.pInputAttachments) |v| {
        for (v[0..value.inputAttachmentCount]) |*vv| {
            print_VkAttachmentReference("pInputAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInputAttachments: [*]const VkAttachmentReference = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachments) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            print_VkAttachmentReference("pColorAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachments: [*]const VkAttachmentReference = null,\n", .{});
    }
    if (value.pResolveAttachments) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            print_VkAttachmentReference("pResolveAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pResolveAttachments: [*]const VkAttachmentReference = null,\n", .{});
    }
    if (value.pDepthStencilAttachment) |v| {
        print_VkAttachmentReference("pDepthStencilAttachment", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthStencilAttachment: *const VkAttachmentReference = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preserveAttachmentCount: u32 = {d},\n", .{value.preserveAttachmentCount});
    if (value.pPreserveAttachments) |v| {
        for (v[0..value.preserveAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPreserveAttachments: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPreserveAttachments: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassDependency(name: []const u8, value: *const vk.VkSubpassDependency, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassDependency = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcSubpass: u32 = {d},\n", .{value.srcSubpass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstSubpass: u32 = {d},\n", .{value.dstSubpass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcStageMask: VkPipelineStageFlags = {any},\n", .{value.srcStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstStageMask: VkPipelineStageFlags = {any},\n", .{value.dstStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags = {any},\n", .{value.dstAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dependencyFlags: VkDependencyFlags = {any},\n", .{value.dependencyFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassCreateInfo(name: []const u8, value: *const vk.VkRenderPassCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkRenderPassCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentCount: u32 = {d},\n", .{value.attachmentCount});
    if (value.pAttachments) |v| {
        for (v[0..value.attachmentCount]) |*vv| {
            print_VkAttachmentDescription("pAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttachments: [*]const VkAttachmentDescription = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassCount: u32 = {d},\n", .{value.subpassCount});
    if (value.pSubpasses) |v| {
        for (v[0..value.subpassCount]) |*vv| {
            print_VkSubpassDescription("pSubpasses", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSubpasses: [*]const VkSubpassDescription = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dependencyCount: u32 = {d},\n", .{value.dependencyCount});
    if (value.pDependencies) |v| {
        for (v[0..value.dependencyCount]) |*vv| {
            print_VkSubpassDependency("pDependencies", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDependencies: [*]const VkSubpassDependency = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkEventCreateInfo(name: []const u8, value: *const vk.VkEventCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkEventCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkEventCreateFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFenceCreateInfo(name: []const u8, value: *const vk.VkFenceCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFenceCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkFenceCreateFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustBufferAccess: u32 = {d},\n", .{value.robustBufferAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fullDrawIndexUint32: u32 = {d},\n", .{value.fullDrawIndexUint32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCubeArray: u32 = {d},\n", .{value.imageCubeArray});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    independentBlend: u32 = {d},\n", .{value.independentBlend});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryShader: u32 = {d},\n", .{value.geometryShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tessellationShader: u32 = {d},\n", .{value.tessellationShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleRateShading: u32 = {d},\n", .{value.sampleRateShading});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dualSrcBlend: u32 = {d},\n", .{value.dualSrcBlend});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    logicOp: u32 = {d},\n", .{value.logicOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiDrawIndirect: u32 = {d},\n", .{value.multiDrawIndirect});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drawIndirectFirstInstance: u32 = {d},\n", .{value.drawIndirectFirstInstance});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClamp: u32 = {d},\n", .{value.depthClamp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasClamp: u32 = {d},\n", .{value.depthBiasClamp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fillModeNonSolid: u32 = {d},\n", .{value.fillModeNonSolid});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBounds: u32 = {d},\n", .{value.depthBounds});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    wideLines: u32 = {d},\n", .{value.wideLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    largePoints: u32 = {d},\n", .{value.largePoints});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alphaToOne: u32 = {d},\n", .{value.alphaToOne});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiViewport: u32 = {d},\n", .{value.multiViewport});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerAnisotropy: u32 = {d},\n", .{value.samplerAnisotropy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureCompressionETC2: u32 = {d},\n", .{value.textureCompressionETC2});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureCompressionASTC_LDR: u32 = {d},\n", .{value.textureCompressionASTC_LDR});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureCompressionBC: u32 = {d},\n", .{value.textureCompressionBC});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    occlusionQueryPrecise: u32 = {d},\n", .{value.occlusionQueryPrecise});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineStatisticsQuery: u32 = {d},\n", .{value.pipelineStatisticsQuery});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexPipelineStoresAndAtomics: u32 = {d},\n", .{value.vertexPipelineStoresAndAtomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentStoresAndAtomics: u32 = {d},\n", .{value.fragmentStoresAndAtomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTessellationAndGeometryPointSize: u32 = {d},\n", .{value.shaderTessellationAndGeometryPointSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderImageGatherExtended: u32 = {d},\n", .{value.shaderImageGatherExtended});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageExtendedFormats: u32 = {d},\n", .{value.shaderStorageImageExtendedFormats});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageMultisample: u32 = {d},\n", .{value.shaderStorageImageMultisample});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageReadWithoutFormat: u32 = {d},\n", .{value.shaderStorageImageReadWithoutFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageWriteWithoutFormat: u32 = {d},\n", .{value.shaderStorageImageWriteWithoutFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformBufferArrayDynamicIndexing: u32 = {d},\n", .{value.shaderUniformBufferArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSampledImageArrayDynamicIndexing: u32 = {d},\n", .{value.shaderSampledImageArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageBufferArrayDynamicIndexing: u32 = {d},\n", .{value.shaderStorageBufferArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageArrayDynamicIndexing: u32 = {d},\n", .{value.shaderStorageImageArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderClipDistance: u32 = {d},\n", .{value.shaderClipDistance});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCullDistance: u32 = {d},\n", .{value.shaderCullDistance});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloat64: u32 = {d},\n", .{value.shaderFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInt64: u32 = {d},\n", .{value.shaderInt64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInt16: u32 = {d},\n", .{value.shaderInt16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderResourceResidency: u32 = {d},\n", .{value.shaderResourceResidency});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderResourceMinLod: u32 = {d},\n", .{value.shaderResourceMinLod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseBinding: u32 = {d},\n", .{value.sparseBinding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidencyBuffer: u32 = {d},\n", .{value.sparseResidencyBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidencyImage2D: u32 = {d},\n", .{value.sparseResidencyImage2D});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidencyImage3D: u32 = {d},\n", .{value.sparseResidencyImage3D});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidency2Samples: u32 = {d},\n", .{value.sparseResidency2Samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidency4Samples: u32 = {d},\n", .{value.sparseResidency4Samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidency8Samples: u32 = {d},\n", .{value.sparseResidency8Samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidency16Samples: u32 = {d},\n", .{value.sparseResidency16Samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseResidencyAliased: u32 = {d},\n", .{value.sparseResidencyAliased});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    variableMultisampleRate: u32 = {d},\n", .{value.variableMultisampleRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inheritedQueries: u32 = {d},\n", .{value.inheritedQueries});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSparseProperties(name: []const u8, value: *const vk.VkPhysicalDeviceSparseProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSparseProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    residencyStandard2DBlockShape: u32 = {d},\n", .{value.residencyStandard2DBlockShape});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    residencyStandard2DMultisampleBlockShape: u32 = {d},\n", .{value.residencyStandard2DMultisampleBlockShape});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    residencyStandard3DBlockShape: u32 = {d},\n", .{value.residencyStandard3DBlockShape});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    residencyAlignedMipSize: u32 = {d},\n", .{value.residencyAlignedMipSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    residencyNonResidentStrict: u32 = {d},\n", .{value.residencyNonResidentStrict});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLimits(name: []const u8, value: *const vk.VkPhysicalDeviceLimits, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLimits = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageDimension1D: u32 = {d},\n", .{value.maxImageDimension1D});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageDimension2D: u32 = {d},\n", .{value.maxImageDimension2D});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageDimension3D: u32 = {d},\n", .{value.maxImageDimension3D});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageDimensionCube: u32 = {d},\n", .{value.maxImageDimensionCube});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageArrayLayers: u32 = {d},\n", .{value.maxImageArrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTexelBufferElements: u32 = {d},\n", .{value.maxTexelBufferElements});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxUniformBufferRange: u32 = {d},\n", .{value.maxUniformBufferRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStorageBufferRange: u32 = {d},\n", .{value.maxStorageBufferRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPushConstantsSize: u32 = {d},\n", .{value.maxPushConstantsSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMemoryAllocationCount: u32 = {d},\n", .{value.maxMemoryAllocationCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSamplerAllocationCount: u32 = {d},\n", .{value.maxSamplerAllocationCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferImageGranularity: u64 = {d},\n", .{value.bufferImageGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseAddressSpaceSize: u64 = {d},\n", .{value.sparseAddressSpaceSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBoundDescriptorSets: u32 = {d},\n", .{value.maxBoundDescriptorSets});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorSamplers: u32 = {d},\n", .{value.maxPerStageDescriptorSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUniformBuffers: u32 = {d},\n", .{value.maxPerStageDescriptorUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorStorageBuffers: u32 = {d},\n", .{value.maxPerStageDescriptorStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorSampledImages: u32 = {d},\n", .{value.maxPerStageDescriptorSampledImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorStorageImages: u32 = {d},\n", .{value.maxPerStageDescriptorStorageImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorInputAttachments: u32 = {d},\n", .{value.maxPerStageDescriptorInputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageResources: u32 = {d},\n", .{value.maxPerStageResources});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetSamplers: u32 = {d},\n", .{value.maxDescriptorSetSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUniformBuffers: u32 = {d},\n", .{value.maxDescriptorSetUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUniformBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUniformBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetStorageBuffers: u32 = {d},\n", .{value.maxDescriptorSetStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetStorageBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetStorageBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetSampledImages: u32 = {d},\n", .{value.maxDescriptorSetSampledImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetStorageImages: u32 = {d},\n", .{value.maxDescriptorSetStorageImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetInputAttachments: u32 = {d},\n", .{value.maxDescriptorSetInputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexInputAttributes: u32 = {d},\n", .{value.maxVertexInputAttributes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexInputBindings: u32 = {d},\n", .{value.maxVertexInputBindings});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexInputAttributeOffset: u32 = {d},\n", .{value.maxVertexInputAttributeOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexInputBindingStride: u32 = {d},\n", .{value.maxVertexInputBindingStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexOutputComponents: u32 = {d},\n", .{value.maxVertexOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationGenerationLevel: u32 = {d},\n", .{value.maxTessellationGenerationLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationPatchSize: u32 = {d},\n", .{value.maxTessellationPatchSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationControlPerVertexInputComponents: u32 = {d},\n", .{value.maxTessellationControlPerVertexInputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationControlPerVertexOutputComponents: u32 = {d},\n", .{value.maxTessellationControlPerVertexOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationControlPerPatchOutputComponents: u32 = {d},\n", .{value.maxTessellationControlPerPatchOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationControlTotalOutputComponents: u32 = {d},\n", .{value.maxTessellationControlTotalOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationEvaluationInputComponents: u32 = {d},\n", .{value.maxTessellationEvaluationInputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTessellationEvaluationOutputComponents: u32 = {d},\n", .{value.maxTessellationEvaluationOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryShaderInvocations: u32 = {d},\n", .{value.maxGeometryShaderInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryInputComponents: u32 = {d},\n", .{value.maxGeometryInputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryOutputComponents: u32 = {d},\n", .{value.maxGeometryOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryOutputVertices: u32 = {d},\n", .{value.maxGeometryOutputVertices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryTotalOutputComponents: u32 = {d},\n", .{value.maxGeometryTotalOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentInputComponents: u32 = {d},\n", .{value.maxFragmentInputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentOutputAttachments: u32 = {d},\n", .{value.maxFragmentOutputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentDualSrcAttachments: u32 = {d},\n", .{value.maxFragmentDualSrcAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentCombinedOutputResources: u32 = {d},\n", .{value.maxFragmentCombinedOutputResources});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxComputeSharedMemorySize: u32 = {d},\n", .{value.maxComputeSharedMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxComputeWorkGroupCount: [3]u32 = {any},\n", .{value.maxComputeWorkGroupCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxComputeWorkGroupInvocations: u32 = {d},\n", .{value.maxComputeWorkGroupInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxComputeWorkGroupSize: [3]u32 = {any},\n", .{value.maxComputeWorkGroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subPixelPrecisionBits: u32 = {d},\n", .{value.subPixelPrecisionBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subTexelPrecisionBits: u32 = {d},\n", .{value.subTexelPrecisionBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mipmapPrecisionBits: u32 = {d},\n", .{value.mipmapPrecisionBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDrawIndexedIndexValue: u32 = {d},\n", .{value.maxDrawIndexedIndexValue});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDrawIndirectCount: u32 = {d},\n", .{value.maxDrawIndirectCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSamplerLodBias: f32 = {d},\n", .{value.maxSamplerLodBias});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSamplerAnisotropy: f32 = {d},\n", .{value.maxSamplerAnisotropy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxViewports: u32 = {d},\n", .{value.maxViewports});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxViewportDimensions: [2]u32 = {any},\n", .{value.maxViewportDimensions});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportBoundsRange: [2]f32 = {any},\n", .{value.viewportBoundsRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportSubPixelBits: u32 = {d},\n", .{value.viewportSubPixelBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minMemoryMapAlignment: u64 = {d},\n", .{value.minMemoryMapAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minTexelBufferOffsetAlignment: u64 = {d},\n", .{value.minTexelBufferOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minUniformBufferOffsetAlignment: u64 = {d},\n", .{value.minUniformBufferOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minStorageBufferOffsetAlignment: u64 = {d},\n", .{value.minStorageBufferOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minTexelOffset: i32 = {d},\n", .{value.minTexelOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTexelOffset: u32 = {d},\n", .{value.maxTexelOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minTexelGatherOffset: i32 = {d},\n", .{value.minTexelGatherOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTexelGatherOffset: u32 = {d},\n", .{value.maxTexelGatherOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minInterpolationOffset: f32 = {d},\n", .{value.minInterpolationOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInterpolationOffset: f32 = {d},\n", .{value.maxInterpolationOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subPixelInterpolationOffsetBits: u32 = {d},\n", .{value.subPixelInterpolationOffsetBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFramebufferWidth: u32 = {d},\n", .{value.maxFramebufferWidth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFramebufferHeight: u32 = {d},\n", .{value.maxFramebufferHeight});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFramebufferLayers: u32 = {d},\n", .{value.maxFramebufferLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebufferColorSampleCounts: VkSampleCountFlags = {any},\n", .{value.framebufferColorSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebufferDepthSampleCounts: VkSampleCountFlags = {any},\n", .{value.framebufferDepthSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebufferStencilSampleCounts: VkSampleCountFlags = {any},\n", .{value.framebufferStencilSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = {any},\n", .{value.framebufferNoAttachmentsSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxColorAttachments: u32 = {d},\n", .{value.maxColorAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampledImageColorSampleCounts: VkSampleCountFlags = {any},\n", .{value.sampledImageColorSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampledImageIntegerSampleCounts: VkSampleCountFlags = {any},\n", .{value.sampledImageIntegerSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampledImageDepthSampleCounts: VkSampleCountFlags = {any},\n", .{value.sampledImageDepthSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampledImageStencilSampleCounts: VkSampleCountFlags = {any},\n", .{value.sampledImageStencilSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageImageSampleCounts: VkSampleCountFlags = {any},\n", .{value.storageImageSampleCounts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSampleMaskWords: u32 = {d},\n", .{value.maxSampleMaskWords});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timestampComputeAndGraphics: u32 = {d},\n", .{value.timestampComputeAndGraphics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timestampPeriod: f32 = {d},\n", .{value.timestampPeriod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxClipDistances: u32 = {d},\n", .{value.maxClipDistances});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCullDistances: u32 = {d},\n", .{value.maxCullDistances});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCombinedClipAndCullDistances: u32 = {d},\n", .{value.maxCombinedClipAndCullDistances});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    discreteQueuePriorities: u32 = {d},\n", .{value.discreteQueuePriorities});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pointSizeRange: [2]f32 = {any},\n", .{value.pointSizeRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineWidthRange: [2]f32 = {any},\n", .{value.lineWidthRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pointSizeGranularity: f32 = {d},\n", .{value.pointSizeGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineWidthGranularity: f32 = {d},\n", .{value.lineWidthGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    strictLines: u32 = {d},\n", .{value.strictLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    standardSampleLocations: u32 = {d},\n", .{value.standardSampleLocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalBufferCopyOffsetAlignment: u64 = {d},\n", .{value.optimalBufferCopyOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalBufferCopyRowPitchAlignment: u64 = {d},\n", .{value.optimalBufferCopyRowPitchAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nonCoherentAtomSize: u64 = {d},\n", .{value.nonCoherentAtomSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreCreateInfo(name: []const u8, value: *const vk.VkSemaphoreCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSemaphoreCreateFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueryPoolCreateInfo(name: []const u8, value: *const vk.VkQueryPoolCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueryPoolCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkQueryPoolCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queryType: VkQueryType = {t},\n", .{value.queryType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queryCount: u32 = {d},\n", .{value.queryCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineStatistics: VkQueryPipelineStatisticFlags = {any},\n", .{value.pipelineStatistics});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFramebufferCreateInfo(name: []const u8, value: *const vk.VkFramebufferCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFramebufferCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkFramebufferCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderPass: VkRenderPass = {},\n", .{value.renderPass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentCount: u32 = {d},\n", .{value.attachmentCount});
    if (value.pAttachments) |v| {
        for (v[0..value.attachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAttachments: [*]const VkImageView = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttachments: [*]const VkImageView = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: u32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: u32 = {d},\n", .{value.height});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layers: u32 = {d},\n", .{value.layers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrawIndirectCommand(name: []const u8, value: *const vk.VkDrawIndirectCommand, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrawIndirectCommand = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexCount: u32 = {d},\n", .{value.vertexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceCount: u32 = {d},\n", .{value.instanceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstVertex: u32 = {d},\n", .{value.firstVertex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstInstance: u32 = {d},\n", .{value.firstInstance});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrawIndexedIndirectCommand(name: []const u8, value: *const vk.VkDrawIndexedIndirectCommand, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrawIndexedIndirectCommand = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexCount: u32 = {d},\n", .{value.indexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceCount: u32 = {d},\n", .{value.instanceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstIndex: u32 = {d},\n", .{value.firstIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexOffset: i32 = {d},\n", .{value.vertexOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstInstance: u32 = {d},\n", .{value.firstInstance});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDispatchIndirectCommand(name: []const u8, value: *const vk.VkDispatchIndirectCommand, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDispatchIndirectCommand = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    x: u32 = {d},\n", .{value.x});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    y: u32 = {d},\n", .{value.y});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    z: u32 = {d},\n", .{value.z});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMultiDrawInfoEXT(name: []const u8, value: *const vk.VkMultiDrawInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMultiDrawInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstVertex: u32 = {d},\n", .{value.firstVertex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexCount: u32 = {d},\n", .{value.vertexCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMultiDrawIndexedInfoEXT(name: []const u8, value: *const vk.VkMultiDrawIndexedInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMultiDrawIndexedInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstIndex: u32 = {d},\n", .{value.firstIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexCount: u32 = {d},\n", .{value.indexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexOffset: i32 = {d},\n", .{value.vertexOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubmitInfo(name: []const u8, value: *const vk.VkSubmitInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubmitInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    waitSemaphoreCount: u32 = {d},\n", .{value.waitSemaphoreCount});
    if (value.pWaitSemaphores) |v| {
        for (v[0..value.waitSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pWaitSemaphores: [*]const VkSemaphore = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitSemaphores: [*]const VkSemaphore = null,\n", .{});
    }
    if (value.pWaitDstStageMask) |v| {
        for (v[0..value.waitSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pWaitDstStageMask: [*]const VkPipelineStageFlags = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitDstStageMask: [*]const VkPipelineStageFlags = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferCount: u32 = {d},\n", .{value.commandBufferCount});
    if (value.pCommandBuffers) |v| {
        for (v[0..value.commandBufferCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCommandBuffers: [*]const VkCommandBuffer = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCommandBuffers: [*]const VkCommandBuffer = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    signalSemaphoreCount: u32 = {d},\n", .{value.signalSemaphoreCount});
    if (value.pSignalSemaphores) |v| {
        for (v[0..value.signalSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSignalSemaphores: [*]const VkSemaphore = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSignalSemaphores: [*]const VkSemaphore = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPropertiesKHR(name: []const u8, value: *const vk.VkDisplayPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    display: VkDisplayKHR = {},\n", .{value.display});
    if (value.displayName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    displayName: [*:0]const u8 = {s}n", .{v});
    }
    print_VkExtent2D("physicalDimensions", &value.physicalDimensions, offset + 1);
    print_VkExtent2D("physicalResolution", &value.physicalResolution, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedTransforms: VkSurfaceTransformFlagsKHR = {any},\n", .{value.supportedTransforms});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    planeReorderPossible: u32 = {d},\n", .{value.planeReorderPossible});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    persistentContent: u32 = {d},\n", .{value.persistentContent});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPlanePropertiesKHR(name: []const u8, value: *const vk.VkDisplayPlanePropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPlanePropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    currentDisplay: VkDisplayKHR = {},\n", .{value.currentDisplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    currentStackIndex: u32 = {d},\n", .{value.currentStackIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayModeParametersKHR(name: []const u8, value: *const vk.VkDisplayModeParametersKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayModeParametersKHR = .{{\n", .{ name });
    print_VkExtent2D("visibleRegion", &value.visibleRegion, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    refreshRate: u32 = {d},\n", .{value.refreshRate});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayModePropertiesKHR(name: []const u8, value: *const vk.VkDisplayModePropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayModePropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displayMode: VkDisplayModeKHR = {},\n", .{value.displayMode});
    print_VkDisplayModeParametersKHR("parameters", &value.parameters, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayModeCreateInfoKHR(name: []const u8, value: *const vk.VkDisplayModeCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayModeCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDisplayModeCreateFlagsKHR = {any},\n", .{value.flags});
    print_VkDisplayModeParametersKHR("parameters", &value.parameters, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPlaneCapabilitiesKHR(name: []const u8, value: *const vk.VkDisplayPlaneCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPlaneCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedAlpha: VkDisplayPlaneAlphaFlagsKHR = {any},\n", .{value.supportedAlpha});
    print_VkOffset2D("minSrcPosition", &value.minSrcPosition, offset + 1);
    print_VkOffset2D("maxSrcPosition", &value.maxSrcPosition, offset + 1);
    print_VkExtent2D("minSrcExtent", &value.minSrcExtent, offset + 1);
    print_VkExtent2D("maxSrcExtent", &value.maxSrcExtent, offset + 1);
    print_VkOffset2D("minDstPosition", &value.minDstPosition, offset + 1);
    print_VkOffset2D("maxDstPosition", &value.maxDstPosition, offset + 1);
    print_VkExtent2D("minDstExtent", &value.minDstExtent, offset + 1);
    print_VkExtent2D("maxDstExtent", &value.maxDstExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplaySurfaceCreateInfoKHR(name: []const u8, value: *const vk.VkDisplaySurfaceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplaySurfaceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDisplaySurfaceCreateFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displayMode: VkDisplayModeKHR = {},\n", .{value.displayMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    planeIndex: u32 = {d},\n", .{value.planeIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    planeStackIndex: u32 = {d},\n", .{value.planeStackIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transform: VkSurfaceTransformFlagsKHR = {any},\n", .{value.transform});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    globalAlpha: f32 = {d},\n", .{value.globalAlpha});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alphaMode: VkDisplayPlaneAlphaFlagsKHR = {any},\n", .{value.alphaMode});
    print_VkExtent2D("imageExtent", &value.imageExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplaySurfaceStereoCreateInfoNV(name: []const u8, value: *const vk.VkDisplaySurfaceStereoCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplaySurfaceStereoCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stereoType: VkDisplaySurfaceStereoTypeNV = {t},\n", .{value.stereoType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPresentInfoKHR(name: []const u8, value: *const vk.VkDisplayPresentInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPresentInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkRect2D("srcRect", &value.srcRect, offset + 1);
    print_VkRect2D("dstRect", &value.dstRect, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    persistent: u32 = {d},\n", .{value.persistent});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCapabilitiesKHR(name: []const u8, value: *const vk.VkSurfaceCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minImageCount: u32 = {d},\n", .{value.minImageCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageCount: u32 = {d},\n", .{value.maxImageCount});
    print_VkExtent2D("currentExtent", &value.currentExtent, offset + 1);
    print_VkExtent2D("minImageExtent", &value.minImageExtent, offset + 1);
    print_VkExtent2D("maxImageExtent", &value.maxImageExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageArrayLayers: u32 = {d},\n", .{value.maxImageArrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedTransforms: VkSurfaceTransformFlagsKHR = {any},\n", .{value.supportedTransforms});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    currentTransform: VkSurfaceTransformFlagsKHR = {any},\n", .{value.currentTransform});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR = {any},\n", .{value.supportedCompositeAlpha});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedUsageFlags: VkImageUsageFlags = {any},\n", .{value.supportedUsageFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAndroidSurfaceCreateInfoKHR(name: []const u8, value: *const vk.VkAndroidSurfaceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAndroidSurfaceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkAndroidSurfaceCreateFlagsKHR = {any},\n", .{value.flags});
    if (value.window) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *ANativeWindow = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *ANativeWindow = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkViSurfaceCreateInfoNN(name: []const u8, value: *const vk.VkViSurfaceCreateInfoNN, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkViSurfaceCreateInfoNN = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkViSurfaceCreateFlagsNN = {any},\n", .{value.flags});
    if (value.window) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWaylandSurfaceCreateInfoKHR(name: []const u8, value: *const vk.VkWaylandSurfaceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWaylandSurfaceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkWaylandSurfaceCreateFlagsKHR = {any},\n", .{value.flags});
    if (value.display) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    display: *wl_display = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    display: *wl_display = null,\n", .{});
    }
    if (value.surface) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    surface: *wl_surface = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    surface: *wl_surface = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWin32SurfaceCreateInfoKHR(name: []const u8, value: *const vk.VkWin32SurfaceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWin32SurfaceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkWin32SurfaceCreateFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkXlibSurfaceCreateInfoKHR(name: []const u8, value: *const vk.VkXlibSurfaceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkXlibSurfaceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkXlibSurfaceCreateFlagsKHR = {any},\n", .{value.flags});
    if (value.dpy) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    dpy: *Display = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    dpy: *Display = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkXcbSurfaceCreateInfoKHR(name: []const u8, value: *const vk.VkXcbSurfaceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkXcbSurfaceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkXcbSurfaceCreateFlagsKHR = {any},\n", .{value.flags});
    if (value.connection) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    connection: *xcb_connection_t = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    connection: *xcb_connection_t = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDirectFBSurfaceCreateInfoEXT(name: []const u8, value: *const vk.VkDirectFBSurfaceCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDirectFBSurfaceCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDirectFBSurfaceCreateFlagsEXT = {any},\n", .{value.flags});
    if (value.dfb) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    dfb: *IDirectFB = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    dfb: *IDirectFB = null,\n", .{});
    }
    if (value.surface) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    surface: *IDirectFBSurface = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    surface: *IDirectFBSurface = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImagePipeSurfaceCreateInfoFUCHSIA(name: []const u8, value: *const vk.VkImagePipeSurfaceCreateInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImagePipeSurfaceCreateInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImagePipeSurfaceCreateFlagsFUCHSIA = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkStreamDescriptorSurfaceCreateInfoGGP(name: []const u8, value: *const vk.VkStreamDescriptorSurfaceCreateInfoGGP, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkStreamDescriptorSurfaceCreateInfoGGP = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkStreamDescriptorSurfaceCreateFlagsGGP = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkScreenSurfaceCreateInfoQNX(name: []const u8, value: *const vk.VkScreenSurfaceCreateInfoQNX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkScreenSurfaceCreateInfoQNX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkScreenSurfaceCreateFlagsQNX = {any},\n", .{value.flags});
    if (value.context) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    context: *_screen_context = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    context: *_screen_context = null,\n", .{});
    }
    if (value.window) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *_screen_window = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *_screen_window = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceFormatKHR(name: []const u8, value: *const vk.VkSurfaceFormatKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceFormatKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorSpace: VkColorSpaceKHR = {t},\n", .{value.colorSpace});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainCreateInfoKHR(name: []const u8, value: *const vk.VkSwapchainCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSwapchainCreateFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    surface: VkSurfaceKHR = {},\n", .{value.surface});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minImageCount: u32 = {d},\n", .{value.minImageCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageFormat: VkFormat = {t},\n", .{value.imageFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageColorSpace: VkColorSpaceKHR = {t},\n", .{value.imageColorSpace});
    print_VkExtent2D("imageExtent", &value.imageExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageArrayLayers: u32 = {d},\n", .{value.imageArrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageUsage: VkImageUsageFlags = {any},\n", .{value.imageUsage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageSharingMode: VkSharingMode = {t},\n", .{value.imageSharingMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndexCount: u32 = {d},\n", .{value.queueFamilyIndexCount});
    if (value.pQueueFamilyIndices) |v| {
        for (v[0..value.queueFamilyIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pQueueFamilyIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueueFamilyIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preTransform: VkSurfaceTransformFlagsKHR = {any},\n", .{value.preTransform});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compositeAlpha: VkCompositeAlphaFlagsKHR = {any},\n", .{value.compositeAlpha});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentMode: VkPresentModeKHR = {t},\n", .{value.presentMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clipped: u32 = {d},\n", .{value.clipped});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    oldSwapchain: VkSwapchainKHR = {},\n", .{value.oldSwapchain});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentInfoKHR(name: []const u8, value: *const vk.VkPresentInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    waitSemaphoreCount: u32 = {d},\n", .{value.waitSemaphoreCount});
    if (value.pWaitSemaphores) |v| {
        for (v[0..value.waitSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pWaitSemaphores: [*]const VkSemaphore = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitSemaphores: [*]const VkSemaphore = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pSwapchains) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSwapchains: [*]const VkSwapchainKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSwapchains: [*]const VkSwapchainKHR = null,\n", .{});
    }
    if (value.pImageIndices) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pImageIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImageIndices: [*]const u32 = null,\n", .{});
    }
    if (value.pResults) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pResults: [*]VkResult = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pResults: [*]VkResult = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugReportCallbackCreateInfoEXT(name: []const u8, value: *const vk.VkDebugReportCallbackCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugReportCallbackCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDebugReportFlagsEXT = {any},\n", .{value.flags});
    if (value.pfnCallback) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnCallback: *const vkDebugReportCallbackEXT = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnCallback: *const vkDebugReportCallbackEXT = null,\n", .{});
    }
    if (value.pUserData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkValidationFlagsEXT(name: []const u8, value: *const vk.VkValidationFlagsEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkValidationFlagsEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    disabledValidationCheckCount: u32 = {d},\n", .{value.disabledValidationCheckCount});
    if (value.pDisabledValidationChecks) |v| {
        for (v[0..value.disabledValidationCheckCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDisabledValidationChecks: [*]const VkValidationCheckEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDisabledValidationChecks: [*]const VkValidationCheckEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkValidationFeaturesEXT(name: []const u8, value: *const vk.VkValidationFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkValidationFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enabledValidationFeatureCount: u32 = {d},\n", .{value.enabledValidationFeatureCount});
    if (value.pEnabledValidationFeatures) |v| {
        for (v[0..value.enabledValidationFeatureCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pEnabledValidationFeatures: [*]const VkValidationFeatureEnableEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pEnabledValidationFeatures: [*]const VkValidationFeatureEnableEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    disabledValidationFeatureCount: u32 = {d},\n", .{value.disabledValidationFeatureCount});
    if (value.pDisabledValidationFeatures) |v| {
        for (v[0..value.disabledValidationFeatureCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDisabledValidationFeatures: [*]const VkValidationFeatureDisableEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDisabledValidationFeatures: [*]const VkValidationFeatureDisableEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLayerSettingsCreateInfoEXT(name: []const u8, value: *const vk.VkLayerSettingsCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLayerSettingsCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    settingCount: u32 = {d},\n", .{value.settingCount});
    if (value.pSettings) |v| {
        for (v[0..value.settingCount]) |*vv| {
            print_VkLayerSettingEXT("pSettings", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSettings: [*]const VkLayerSettingEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLayerSettingEXT(name: []const u8, value: *const vk.VkLayerSettingEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLayerSettingEXT = .{{\n", .{ name });
    if (value.pLayerName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLayerName: [*:0]const u8 = {s}n", .{v});
    }
    if (value.pSettingName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSettingName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkLayerSettingTypeEXT = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    valueCount: u32 = {d},\n", .{value.valueCount});
    if (value.pValues) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pValues: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pValues: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkApplicationParametersEXT(name: []const u8, value: *const vk.VkApplicationParametersEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkApplicationParametersEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorID: u32 = {d},\n", .{value.vendorID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceID: u32 = {d},\n", .{value.deviceID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    key: u32 = {d},\n", .{value.key});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    value: u64 = {d},\n", .{value.value});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRasterizationStateRasterizationOrderAMD(name: []const u8, value: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRasterizationStateRasterizationOrderAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationOrder: VkRasterizationOrderAMD = {t},\n", .{value.rasterizationOrder});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugMarkerObjectNameInfoEXT(name: []const u8, value: *const vk.VkDebugMarkerObjectNameInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugMarkerObjectNameInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectType: VkDebugReportObjectTypeEXT = {t},\n", .{value.objectType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    object: u64 = {d},\n", .{value.object});
    if (value.pObjectName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pObjectName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugMarkerObjectTagInfoEXT(name: []const u8, value: *const vk.VkDebugMarkerObjectTagInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugMarkerObjectTagInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectType: VkDebugReportObjectTypeEXT = {t},\n", .{value.objectType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    object: u64 = {d},\n", .{value.object});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tagName: u64 = {d},\n", .{value.tagName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tagSize: u64 = {d},\n", .{value.tagSize});
    if (value.pTag) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTag: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTag: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugMarkerMarkerInfoEXT(name: []const u8, value: *const vk.VkDebugMarkerMarkerInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugMarkerMarkerInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pMarkerName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pMarkerName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    color: [4]f32 = {any},\n", .{value.color});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDedicatedAllocationImageCreateInfoNV(name: []const u8, value: *const vk.VkDedicatedAllocationImageCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDedicatedAllocationImageCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dedicatedAllocation: u32 = {d},\n", .{value.dedicatedAllocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDedicatedAllocationBufferCreateInfoNV(name: []const u8, value: *const vk.VkDedicatedAllocationBufferCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDedicatedAllocationBufferCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dedicatedAllocation: u32 = {d},\n", .{value.dedicatedAllocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDedicatedAllocationMemoryAllocateInfoNV(name: []const u8, value: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDedicatedAllocationMemoryAllocateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalImageFormatPropertiesNV(name: []const u8, value: *const vk.VkExternalImageFormatPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalImageFormatPropertiesNV = .{{\n", .{ name });
    print_VkImageFormatProperties("imageFormatProperties", &value.imageFormatProperties, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV = {any},\n", .{value.externalMemoryFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV = {any},\n", .{value.exportFromImportedHandleTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV = {any},\n", .{value.compatibleHandleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalMemoryImageCreateInfoNV(name: []const u8, value: *const vk.VkExternalMemoryImageCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalMemoryImageCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalMemoryHandleTypeFlagsNV = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMemoryAllocateInfoNV(name: []const u8, value: *const vk.VkExportMemoryAllocateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMemoryAllocateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalMemoryHandleTypeFlagsNV = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemoryWin32HandleInfoNV(name: []const u8, value: *const vk.VkImportMemoryWin32HandleInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemoryWin32HandleInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlagsNV = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMemoryWin32HandleInfoNV(name: []const u8, value: *const vk.VkExportMemoryWin32HandleInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMemoryWin32HandleInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pAttributes) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMemorySciBufInfoNV(name: []const u8, value: *const vk.VkExportMemorySciBufInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMemorySciBufInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemorySciBufInfoNV(name: []const u8, value: *const vk.VkImportMemorySciBufInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemorySciBufInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetSciBufInfoNV(name: []const u8, value: *const vk.VkMemoryGetSciBufInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetSciBufInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemorySciBufPropertiesNV(name: []const u8, value: *const vk.VkMemorySciBufPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemorySciBufPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalMemorySciBufFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExternalMemorySciBufFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalMemorySciBufFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciBufImport: u32 = {d},\n", .{value.sciBufImport});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciBufExport: u32 = {d},\n", .{value.sciBufExport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWin32KeyedMutexAcquireReleaseInfoNV(name: []const u8, value: *const vk.VkWin32KeyedMutexAcquireReleaseInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWin32KeyedMutexAcquireReleaseInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    acquireCount: u32 = {d},\n", .{value.acquireCount});
    if (value.pAcquireSyncs) |v| {
        for (v[0..value.acquireCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAcquireSyncs: [*]const VkDeviceMemory = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAcquireSyncs: [*]const VkDeviceMemory = null,\n", .{});
    }
    if (value.pAcquireKeys) |v| {
        for (v[0..value.acquireCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAcquireKeys: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAcquireKeys: [*]const u64 = null,\n", .{});
    }
    if (value.pAcquireTimeoutMilliseconds) |v| {
        for (v[0..value.acquireCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAcquireTimeoutMilliseconds: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAcquireTimeoutMilliseconds: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    releaseCount: u32 = {d},\n", .{value.releaseCount});
    if (value.pReleaseSyncs) |v| {
        for (v[0..value.releaseCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pReleaseSyncs: [*]const VkDeviceMemory = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pReleaseSyncs: [*]const VkDeviceMemory = null,\n", .{});
    }
    if (value.pReleaseKeys) |v| {
        for (v[0..value.releaseCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pReleaseKeys: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pReleaseKeys: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceGeneratedCommands: u32 = {d},\n", .{value.deviceGeneratedCommands});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceGeneratedCompute: u32 = {d},\n", .{value.deviceGeneratedCompute});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceGeneratedComputePipelines: u32 = {d},\n", .{value.deviceGeneratedComputePipelines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceGeneratedComputeCaptureReplay: u32 = {d},\n", .{value.deviceGeneratedComputeCaptureReplay});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDevicePrivateDataCreateInfo(name: []const u8, value: *const vk.VkDevicePrivateDataCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDevicePrivateDataCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    privateDataSlotRequestCount: u32 = {d},\n", .{value.privateDataSlotRequestCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPrivateDataSlotCreateInfo(name: []const u8, value: *const vk.VkPrivateDataSlotCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPrivateDataSlotCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPrivateDataSlotCreateFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePrivateDataFeatures(name: []const u8, value: *const vk.VkPhysicalDevicePrivateDataFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePrivateDataFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    privateData: u32 = {d},\n", .{value.privateData});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGraphicsShaderGroupCount: u32 = {d},\n", .{value.maxGraphicsShaderGroupCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectSequenceCount: u32 = {d},\n", .{value.maxIndirectSequenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectCommandsTokenCount: u32 = {d},\n", .{value.maxIndirectCommandsTokenCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectCommandsStreamCount: u32 = {d},\n", .{value.maxIndirectCommandsStreamCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectCommandsTokenOffset: u32 = {d},\n", .{value.maxIndirectCommandsTokenOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectCommandsStreamStride: u32 = {d},\n", .{value.maxIndirectCommandsStreamStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minSequencesCountBufferOffsetAlignment: u32 = {d},\n", .{value.minSequencesCountBufferOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minSequencesIndexBufferOffsetAlignment: u32 = {d},\n", .{value.minSequencesIndexBufferOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minIndirectCommandsBufferOffsetAlignment: u32 = {d},\n", .{value.minIndirectCommandsBufferOffsetAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterAccelerationStructure: u32 = {d},\n", .{value.clusterAccelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVerticesPerCluster: u32 = {d},\n", .{value.maxVerticesPerCluster});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTrianglesPerCluster: u32 = {d},\n", .{value.maxTrianglesPerCluster});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterScratchByteAlignment: u32 = {d},\n", .{value.clusterScratchByteAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterByteAlignment: u32 = {d},\n", .{value.clusterByteAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterTemplateByteAlignment: u32 = {d},\n", .{value.clusterTemplateByteAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterBottomLevelByteAlignment: u32 = {d},\n", .{value.clusterBottomLevelByteAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterTemplateBoundsByteAlignment: u32 = {d},\n", .{value.clusterTemplateBoundsByteAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxClusterGeometryIndex: u32 = {d},\n", .{value.maxClusterGeometryIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkStridedDeviceAddressNV(name: []const u8, value: *const vk.VkStridedDeviceAddressNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkStridedDeviceAddressNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    startAddress: u64 = {d},\n", .{value.startAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    strideInBytes: u64 = {d},\n", .{value.strideInBytes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(name: []const u8, value: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    allowClusterAccelerationStructure: u32 = {d},\n", .{value.allowClusterAccelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    packed_field0: <packed> = {any},\n", .{value.packed_field0});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureMoveObjectsInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureMoveObjectsInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureMoveObjectsInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccelerationStructure: u64 = {d},\n", .{value.srcAccelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterReferencesCount: u32 = {d},\n", .{value.clusterReferencesCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterReferencesStride: u32 = {d},\n", .{value.clusterReferencesStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterReferences: u64 = {d},\n", .{value.clusterReferences});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureGetTemplateIndicesInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureGetTemplateIndicesInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureGetTemplateIndicesInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterTemplateAddress: u64 = {d},\n", .{value.clusterTemplateAddress});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureBuildTriangleClusterInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureBuildTriangleClusterInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureBuildTriangleClusterInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterID: u32 = {d},\n", .{value.clusterID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterFlags: VkClusterAccelerationStructureClusterFlagsNV = {any},\n", .{value.clusterFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    packed_field0: <packed> = {any},\n", .{value.packed_field0});
    print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV("baseGeometryIndexAndGeometryFlags", &value.baseGeometryIndexAndGeometryFlags, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexBufferStride: u16 = {d},\n", .{value.indexBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBufferStride: u16 = {d},\n", .{value.vertexBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryIndexAndFlagsBufferStride: u16 = {d},\n", .{value.geometryIndexAndFlagsBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opacityMicromapIndexBufferStride: u16 = {d},\n", .{value.opacityMicromapIndexBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexBuffer: u64 = {d},\n", .{value.indexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBuffer: u64 = {d},\n", .{value.vertexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryIndexAndFlagsBuffer: u64 = {d},\n", .{value.geometryIndexAndFlagsBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opacityMicromapArray: u64 = {d},\n", .{value.opacityMicromapArray});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opacityMicromapIndexBuffer: u64 = {d},\n", .{value.opacityMicromapIndexBuffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterID: u32 = {d},\n", .{value.clusterID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterFlags: VkClusterAccelerationStructureClusterFlagsNV = {any},\n", .{value.clusterFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    packed_field0: <packed> = {any},\n", .{value.packed_field0});
    print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV("baseGeometryIndexAndGeometryFlags", &value.baseGeometryIndexAndGeometryFlags, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexBufferStride: u16 = {d},\n", .{value.indexBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBufferStride: u16 = {d},\n", .{value.vertexBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryIndexAndFlagsBufferStride: u16 = {d},\n", .{value.geometryIndexAndFlagsBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opacityMicromapIndexBufferStride: u16 = {d},\n", .{value.opacityMicromapIndexBufferStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexBuffer: u64 = {d},\n", .{value.indexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBuffer: u64 = {d},\n", .{value.vertexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryIndexAndFlagsBuffer: u64 = {d},\n", .{value.geometryIndexAndFlagsBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opacityMicromapArray: u64 = {d},\n", .{value.opacityMicromapArray});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opacityMicromapIndexBuffer: u64 = {d},\n", .{value.opacityMicromapIndexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instantiationBoundingBoxLimit: u64 = {d},\n", .{value.instantiationBoundingBoxLimit});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureInstantiateClusterInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureInstantiateClusterInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureInstantiateClusterInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterIdOffset: u32 = {d},\n", .{value.clusterIdOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    packed_field0: <packed> = {any},\n", .{value.packed_field0});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterTemplateAddress: u64 = {d},\n", .{value.clusterTemplateAddress});
    print_VkStridedDeviceAddressNV("vertexBuffer", &value.vertexBuffer, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureClustersBottomLevelInputNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureClustersBottomLevelInputNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTotalClusterCount: u32 = {d},\n", .{value.maxTotalClusterCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxClusterCountPerAccelerationStructure: u32 = {d},\n", .{value.maxClusterCountPerAccelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureTriangleClusterInputNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureTriangleClusterInputNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexFormat: VkFormat = {t},\n", .{value.vertexFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryIndexValue: u32 = {d},\n", .{value.maxGeometryIndexValue});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxClusterUniqueGeometryCount: u32 = {d},\n", .{value.maxClusterUniqueGeometryCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxClusterTriangleCount: u32 = {d},\n", .{value.maxClusterTriangleCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxClusterVertexCount: u32 = {d},\n", .{value.maxClusterVertexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTotalTriangleCount: u32 = {d},\n", .{value.maxTotalTriangleCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTotalVertexCount: u32 = {d},\n", .{value.maxTotalVertexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minPositionTruncateBitCount: u32 = {d},\n", .{value.minPositionTruncateBitCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureMoveObjectsInputNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureMoveObjectsInputNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkClusterAccelerationStructureTypeNV = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    noMoveOverlap: u32 = {d},\n", .{value.noMoveOverlap});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMovedBytes: u64 = {d},\n", .{value.maxMovedBytes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureInputInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureInputInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureInputInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxAccelerationStructureCount: u32 = {d},\n", .{value.maxAccelerationStructureCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkBuildAccelerationStructureFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opType: VkClusterAccelerationStructureOpTypeNV = {t},\n", .{value.opType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opMode: VkClusterAccelerationStructureOpModeNV = {t},\n", .{value.opMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.opType) {
        .VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV => log.output("    opInput: VkClusterAccelerationStructureOpInputNV = {any},\n", .{value.opInput.pMoveObjects}),
        .VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV => log.output("    opInput: VkClusterAccelerationStructureOpInputNV = {any},\n", .{value.opInput.pClustersBottomLevel}),
        else => log.output("    opInput: VkClusterAccelerationStructureOpInputNV = ???,\n", .{}),
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkClusterAccelerationStructureCommandsInfoNV(name: []const u8, value: *const vk.VkClusterAccelerationStructureCommandsInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkClusterAccelerationStructureCommandsInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkClusterAccelerationStructureInputInfoNV("input", &value.input, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImplicitData: u64 = {d},\n", .{value.dstImplicitData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scratchData: u64 = {d},\n", .{value.scratchData});
    print_VkStridedDeviceAddressRegionKHR("dstAddressesArray", &value.dstAddressesArray, offset + 1);
    print_VkStridedDeviceAddressRegionKHR("dstSizesArray", &value.dstSizesArray, offset + 1);
    print_VkStridedDeviceAddressRegionKHR("srcInfosArray", &value.srcInfosArray, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcInfosCount: u64 = {d},\n", .{value.srcInfosCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    addressResolutionFlags: VkClusterAccelerationStructureAddressResolutionFlagsNV = {any},\n", .{value.addressResolutionFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultiDrawPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultiDrawPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMultiDrawCount: u32 = {d},\n", .{value.maxMultiDrawCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGraphicsShaderGroupCreateInfoNV(name: []const u8, value: *const vk.VkGraphicsShaderGroupCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGraphicsShaderGroupCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageCount: u32 = {d},\n", .{value.stageCount});
    if (value.pStages) |v| {
        for (v[0..value.stageCount]) |*vv| {
            print_VkPipelineShaderStageCreateInfo("pStages", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStages: [*]const VkPipelineShaderStageCreateInfo = null,\n", .{});
    }
    if (value.pVertexInputState) |v| {
        print_VkPipelineVertexInputStateCreateInfo("pVertexInputState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVertexInputState: *const VkPipelineVertexInputStateCreateInfo = null,\n", .{});
    }
    if (value.pTessellationState) |v| {
        print_VkPipelineTessellationStateCreateInfo("pTessellationState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTessellationState: *const VkPipelineTessellationStateCreateInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGraphicsPipelineShaderGroupsCreateInfoNV(name: []const u8, value: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGraphicsPipelineShaderGroupsCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupCount: u32 = {d},\n", .{value.groupCount});
    if (value.pGroups) |v| {
        for (v[0..value.groupCount]) |*vv| {
            print_VkGraphicsShaderGroupCreateInfoNV("pGroups", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pGroups: [*]const VkGraphicsShaderGroupCreateInfoNV = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCount: u32 = {d},\n", .{value.pipelineCount});
    if (value.pPipelines) |v| {
        for (v[0..value.pipelineCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPipelines: [*]const VkPipeline = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelines: [*]const VkPipeline = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindShaderGroupIndirectCommandNV(name: []const u8, value: *const vk.VkBindShaderGroupIndirectCommandNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindShaderGroupIndirectCommandNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupIndex: u32 = {d},\n", .{value.groupIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindIndexBufferIndirectCommandNV(name: []const u8, value: *const vk.VkBindIndexBufferIndirectCommandNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindIndexBufferIndirectCommandNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferAddress: u64 = {d},\n", .{value.bufferAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u32 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindVertexBufferIndirectCommandNV(name: []const u8, value: *const vk.VkBindVertexBufferIndirectCommandNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindVertexBufferIndirectCommandNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferAddress: u64 = {d},\n", .{value.bufferAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u32 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u32 = {d},\n", .{value.stride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSetStateFlagsIndirectCommandNV(name: []const u8, value: *const vk.VkSetStateFlagsIndirectCommandNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSetStateFlagsIndirectCommandNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    data: u32 = {d},\n", .{value.data});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsStreamNV(name: []const u8, value: *const vk.VkIndirectCommandsStreamNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsStreamNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsLayoutTokenNV(name: []const u8, value: *const vk.VkIndirectCommandsLayoutTokenNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsLayoutTokenNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tokenType: VkIndirectCommandsTokenTypeNV = {t},\n", .{value.tokenType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stream: u32 = {d},\n", .{value.stream});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u32 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBindingUnit: u32 = {d},\n", .{value.vertexBindingUnit});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexDynamicStride: u32 = {d},\n", .{value.vertexDynamicStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushconstantPipelineLayout: VkPipelineLayout = {},\n", .{value.pushconstantPipelineLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushconstantShaderStageFlags: VkShaderStageFlags = {any},\n", .{value.pushconstantShaderStageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushconstantOffset: u32 = {d},\n", .{value.pushconstantOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushconstantSize: u32 = {d},\n", .{value.pushconstantSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectStateFlags: VkIndirectStateFlagsNV = {any},\n", .{value.indirectStateFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexTypeCount: u32 = {d},\n", .{value.indexTypeCount});
    if (value.pIndexTypes) |v| {
        for (v[0..value.indexTypeCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pIndexTypes: [*]const VkIndexType = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pIndexTypes: [*]const VkIndexType = null,\n", .{});
    }
    if (value.pIndexTypeValues) |v| {
        for (v[0..value.indexTypeCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pIndexTypeValues: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pIndexTypeValues: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsLayoutCreateInfoNV(name: []const u8, value: *const vk.VkIndirectCommandsLayoutCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsLayoutCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkIndirectCommandsLayoutUsageFlagsNV = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBindPoint: VkPipelineBindPoint = {t},\n", .{value.pipelineBindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tokenCount: u32 = {d},\n", .{value.tokenCount});
    if (value.pTokens) |v| {
        for (v[0..value.tokenCount]) |*vv| {
            print_VkIndirectCommandsLayoutTokenNV("pTokens", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTokens: [*]const VkIndirectCommandsLayoutTokenNV = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    streamCount: u32 = {d},\n", .{value.streamCount});
    if (value.pStreamStrides) |v| {
        for (v[0..value.streamCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStreamStrides: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStreamStrides: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeneratedCommandsInfoNV(name: []const u8, value: *const vk.VkGeneratedCommandsInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeneratedCommandsInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBindPoint: VkPipelineBindPoint = {t},\n", .{value.pipelineBindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectCommandsLayout: VkIndirectCommandsLayoutNV = {},\n", .{value.indirectCommandsLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    streamCount: u32 = {d},\n", .{value.streamCount});
    if (value.pStreams) |v| {
        for (v[0..value.streamCount]) |*vv| {
            print_VkIndirectCommandsStreamNV("pStreams", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStreams: [*]const VkIndirectCommandsStreamNV = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sequencesCount: u32 = {d},\n", .{value.sequencesCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preprocessBuffer: VkBuffer = {},\n", .{value.preprocessBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preprocessOffset: u64 = {d},\n", .{value.preprocessOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preprocessSize: u64 = {d},\n", .{value.preprocessSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sequencesCountBuffer: VkBuffer = {},\n", .{value.sequencesCountBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sequencesCountOffset: u64 = {d},\n", .{value.sequencesCountOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sequencesIndexBuffer: VkBuffer = {},\n", .{value.sequencesIndexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sequencesIndexOffset: u64 = {d},\n", .{value.sequencesIndexOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeneratedCommandsMemoryRequirementsInfoNV(name: []const u8, value: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeneratedCommandsMemoryRequirementsInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBindPoint: VkPipelineBindPoint = {t},\n", .{value.pipelineBindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectCommandsLayout: VkIndirectCommandsLayoutNV = {},\n", .{value.indirectCommandsLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSequencesCount: u32 = {d},\n", .{value.maxSequencesCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineIndirectDeviceAddressInfoNV(name: []const u8, value: *const vk.VkPipelineIndirectDeviceAddressInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineIndirectDeviceAddressInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBindPoint: VkPipelineBindPoint = {t},\n", .{value.pipelineBindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindPipelineIndirectCommandNV(name: []const u8, value: *const vk.VkBindPipelineIndirectCommandNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindPipelineIndirectCommandNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineAddress: u64 = {d},\n", .{value.pipelineAddress});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFeatures2(name: []const u8, value: *const vk.VkPhysicalDeviceFeatures2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFeatures2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkPhysicalDeviceFeatures("features", &value.features, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceProperties2(name: []const u8, value: *const vk.VkPhysicalDeviceProperties2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceProperties2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkPhysicalDeviceProperties("properties", &value.properties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFormatProperties2(name: []const u8, value: *const vk.VkFormatProperties2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFormatProperties2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkFormatProperties("formatProperties", &value.formatProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageFormatProperties2(name: []const u8, value: *const vk.VkImageFormatProperties2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageFormatProperties2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkImageFormatProperties("imageFormatProperties", &value.imageFormatProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageFormatInfo2(name: []const u8, value: *const vk.VkPhysicalDeviceImageFormatInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageFormatInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkImageType = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tiling: VkImageTiling = {t},\n", .{value.tiling});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkImageUsageFlags = {any},\n", .{value.usage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImageCreateFlags = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyProperties2(name: []const u8, value: *const vk.VkQueueFamilyProperties2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyProperties2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkQueueFamilyProperties("queueFamilyProperties", &value.queueFamilyProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMemoryProperties2(name: []const u8, value: *const vk.VkPhysicalDeviceMemoryProperties2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMemoryProperties2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkPhysicalDeviceMemoryProperties("memoryProperties", &value.memoryProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseImageFormatProperties2(name: []const u8, value: *const vk.VkSparseImageFormatProperties2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseImageFormatProperties2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkSparseImageFormatProperties("properties", &value.properties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSparseImageFormatInfo2(name: []const u8, value: *const vk.VkPhysicalDeviceSparseImageFormatInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSparseImageFormatInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkImageType = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samples: VkSampleCountFlags = {any},\n", .{value.samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkImageUsageFlags = {any},\n", .{value.usage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tiling: VkImageTiling = {t},\n", .{value.tiling});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePushDescriptorProperties(name: []const u8, value: *const vk.VkPhysicalDevicePushDescriptorProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePushDescriptorProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPushDescriptors: u32 = {d},\n", .{value.maxPushDescriptors});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkConformanceVersion(name: []const u8, value: *const vk.VkConformanceVersion, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkConformanceVersion = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    major: u8 = {d},\n", .{value.major});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minor: u8 = {d},\n", .{value.minor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subminor: u8 = {d},\n", .{value.subminor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    patch: u8 = {d},\n", .{value.patch});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDriverProperties(name: []const u8, value: *const vk.VkPhysicalDeviceDriverProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDriverProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverID: VkDriverId = {t},\n", .{value.driverID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverName: [VK_MAX_DRIVER_NAME_SIZE]u8 = {any},\n", .{value.driverName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverInfo: [VK_MAX_DRIVER_INFO_SIZE]u8 = {any},\n", .{value.driverInfo});
    print_VkConformanceVersion("conformanceVersion", &value.conformanceVersion, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentRegionsKHR(name: []const u8, value: *const vk.VkPresentRegionsKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentRegionsKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pRegions) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            print_VkPresentRegionKHR("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkPresentRegionKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentRegionKHR(name: []const u8, value: *const vk.VkPresentRegionKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentRegionKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rectangleCount: u32 = {d},\n", .{value.rectangleCount});
    if (value.pRectangles) |v| {
        for (v[0..value.rectangleCount]) |*vv| {
            print_VkRectLayerKHR("pRectangles", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRectangles: [*]const VkRectLayerKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRectLayerKHR(name: []const u8, value: *const vk.VkRectLayerKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRectLayerKHR = .{{\n", .{ name });
    print_VkOffset2D("offset", &value.offset, offset + 1);
    print_VkExtent2D("extent", &value.extent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layer: u32 = {d},\n", .{value.layer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVariablePointersFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceVariablePointersFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVariablePointersFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    variablePointersStorageBuffer: u32 = {d},\n", .{value.variablePointersStorageBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    variablePointers: u32 = {d},\n", .{value.variablePointers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalMemoryProperties(name: []const u8, value: *const vk.VkExternalMemoryProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalMemoryProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalMemoryFeatures: VkExternalMemoryFeatureFlags = {any},\n", .{value.externalMemoryFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.exportFromImportedHandleTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compatibleHandleTypes: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.compatibleHandleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalImageFormatInfo(name: []const u8, value: *const vk.VkPhysicalDeviceExternalImageFormatInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalImageFormatInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalImageFormatProperties(name: []const u8, value: *const vk.VkExternalImageFormatProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalImageFormatProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExternalMemoryProperties("externalMemoryProperties", &value.externalMemoryProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalBufferInfo(name: []const u8, value: *const vk.VkPhysicalDeviceExternalBufferInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalBufferInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkBufferCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkBufferUsageFlags = {any},\n", .{value.usage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalBufferProperties(name: []const u8, value: *const vk.VkExternalBufferProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalBufferProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExternalMemoryProperties("externalMemoryProperties", &value.externalMemoryProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceIDProperties(name: []const u8, value: *const vk.VkPhysicalDeviceIDProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceIDProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.deviceUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.driverUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceLUID: [VK_LUID_SIZE]u8 = {any},\n", .{value.deviceLUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceNodeMask: u32 = {d},\n", .{value.deviceNodeMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceLUIDValid: u32 = {d},\n", .{value.deviceLUIDValid});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalMemoryImageCreateInfo(name: []const u8, value: *const vk.VkExternalMemoryImageCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalMemoryImageCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalMemoryBufferCreateInfo(name: []const u8, value: *const vk.VkExternalMemoryBufferCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalMemoryBufferCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMemoryAllocateInfo(name: []const u8, value: *const vk.VkExportMemoryAllocateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMemoryAllocateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemoryWin32HandleInfoKHR(name: []const u8, value: *const vk.VkImportMemoryWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemoryWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMemoryWin32HandleInfoKHR(name: []const u8, value: *const vk.VkExportMemoryWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMemoryWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pAttributes) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemoryZirconHandleInfoFUCHSIA(name: []const u8, value: *const vk.VkImportMemoryZirconHandleInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemoryZirconHandleInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryZirconHandlePropertiesFUCHSIA(name: []const u8, value: *const vk.VkMemoryZirconHandlePropertiesFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryZirconHandlePropertiesFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetZirconHandleInfoFUCHSIA(name: []const u8, value: *const vk.VkMemoryGetZirconHandleInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetZirconHandleInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryWin32HandlePropertiesKHR(name: []const u8, value: *const vk.VkMemoryWin32HandlePropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryWin32HandlePropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetWin32HandleInfoKHR(name: []const u8, value: *const vk.VkMemoryGetWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemoryFdInfoKHR(name: []const u8, value: *const vk.VkImportMemoryFdInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemoryFdInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryFdPropertiesKHR(name: []const u8, value: *const vk.VkMemoryFdPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryFdPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetFdInfoKHR(name: []const u8, value: *const vk.VkMemoryGetFdInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetFdInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWin32KeyedMutexAcquireReleaseInfoKHR(name: []const u8, value: *const vk.VkWin32KeyedMutexAcquireReleaseInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWin32KeyedMutexAcquireReleaseInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    acquireCount: u32 = {d},\n", .{value.acquireCount});
    if (value.pAcquireSyncs) |v| {
        for (v[0..value.acquireCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAcquireSyncs: [*]const VkDeviceMemory = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAcquireSyncs: [*]const VkDeviceMemory = null,\n", .{});
    }
    if (value.pAcquireKeys) |v| {
        for (v[0..value.acquireCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAcquireKeys: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAcquireKeys: [*]const u64 = null,\n", .{});
    }
    if (value.pAcquireTimeouts) |v| {
        for (v[0..value.acquireCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAcquireTimeouts: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAcquireTimeouts: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    releaseCount: u32 = {d},\n", .{value.releaseCount});
    if (value.pReleaseSyncs) |v| {
        for (v[0..value.releaseCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pReleaseSyncs: [*]const VkDeviceMemory = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pReleaseSyncs: [*]const VkDeviceMemory = null,\n", .{});
    }
    if (value.pReleaseKeys) |v| {
        for (v[0..value.releaseCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pReleaseKeys: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pReleaseKeys: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemoryMetalHandleInfoEXT(name: []const u8, value: *const vk.VkImportMemoryMetalHandleInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemoryMetalHandleInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    if (value.handle) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryMetalHandlePropertiesEXT(name: []const u8, value: *const vk.VkMemoryMetalHandlePropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryMetalHandlePropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetMetalHandleInfoEXT(name: []const u8, value: *const vk.VkMemoryGetMetalHandleInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetMetalHandleInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalSemaphoreInfo(name: []const u8, value: *const vk.VkPhysicalDeviceExternalSemaphoreInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalSemaphoreInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalSemaphoreProperties(name: []const u8, value: *const vk.VkExternalSemaphoreProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalSemaphoreProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.exportFromImportedHandleTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.compatibleHandleTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags = {any},\n", .{value.externalSemaphoreFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportSemaphoreCreateInfo(name: []const u8, value: *const vk.VkExportSemaphoreCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportSemaphoreCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportSemaphoreWin32HandleInfoKHR(name: []const u8, value: *const vk.VkImportSemaphoreWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportSemaphoreWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSemaphoreImportFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportSemaphoreWin32HandleInfoKHR(name: []const u8, value: *const vk.VkExportSemaphoreWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportSemaphoreWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pAttributes) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkD3D12FenceSubmitInfoKHR(name: []const u8, value: *const vk.VkD3D12FenceSubmitInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkD3D12FenceSubmitInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    waitSemaphoreValuesCount: u32 = {d},\n", .{value.waitSemaphoreValuesCount});
    if (value.pWaitSemaphoreValues) |v| {
        for (v[0..value.waitSemaphoreValuesCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pWaitSemaphoreValues: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitSemaphoreValues: [*]const u64 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    signalSemaphoreValuesCount: u32 = {d},\n", .{value.signalSemaphoreValuesCount});
    if (value.pSignalSemaphoreValues) |v| {
        for (v[0..value.signalSemaphoreValuesCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSignalSemaphoreValues: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSignalSemaphoreValues: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreGetWin32HandleInfoKHR(name: []const u8, value: *const vk.VkSemaphoreGetWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreGetWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportSemaphoreFdInfoKHR(name: []const u8, value: *const vk.VkImportSemaphoreFdInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportSemaphoreFdInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSemaphoreImportFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreGetFdInfoKHR(name: []const u8, value: *const vk.VkSemaphoreGetFdInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreGetFdInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportSemaphoreZirconHandleInfoFUCHSIA(name: []const u8, value: *const vk.VkImportSemaphoreZirconHandleInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportSemaphoreZirconHandleInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSemaphoreImportFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreGetZirconHandleInfoFUCHSIA(name: []const u8, value: *const vk.VkSemaphoreGetZirconHandleInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreGetZirconHandleInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalFenceInfo(name: []const u8, value: *const vk.VkPhysicalDeviceExternalFenceInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalFenceInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalFenceProperties(name: []const u8, value: *const vk.VkExternalFenceProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalFenceProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags = {any},\n", .{value.exportFromImportedHandleTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compatibleHandleTypes: VkExternalFenceHandleTypeFlags = {any},\n", .{value.compatibleHandleTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFenceFeatures: VkExternalFenceFeatureFlags = {any},\n", .{value.externalFenceFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportFenceCreateInfo(name: []const u8, value: *const vk.VkExportFenceCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportFenceCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportFenceWin32HandleInfoKHR(name: []const u8, value: *const vk.VkImportFenceWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportFenceWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fence: VkFence = {},\n", .{value.fence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkFenceImportFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportFenceWin32HandleInfoKHR(name: []const u8, value: *const vk.VkExportFenceWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportFenceWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pAttributes) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttributes: *const SECURITY_ATTRIBUTES = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFenceGetWin32HandleInfoKHR(name: []const u8, value: *const vk.VkFenceGetWin32HandleInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFenceGetWin32HandleInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fence: VkFence = {},\n", .{value.fence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportFenceFdInfoKHR(name: []const u8, value: *const vk.VkImportFenceFdInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportFenceFdInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fence: VkFence = {},\n", .{value.fence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkFenceImportFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFenceGetFdInfoKHR(name: []const u8, value: *const vk.VkFenceGetFdInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFenceGetFdInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fence: VkFence = {},\n", .{value.fence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportFenceSciSyncInfoNV(name: []const u8, value: *const vk.VkExportFenceSciSyncInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportFenceSciSyncInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportFenceSciSyncInfoNV(name: []const u8, value: *const vk.VkImportFenceSciSyncInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportFenceSciSyncInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fence: VkFence = {},\n", .{value.fence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleType});
    if (value.handle) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFenceGetSciSyncInfoNV(name: []const u8, value: *const vk.VkFenceGetSciSyncInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFenceGetSciSyncInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fence: VkFence = {},\n", .{value.fence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalFenceHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportSemaphoreSciSyncInfoNV(name: []const u8, value: *const vk.VkExportSemaphoreSciSyncInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportSemaphoreSciSyncInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportSemaphoreSciSyncInfoNV(name: []const u8, value: *const vk.VkImportSemaphoreSciSyncInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportSemaphoreSciSyncInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    if (value.handle) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreGetSciSyncInfoNV(name: []const u8, value: *const vk.VkSemaphoreGetSciSyncInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreGetSciSyncInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSciSyncAttributesInfoNV(name: []const u8, value: *const vk.VkSciSyncAttributesInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSciSyncAttributesInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clientType: VkSciSyncClientTypeNV = {t},\n", .{value.clientType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveType: VkSciSyncPrimitiveTypeNV = {t},\n", .{value.primitiveType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalSciSyncFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExternalSciSyncFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalSciSyncFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncFence: u32 = {d},\n", .{value.sciSyncFence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncSemaphore: u32 = {d},\n", .{value.sciSyncSemaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncImport: u32 = {d},\n", .{value.sciSyncImport});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncExport: u32 = {d},\n", .{value.sciSyncExport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalSciSync2FeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExternalSciSync2FeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalSciSync2FeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncFence: u32 = {d},\n", .{value.sciSyncFence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncSemaphore2: u32 = {d},\n", .{value.sciSyncSemaphore2});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncImport: u32 = {d},\n", .{value.sciSyncImport});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sciSyncExport: u32 = {d},\n", .{value.sciSyncExport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreSciSyncPoolCreateInfoNV(name: []const u8, value: *const vk.VkSemaphoreSciSyncPoolCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreSciSyncPoolCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreSciSyncCreateInfoNV(name: []const u8, value: *const vk.VkSemaphoreSciSyncCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreSciSyncCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphorePool: VkSemaphoreSciSyncPoolNV = {},\n", .{value.semaphorePool});
    if (value.pFence) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFence: *const NvSciSyncFence = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFence: *const NvSciSyncFence = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV(name: []const u8, value: *const vk.VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphoreSciSyncPoolRequestCount: u32 = {d},\n", .{value.semaphoreSciSyncPoolRequestCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultiviewFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceMultiviewFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultiviewFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiview: u32 = {d},\n", .{value.multiview});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewGeometryShader: u32 = {d},\n", .{value.multiviewGeometryShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewTessellationShader: u32 = {d},\n", .{value.multiviewTessellationShader});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultiviewProperties(name: []const u8, value: *const vk.VkPhysicalDeviceMultiviewProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultiviewProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMultiviewViewCount: u32 = {d},\n", .{value.maxMultiviewViewCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMultiviewInstanceIndex: u32 = {d},\n", .{value.maxMultiviewInstanceIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassMultiviewCreateInfo(name: []const u8, value: *const vk.VkRenderPassMultiviewCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassMultiviewCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassCount: u32 = {d},\n", .{value.subpassCount});
    if (value.pViewMasks) |v| {
        for (v[0..value.subpassCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pViewMasks: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewMasks: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dependencyCount: u32 = {d},\n", .{value.dependencyCount});
    if (value.pViewOffsets) |v| {
        for (v[0..value.dependencyCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pViewOffsets: [*]const i32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewOffsets: [*]const i32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    correlationMaskCount: u32 = {d},\n", .{value.correlationMaskCount});
    if (value.pCorrelationMasks) |v| {
        for (v[0..value.correlationMaskCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCorrelationMasks: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCorrelationMasks: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCapabilities2EXT(name: []const u8, value: *const vk.VkSurfaceCapabilities2EXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCapabilities2EXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minImageCount: u32 = {d},\n", .{value.minImageCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageCount: u32 = {d},\n", .{value.maxImageCount});
    print_VkExtent2D("currentExtent", &value.currentExtent, offset + 1);
    print_VkExtent2D("minImageExtent", &value.minImageExtent, offset + 1);
    print_VkExtent2D("maxImageExtent", &value.maxImageExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageArrayLayers: u32 = {d},\n", .{value.maxImageArrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedTransforms: VkSurfaceTransformFlagsKHR = {any},\n", .{value.supportedTransforms});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    currentTransform: VkSurfaceTransformFlagsKHR = {any},\n", .{value.currentTransform});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR = {any},\n", .{value.supportedCompositeAlpha});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedUsageFlags: VkImageUsageFlags = {any},\n", .{value.supportedUsageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedSurfaceCounters: VkSurfaceCounterFlagsEXT = {any},\n", .{value.supportedSurfaceCounters});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPowerInfoEXT(name: []const u8, value: *const vk.VkDisplayPowerInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPowerInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    powerState: VkDisplayPowerStateEXT = {t},\n", .{value.powerState});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceEventInfoEXT(name: []const u8, value: *const vk.VkDeviceEventInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceEventInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceEvent: VkDeviceEventTypeEXT = {t},\n", .{value.deviceEvent});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayEventInfoEXT(name: []const u8, value: *const vk.VkDisplayEventInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayEventInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displayEvent: VkDisplayEventTypeEXT = {t},\n", .{value.displayEvent});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainCounterCreateInfoEXT(name: []const u8, value: *const vk.VkSwapchainCounterCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainCounterCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    surfaceCounters: VkSurfaceCounterFlagsEXT = {any},\n", .{value.surfaceCounters});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceGroupProperties(name: []const u8, value: *const vk.VkPhysicalDeviceGroupProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceGroupProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    physicalDeviceCount: u32 = {d},\n", .{value.physicalDeviceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    physicalDevices: [VK_MAX_DEVICE_GROUP_SIZE]VkPhysicalDevice = {any},\n", .{value.physicalDevices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subsetAllocation: u32 = {d},\n", .{value.subsetAllocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryAllocateFlagsInfo(name: []const u8, value: *const vk.VkMemoryAllocateFlagsInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryAllocateFlagsInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkMemoryAllocateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceMask: u32 = {d},\n", .{value.deviceMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindBufferMemoryInfo(name: []const u8, value: *const vk.VkBindBufferMemoryInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindBufferMemoryInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindBufferMemoryDeviceGroupInfo(name: []const u8, value: *const vk.VkBindBufferMemoryDeviceGroupInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindBufferMemoryDeviceGroupInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceIndexCount: u32 = {d},\n", .{value.deviceIndexCount});
    if (value.pDeviceIndices) |v| {
        for (v[0..value.deviceIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDeviceIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDeviceIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindImageMemoryInfo(name: []const u8, value: *const vk.VkBindImageMemoryInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindImageMemoryInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindImageMemoryDeviceGroupInfo(name: []const u8, value: *const vk.VkBindImageMemoryDeviceGroupInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindImageMemoryDeviceGroupInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceIndexCount: u32 = {d},\n", .{value.deviceIndexCount});
    if (value.pDeviceIndices) |v| {
        for (v[0..value.deviceIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDeviceIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDeviceIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    splitInstanceBindRegionCount: u32 = {d},\n", .{value.splitInstanceBindRegionCount});
    if (value.pSplitInstanceBindRegions) |v| {
        for (v[0..value.splitInstanceBindRegionCount]) |*vv| {
            print_VkRect2D("pSplitInstanceBindRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSplitInstanceBindRegions: [*]const VkRect2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupRenderPassBeginInfo(name: []const u8, value: *const vk.VkDeviceGroupRenderPassBeginInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupRenderPassBeginInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceMask: u32 = {d},\n", .{value.deviceMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceRenderAreaCount: u32 = {d},\n", .{value.deviceRenderAreaCount});
    if (value.pDeviceRenderAreas) |v| {
        for (v[0..value.deviceRenderAreaCount]) |*vv| {
            print_VkRect2D("pDeviceRenderAreas", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDeviceRenderAreas: [*]const VkRect2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupCommandBufferBeginInfo(name: []const u8, value: *const vk.VkDeviceGroupCommandBufferBeginInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupCommandBufferBeginInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceMask: u32 = {d},\n", .{value.deviceMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupSubmitInfo(name: []const u8, value: *const vk.VkDeviceGroupSubmitInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupSubmitInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    waitSemaphoreCount: u32 = {d},\n", .{value.waitSemaphoreCount});
    if (value.pWaitSemaphoreDeviceIndices) |v| {
        for (v[0..value.waitSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pWaitSemaphoreDeviceIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitSemaphoreDeviceIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferCount: u32 = {d},\n", .{value.commandBufferCount});
    if (value.pCommandBufferDeviceMasks) |v| {
        for (v[0..value.commandBufferCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCommandBufferDeviceMasks: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCommandBufferDeviceMasks: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    signalSemaphoreCount: u32 = {d},\n", .{value.signalSemaphoreCount});
    if (value.pSignalSemaphoreDeviceIndices) |v| {
        for (v[0..value.signalSemaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSignalSemaphoreDeviceIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSignalSemaphoreDeviceIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupBindSparseInfo(name: []const u8, value: *const vk.VkDeviceGroupBindSparseInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupBindSparseInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resourceDeviceIndex: u32 = {d},\n", .{value.resourceDeviceIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryDeviceIndex: u32 = {d},\n", .{value.memoryDeviceIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupPresentCapabilitiesKHR(name: []const u8, value: *const vk.VkDeviceGroupPresentCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupPresentCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentMask: [VK_MAX_DEVICE_GROUP_SIZE]u32 = {any},\n", .{value.presentMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    modes: VkDeviceGroupPresentModeFlagsKHR = {any},\n", .{value.modes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageSwapchainCreateInfoKHR(name: []const u8, value: *const vk.VkImageSwapchainCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageSwapchainCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchain: VkSwapchainKHR = {},\n", .{value.swapchain});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindImageMemorySwapchainInfoKHR(name: []const u8, value: *const vk.VkBindImageMemorySwapchainInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindImageMemorySwapchainInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchain: VkSwapchainKHR = {},\n", .{value.swapchain});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageIndex: u32 = {d},\n", .{value.imageIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAcquireNextImageInfoKHR(name: []const u8, value: *const vk.VkAcquireNextImageInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAcquireNextImageInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchain: VkSwapchainKHR = {},\n", .{value.swapchain});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeout: u64 = {d},\n", .{value.timeout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fence: VkFence = {},\n", .{value.fence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceMask: u32 = {d},\n", .{value.deviceMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupPresentInfoKHR(name: []const u8, value: *const vk.VkDeviceGroupPresentInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupPresentInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pDeviceMasks) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDeviceMasks: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDeviceMasks: [*]const u32 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkDeviceGroupPresentModeFlagsKHR = {any},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupDeviceCreateInfo(name: []const u8, value: *const vk.VkDeviceGroupDeviceCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupDeviceCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    physicalDeviceCount: u32 = {d},\n", .{value.physicalDeviceCount});
    if (value.pPhysicalDevices) |v| {
        for (v[0..value.physicalDeviceCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPhysicalDevices: [*]const VkPhysicalDevice = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPhysicalDevices: [*]const VkPhysicalDevice = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceGroupSwapchainCreateInfoKHR(name: []const u8, value: *const vk.VkDeviceGroupSwapchainCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceGroupSwapchainCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    modes: VkDeviceGroupPresentModeFlagsKHR = {any},\n", .{value.modes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorUpdateTemplateEntry(name: []const u8, value: *const vk.VkDescriptorUpdateTemplateEntry, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorUpdateTemplateEntry = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBinding: u32 = {d},\n", .{value.dstBinding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstArrayElement: u32 = {d},\n", .{value.dstArrayElement});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorCount: u32 = {d},\n", .{value.descriptorCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorType: VkDescriptorType = {t},\n", .{value.descriptorType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u64 = {d},\n", .{value.stride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorUpdateTemplateCreateInfo(name: []const u8, value: *const vk.VkDescriptorUpdateTemplateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorUpdateTemplateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDescriptorUpdateTemplateCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorUpdateEntryCount: u32 = {d},\n", .{value.descriptorUpdateEntryCount});
    if (value.pDescriptorUpdateEntries) |v| {
        for (v[0..value.descriptorUpdateEntryCount]) |*vv| {
            print_VkDescriptorUpdateTemplateEntry("pDescriptorUpdateEntries", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDescriptorUpdateEntries: [*]const VkDescriptorUpdateTemplateEntry = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    templateType: VkDescriptorUpdateTemplateType = {t},\n", .{value.templateType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetLayout: VkDescriptorSetLayout = {},\n", .{value.descriptorSetLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBindPoint: VkPipelineBindPoint = {t},\n", .{value.pipelineBindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineLayout: VkPipelineLayout = {},\n", .{value.pipelineLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    set: u32 = {d},\n", .{value.set});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkXYColorEXT(name: []const u8, value: *const vk.VkXYColorEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkXYColorEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    x: f32 = {d},\n", .{value.x});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    y: f32 = {d},\n", .{value.y});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentIdFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePresentIdFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentIdFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentId: u32 = {d},\n", .{value.presentId});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentIdKHR(name: []const u8, value: *const vk.VkPresentIdKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentIdKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pPresentIds) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPresentIds: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentIds: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentId2FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePresentId2FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentId2FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentId2: u32 = {d},\n", .{value.presentId2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentId2KHR(name: []const u8, value: *const vk.VkPresentId2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentId2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pPresentIds) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPresentIds: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentIds: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentWait2InfoKHR(name: []const u8, value: *const vk.VkPresentWait2InfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentWait2InfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentId: u64 = {d},\n", .{value.presentId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeout: u64 = {d},\n", .{value.timeout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentWaitFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentWaitFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentWait: u32 = {d},\n", .{value.presentWait});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentWait2FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentWait2FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentWait2: u32 = {d},\n", .{value.presentWait2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentTimingFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDevicePresentTimingFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentTimingFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentTiming: u32 = {d},\n", .{value.presentTiming});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentAtAbsoluteTime: u32 = {d},\n", .{value.presentAtAbsoluteTime});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentAtRelativeTime: u32 = {d},\n", .{value.presentAtRelativeTime});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentTimingSurfaceCapabilitiesEXT(name: []const u8, value: *const vk.VkPresentTimingSurfaceCapabilitiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentTimingSurfaceCapabilitiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentTimingSupported: u32 = {d},\n", .{value.presentTimingSupported});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentAtAbsoluteTimeSupported: u32 = {d},\n", .{value.presentAtAbsoluteTimeSupported});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentAtRelativeTimeSupported: u32 = {d},\n", .{value.presentAtRelativeTimeSupported});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentStageQueries: VkPresentStageFlagsEXT = {any},\n", .{value.presentStageQueries});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainTimingPropertiesEXT(name: []const u8, value: *const vk.VkSwapchainTimingPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainTimingPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    refreshDuration: u64 = {d},\n", .{value.refreshDuration});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    refreshInterval: u64 = {d},\n", .{value.refreshInterval});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainTimeDomainPropertiesEXT(name: []const u8, value: *const vk.VkSwapchainTimeDomainPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainTimeDomainPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeDomainCount: u32 = {d},\n", .{value.timeDomainCount});
    if (value.pTimeDomains) |v| {
        for (v[0..value.timeDomainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pTimeDomains: [*]VkTimeDomainKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTimeDomains: [*]VkTimeDomainKHR = null,\n", .{});
    }
    if (value.pTimeDomainIds) |v| {
        for (v[0..value.timeDomainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pTimeDomainIds: [*]u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTimeDomainIds: [*]u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentStageTimeEXT(name: []const u8, value: *const vk.VkPresentStageTimeEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentStageTimeEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stage: VkPresentStageFlagsEXT = {any},\n", .{value.stage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    time: u64 = {d},\n", .{value.time});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPastPresentationTimingInfoEXT(name: []const u8, value: *const vk.VkPastPresentationTimingInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPastPresentationTimingInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPastPresentationTimingFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchain: VkSwapchainKHR = {},\n", .{value.swapchain});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPastPresentationTimingPropertiesEXT(name: []const u8, value: *const vk.VkPastPresentationTimingPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPastPresentationTimingPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timingPropertiesCounter: u64 = {d},\n", .{value.timingPropertiesCounter});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeDomainsCounter: u64 = {d},\n", .{value.timeDomainsCounter});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentationTimingCount: u32 = {d},\n", .{value.presentationTimingCount});
    if (value.pPresentationTimings) |v| {
        for (v[0..value.presentationTimingCount]) |*vv| {
            print_VkPastPresentationTimingEXT("pPresentationTimings", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentationTimings: [*]VkPastPresentationTimingEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPastPresentationTimingEXT(name: []const u8, value: *const vk.VkPastPresentationTimingEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPastPresentationTimingEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentId: u64 = {d},\n", .{value.presentId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    targetTime: u64 = {d},\n", .{value.targetTime});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentStageCount: u32 = {d},\n", .{value.presentStageCount});
    if (value.pPresentStages) |v| {
        for (v[0..value.presentStageCount]) |*vv| {
            print_VkPresentStageTimeEXT("pPresentStages", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentStages: [*]VkPresentStageTimeEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeDomain: VkTimeDomainKHR = {t},\n", .{value.timeDomain});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeDomainId: u64 = {d},\n", .{value.timeDomainId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    reportComplete: u32 = {d},\n", .{value.reportComplete});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentTimingsInfoEXT(name: []const u8, value: *const vk.VkPresentTimingsInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentTimingsInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pTimingInfos) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            print_VkPresentTimingInfoEXT("pTimingInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTimingInfos: [*]const VkPresentTimingInfoEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentTimingInfoEXT(name: []const u8, value: *const vk.VkPresentTimingInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentTimingInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPresentTimingInfoFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    targetTime: u64 = {d},\n", .{value.targetTime});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeDomainId: u64 = {d},\n", .{value.timeDomainId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentStageQueries: VkPresentStageFlagsEXT = {any},\n", .{value.presentStageQueries});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    targetTimeDomainPresentStage: VkPresentStageFlagsEXT = {any},\n", .{value.targetTimeDomainPresentStage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainCalibratedTimestampInfoEXT(name: []const u8, value: *const vk.VkSwapchainCalibratedTimestampInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainCalibratedTimestampInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchain: VkSwapchainKHR = {},\n", .{value.swapchain});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentStage: VkPresentStageFlagsEXT = {any},\n", .{value.presentStage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeDomainId: u64 = {d},\n", .{value.timeDomainId});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkHdrMetadataEXT(name: []const u8, value: *const vk.VkHdrMetadataEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkHdrMetadataEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkXYColorEXT("displayPrimaryRed", &value.displayPrimaryRed, offset + 1);
    print_VkXYColorEXT("displayPrimaryGreen", &value.displayPrimaryGreen, offset + 1);
    print_VkXYColorEXT("displayPrimaryBlue", &value.displayPrimaryBlue, offset + 1);
    print_VkXYColorEXT("whitePoint", &value.whitePoint, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxLuminance: f32 = {d},\n", .{value.maxLuminance});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minLuminance: f32 = {d},\n", .{value.minLuminance});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxContentLightLevel: f32 = {d},\n", .{value.maxContentLightLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFrameAverageLightLevel: f32 = {d},\n", .{value.maxFrameAverageLightLevel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkHdrVividDynamicMetadataHUAWEI(name: []const u8, value: *const vk.VkHdrVividDynamicMetadataHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkHdrVividDynamicMetadataHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicMetadataSize: u64 = {d},\n", .{value.dynamicMetadataSize});
    if (value.pDynamicMetadata) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDynamicMetadata: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDynamicMetadata: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayNativeHdrSurfaceCapabilitiesAMD(name: []const u8, value: *const vk.VkDisplayNativeHdrSurfaceCapabilitiesAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayNativeHdrSurfaceCapabilitiesAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    localDimmingSupport: u32 = {d},\n", .{value.localDimmingSupport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainDisplayNativeHdrCreateInfoAMD(name: []const u8, value: *const vk.VkSwapchainDisplayNativeHdrCreateInfoAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainDisplayNativeHdrCreateInfoAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    localDimmingEnable: u32 = {d},\n", .{value.localDimmingEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRefreshCycleDurationGOOGLE(name: []const u8, value: *const vk.VkRefreshCycleDurationGOOGLE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRefreshCycleDurationGOOGLE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    refreshDuration: u64 = {d},\n", .{value.refreshDuration});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPastPresentationTimingGOOGLE(name: []const u8, value: *const vk.VkPastPresentationTimingGOOGLE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPastPresentationTimingGOOGLE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentID: u32 = {d},\n", .{value.presentID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    desiredPresentTime: u64 = {d},\n", .{value.desiredPresentTime});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    actualPresentTime: u64 = {d},\n", .{value.actualPresentTime});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    earliestPresentTime: u64 = {d},\n", .{value.earliestPresentTime});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentMargin: u64 = {d},\n", .{value.presentMargin});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentTimesInfoGOOGLE(name: []const u8, value: *const vk.VkPresentTimesInfoGOOGLE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentTimesInfoGOOGLE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pTimes) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            print_VkPresentTimeGOOGLE("pTimes", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTimes: [*]const VkPresentTimeGOOGLE = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentTimeGOOGLE(name: []const u8, value: *const vk.VkPresentTimeGOOGLE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentTimeGOOGLE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentID: u32 = {d},\n", .{value.presentID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    desiredPresentTime: u64 = {d},\n", .{value.desiredPresentTime});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIOSSurfaceCreateInfoMVK(name: []const u8, value: *const vk.VkIOSSurfaceCreateInfoMVK, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIOSSurfaceCreateInfoMVK = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkIOSSurfaceCreateFlagsMVK = {any},\n", .{value.flags});
    if (value.pView) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pView: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pView: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMacOSSurfaceCreateInfoMVK(name: []const u8, value: *const vk.VkMacOSSurfaceCreateInfoMVK, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMacOSSurfaceCreateInfoMVK = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkMacOSSurfaceCreateFlagsMVK = {any},\n", .{value.flags});
    if (value.pView) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pView: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pView: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMetalSurfaceCreateInfoEXT(name: []const u8, value: *const vk.VkMetalSurfaceCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMetalSurfaceCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkMetalSurfaceCreateFlagsEXT = {any},\n", .{value.flags});
    if (value.pLayer) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLayer: *const CAMetalLayer = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLayer: *const CAMetalLayer = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkViewportWScalingNV(name: []const u8, value: *const vk.VkViewportWScalingNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkViewportWScalingNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    xcoeff: f32 = {d},\n", .{value.xcoeff});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ycoeff: f32 = {d},\n", .{value.ycoeff});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportWScalingStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineViewportWScalingStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportWScalingStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportWScalingEnable: u32 = {d},\n", .{value.viewportWScalingEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportCount: u32 = {d},\n", .{value.viewportCount});
    if (value.pViewportWScalings) |v| {
        for (v[0..value.viewportCount]) |*vv| {
            print_VkViewportWScalingNV("pViewportWScalings", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewportWScalings: [*]const VkViewportWScalingNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkViewportSwizzleNV(name: []const u8, value: *const vk.VkViewportSwizzleNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkViewportSwizzleNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    x: VkViewportCoordinateSwizzleNV = {t},\n", .{value.x});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    y: VkViewportCoordinateSwizzleNV = {t},\n", .{value.y});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    z: VkViewportCoordinateSwizzleNV = {t},\n", .{value.z});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    w: VkViewportCoordinateSwizzleNV = {t},\n", .{value.w});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportSwizzleStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportSwizzleStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineViewportSwizzleStateCreateFlagsNV = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportCount: u32 = {d},\n", .{value.viewportCount});
    if (value.pViewportSwizzles) |v| {
        for (v[0..value.viewportCount]) |*vv| {
            print_VkViewportSwizzleNV("pViewportSwizzles", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewportSwizzles: [*]const VkViewportSwizzleNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDiscardRectanglePropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDiscardRectanglePropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDiscardRectangles: u32 = {d},\n", .{value.maxDiscardRectangles});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineDiscardRectangleStateCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineDiscardRectangleStateCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineDiscardRectangleStateCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    discardRectangleMode: VkDiscardRectangleModeEXT = {t},\n", .{value.discardRectangleMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    discardRectangleCount: u32 = {d},\n", .{value.discardRectangleCount});
    if (value.pDiscardRectangles) |v| {
        for (v[0..value.discardRectangleCount]) |*vv| {
            print_VkRect2D("pDiscardRectangles", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDiscardRectangles: [*]const VkRect2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(name: []const u8, value: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    perViewPositionAllComponents: u32 = {d},\n", .{value.perViewPositionAllComponents});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkInputAttachmentAspectReference(name: []const u8, value: *const vk.VkInputAttachmentAspectReference, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkInputAttachmentAspectReference = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpass: u32 = {d},\n", .{value.subpass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputAttachmentIndex: u32 = {d},\n", .{value.inputAttachmentIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectMask: VkImageAspectFlags = {any},\n", .{value.aspectMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassInputAttachmentAspectCreateInfo(name: []const u8, value: *const vk.VkRenderPassInputAttachmentAspectCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassInputAttachmentAspectCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectReferenceCount: u32 = {d},\n", .{value.aspectReferenceCount});
    if (value.pAspectReferences) |v| {
        for (v[0..value.aspectReferenceCount]) |*vv| {
            print_VkInputAttachmentAspectReference("pAspectReferences", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAspectReferences: [*]const VkInputAttachmentAspectReference = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSurfaceInfo2KHR(name: []const u8, value: *const vk.VkPhysicalDeviceSurfaceInfo2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSurfaceInfo2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    surface: VkSurfaceKHR = {},\n", .{value.surface});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCapabilities2KHR(name: []const u8, value: *const vk.VkSurfaceCapabilities2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCapabilities2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkSurfaceCapabilitiesKHR("surfaceCapabilities", &value.surfaceCapabilities, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceFormat2KHR(name: []const u8, value: *const vk.VkSurfaceFormat2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceFormat2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkSurfaceFormatKHR("surfaceFormat", &value.surfaceFormat, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayProperties2KHR(name: []const u8, value: *const vk.VkDisplayProperties2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayProperties2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkDisplayPropertiesKHR("displayProperties", &value.displayProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPlaneProperties2KHR(name: []const u8, value: *const vk.VkDisplayPlaneProperties2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPlaneProperties2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkDisplayPlanePropertiesKHR("displayPlaneProperties", &value.displayPlaneProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayModeProperties2KHR(name: []const u8, value: *const vk.VkDisplayModeProperties2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayModeProperties2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkDisplayModePropertiesKHR("displayModeProperties", &value.displayModeProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayModeStereoPropertiesNV(name: []const u8, value: *const vk.VkDisplayModeStereoPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayModeStereoPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hdmi3DSupported: u32 = {d},\n", .{value.hdmi3DSupported});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPlaneInfo2KHR(name: []const u8, value: *const vk.VkDisplayPlaneInfo2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPlaneInfo2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkDisplayModeKHR = {},\n", .{value.mode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    planeIndex: u32 = {d},\n", .{value.planeIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDisplayPlaneCapabilities2KHR(name: []const u8, value: *const vk.VkDisplayPlaneCapabilities2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDisplayPlaneCapabilities2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkDisplayPlaneCapabilitiesKHR("capabilities", &value.capabilities, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSharedPresentSurfaceCapabilitiesKHR(name: []const u8, value: *const vk.VkSharedPresentSurfaceCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSharedPresentSurfaceCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharedPresentSupportedUsageFlags: VkImageUsageFlags = {any},\n", .{value.sharedPresentSupportedUsageFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevice16BitStorageFeatures(name: []const u8, value: *const vk.VkPhysicalDevice16BitStorageFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevice16BitStorageFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageBuffer16BitAccess: u32 = {d},\n", .{value.storageBuffer16BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformAndStorageBuffer16BitAccess: u32 = {d},\n", .{value.uniformAndStorageBuffer16BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storagePushConstant16: u32 = {d},\n", .{value.storagePushConstant16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageInputOutput16: u32 = {d},\n", .{value.storageInputOutput16});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSubgroupProperties(name: []const u8, value: *const vk.VkPhysicalDeviceSubgroupProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSubgroupProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupSize: u32 = {d},\n", .{value.subgroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedStages: VkShaderStageFlags = {any},\n", .{value.supportedStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedOperations: VkSubgroupFeatureFlags = {any},\n", .{value.supportedOperations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    quadOperationsInAllStages: u32 = {d},\n", .{value.quadOperationsInAllStages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupExtendedTypes: u32 = {d},\n", .{value.shaderSubgroupExtendedTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferMemoryRequirementsInfo2(name: []const u8, value: *const vk.VkBufferMemoryRequirementsInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferMemoryRequirementsInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceBufferMemoryRequirements(name: []const u8, value: *const vk.VkDeviceBufferMemoryRequirements, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceBufferMemoryRequirements = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pCreateInfo) |v| {
        print_VkBufferCreateInfo("pCreateInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCreateInfo: *const VkBufferCreateInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageMemoryRequirementsInfo2(name: []const u8, value: *const vk.VkImageMemoryRequirementsInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageMemoryRequirementsInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageSparseMemoryRequirementsInfo2(name: []const u8, value: *const vk.VkImageSparseMemoryRequirementsInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageSparseMemoryRequirementsInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceImageMemoryRequirements(name: []const u8, value: *const vk.VkDeviceImageMemoryRequirements, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceImageMemoryRequirements = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pCreateInfo) |v| {
        print_VkImageCreateInfo("pCreateInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCreateInfo: *const VkImageCreateInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    planeAspect: VkImageAspectFlags = {any},\n", .{value.planeAspect});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryRequirements2(name: []const u8, value: *const vk.VkMemoryRequirements2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryRequirements2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkMemoryRequirements("memoryRequirements", &value.memoryRequirements, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSparseImageMemoryRequirements2(name: []const u8, value: *const vk.VkSparseImageMemoryRequirements2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSparseImageMemoryRequirements2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkSparseImageMemoryRequirements("memoryRequirements", &value.memoryRequirements, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePointClippingProperties(name: []const u8, value: *const vk.VkPhysicalDevicePointClippingProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePointClippingProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pointClippingBehavior: VkPointClippingBehavior = {t},\n", .{value.pointClippingBehavior});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryDedicatedRequirements(name: []const u8, value: *const vk.VkMemoryDedicatedRequirements, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryDedicatedRequirements = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersDedicatedAllocation: u32 = {d},\n", .{value.prefersDedicatedAllocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiresDedicatedAllocation: u32 = {d},\n", .{value.requiresDedicatedAllocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryDedicatedAllocateInfo(name: []const u8, value: *const vk.VkMemoryDedicatedAllocateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryDedicatedAllocateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewUsageCreateInfo(name: []const u8, value: *const vk.VkImageViewUsageCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewUsageCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkImageUsageFlags = {any},\n", .{value.usage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewSlicedCreateInfoEXT(name: []const u8, value: *const vk.VkImageViewSlicedCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewSlicedCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sliceOffset: u32 = {d},\n", .{value.sliceOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sliceCount: u32 = {d},\n", .{value.sliceCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineTessellationDomainOriginStateCreateInfo(name: []const u8, value: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineTessellationDomainOriginStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    domainOrigin: VkTessellationDomainOrigin = {t},\n", .{value.domainOrigin});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerYcbcrConversionInfo(name: []const u8, value: *const vk.VkSamplerYcbcrConversionInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerYcbcrConversionInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    conversion: VkSamplerYcbcrConversion = {},\n", .{value.conversion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerYcbcrConversionCreateInfo(name: []const u8, value: *const vk.VkSamplerYcbcrConversionCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerYcbcrConversionCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ycbcrModel: VkSamplerYcbcrModelConversion = {t},\n", .{value.ycbcrModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ycbcrRange: VkSamplerYcbcrRange = {t},\n", .{value.ycbcrRange});
    print_VkComponentMapping("components", &value.components, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    xChromaOffset: VkChromaLocation = {t},\n", .{value.xChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    yChromaOffset: VkChromaLocation = {t},\n", .{value.yChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    chromaFilter: VkFilter = {t},\n", .{value.chromaFilter});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    forceExplicitReconstruction: u32 = {d},\n", .{value.forceExplicitReconstruction});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindImagePlaneMemoryInfo(name: []const u8, value: *const vk.VkBindImagePlaneMemoryInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindImagePlaneMemoryInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    planeAspect: VkImageAspectFlags = {any},\n", .{value.planeAspect});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImagePlaneMemoryRequirementsInfo(name: []const u8, value: *const vk.VkImagePlaneMemoryRequirementsInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImagePlaneMemoryRequirementsInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    planeAspect: VkImageAspectFlags = {any},\n", .{value.planeAspect});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSamplerYcbcrConversionFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSamplerYcbcrConversionFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerYcbcrConversion: u32 = {d},\n", .{value.samplerYcbcrConversion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerYcbcrConversionImageFormatProperties(name: []const u8, value: *const vk.VkSamplerYcbcrConversionImageFormatProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerYcbcrConversionImageFormatProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    combinedImageSamplerDescriptorCount: u32 = {d},\n", .{value.combinedImageSamplerDescriptorCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTextureLODGatherFormatPropertiesAMD(name: []const u8, value: *const vk.VkTextureLODGatherFormatPropertiesAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTextureLODGatherFormatPropertiesAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportsTextureGatherLODBiasAMD: u32 = {d},\n", .{value.supportsTextureGatherLODBiasAMD});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkConditionalRenderingBeginInfoEXT(name: []const u8, value: *const vk.VkConditionalRenderingBeginInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkConditionalRenderingBeginInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkConditionalRenderingFlagsEXT = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkProtectedSubmitInfo(name: []const u8, value: *const vk.VkProtectedSubmitInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkProtectedSubmitInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    protectedSubmit: u32 = {d},\n", .{value.protectedSubmit});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceProtectedMemoryFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceProtectedMemoryFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceProtectedMemoryFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    protectedMemory: u32 = {d},\n", .{value.protectedMemory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceProtectedMemoryProperties(name: []const u8, value: *const vk.VkPhysicalDeviceProtectedMemoryProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceProtectedMemoryProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    protectedNoFault: u32 = {d},\n", .{value.protectedNoFault});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceQueueInfo2(name: []const u8, value: *const vk.VkDeviceQueueInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceQueueInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDeviceQueueCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndex: u32 = {d},\n", .{value.queueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueIndex: u32 = {d},\n", .{value.queueIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCoverageToColorStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineCoverageToColorStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCoverageToColorStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCoverageToColorStateCreateFlagsNV = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageToColorEnable: u32 = {d},\n", .{value.coverageToColorEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageToColorLocation: u32 = {d},\n", .{value.coverageToColorLocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSamplerFilterMinmaxProperties(name: []const u8, value: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSamplerFilterMinmaxProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filterMinmaxSingleComponentFormats: u32 = {d},\n", .{value.filterMinmaxSingleComponentFormats});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filterMinmaxImageComponentMapping: u32 = {d},\n", .{value.filterMinmaxImageComponentMapping});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSampleLocationEXT(name: []const u8, value: *const vk.VkSampleLocationEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSampleLocationEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    x: f32 = {d},\n", .{value.x});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    y: f32 = {d},\n", .{value.y});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSampleLocationsInfoEXT(name: []const u8, value: *const vk.VkSampleLocationsInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSampleLocationsInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleLocationsPerPixel: VkSampleCountFlags = {any},\n", .{value.sampleLocationsPerPixel});
    print_VkExtent2D("sampleLocationGridSize", &value.sampleLocationGridSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleLocationsCount: u32 = {d},\n", .{value.sampleLocationsCount});
    if (value.pSampleLocations) |v| {
        for (v[0..value.sampleLocationsCount]) |*vv| {
            print_VkSampleLocationEXT("pSampleLocations", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSampleLocations: [*]const VkSampleLocationEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentSampleLocationsEXT(name: []const u8, value: *const vk.VkAttachmentSampleLocationsEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentSampleLocationsEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentIndex: u32 = {d},\n", .{value.attachmentIndex});
    print_VkSampleLocationsInfoEXT("sampleLocationsInfo", &value.sampleLocationsInfo, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassSampleLocationsEXT(name: []const u8, value: *const vk.VkSubpassSampleLocationsEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassSampleLocationsEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassIndex: u32 = {d},\n", .{value.subpassIndex});
    print_VkSampleLocationsInfoEXT("sampleLocationsInfo", &value.sampleLocationsInfo, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassSampleLocationsBeginInfoEXT(name: []const u8, value: *const vk.VkRenderPassSampleLocationsBeginInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassSampleLocationsBeginInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentInitialSampleLocationsCount: u32 = {d},\n", .{value.attachmentInitialSampleLocationsCount});
    if (value.pAttachmentInitialSampleLocations) |v| {
        for (v[0..value.attachmentInitialSampleLocationsCount]) |*vv| {
            print_VkAttachmentSampleLocationsEXT("pAttachmentInitialSampleLocations", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttachmentInitialSampleLocations: [*]const VkAttachmentSampleLocationsEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    postSubpassSampleLocationsCount: u32 = {d},\n", .{value.postSubpassSampleLocationsCount});
    if (value.pPostSubpassSampleLocations) |v| {
        for (v[0..value.postSubpassSampleLocationsCount]) |*vv| {
            print_VkSubpassSampleLocationsEXT("pPostSubpassSampleLocations", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPostSubpassSampleLocations: [*]const VkSubpassSampleLocationsEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineSampleLocationsStateCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineSampleLocationsStateCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleLocationsEnable: u32 = {d},\n", .{value.sampleLocationsEnable});
    print_VkSampleLocationsInfoEXT("sampleLocationsInfo", &value.sampleLocationsInfo, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSampleLocationsPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSampleLocationsPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleLocationSampleCounts: VkSampleCountFlags = {any},\n", .{value.sampleLocationSampleCounts});
    print_VkExtent2D("maxSampleLocationGridSize", &value.maxSampleLocationGridSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleLocationCoordinateRange: [2]f32 = {any},\n", .{value.sampleLocationCoordinateRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleLocationSubPixelBits: u32 = {d},\n", .{value.sampleLocationSubPixelBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    variableSampleLocations: u32 = {d},\n", .{value.variableSampleLocations});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMultisamplePropertiesEXT(name: []const u8, value: *const vk.VkMultisamplePropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMultisamplePropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("maxSampleLocationGridSize", &value.maxSampleLocationGridSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerReductionModeCreateInfo(name: []const u8, value: *const vk.VkSamplerReductionModeCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerReductionModeCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    reductionMode: VkSamplerReductionMode = {t},\n", .{value.reductionMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendCoherentOperations: u32 = {d},\n", .{value.advancedBlendCoherentOperations});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultiDrawFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultiDrawFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiDraw: u32 = {d},\n", .{value.multiDraw});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendMaxColorAttachments: u32 = {d},\n", .{value.advancedBlendMaxColorAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendIndependentBlend: u32 = {d},\n", .{value.advancedBlendIndependentBlend});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendNonPremultipliedSrcColor: u32 = {d},\n", .{value.advancedBlendNonPremultipliedSrcColor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendNonPremultipliedDstColor: u32 = {d},\n", .{value.advancedBlendNonPremultipliedDstColor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendCorrelatedOverlap: u32 = {d},\n", .{value.advancedBlendCorrelatedOverlap});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendAllOperations: u32 = {d},\n", .{value.advancedBlendAllOperations});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineColorBlendAdvancedStateCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineColorBlendAdvancedStateCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcPremultiplied: u32 = {d},\n", .{value.srcPremultiplied});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstPremultiplied: u32 = {d},\n", .{value.dstPremultiplied});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blendOverlap: VkBlendOverlapEXT = {t},\n", .{value.blendOverlap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceInlineUniformBlockFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceInlineUniformBlockFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inlineUniformBlock: u32 = {d},\n", .{value.inlineUniformBlock});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingInlineUniformBlockUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingInlineUniformBlockUpdateAfterBind});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceInlineUniformBlockProperties(name: []const u8, value: *const vk.VkPhysicalDeviceInlineUniformBlockProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceInlineUniformBlockProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInlineUniformBlockSize: u32 = {d},\n", .{value.maxInlineUniformBlockSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorInlineUniformBlocks: u32 = {d},\n", .{value.maxPerStageDescriptorInlineUniformBlocks});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetInlineUniformBlocks: u32 = {d},\n", .{value.maxDescriptorSetInlineUniformBlocks});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindInlineUniformBlocks});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteDescriptorSetInlineUniformBlock(name: []const u8, value: *const vk.VkWriteDescriptorSetInlineUniformBlock, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteDescriptorSetInlineUniformBlock = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u32 = {d},\n", .{value.dataSize});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorPoolInlineUniformBlockCreateInfo(name: []const u8, value: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorPoolInlineUniformBlockCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInlineUniformBlockBindings: u32 = {d},\n", .{value.maxInlineUniformBlockBindings});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCoverageModulationStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineCoverageModulationStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCoverageModulationStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCoverageModulationStateCreateFlagsNV = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageModulationMode: VkCoverageModulationModeNV = {t},\n", .{value.coverageModulationMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageModulationTableEnable: u32 = {d},\n", .{value.coverageModulationTableEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageModulationTableCount: u32 = {d},\n", .{value.coverageModulationTableCount});
    if (value.pCoverageModulationTable) |v| {
        for (v[0..value.coverageModulationTableCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCoverageModulationTable: [*]const f32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCoverageModulationTable: [*]const f32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageFormatListCreateInfo(name: []const u8, value: *const vk.VkImageFormatListCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageFormatListCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewFormatCount: u32 = {d},\n", .{value.viewFormatCount});
    if (value.pViewFormats) |v| {
        for (v[0..value.viewFormatCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pViewFormats: [*]const VkFormat = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewFormats: [*]const VkFormat = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkValidationCacheCreateInfoEXT(name: []const u8, value: *const vk.VkValidationCacheCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkValidationCacheCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkValidationCacheCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialDataSize: u64 = {d},\n", .{value.initialDataSize});
    if (value.pInitialData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInitialData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInitialData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkShaderModuleValidationCacheCreateInfoEXT(name: []const u8, value: *const vk.VkShaderModuleValidationCacheCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkShaderModuleValidationCacheCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    validationCache: VkValidationCacheEXT = {},\n", .{value.validationCache});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance3Properties(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance3Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance3Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerSetDescriptors: u32 = {d},\n", .{value.maxPerSetDescriptors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMemoryAllocationSize: u64 = {d},\n", .{value.maxMemoryAllocationSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance4Features(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance4Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance4Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance4: u32 = {d},\n", .{value.maintenance4});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance4Properties(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance4Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance4Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBufferSize: u64 = {d},\n", .{value.maxBufferSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance5Features(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance5Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance5Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance5: u32 = {d},\n", .{value.maintenance5});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance5Properties(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance5Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance5Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    earlyFragmentMultisampleCoverageAfterSampleCounting: u32 = {d},\n", .{value.earlyFragmentMultisampleCoverageAfterSampleCounting});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    earlyFragmentSampleMaskTestBeforeSampleCounting: u32 = {d},\n", .{value.earlyFragmentSampleMaskTestBeforeSampleCounting});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthStencilSwizzleOneSupport: u32 = {d},\n", .{value.depthStencilSwizzleOneSupport});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    polygonModePointSize: u32 = {d},\n", .{value.polygonModePointSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nonStrictSinglePixelWideLinesUseParallelogram: u32 = {d},\n", .{value.nonStrictSinglePixelWideLinesUseParallelogram});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nonStrictWideLinesUseParallelogram: u32 = {d},\n", .{value.nonStrictWideLinesUseParallelogram});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance6Features(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance6Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance6Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance6: u32 = {d},\n", .{value.maintenance6});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance6Properties(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance6Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance6Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockTexelViewCompatibleMultipleLayers: u32 = {d},\n", .{value.blockTexelViewCompatibleMultipleLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCombinedImageSamplerDescriptorCount: u32 = {d},\n", .{value.maxCombinedImageSamplerDescriptorCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateClampCombinerInputs: u32 = {d},\n", .{value.fragmentShadingRateClampCombinerInputs});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance7FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance7FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance7: u32 = {d},\n", .{value.maintenance7});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance7PropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance7PropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustFragmentShadingRateAttachmentAccess: u32 = {d},\n", .{value.robustFragmentShadingRateAttachmentAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    separateDepthStencilAttachmentAccess: u32 = {d},\n", .{value.separateDepthStencilAttachmentAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetTotalUniformBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetTotalUniformBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetTotalStorageBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetTotalStorageBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetTotalBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetTotalBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLayeredApiPropertiesListKHR(name: []const u8, value: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLayeredApiPropertiesListKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layeredApiCount: u32 = {d},\n", .{value.layeredApiCount});
    if (value.pLayeredApis) |v| {
        for (v[0..value.layeredApiCount]) |*vv| {
            print_VkPhysicalDeviceLayeredApiPropertiesKHR("pLayeredApis", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLayeredApis: [*]VkPhysicalDeviceLayeredApiPropertiesKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLayeredApiPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLayeredApiPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorID: u32 = {d},\n", .{value.vendorID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceID: u32 = {d},\n", .{value.deviceID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layeredAPI: VkPhysicalDeviceLayeredApiKHR = {t},\n", .{value.layeredAPI});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceName: [VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8 = {any},\n", .{value.deviceName});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkPhysicalDeviceProperties2("properties", &value.properties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance8FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance8FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance8: u32 = {d},\n", .{value.maintenance8});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance9FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance9FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance9: u32 = {d},\n", .{value.maintenance9});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance9PropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance9PropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image2DViewOf3DSparse: u32 = {d},\n", .{value.image2DViewOf3DSparse});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultVertexAttributeValue: VkDefaultVertexAttributeValueKHR = {t},\n", .{value.defaultVertexAttributeValue});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance10PropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance10PropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance10PropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rgba4OpaqueBlackSwizzled: u32 = {d},\n", .{value.rgba4OpaqueBlackSwizzled});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resolveSrgbFormatAppliesTransferFunction: u32 = {d},\n", .{value.resolveSrgbFormatAppliesTransferFunction});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resolveSrgbFormatSupportsTransferFunctionControl: u32 = {d},\n", .{value.resolveSrgbFormatSupportsTransferFunctionControl});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMaintenance10FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceMaintenance10FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMaintenance10FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance10: u32 = {d},\n", .{value.maintenance10});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyOwnershipTransferPropertiesKHR(name: []const u8, value: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyOwnershipTransferPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalImageTransferToQueueFamilies: u32 = {d},\n", .{value.optimalImageTransferToQueueFamilies});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingAreaInfo(name: []const u8, value: *const vk.VkRenderingAreaInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingAreaInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewMask: u32 = {d},\n", .{value.viewMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachmentFormats) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorAttachmentFormats: [*]const VkFormat = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachmentFormats: [*]const VkFormat = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthAttachmentFormat: VkFormat = {t},\n", .{value.depthAttachmentFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilAttachmentFormat: VkFormat = {t},\n", .{value.stencilAttachmentFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetLayoutSupport(name: []const u8, value: *const vk.VkDescriptorSetLayoutSupport, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetLayoutSupport = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supported: u32 = {d},\n", .{value.supported});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderDrawParametersFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderDrawParametersFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDrawParameters: u32 = {d},\n", .{value.shaderDrawParameters});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderFloat16Int8Features(name: []const u8, value: *const vk.VkPhysicalDeviceShaderFloat16Int8Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderFloat16Int8Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloat16: u32 = {d},\n", .{value.shaderFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInt8: u32 = {d},\n", .{value.shaderInt8});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFloatControlsProperties(name: []const u8, value: *const vk.VkPhysicalDeviceFloatControlsProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFloatControlsProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    denormBehaviorIndependence: VkShaderFloatControlsIndependence = {t},\n", .{value.denormBehaviorIndependence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    roundingModeIndependence: VkShaderFloatControlsIndependence = {t},\n", .{value.roundingModeIndependence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSignedZeroInfNanPreserveFloat16: u32 = {d},\n", .{value.shaderSignedZeroInfNanPreserveFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSignedZeroInfNanPreserveFloat32: u32 = {d},\n", .{value.shaderSignedZeroInfNanPreserveFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSignedZeroInfNanPreserveFloat64: u32 = {d},\n", .{value.shaderSignedZeroInfNanPreserveFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormPreserveFloat16: u32 = {d},\n", .{value.shaderDenormPreserveFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormPreserveFloat32: u32 = {d},\n", .{value.shaderDenormPreserveFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormPreserveFloat64: u32 = {d},\n", .{value.shaderDenormPreserveFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormFlushToZeroFloat16: u32 = {d},\n", .{value.shaderDenormFlushToZeroFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormFlushToZeroFloat32: u32 = {d},\n", .{value.shaderDenormFlushToZeroFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormFlushToZeroFloat64: u32 = {d},\n", .{value.shaderDenormFlushToZeroFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTEFloat16: u32 = {d},\n", .{value.shaderRoundingModeRTEFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTEFloat32: u32 = {d},\n", .{value.shaderRoundingModeRTEFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTEFloat64: u32 = {d},\n", .{value.shaderRoundingModeRTEFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTZFloat16: u32 = {d},\n", .{value.shaderRoundingModeRTZFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTZFloat32: u32 = {d},\n", .{value.shaderRoundingModeRTZFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTZFloat64: u32 = {d},\n", .{value.shaderRoundingModeRTZFloat64});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceHostQueryResetFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceHostQueryResetFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceHostQueryResetFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hostQueryReset: u32 = {d},\n", .{value.hostQueryReset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkShaderResourceUsageAMD(name: []const u8, value: *const vk.VkShaderResourceUsageAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkShaderResourceUsageAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numUsedVgprs: u32 = {d},\n", .{value.numUsedVgprs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numUsedSgprs: u32 = {d},\n", .{value.numUsedSgprs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ldsSizePerLocalWorkGroup: u32 = {d},\n", .{value.ldsSizePerLocalWorkGroup});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ldsUsageSizeInBytes: u64 = {d},\n", .{value.ldsUsageSizeInBytes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scratchMemUsageInBytes: u64 = {d},\n", .{value.scratchMemUsageInBytes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkShaderStatisticsInfoAMD(name: []const u8, value: *const vk.VkShaderStatisticsInfoAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkShaderStatisticsInfoAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStageMask: VkShaderStageFlags = {any},\n", .{value.shaderStageMask});
    print_VkShaderResourceUsageAMD("resourceUsage", &value.resourceUsage, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numPhysicalVgprs: u32 = {d},\n", .{value.numPhysicalVgprs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numPhysicalSgprs: u32 = {d},\n", .{value.numPhysicalSgprs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numAvailableVgprs: u32 = {d},\n", .{value.numAvailableVgprs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numAvailableSgprs: u32 = {d},\n", .{value.numAvailableSgprs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeWorkGroupSize: [3]u32 = {any},\n", .{value.computeWorkGroupSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceQueueGlobalPriorityCreateInfo(name: []const u8, value: *const vk.VkDeviceQueueGlobalPriorityCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceQueueGlobalPriorityCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    globalPriority: VkQueueGlobalPriority = {t},\n", .{value.globalPriority});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceGlobalPriorityQueryFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceGlobalPriorityQueryFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    globalPriorityQuery: u32 = {d},\n", .{value.globalPriorityQuery});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyGlobalPriorityProperties(name: []const u8, value: *const vk.VkQueueFamilyGlobalPriorityProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyGlobalPriorityProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    priorityCount: u32 = {d},\n", .{value.priorityCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    priorities: [VK_MAX_GLOBAL_PRIORITY_SIZE]VkQueueGlobalPriority = {any},\n", .{value.priorities});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugUtilsObjectNameInfoEXT(name: []const u8, value: *const vk.VkDebugUtilsObjectNameInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugUtilsObjectNameInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectType: VkObjectType = {t},\n", .{value.objectType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectHandle: u64 = {d},\n", .{value.objectHandle});
    if (value.pObjectName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pObjectName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugUtilsObjectTagInfoEXT(name: []const u8, value: *const vk.VkDebugUtilsObjectTagInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugUtilsObjectTagInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectType: VkObjectType = {t},\n", .{value.objectType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectHandle: u64 = {d},\n", .{value.objectHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tagName: u64 = {d},\n", .{value.tagName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tagSize: u64 = {d},\n", .{value.tagSize});
    if (value.pTag) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTag: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTag: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugUtilsLabelEXT(name: []const u8, value: *const vk.VkDebugUtilsLabelEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugUtilsLabelEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pLabelName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLabelName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    color: [4]f32 = {any},\n", .{value.color});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugUtilsMessengerCreateInfoEXT(name: []const u8, value: *const vk.VkDebugUtilsMessengerCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugUtilsMessengerCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDebugUtilsMessengerCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT = {any},\n", .{value.messageSeverity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    messageType: VkDebugUtilsMessageTypeFlagsEXT = {any},\n", .{value.messageType});
    if (value.pfnUserCallback) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnUserCallback: *const vkDebugUtilsMessengerCallbackEXT = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnUserCallback: *const vkDebugUtilsMessengerCallbackEXT = null,\n", .{});
    }
    if (value.pUserData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDebugUtilsMessengerCallbackDataEXT(name: []const u8, value: *const vk.VkDebugUtilsMessengerCallbackDataEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDebugUtilsMessengerCallbackDataEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDebugUtilsMessengerCallbackDataFlagsEXT = {any},\n", .{value.flags});
    if (value.pMessageIdName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pMessageIdName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    messageIdNumber: i32 = {d},\n", .{value.messageIdNumber});
    if (value.pMessage) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pMessage: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueLabelCount: u32 = {d},\n", .{value.queueLabelCount});
    if (value.pQueueLabels) |v| {
        for (v[0..value.queueLabelCount]) |*vv| {
            print_VkDebugUtilsLabelEXT("pQueueLabels", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueueLabels: [*]const VkDebugUtilsLabelEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cmdBufLabelCount: u32 = {d},\n", .{value.cmdBufLabelCount});
    if (value.pCmdBufLabels) |v| {
        for (v[0..value.cmdBufLabelCount]) |*vv| {
            print_VkDebugUtilsLabelEXT("pCmdBufLabels", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCmdBufLabels: [*]const VkDebugUtilsLabelEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectCount: u32 = {d},\n", .{value.objectCount});
    if (value.pObjects) |v| {
        for (v[0..value.objectCount]) |*vv| {
            print_VkDebugUtilsObjectNameInfoEXT("pObjects", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pObjects: [*]const VkDebugUtilsObjectNameInfoEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceMemoryReport: u32 = {d},\n", .{value.deviceMemoryReport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceDeviceMemoryReportCreateInfoEXT(name: []const u8, value: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceDeviceMemoryReportCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDeviceMemoryReportFlagsEXT = {any},\n", .{value.flags});
    if (value.pfnUserCallback) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnUserCallback: *const vkDeviceMemoryReportCallbackEXT = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnUserCallback: *const vkDeviceMemoryReportCallbackEXT = null,\n", .{});
    }
    if (value.pUserData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceMemoryReportCallbackDataEXT(name: []const u8, value: *const vk.VkDeviceMemoryReportCallbackDataEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceMemoryReportCallbackDataEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDeviceMemoryReportFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkDeviceMemoryReportEventTypeEXT = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryObjectId: u64 = {d},\n", .{value.memoryObjectId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectType: VkObjectType = {t},\n", .{value.objectType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectHandle: u64 = {d},\n", .{value.objectHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    heapIndex: u32 = {d},\n", .{value.heapIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemoryHostPointerInfoEXT(name: []const u8, value: *const vk.VkImportMemoryHostPointerInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemoryHostPointerInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    if (value.pHostPointer) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pHostPointer: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pHostPointer: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryHostPointerPropertiesEXT(name: []const u8, value: *const vk.VkMemoryHostPointerPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryHostPointerPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalMemoryHostPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minImportedHostPointerAlignment: u64 = {d},\n", .{value.minImportedHostPointerAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceConservativeRasterizationPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveOverestimationSize: f32 = {d},\n", .{value.primitiveOverestimationSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExtraPrimitiveOverestimationSize: f32 = {d},\n", .{value.maxExtraPrimitiveOverestimationSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extraPrimitiveOverestimationSizeGranularity: f32 = {d},\n", .{value.extraPrimitiveOverestimationSizeGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveUnderestimation: u32 = {d},\n", .{value.primitiveUnderestimation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    conservativePointAndLineRasterization: u32 = {d},\n", .{value.conservativePointAndLineRasterization});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    degenerateTrianglesRasterized: u32 = {d},\n", .{value.degenerateTrianglesRasterized});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    degenerateLinesRasterized: u32 = {d},\n", .{value.degenerateLinesRasterized});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fullyCoveredFragmentShaderInputVariable: u32 = {d},\n", .{value.fullyCoveredFragmentShaderInputVariable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    conservativeRasterizationPostDepthCoverage: u32 = {d},\n", .{value.conservativeRasterizationPostDepthCoverage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCalibratedTimestampInfoKHR(name: []const u8, value: *const vk.VkCalibratedTimestampInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCalibratedTimestampInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeDomain: VkTimeDomainKHR = {t},\n", .{value.timeDomain});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderCorePropertiesAMD(name: []const u8, value: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderCorePropertiesAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderEngineCount: u32 = {d},\n", .{value.shaderEngineCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderArraysPerEngineCount: u32 = {d},\n", .{value.shaderArraysPerEngineCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeUnitsPerShaderArray: u32 = {d},\n", .{value.computeUnitsPerShaderArray});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    simdPerComputeUnit: u32 = {d},\n", .{value.simdPerComputeUnit});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    wavefrontsPerSimd: u32 = {d},\n", .{value.wavefrontsPerSimd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    wavefrontSize: u32 = {d},\n", .{value.wavefrontSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sgprsPerSimd: u32 = {d},\n", .{value.sgprsPerSimd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minSgprAllocation: u32 = {d},\n", .{value.minSgprAllocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSgprAllocation: u32 = {d},\n", .{value.maxSgprAllocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sgprAllocationGranularity: u32 = {d},\n", .{value.sgprAllocationGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vgprsPerSimd: u32 = {d},\n", .{value.vgprsPerSimd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minVgprAllocation: u32 = {d},\n", .{value.minVgprAllocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVgprAllocation: u32 = {d},\n", .{value.maxVgprAllocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vgprAllocationGranularity: u32 = {d},\n", .{value.vgprAllocationGranularity});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderCoreProperties2AMD(name: []const u8, value: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderCoreProperties2AMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD = {any},\n", .{value.shaderCoreFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    activeComputeUnitCount: u32 = {d},\n", .{value.activeComputeUnitCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRasterizationConservativeStateCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRasterizationConservativeStateCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    conservativeRasterizationMode: VkConservativeRasterizationModeEXT = {t},\n", .{value.conservativeRasterizationMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extraPrimitiveOverestimationSize: f32 = {d},\n", .{value.extraPrimitiveOverestimationSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorIndexingFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorIndexingFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInputAttachmentArrayDynamicIndexing: u32 = {d},\n", .{value.shaderInputAttachmentArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformTexelBufferArrayDynamicIndexing: u32 = {d},\n", .{value.shaderUniformTexelBufferArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageTexelBufferArrayDynamicIndexing: u32 = {d},\n", .{value.shaderStorageTexelBufferArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderUniformBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSampledImageArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderSampledImageArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderStorageBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderStorageImageArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInputAttachmentArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderInputAttachmentArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformTexelBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderUniformTexelBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageTexelBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderStorageTexelBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingUniformBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingUniformBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingSampledImageUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingSampledImageUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingStorageImageUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingStorageImageUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingStorageBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingStorageBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingUniformTexelBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingUniformTexelBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingStorageTexelBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingStorageTexelBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingUpdateUnusedWhilePending: u32 = {d},\n", .{value.descriptorBindingUpdateUnusedWhilePending});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingPartiallyBound: u32 = {d},\n", .{value.descriptorBindingPartiallyBound});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingVariableDescriptorCount: u32 = {d},\n", .{value.descriptorBindingVariableDescriptorCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    runtimeDescriptorArray: u32 = {d},\n", .{value.runtimeDescriptorArray});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorIndexingProperties(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorIndexingProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorIndexingProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxUpdateAfterBindDescriptorsInAllPools: u32 = {d},\n", .{value.maxUpdateAfterBindDescriptorsInAllPools});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformBufferArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderUniformBufferArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSampledImageArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderSampledImageArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageBufferArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderStorageBufferArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderStorageImageArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInputAttachmentArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderInputAttachmentArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustBufferAccessUpdateAfterBind: u32 = {d},\n", .{value.robustBufferAccessUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    quadDivergentImplicitLod: u32 = {d},\n", .{value.quadDivergentImplicitLod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindSamplers: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindSampledImages: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindSampledImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindStorageImages: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindStorageImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindInputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageUpdateAfterBindResources: u32 = {d},\n", .{value.maxPerStageUpdateAfterBindResources});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindSamplers: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindUniformBuffers: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindStorageBuffers: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindSampledImages: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindSampledImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindStorageImages: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindStorageImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindInputAttachments: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindInputAttachments});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetLayoutBindingFlagsCreateInfo(name: []const u8, value: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetLayoutBindingFlagsCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindingCount: u32 = {d},\n", .{value.bindingCount});
    if (value.pBindingFlags) |v| {
        for (v[0..value.bindingCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pBindingFlags: [*]const VkDescriptorBindingFlags = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBindingFlags: [*]const VkDescriptorBindingFlags = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetVariableDescriptorCountAllocateInfo(name: []const u8, value: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetVariableDescriptorCountAllocateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetCount: u32 = {d},\n", .{value.descriptorSetCount});
    if (value.pDescriptorCounts) |v| {
        for (v[0..value.descriptorSetCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDescriptorCounts: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDescriptorCounts: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetVariableDescriptorCountLayoutSupport(name: []const u8, value: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetVariableDescriptorCountLayoutSupport = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVariableDescriptorCount: u32 = {d},\n", .{value.maxVariableDescriptorCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentDescription2(name: []const u8, value: *const vk.VkAttachmentDescription2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentDescription2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkAttachmentDescriptionFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samples: VkSampleCountFlags = {any},\n", .{value.samples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    loadOp: VkAttachmentLoadOp = {t},\n", .{value.loadOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storeOp: VkAttachmentStoreOp = {t},\n", .{value.storeOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilLoadOp: VkAttachmentLoadOp = {t},\n", .{value.stencilLoadOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilStoreOp: VkAttachmentStoreOp = {t},\n", .{value.stencilStoreOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialLayout: VkImageLayout = {t},\n", .{value.initialLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    finalLayout: VkImageLayout = {t},\n", .{value.finalLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentReference2(name: []const u8, value: *const vk.VkAttachmentReference2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentReference2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachment: u32 = {d},\n", .{value.attachment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkImageLayout = {t},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aspectMask: VkImageAspectFlags = {any},\n", .{value.aspectMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassDescription2(name: []const u8, value: *const vk.VkSubpassDescription2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassDescription2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSubpassDescriptionFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBindPoint: VkPipelineBindPoint = {t},\n", .{value.pipelineBindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewMask: u32 = {d},\n", .{value.viewMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputAttachmentCount: u32 = {d},\n", .{value.inputAttachmentCount});
    if (value.pInputAttachments) |v| {
        for (v[0..value.inputAttachmentCount]) |*vv| {
            print_VkAttachmentReference2("pInputAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInputAttachments: [*]const VkAttachmentReference2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachments) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            print_VkAttachmentReference2("pColorAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachments: [*]const VkAttachmentReference2 = null,\n", .{});
    }
    if (value.pResolveAttachments) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            print_VkAttachmentReference2("pResolveAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pResolveAttachments: [*]const VkAttachmentReference2 = null,\n", .{});
    }
    if (value.pDepthStencilAttachment) |v| {
        print_VkAttachmentReference2("pDepthStencilAttachment", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthStencilAttachment: *const VkAttachmentReference2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preserveAttachmentCount: u32 = {d},\n", .{value.preserveAttachmentCount});
    if (value.pPreserveAttachments) |v| {
        for (v[0..value.preserveAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPreserveAttachments: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPreserveAttachments: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassDependency2(name: []const u8, value: *const vk.VkSubpassDependency2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassDependency2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcSubpass: u32 = {d},\n", .{value.srcSubpass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstSubpass: u32 = {d},\n", .{value.dstSubpass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcStageMask: VkPipelineStageFlags = {any},\n", .{value.srcStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstStageMask: VkPipelineStageFlags = {any},\n", .{value.dstStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags = {any},\n", .{value.dstAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dependencyFlags: VkDependencyFlags = {any},\n", .{value.dependencyFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewOffset: i32 = {d},\n", .{value.viewOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassCreateInfo2(name: []const u8, value: *const vk.VkRenderPassCreateInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassCreateInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkRenderPassCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentCount: u32 = {d},\n", .{value.attachmentCount});
    if (value.pAttachments) |v| {
        for (v[0..value.attachmentCount]) |*vv| {
            print_VkAttachmentDescription2("pAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttachments: [*]const VkAttachmentDescription2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassCount: u32 = {d},\n", .{value.subpassCount});
    if (value.pSubpasses) |v| {
        for (v[0..value.subpassCount]) |*vv| {
            print_VkSubpassDescription2("pSubpasses", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSubpasses: [*]const VkSubpassDescription2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dependencyCount: u32 = {d},\n", .{value.dependencyCount});
    if (value.pDependencies) |v| {
        for (v[0..value.dependencyCount]) |*vv| {
            print_VkSubpassDependency2("pDependencies", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDependencies: [*]const VkSubpassDependency2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    correlatedViewMaskCount: u32 = {d},\n", .{value.correlatedViewMaskCount});
    if (value.pCorrelatedViewMasks) |v| {
        for (v[0..value.correlatedViewMaskCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCorrelatedViewMasks: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCorrelatedViewMasks: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassBeginInfo(name: []const u8, value: *const vk.VkSubpassBeginInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassBeginInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    contents: VkSubpassContents = {t},\n", .{value.contents});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassEndInfo(name: []const u8, value: *const vk.VkSubpassEndInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassEndInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTimelineSemaphoreFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTimelineSemaphoreFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timelineSemaphore: u32 = {d},\n", .{value.timelineSemaphore});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTimelineSemaphoreProperties(name: []const u8, value: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTimelineSemaphoreProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTimelineSemaphoreValueDifference: u64 = {d},\n", .{value.maxTimelineSemaphoreValueDifference});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreTypeCreateInfo(name: []const u8, value: *const vk.VkSemaphoreTypeCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreTypeCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphoreType: VkSemaphoreType = {t},\n", .{value.semaphoreType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialValue: u64 = {d},\n", .{value.initialValue});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTimelineSemaphoreSubmitInfo(name: []const u8, value: *const vk.VkTimelineSemaphoreSubmitInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTimelineSemaphoreSubmitInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    waitSemaphoreValueCount: u32 = {d},\n", .{value.waitSemaphoreValueCount});
    if (value.pWaitSemaphoreValues) |v| {
        for (v[0..value.waitSemaphoreValueCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pWaitSemaphoreValues: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitSemaphoreValues: [*]const u64 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    signalSemaphoreValueCount: u32 = {d},\n", .{value.signalSemaphoreValueCount});
    if (value.pSignalSemaphoreValues) |v| {
        for (v[0..value.signalSemaphoreValueCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSignalSemaphoreValues: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSignalSemaphoreValues: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreWaitInfo(name: []const u8, value: *const vk.VkSemaphoreWaitInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreWaitInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSemaphoreWaitFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphoreCount: u32 = {d},\n", .{value.semaphoreCount});
    if (value.pSemaphores) |v| {
        for (v[0..value.semaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSemaphores: [*]const VkSemaphore = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSemaphores: [*]const VkSemaphore = null,\n", .{});
    }
    if (value.pValues) |v| {
        for (v[0..value.semaphoreCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pValues: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pValues: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreSignalInfo(name: []const u8, value: *const vk.VkSemaphoreSignalInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreSignalInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    value: u64 = {d},\n", .{value.value});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVertexInputBindingDivisorDescription(name: []const u8, value: *const vk.VkVertexInputBindingDivisorDescription, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVertexInputBindingDivisorDescription = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    divisor: u32 = {d},\n", .{value.divisor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineVertexInputDivisorStateCreateInfo(name: []const u8, value: *const vk.VkPipelineVertexInputDivisorStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineVertexInputDivisorStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBindingDivisorCount: u32 = {d},\n", .{value.vertexBindingDivisorCount});
    if (value.pVertexBindingDivisors) |v| {
        for (v[0..value.vertexBindingDivisorCount]) |*vv| {
            print_VkVertexInputBindingDivisorDescription("pVertexBindingDivisors", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVertexBindingDivisors: [*]const VkVertexInputBindingDivisorDescription = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexAttribDivisor: u32 = {d},\n", .{value.maxVertexAttribDivisor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVertexAttributeDivisorProperties(name: []const u8, value: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVertexAttributeDivisorProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexAttribDivisor: u32 = {d},\n", .{value.maxVertexAttribDivisor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportsNonZeroFirstInstance: u32 = {d},\n", .{value.supportsNonZeroFirstInstance});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePCIBusInfoPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePCIBusInfoPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pciDomain: u32 = {d},\n", .{value.pciDomain});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pciBus: u32 = {d},\n", .{value.pciBus});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pciDevice: u32 = {d},\n", .{value.pciDevice});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pciFunction: u32 = {d},\n", .{value.pciFunction});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportAndroidHardwareBufferInfoANDROID(name: []const u8, value: *const vk.VkImportAndroidHardwareBufferInfoANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportAndroidHardwareBufferInfoANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.buffer) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    buffer: *AHardwareBuffer = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    buffer: *AHardwareBuffer = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAndroidHardwareBufferUsageANDROID(name: []const u8, value: *const vk.VkAndroidHardwareBufferUsageANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAndroidHardwareBufferUsageANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    androidHardwareBufferUsage: u64 = {d},\n", .{value.androidHardwareBufferUsage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAndroidHardwareBufferPropertiesANDROID(name: []const u8, value: *const vk.VkAndroidHardwareBufferPropertiesANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAndroidHardwareBufferPropertiesANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    allocationSize: u64 = {d},\n", .{value.allocationSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetAndroidHardwareBufferInfoANDROID(name: []const u8, value: *const vk.VkMemoryGetAndroidHardwareBufferInfoANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetAndroidHardwareBufferInfoANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAndroidHardwareBufferFormatPropertiesANDROID(name: []const u8, value: *const vk.VkAndroidHardwareBufferFormatPropertiesANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAndroidHardwareBufferFormatPropertiesANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormat: u64 = {d},\n", .{value.externalFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatFeatures: VkFormatFeatureFlags = {any},\n", .{value.formatFeatures});
    print_VkComponentMapping("samplerYcbcrConversionComponents", &value.samplerYcbcrConversionComponents, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = {t},\n", .{value.suggestedYcbcrModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrRange: VkSamplerYcbcrRange = {t},\n", .{value.suggestedYcbcrRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedXChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedXChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedYChromaOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferInheritanceConditionalRenderingInfoEXT(name: []const u8, value: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferInheritanceConditionalRenderingInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    conditionalRenderingEnable: u32 = {d},\n", .{value.conditionalRenderingEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalFormatANDROID(name: []const u8, value: *const vk.VkExternalFormatANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalFormatANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormat: u64 = {d},\n", .{value.externalFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevice8BitStorageFeatures(name: []const u8, value: *const vk.VkPhysicalDevice8BitStorageFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevice8BitStorageFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageBuffer8BitAccess: u32 = {d},\n", .{value.storageBuffer8BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformAndStorageBuffer8BitAccess: u32 = {d},\n", .{value.uniformAndStorageBuffer8BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storagePushConstant8: u32 = {d},\n", .{value.storagePushConstant8});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceConditionalRenderingFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceConditionalRenderingFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    conditionalRendering: u32 = {d},\n", .{value.conditionalRendering});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inheritedConditionalRendering: u32 = {d},\n", .{value.inheritedConditionalRendering});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkanMemoryModelFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkanMemoryModelFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vulkanMemoryModel: u32 = {d},\n", .{value.vulkanMemoryModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vulkanMemoryModelDeviceScope: u32 = {d},\n", .{value.vulkanMemoryModelDeviceScope});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vulkanMemoryModelAvailabilityVisibilityChains: u32 = {d},\n", .{value.vulkanMemoryModelAvailabilityVisibilityChains});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderAtomicInt64Features(name: []const u8, value: *const vk.VkPhysicalDeviceShaderAtomicInt64Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderAtomicInt64Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferInt64Atomics: u32 = {d},\n", .{value.shaderBufferInt64Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedInt64Atomics: u32 = {d},\n", .{value.shaderSharedInt64Atomics});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat32Atomics: u32 = {d},\n", .{value.shaderBufferFloat32Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat32AtomicAdd: u32 = {d},\n", .{value.shaderBufferFloat32AtomicAdd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat64Atomics: u32 = {d},\n", .{value.shaderBufferFloat64Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat64AtomicAdd: u32 = {d},\n", .{value.shaderBufferFloat64AtomicAdd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat32Atomics: u32 = {d},\n", .{value.shaderSharedFloat32Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat32AtomicAdd: u32 = {d},\n", .{value.shaderSharedFloat32AtomicAdd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat64Atomics: u32 = {d},\n", .{value.shaderSharedFloat64Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat64AtomicAdd: u32 = {d},\n", .{value.shaderSharedFloat64AtomicAdd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderImageFloat32Atomics: u32 = {d},\n", .{value.shaderImageFloat32Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderImageFloat32AtomicAdd: u32 = {d},\n", .{value.shaderImageFloat32AtomicAdd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseImageFloat32Atomics: u32 = {d},\n", .{value.sparseImageFloat32Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseImageFloat32AtomicAdd: u32 = {d},\n", .{value.sparseImageFloat32AtomicAdd});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat16Atomics: u32 = {d},\n", .{value.shaderBufferFloat16Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat16AtomicAdd: u32 = {d},\n", .{value.shaderBufferFloat16AtomicAdd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat16AtomicMinMax: u32 = {d},\n", .{value.shaderBufferFloat16AtomicMinMax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat32AtomicMinMax: u32 = {d},\n", .{value.shaderBufferFloat32AtomicMinMax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferFloat64AtomicMinMax: u32 = {d},\n", .{value.shaderBufferFloat64AtomicMinMax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat16Atomics: u32 = {d},\n", .{value.shaderSharedFloat16Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat16AtomicAdd: u32 = {d},\n", .{value.shaderSharedFloat16AtomicAdd});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat16AtomicMinMax: u32 = {d},\n", .{value.shaderSharedFloat16AtomicMinMax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat32AtomicMinMax: u32 = {d},\n", .{value.shaderSharedFloat32AtomicMinMax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedFloat64AtomicMinMax: u32 = {d},\n", .{value.shaderSharedFloat64AtomicMinMax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderImageFloat32AtomicMinMax: u32 = {d},\n", .{value.shaderImageFloat32AtomicMinMax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseImageFloat32AtomicMinMax: u32 = {d},\n", .{value.sparseImageFloat32AtomicMinMax});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVertexAttributeDivisorFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVertexAttributeDivisorFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexAttributeInstanceRateDivisor: u32 = {d},\n", .{value.vertexAttributeInstanceRateDivisor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexAttributeInstanceRateZeroDivisor: u32 = {d},\n", .{value.vertexAttributeInstanceRateZeroDivisor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyCheckpointPropertiesNV(name: []const u8, value: *const vk.VkQueueFamilyCheckpointPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyCheckpointPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    checkpointExecutionStageMask: VkPipelineStageFlags = {any},\n", .{value.checkpointExecutionStageMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCheckpointDataNV(name: []const u8, value: *const vk.VkCheckpointDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCheckpointDataNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stage: VkPipelineStageFlags = {any},\n", .{value.stage});
    if (value.pCheckpointMarker) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCheckpointMarker: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCheckpointMarker: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDepthStencilResolveProperties(name: []const u8, value: *const vk.VkPhysicalDeviceDepthStencilResolveProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDepthStencilResolveProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedDepthResolveModes: VkResolveModeFlags = {any},\n", .{value.supportedDepthResolveModes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedStencilResolveModes: VkResolveModeFlags = {any},\n", .{value.supportedStencilResolveModes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    independentResolveNone: u32 = {d},\n", .{value.independentResolveNone});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    independentResolve: u32 = {d},\n", .{value.independentResolve});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassDescriptionDepthStencilResolve(name: []const u8, value: *const vk.VkSubpassDescriptionDepthStencilResolve, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassDescriptionDepthStencilResolve = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthResolveMode: VkResolveModeFlags = {any},\n", .{value.depthResolveMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilResolveMode: VkResolveModeFlags = {any},\n", .{value.stencilResolveMode});
    if (value.pDepthStencilResolveAttachment) |v| {
        print_VkAttachmentReference2("pDepthStencilResolveAttachment", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthStencilResolveAttachment: *const VkAttachmentReference2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewASTCDecodeModeEXT(name: []const u8, value: *const vk.VkImageViewASTCDecodeModeEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewASTCDecodeModeEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    decodeMode: VkFormat = {t},\n", .{value.decodeMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceASTCDecodeFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceASTCDecodeFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    decodeModeSharedExponent: u32 = {d},\n", .{value.decodeModeSharedExponent});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTransformFeedbackFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTransformFeedbackFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformFeedback: u32 = {d},\n", .{value.transformFeedback});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryStreams: u32 = {d},\n", .{value.geometryStreams});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTransformFeedbackPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTransformFeedbackPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTransformFeedbackStreams: u32 = {d},\n", .{value.maxTransformFeedbackStreams});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTransformFeedbackBuffers: u32 = {d},\n", .{value.maxTransformFeedbackBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTransformFeedbackBufferSize: u64 = {d},\n", .{value.maxTransformFeedbackBufferSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTransformFeedbackStreamDataSize: u32 = {d},\n", .{value.maxTransformFeedbackStreamDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTransformFeedbackBufferDataSize: u32 = {d},\n", .{value.maxTransformFeedbackBufferDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTransformFeedbackBufferDataStride: u32 = {d},\n", .{value.maxTransformFeedbackBufferDataStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformFeedbackQueries: u32 = {d},\n", .{value.transformFeedbackQueries});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformFeedbackStreamsLinesTriangles: u32 = {d},\n", .{value.transformFeedbackStreamsLinesTriangles});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformFeedbackRasterizationStreamSelect: u32 = {d},\n", .{value.transformFeedbackRasterizationStreamSelect});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformFeedbackDraw: u32 = {d},\n", .{value.transformFeedbackDraw});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRasterizationStateStreamCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRasterizationStateStreamCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineRasterizationStateStreamCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationStream: u32 = {d},\n", .{value.rasterizationStream});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    representativeFragmentTest: u32 = {d},\n", .{value.representativeFragmentTest});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRepresentativeFragmentTestStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    representativeFragmentTestEnable: u32 = {d},\n", .{value.representativeFragmentTestEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExclusiveScissorFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExclusiveScissorFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    exclusiveScissor: u32 = {d},\n", .{value.exclusiveScissor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportExclusiveScissorStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportExclusiveScissorStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    exclusiveScissorCount: u32 = {d},\n", .{value.exclusiveScissorCount});
    if (value.pExclusiveScissors) |v| {
        for (v[0..value.exclusiveScissorCount]) |*vv| {
            print_VkRect2D("pExclusiveScissors", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pExclusiveScissors: [*]const VkRect2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCornerSampledImageFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCornerSampledImageFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cornerSampledImage: u32 = {d},\n", .{value.cornerSampledImage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeDerivativeGroupQuads: u32 = {d},\n", .{value.computeDerivativeGroupQuads});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeDerivativeGroupLinear: u32 = {d},\n", .{value.computeDerivativeGroupLinear});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshAndTaskShaderDerivatives: u32 = {d},\n", .{value.meshAndTaskShaderDerivatives});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderImageFootprintFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderImageFootprintFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageFootprint: u32 = {d},\n", .{value.imageFootprint});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dedicatedAllocationImageAliasing: u32 = {d},\n", .{value.dedicatedAllocationImageAliasing});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectMemoryCopy: u32 = {d},\n", .{value.indirectMemoryCopy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectMemoryToImageCopy: u32 = {d},\n", .{value.indirectMemoryToImageCopy});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectCopy: u32 = {d},\n", .{value.indirectCopy});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedQueues: VkQueueFlags = {any},\n", .{value.supportedQueues});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMemoryDecompressionFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMemoryDecompressionFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryDecompression: u32 = {d},\n", .{value.memoryDecompression});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMemoryDecompressionPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMemoryDecompressionPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    decompressionMethods: VkMemoryDecompressionMethodFlagsEXT = {any},\n", .{value.decompressionMethods});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDecompressionIndirectCount: u64 = {d},\n", .{value.maxDecompressionIndirectCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkShadingRatePaletteNV(name: []const u8, value: *const vk.VkShadingRatePaletteNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkShadingRatePaletteNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRatePaletteEntryCount: u32 = {d},\n", .{value.shadingRatePaletteEntryCount});
    if (value.pShadingRatePaletteEntries) |v| {
        for (v[0..value.shadingRatePaletteEntryCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pShadingRatePaletteEntries: [*]const VkShadingRatePaletteEntryNV = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pShadingRatePaletteEntries: [*]const VkShadingRatePaletteEntryNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportShadingRateImageStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportShadingRateImageStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRateImageEnable: u32 = {d},\n", .{value.shadingRateImageEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportCount: u32 = {d},\n", .{value.viewportCount});
    if (value.pShadingRatePalettes) |v| {
        for (v[0..value.viewportCount]) |*vv| {
            print_VkShadingRatePaletteNV("pShadingRatePalettes", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pShadingRatePalettes: [*]const VkShadingRatePaletteNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShadingRateImageFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShadingRateImageFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRateImage: u32 = {d},\n", .{value.shadingRateImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRateCoarseSampleOrder: u32 = {d},\n", .{value.shadingRateCoarseSampleOrder});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShadingRateImagePropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShadingRateImagePropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("shadingRateTexelSize", &value.shadingRateTexelSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRatePaletteSize: u32 = {d},\n", .{value.shadingRatePaletteSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRateMaxCoarseSamples: u32 = {d},\n", .{value.shadingRateMaxCoarseSamples});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(name: []const u8, value: *const vk.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    invocationMask: u32 = {d},\n", .{value.invocationMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCoarseSampleLocationNV(name: []const u8, value: *const vk.VkCoarseSampleLocationNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCoarseSampleLocationNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pixelX: u32 = {d},\n", .{value.pixelX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pixelY: u32 = {d},\n", .{value.pixelY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sample: u32 = {d},\n", .{value.sample});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCoarseSampleOrderCustomNV(name: []const u8, value: *const vk.VkCoarseSampleOrderCustomNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCoarseSampleOrderCustomNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRate: VkShadingRatePaletteEntryNV = {t},\n", .{value.shadingRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleCount: u32 = {d},\n", .{value.sampleCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleLocationCount: u32 = {d},\n", .{value.sampleLocationCount});
    if (value.pSampleLocations) |v| {
        for (v[0..value.sampleLocationCount]) |*vv| {
            print_VkCoarseSampleLocationNV("pSampleLocations", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSampleLocations: [*]const VkCoarseSampleLocationNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleOrderType: VkCoarseSampleOrderTypeNV = {t},\n", .{value.sampleOrderType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    customSampleOrderCount: u32 = {d},\n", .{value.customSampleOrderCount});
    if (value.pCustomSampleOrders) |v| {
        for (v[0..value.customSampleOrderCount]) |*vv| {
            print_VkCoarseSampleOrderCustomNV("pCustomSampleOrders", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCustomSampleOrders: [*]const VkCoarseSampleOrderCustomNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMeshShaderFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMeshShaderFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    taskShader: u32 = {d},\n", .{value.taskShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshShader: u32 = {d},\n", .{value.meshShader});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMeshShaderPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMeshShaderPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDrawMeshTasksCount: u32 = {d},\n", .{value.maxDrawMeshTasksCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskWorkGroupInvocations: u32 = {d},\n", .{value.maxTaskWorkGroupInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskWorkGroupSize: [3]u32 = {any},\n", .{value.maxTaskWorkGroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskTotalMemorySize: u32 = {d},\n", .{value.maxTaskTotalMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskOutputCount: u32 = {d},\n", .{value.maxTaskOutputCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshWorkGroupInvocations: u32 = {d},\n", .{value.maxMeshWorkGroupInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshWorkGroupSize: [3]u32 = {any},\n", .{value.maxMeshWorkGroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshTotalMemorySize: u32 = {d},\n", .{value.maxMeshTotalMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshOutputVertices: u32 = {d},\n", .{value.maxMeshOutputVertices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshOutputPrimitives: u32 = {d},\n", .{value.maxMeshOutputPrimitives});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshMultiviewViewCount: u32 = {d},\n", .{value.maxMeshMultiviewViewCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshOutputPerVertexGranularity: u32 = {d},\n", .{value.meshOutputPerVertexGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshOutputPerPrimitiveGranularity: u32 = {d},\n", .{value.meshOutputPerPrimitiveGranularity});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrawMeshTasksIndirectCommandNV(name: []const u8, value: *const vk.VkDrawMeshTasksIndirectCommandNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrawMeshTasksIndirectCommandNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    taskCount: u32 = {d},\n", .{value.taskCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstTask: u32 = {d},\n", .{value.firstTask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMeshShaderFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMeshShaderFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    taskShader: u32 = {d},\n", .{value.taskShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshShader: u32 = {d},\n", .{value.meshShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewMeshShader: u32 = {d},\n", .{value.multiviewMeshShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveFragmentShadingRateMeshShader: u32 = {d},\n", .{value.primitiveFragmentShadingRateMeshShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshShaderQueries: u32 = {d},\n", .{value.meshShaderQueries});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMeshShaderPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMeshShaderPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskWorkGroupTotalCount: u32 = {d},\n", .{value.maxTaskWorkGroupTotalCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskWorkGroupCount: [3]u32 = {any},\n", .{value.maxTaskWorkGroupCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskWorkGroupInvocations: u32 = {d},\n", .{value.maxTaskWorkGroupInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskWorkGroupSize: [3]u32 = {any},\n", .{value.maxTaskWorkGroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskPayloadSize: u32 = {d},\n", .{value.maxTaskPayloadSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskSharedMemorySize: u32 = {d},\n", .{value.maxTaskSharedMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTaskPayloadAndSharedMemorySize: u32 = {d},\n", .{value.maxTaskPayloadAndSharedMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshWorkGroupTotalCount: u32 = {d},\n", .{value.maxMeshWorkGroupTotalCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshWorkGroupCount: [3]u32 = {any},\n", .{value.maxMeshWorkGroupCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshWorkGroupInvocations: u32 = {d},\n", .{value.maxMeshWorkGroupInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshWorkGroupSize: [3]u32 = {any},\n", .{value.maxMeshWorkGroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshSharedMemorySize: u32 = {d},\n", .{value.maxMeshSharedMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshPayloadAndSharedMemorySize: u32 = {d},\n", .{value.maxMeshPayloadAndSharedMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshOutputMemorySize: u32 = {d},\n", .{value.maxMeshOutputMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshPayloadAndOutputMemorySize: u32 = {d},\n", .{value.maxMeshPayloadAndOutputMemorySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshOutputComponents: u32 = {d},\n", .{value.maxMeshOutputComponents});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshOutputVertices: u32 = {d},\n", .{value.maxMeshOutputVertices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshOutputPrimitives: u32 = {d},\n", .{value.maxMeshOutputPrimitives});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshOutputLayers: u32 = {d},\n", .{value.maxMeshOutputLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMeshMultiviewViewCount: u32 = {d},\n", .{value.maxMeshMultiviewViewCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshOutputPerVertexGranularity: u32 = {d},\n", .{value.meshOutputPerVertexGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    meshOutputPerPrimitiveGranularity: u32 = {d},\n", .{value.meshOutputPerPrimitiveGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPreferredTaskWorkGroupInvocations: u32 = {d},\n", .{value.maxPreferredTaskWorkGroupInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPreferredMeshWorkGroupInvocations: u32 = {d},\n", .{value.maxPreferredMeshWorkGroupInvocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersLocalInvocationVertexOutput: u32 = {d},\n", .{value.prefersLocalInvocationVertexOutput});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersLocalInvocationPrimitiveOutput: u32 = {d},\n", .{value.prefersLocalInvocationPrimitiveOutput});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersCompactVertexOutput: u32 = {d},\n", .{value.prefersCompactVertexOutput});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersCompactPrimitiveOutput: u32 = {d},\n", .{value.prefersCompactPrimitiveOutput});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrawMeshTasksIndirectCommandEXT(name: []const u8, value: *const vk.VkDrawMeshTasksIndirectCommandEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrawMeshTasksIndirectCommandEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupCountX: u32 = {d},\n", .{value.groupCountX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupCountY: u32 = {d},\n", .{value.groupCountY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupCountZ: u32 = {d},\n", .{value.groupCountZ});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRayTracingShaderGroupCreateInfoNV(name: []const u8, value: *const vk.VkRayTracingShaderGroupCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRayTracingShaderGroupCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkRayTracingShaderGroupTypeKHR = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    generalShader: u32 = {d},\n", .{value.generalShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    closestHitShader: u32 = {d},\n", .{value.closestHitShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    anyHitShader: u32 = {d},\n", .{value.anyHitShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intersectionShader: u32 = {d},\n", .{value.intersectionShader});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRayTracingShaderGroupCreateInfoKHR(name: []const u8, value: *const vk.VkRayTracingShaderGroupCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRayTracingShaderGroupCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkRayTracingShaderGroupTypeKHR = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    generalShader: u32 = {d},\n", .{value.generalShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    closestHitShader: u32 = {d},\n", .{value.closestHitShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    anyHitShader: u32 = {d},\n", .{value.anyHitShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intersectionShader: u32 = {d},\n", .{value.intersectionShader});
    if (value.pShaderGroupCaptureReplayHandle) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pShaderGroupCaptureReplayHandle: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pShaderGroupCaptureReplayHandle: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRayTracingPipelineCreateInfoNV(name: []const u8, value: *const vk.VkRayTracingPipelineCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRayTracingPipelineCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageCount: u32 = {d},\n", .{value.stageCount});
    if (value.pStages) |v| {
        for (v[0..value.stageCount]) |*vv| {
            print_VkPipelineShaderStageCreateInfo("pStages", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStages: [*]const VkPipelineShaderStageCreateInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupCount: u32 = {d},\n", .{value.groupCount});
    if (value.pGroups) |v| {
        for (v[0..value.groupCount]) |*vv| {
            print_VkRayTracingShaderGroupCreateInfoNV("pGroups", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pGroups: [*]const VkRayTracingShaderGroupCreateInfoNV = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRecursionDepth: u32 = {d},\n", .{value.maxRecursionDepth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineHandle: VkPipeline = {},\n", .{value.basePipelineHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineIndex: i32 = {d},\n", .{value.basePipelineIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRayTracingPipelineCreateInfoKHR(name: []const u8, value: *const vk.VkRayTracingPipelineCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRayTracingPipelineCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageCount: u32 = {d},\n", .{value.stageCount});
    if (value.pStages) |v| {
        for (v[0..value.stageCount]) |*vv| {
            print_VkPipelineShaderStageCreateInfo("pStages", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStages: [*]const VkPipelineShaderStageCreateInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupCount: u32 = {d},\n", .{value.groupCount});
    if (value.pGroups) |v| {
        for (v[0..value.groupCount]) |*vv| {
            print_VkRayTracingShaderGroupCreateInfoKHR("pGroups", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pGroups: [*]const VkRayTracingShaderGroupCreateInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPipelineRayRecursionDepth: u32 = {d},\n", .{value.maxPipelineRayRecursionDepth});
    if (value.pLibraryInfo) |v| {
        print_VkPipelineLibraryCreateInfoKHR("pLibraryInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLibraryInfo: *const VkPipelineLibraryCreateInfoKHR = null,\n", .{});
    }
    if (value.pLibraryInterface) |v| {
        print_VkRayTracingPipelineInterfaceCreateInfoKHR("pLibraryInterface", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLibraryInterface: *const VkRayTracingPipelineInterfaceCreateInfoKHR = null,\n", .{});
    }
    if (value.pDynamicState) |v| {
        print_VkPipelineDynamicStateCreateInfo("pDynamicState", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDynamicState: *const VkPipelineDynamicStateCreateInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineHandle: VkPipeline = {},\n", .{value.basePipelineHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineIndex: i32 = {d},\n", .{value.basePipelineIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeometryTrianglesNV(name: []const u8, value: *const vk.VkGeometryTrianglesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeometryTrianglesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexData: VkBuffer = {},\n", .{value.vertexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexOffset: u64 = {d},\n", .{value.vertexOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexCount: u32 = {d},\n", .{value.vertexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexStride: u64 = {d},\n", .{value.vertexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexFormat: VkFormat = {t},\n", .{value.vertexFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexData: VkBuffer = {},\n", .{value.indexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexOffset: u64 = {d},\n", .{value.indexOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexCount: u32 = {d},\n", .{value.indexCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformData: VkBuffer = {},\n", .{value.transformData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformOffset: u64 = {d},\n", .{value.transformOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeometryAABBNV(name: []const u8, value: *const vk.VkGeometryAABBNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeometryAABBNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    aabbData: VkBuffer = {},\n", .{value.aabbData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numAABBs: u32 = {d},\n", .{value.numAABBs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u32 = {d},\n", .{value.stride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeometryDataNV(name: []const u8, value: *const vk.VkGeometryDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeometryDataNV = .{{\n", .{ name });
    print_VkGeometryTrianglesNV("triangles", &value.triangles, offset + 1);
    print_VkGeometryAABBNV("aabbs", &value.aabbs, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeometryNV(name: []const u8, value: *const vk.VkGeometryNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeometryNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryType: VkGeometryTypeKHR = {t},\n", .{value.geometryType});
    print_VkGeometryDataNV("geometry", &value.geometry, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkGeometryFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureInfoNV(name: []const u8, value: *const vk.VkAccelerationStructureInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkAccelerationStructureTypeKHR = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceCount: u32 = {d},\n", .{value.instanceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryCount: u32 = {d},\n", .{value.geometryCount});
    if (value.pGeometries) |v| {
        for (v[0..value.geometryCount]) |*vv| {
            print_VkGeometryNV("pGeometries", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pGeometries: [*]const VkGeometryNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureCreateInfoNV(name: []const u8, value: *const vk.VkAccelerationStructureCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compactedSize: u64 = {d},\n", .{value.compactedSize});
    print_VkAccelerationStructureInfoNV("info", &value.info, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindAccelerationStructureMemoryInfoNV(name: []const u8, value: *const vk.VkBindAccelerationStructureMemoryInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindAccelerationStructureMemoryInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructure: VkAccelerationStructureNV = {},\n", .{value.accelerationStructure});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceIndexCount: u32 = {d},\n", .{value.deviceIndexCount});
    if (value.pDeviceIndices) |v| {
        for (v[0..value.deviceIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDeviceIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDeviceIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteDescriptorSetAccelerationStructureKHR(name: []const u8, value: *const vk.VkWriteDescriptorSetAccelerationStructureKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteDescriptorSetAccelerationStructureKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureCount: u32 = {d},\n", .{value.accelerationStructureCount});
    if (value.pAccelerationStructures) |v| {
        for (v[0..value.accelerationStructureCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAccelerationStructures: [*]const VkAccelerationStructureKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAccelerationStructures: [*]const VkAccelerationStructureKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteDescriptorSetAccelerationStructureNV(name: []const u8, value: *const vk.VkWriteDescriptorSetAccelerationStructureNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteDescriptorSetAccelerationStructureNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureCount: u32 = {d},\n", .{value.accelerationStructureCount});
    if (value.pAccelerationStructures) |v| {
        for (v[0..value.accelerationStructureCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAccelerationStructures: [*]const VkAccelerationStructureNV = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAccelerationStructures: [*]const VkAccelerationStructureNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureMemoryRequirementsInfoNV(name: []const u8, value: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureMemoryRequirementsInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkAccelerationStructureMemoryRequirementsTypeNV = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructure: VkAccelerationStructureNV = {},\n", .{value.accelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceAccelerationStructureFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceAccelerationStructureFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructure: u32 = {d},\n", .{value.accelerationStructure});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureCaptureReplay: u32 = {d},\n", .{value.accelerationStructureCaptureReplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureIndirectBuild: u32 = {d},\n", .{value.accelerationStructureIndirectBuild});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureHostCommands: u32 = {d},\n", .{value.accelerationStructureHostCommands});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingAccelerationStructureUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingAccelerationStructureUpdateAfterBind});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingPipelineFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingPipeline: u32 = {d},\n", .{value.rayTracingPipeline});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingPipelineShaderGroupHandleCaptureReplay: u32 = {d},\n", .{value.rayTracingPipelineShaderGroupHandleCaptureReplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: u32 = {d},\n", .{value.rayTracingPipelineShaderGroupHandleCaptureReplayMixed});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingPipelineTraceRaysIndirect: u32 = {d},\n", .{value.rayTracingPipelineTraceRaysIndirect});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTraversalPrimitiveCulling: u32 = {d},\n", .{value.rayTraversalPrimitiveCulling});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayQueryFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayQueryFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayQuery: u32 = {d},\n", .{value.rayQuery});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceAccelerationStructurePropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceAccelerationStructurePropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryCount: u64 = {d},\n", .{value.maxGeometryCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInstanceCount: u64 = {d},\n", .{value.maxInstanceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPrimitiveCount: u64 = {d},\n", .{value.maxPrimitiveCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorAccelerationStructures: u32 = {d},\n", .{value.maxPerStageDescriptorAccelerationStructures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindAccelerationStructures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetAccelerationStructures: u32 = {d},\n", .{value.maxDescriptorSetAccelerationStructures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindAccelerationStructures: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindAccelerationStructures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minAccelerationStructureScratchOffsetAlignment: u32 = {d},\n", .{value.minAccelerationStructureScratchOffsetAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingPipelinePropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderGroupHandleSize: u32 = {d},\n", .{value.shaderGroupHandleSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRayRecursionDepth: u32 = {d},\n", .{value.maxRayRecursionDepth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxShaderGroupStride: u32 = {d},\n", .{value.maxShaderGroupStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderGroupBaseAlignment: u32 = {d},\n", .{value.shaderGroupBaseAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderGroupHandleCaptureReplaySize: u32 = {d},\n", .{value.shaderGroupHandleCaptureReplaySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRayDispatchInvocationCount: u32 = {d},\n", .{value.maxRayDispatchInvocationCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderGroupHandleAlignment: u32 = {d},\n", .{value.shaderGroupHandleAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRayHitAttributeSize: u32 = {d},\n", .{value.maxRayHitAttributeSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderGroupHandleSize: u32 = {d},\n", .{value.shaderGroupHandleSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRecursionDepth: u32 = {d},\n", .{value.maxRecursionDepth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxShaderGroupStride: u32 = {d},\n", .{value.maxShaderGroupStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderGroupBaseAlignment: u32 = {d},\n", .{value.shaderGroupBaseAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryCount: u64 = {d},\n", .{value.maxGeometryCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInstanceCount: u64 = {d},\n", .{value.maxInstanceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTriangleCount: u64 = {d},\n", .{value.maxTriangleCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetAccelerationStructures: u32 = {d},\n", .{value.maxDescriptorSetAccelerationStructures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkStridedDeviceAddressRegionKHR(name: []const u8, value: *const vk.VkStridedDeviceAddressRegionKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkStridedDeviceAddressRegionKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceAddress: u64 = {d},\n", .{value.deviceAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u64 = {d},\n", .{value.stride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTraceRaysIndirectCommandKHR(name: []const u8, value: *const vk.VkTraceRaysIndirectCommandKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTraceRaysIndirectCommandKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: u32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: u32 = {d},\n", .{value.height});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depth: u32 = {d},\n", .{value.depth});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTraceRaysIndirectCommand2KHR(name: []const u8, value: *const vk.VkTraceRaysIndirectCommand2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTraceRaysIndirectCommand2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    raygenShaderRecordAddress: u64 = {d},\n", .{value.raygenShaderRecordAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    raygenShaderRecordSize: u64 = {d},\n", .{value.raygenShaderRecordSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    missShaderBindingTableAddress: u64 = {d},\n", .{value.missShaderBindingTableAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    missShaderBindingTableSize: u64 = {d},\n", .{value.missShaderBindingTableSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    missShaderBindingTableStride: u64 = {d},\n", .{value.missShaderBindingTableStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hitShaderBindingTableAddress: u64 = {d},\n", .{value.hitShaderBindingTableAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hitShaderBindingTableSize: u64 = {d},\n", .{value.hitShaderBindingTableSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hitShaderBindingTableStride: u64 = {d},\n", .{value.hitShaderBindingTableStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    callableShaderBindingTableAddress: u64 = {d},\n", .{value.callableShaderBindingTableAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    callableShaderBindingTableSize: u64 = {d},\n", .{value.callableShaderBindingTableSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    callableShaderBindingTableStride: u64 = {d},\n", .{value.callableShaderBindingTableStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: u32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: u32 = {d},\n", .{value.height});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depth: u32 = {d},\n", .{value.depth});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingMaintenance1: u32 = {d},\n", .{value.rayTracingMaintenance1});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingPipelineTraceRaysIndirect2: u32 = {d},\n", .{value.rayTracingPipelineTraceRaysIndirect2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrmFormatModifierPropertiesListEXT(name: []const u8, value: *const vk.VkDrmFormatModifierPropertiesListEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrmFormatModifierPropertiesListEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierCount: u32 = {d},\n", .{value.drmFormatModifierCount});
    if (value.pDrmFormatModifierProperties) |v| {
        for (v[0..value.drmFormatModifierCount]) |*vv| {
            print_VkDrmFormatModifierPropertiesEXT("pDrmFormatModifierProperties", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDrmFormatModifierProperties: [*]VkDrmFormatModifierPropertiesEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrmFormatModifierPropertiesEXT(name: []const u8, value: *const vk.VkDrmFormatModifierPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrmFormatModifierPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifier: u64 = {d},\n", .{value.drmFormatModifier});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierPlaneCount: u32 = {d},\n", .{value.drmFormatModifierPlaneCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierTilingFeatures: VkFormatFeatureFlags = {any},\n", .{value.drmFormatModifierTilingFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(name: []const u8, value: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageDrmFormatModifierInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifier: u64 = {d},\n", .{value.drmFormatModifier});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharingMode: VkSharingMode = {t},\n", .{value.sharingMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndexCount: u32 = {d},\n", .{value.queueFamilyIndexCount});
    if (value.pQueueFamilyIndices) |v| {
        for (v[0..value.queueFamilyIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pQueueFamilyIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueueFamilyIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageDrmFormatModifierListCreateInfoEXT(name: []const u8, value: *const vk.VkImageDrmFormatModifierListCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageDrmFormatModifierListCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierCount: u32 = {d},\n", .{value.drmFormatModifierCount});
    if (value.pDrmFormatModifiers) |v| {
        for (v[0..value.drmFormatModifierCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDrmFormatModifiers: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDrmFormatModifiers: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageDrmFormatModifierExplicitCreateInfoEXT(name: []const u8, value: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageDrmFormatModifierExplicitCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifier: u64 = {d},\n", .{value.drmFormatModifier});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierPlaneCount: u32 = {d},\n", .{value.drmFormatModifierPlaneCount});
    if (value.pPlaneLayouts) |v| {
        for (v[0..value.drmFormatModifierPlaneCount]) |*vv| {
            print_VkSubresourceLayout("pPlaneLayouts", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPlaneLayouts: [*]const VkSubresourceLayout = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageDrmFormatModifierPropertiesEXT(name: []const u8, value: *const vk.VkImageDrmFormatModifierPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageDrmFormatModifierPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifier: u64 = {d},\n", .{value.drmFormatModifier});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageStencilUsageCreateInfo(name: []const u8, value: *const vk.VkImageStencilUsageCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageStencilUsageCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilUsage: VkImageUsageFlags = {any},\n", .{value.stencilUsage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceMemoryOverallocationCreateInfoAMD(name: []const u8, value: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceMemoryOverallocationCreateInfoAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    overallocationBehavior: VkMemoryOverallocationBehaviorAMD = {t},\n", .{value.overallocationBehavior});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMapFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityMap: u32 = {d},\n", .{value.fragmentDensityMap});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityMapDynamic: u32 = {d},\n", .{value.fragmentDensityMapDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityMapNonSubsampledImages: u32 = {d},\n", .{value.fragmentDensityMapNonSubsampledImages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityMapDeferred: u32 = {d},\n", .{value.fragmentDensityMapDeferred});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityMapOffset: u32 = {d},\n", .{value.fragmentDensityMapOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMapPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("minFragmentDensityTexelSize", &value.minFragmentDensityTexelSize, offset + 1);
    print_VkExtent2D("maxFragmentDensityTexelSize", &value.maxFragmentDensityTexelSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityInvocations: u32 = {d},\n", .{value.fragmentDensityInvocations});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subsampledLoads: u32 = {d},\n", .{value.subsampledLoads});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subsampledCoarseReconstructionEarlyAccess: u32 = {d},\n", .{value.subsampledCoarseReconstructionEarlyAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSubsampledArrayLayers: u32 = {d},\n", .{value.maxSubsampledArrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetSubsampledSamplers: u32 = {d},\n", .{value.maxDescriptorSetSubsampledSamplers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("fragmentDensityOffsetGranularity", &value.fragmentDensityOffsetGranularity, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassFragmentDensityMapCreateInfoEXT(name: []const u8, value: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassFragmentDensityMapCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkAttachmentReference("fragmentDensityMapAttachment", &value.fragmentDensityMapAttachment, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(name: []const u8, value: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassFragmentDensityMapOffsetEndInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityOffsetCount: u32 = {d},\n", .{value.fragmentDensityOffsetCount});
    if (value.pFragmentDensityOffsets) |v| {
        for (v[0..value.fragmentDensityOffsetCount]) |*vv| {
            print_VkOffset2D("pFragmentDensityOffsets", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFragmentDensityOffsets: [*]const VkOffset2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceScalarBlockLayoutFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceScalarBlockLayoutFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scalarBlockLayout: u32 = {d},\n", .{value.scalarBlockLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceProtectedCapabilitiesKHR(name: []const u8, value: *const vk.VkSurfaceProtectedCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceProtectedCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportsProtected: u32 = {d},\n", .{value.supportsProtected});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceUniformBufferStandardLayoutFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformBufferStandardLayout: u32 = {d},\n", .{value.uniformBufferStandardLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDepthClipEnableFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDepthClipEnableFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClipEnable: u32 = {d},\n", .{value.depthClipEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRasterizationDepthClipStateCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRasterizationDepthClipStateCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClipEnable: u32 = {d},\n", .{value.depthClipEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMemoryBudgetPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMemoryBudgetPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    heapBudget: [VK_MAX_MEMORY_HEAPS]u64 = {any},\n", .{value.heapBudget});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    heapUsage: [VK_MAX_MEMORY_HEAPS]u64 = {any},\n", .{value.heapUsage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMemoryPriorityFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMemoryPriorityFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryPriority: u32 = {d},\n", .{value.memoryPriority});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryPriorityAllocateInfoEXT(name: []const u8, value: *const vk.VkMemoryPriorityAllocateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryPriorityAllocateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    priority: f32 = {d},\n", .{value.priority});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pageableDeviceLocalMemory: u32 = {d},\n", .{value.pageableDeviceLocalMemory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceBufferDeviceAddressFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceBufferDeviceAddressFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddress: u32 = {d},\n", .{value.bufferDeviceAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddressCaptureReplay: u32 = {d},\n", .{value.bufferDeviceAddressCaptureReplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddressMultiDevice: u32 = {d},\n", .{value.bufferDeviceAddressMultiDevice});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddress: u32 = {d},\n", .{value.bufferDeviceAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddressCaptureReplay: u32 = {d},\n", .{value.bufferDeviceAddressCaptureReplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddressMultiDevice: u32 = {d},\n", .{value.bufferDeviceAddressMultiDevice});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferDeviceAddressInfo(name: []const u8, value: *const vk.VkBufferDeviceAddressInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferDeviceAddressInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferOpaqueCaptureAddressCreateInfo(name: []const u8, value: *const vk.VkBufferOpaqueCaptureAddressCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferOpaqueCaptureAddressCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opaqueCaptureAddress: u64 = {d},\n", .{value.opaqueCaptureAddress});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferDeviceAddressCreateInfoEXT(name: []const u8, value: *const vk.VkBufferDeviceAddressCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferDeviceAddressCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceAddress: u64 = {d},\n", .{value.deviceAddress});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageViewImageFormatInfoEXT(name: []const u8, value: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageViewImageFormatInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageViewType: VkImageViewType = {t},\n", .{value.imageViewType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFilterCubicImageViewImageFormatPropertiesEXT(name: []const u8, value: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFilterCubicImageViewImageFormatPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filterCubic: u32 = {d},\n", .{value.filterCubic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filterCubicMinmax: u32 = {d},\n", .{value.filterCubicMinmax});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImagelessFramebufferFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImagelessFramebufferFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imagelessFramebuffer: u32 = {d},\n", .{value.imagelessFramebuffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFramebufferAttachmentsCreateInfo(name: []const u8, value: *const vk.VkFramebufferAttachmentsCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFramebufferAttachmentsCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentImageInfoCount: u32 = {d},\n", .{value.attachmentImageInfoCount});
    if (value.pAttachmentImageInfos) |v| {
        for (v[0..value.attachmentImageInfoCount]) |*vv| {
            print_VkFramebufferAttachmentImageInfo("pAttachmentImageInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttachmentImageInfos: [*]const VkFramebufferAttachmentImageInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFramebufferAttachmentImageInfo(name: []const u8, value: *const vk.VkFramebufferAttachmentImageInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFramebufferAttachmentImageInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImageCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkImageUsageFlags = {any},\n", .{value.usage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: u32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: u32 = {d},\n", .{value.height});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layerCount: u32 = {d},\n", .{value.layerCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewFormatCount: u32 = {d},\n", .{value.viewFormatCount});
    if (value.pViewFormats) |v| {
        for (v[0..value.viewFormatCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pViewFormats: [*]const VkFormat = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewFormats: [*]const VkFormat = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassAttachmentBeginInfo(name: []const u8, value: *const vk.VkRenderPassAttachmentBeginInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassAttachmentBeginInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentCount: u32 = {d},\n", .{value.attachmentCount});
    if (value.pAttachments) |v| {
        for (v[0..value.attachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAttachments: [*]const VkImageView = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAttachments: [*]const VkImageView = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTextureCompressionASTCHDRFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureCompressionASTC_HDR: u32 = {d},\n", .{value.textureCompressionASTC_HDR});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeMatrixFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeMatrixFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrix: u32 = {d},\n", .{value.cooperativeMatrix});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixRobustBufferAccess: u32 = {d},\n", .{value.cooperativeMatrixRobustBufferAccess});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeMatrixPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeMatrixPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixSupportedStages: VkShaderStageFlags = {any},\n", .{value.cooperativeMatrixSupportedStages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCooperativeMatrixPropertiesNV(name: []const u8, value: *const vk.VkCooperativeMatrixPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCooperativeMatrixPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    MSize: u32 = {d},\n", .{value.MSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    NSize: u32 = {d},\n", .{value.NSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    KSize: u32 = {d},\n", .{value.KSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    AType: VkComponentTypeKHR = {t},\n", .{value.AType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    BType: VkComponentTypeKHR = {t},\n", .{value.BType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    CType: VkComponentTypeKHR = {t},\n", .{value.CType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    DType: VkComponentTypeKHR = {t},\n", .{value.DType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scope: VkScopeKHR = {t},\n", .{value.scope});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ycbcrImageArrays: u32 = {d},\n", .{value.ycbcrImageArrays});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewHandleInfoNVX(name: []const u8, value: *const vk.VkImageViewHandleInfoNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewHandleInfoNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView: VkImageView = {},\n", .{value.imageView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorType: VkDescriptorType = {t},\n", .{value.descriptorType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampler: VkSampler = {},\n", .{value.sampler});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewAddressPropertiesNVX(name: []const u8, value: *const vk.VkImageViewAddressPropertiesNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewAddressPropertiesNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceAddress: u64 = {d},\n", .{value.deviceAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPresentFrameTokenGGP(name: []const u8, value: *const vk.VkPresentFrameTokenGGP, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPresentFrameTokenGGP = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCreationFeedback(name: []const u8, value: *const vk.VkPipelineCreationFeedback, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCreationFeedback = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCreationFeedbackFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    duration: u64 = {d},\n", .{value.duration});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCreationFeedbackCreateInfo(name: []const u8, value: *const vk.VkPipelineCreationFeedbackCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCreationFeedbackCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pPipelineCreationFeedback) |v| {
        print_VkPipelineCreationFeedback("pPipelineCreationFeedback", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineCreationFeedback: *VkPipelineCreationFeedback = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineStageCreationFeedbackCount: u32 = {d},\n", .{value.pipelineStageCreationFeedbackCount});
    if (value.pPipelineStageCreationFeedbacks) |v| {
        for (v[0..value.pipelineStageCreationFeedbackCount]) |*vv| {
            print_VkPipelineCreationFeedback("pPipelineStageCreationFeedbacks", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineStageCreationFeedbacks: [*]VkPipelineCreationFeedback = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceFullScreenExclusiveInfoEXT(name: []const u8, value: *const vk.VkSurfaceFullScreenExclusiveInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceFullScreenExclusiveInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fullScreenExclusive: VkFullScreenExclusiveEXT = {t},\n", .{value.fullScreenExclusive});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceFullScreenExclusiveWin32InfoEXT(name: []const u8, value: *const vk.VkSurfaceFullScreenExclusiveWin32InfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceFullScreenExclusiveWin32InfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCapabilitiesFullScreenExclusiveEXT(name: []const u8, value: *const vk.VkSurfaceCapabilitiesFullScreenExclusiveEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCapabilitiesFullScreenExclusiveEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fullScreenExclusiveSupported: u32 = {d},\n", .{value.fullScreenExclusiveSupported});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentBarrierFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentBarrierFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentBarrier: u32 = {d},\n", .{value.presentBarrier});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCapabilitiesPresentBarrierNV(name: []const u8, value: *const vk.VkSurfaceCapabilitiesPresentBarrierNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCapabilitiesPresentBarrierNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentBarrierSupported: u32 = {d},\n", .{value.presentBarrierSupported});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainPresentBarrierCreateInfoNV(name: []const u8, value: *const vk.VkSwapchainPresentBarrierCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainPresentBarrierCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentBarrierEnable: u32 = {d},\n", .{value.presentBarrierEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePerformanceQueryFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePerformanceQueryFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    performanceCounterQueryPools: u32 = {d},\n", .{value.performanceCounterQueryPools});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    performanceCounterMultipleQueryPools: u32 = {d},\n", .{value.performanceCounterMultipleQueryPools});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePerformanceQueryPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePerformanceQueryPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    allowCommandBufferQueryCopies: u32 = {d},\n", .{value.allowCommandBufferQueryCopies});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceCounterKHR(name: []const u8, value: *const vk.VkPerformanceCounterKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceCounterKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    unit: VkPerformanceCounterUnitKHR = {t},\n", .{value.unit});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scope: VkPerformanceCounterScopeKHR = {t},\n", .{value.scope});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storage: VkPerformanceCounterStorageKHR = {t},\n", .{value.storage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uuid: [VK_UUID_SIZE]u8 = {any},\n", .{value.uuid});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceCounterDescriptionKHR(name: []const u8, value: *const vk.VkPerformanceCounterDescriptionKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceCounterDescriptionKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPerformanceCounterDescriptionFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    name: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.name});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    category: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.category});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueryPoolPerformanceCreateInfoKHR(name: []const u8, value: *const vk.VkQueryPoolPerformanceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueryPoolPerformanceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndex: u32 = {d},\n", .{value.queueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    counterIndexCount: u32 = {d},\n", .{value.counterIndexCount});
    if (value.pCounterIndices) |v| {
        for (v[0..value.counterIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCounterIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCounterIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAcquireProfilingLockInfoKHR(name: []const u8, value: *const vk.VkAcquireProfilingLockInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAcquireProfilingLockInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkAcquireProfilingLockFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timeout: u64 = {d},\n", .{value.timeout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceQuerySubmitInfoKHR(name: []const u8, value: *const vk.VkPerformanceQuerySubmitInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceQuerySubmitInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    counterPassIndex: u32 = {d},\n", .{value.counterPassIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceQueryReservationInfoKHR(name: []const u8, value: *const vk.VkPerformanceQueryReservationInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceQueryReservationInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerformanceQueriesPerPool: u32 = {d},\n", .{value.maxPerformanceQueriesPerPool});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkHeadlessSurfaceCreateInfoEXT(name: []const u8, value: *const vk.VkHeadlessSurfaceCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkHeadlessSurfaceCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkHeadlessSurfaceCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCoverageReductionModeFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCoverageReductionModeFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageReductionMode: u32 = {d},\n", .{value.coverageReductionMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCoverageReductionStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineCoverageReductionStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCoverageReductionStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCoverageReductionStateCreateFlagsNV = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageReductionMode: VkCoverageReductionModeNV = {t},\n", .{value.coverageReductionMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFramebufferMixedSamplesCombinationNV(name: []const u8, value: *const vk.VkFramebufferMixedSamplesCombinationNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFramebufferMixedSamplesCombinationNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    coverageReductionMode: VkCoverageReductionModeNV = {t},\n", .{value.coverageReductionMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationSamples: VkSampleCountFlags = {any},\n", .{value.rasterizationSamples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthStencilSamples: VkSampleCountFlags = {any},\n", .{value.depthStencilSamples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorSamples: VkSampleCountFlags = {any},\n", .{value.colorSamples});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(name: []const u8, value: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderIntegerFunctions2: u32 = {d},\n", .{value.shaderIntegerFunctions2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceValueINTEL(name: []const u8, value: *const vk.VkPerformanceValueINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceValueINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkPerformanceValueTypeINTEL = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.type) {
        .VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL => log.output("    data: VkPerformanceValueDataINTEL = {any},\n", .{value.data.value32}),
        .VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL => log.output("    data: VkPerformanceValueDataINTEL = {any},\n", .{value.data.value64}),
        .VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL => log.output("    data: VkPerformanceValueDataINTEL = {any},\n", .{value.data.valueFloat}),
        .VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL => log.output("    data: VkPerformanceValueDataINTEL = {any},\n", .{value.data.valueBool}),
        .VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL => log.output("    data: VkPerformanceValueDataINTEL = {any},\n", .{value.data.valueString}),
        else => log.output("    data: VkPerformanceValueDataINTEL = ???,\n", .{}),
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkInitializePerformanceApiInfoINTEL(name: []const u8, value: *const vk.VkInitializePerformanceApiInfoINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkInitializePerformanceApiInfoINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pUserData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUserData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueryPoolPerformanceQueryCreateInfoINTEL(name: []const u8, value: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueryPoolPerformanceQueryCreateInfoINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    performanceCountersSampling: VkQueryPoolSamplingModeINTEL = {t},\n", .{value.performanceCountersSampling});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceMarkerInfoINTEL(name: []const u8, value: *const vk.VkPerformanceMarkerInfoINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceMarkerInfoINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    marker: u64 = {d},\n", .{value.marker});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceStreamMarkerInfoINTEL(name: []const u8, value: *const vk.VkPerformanceStreamMarkerInfoINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceStreamMarkerInfoINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    marker: u32 = {d},\n", .{value.marker});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceOverrideInfoINTEL(name: []const u8, value: *const vk.VkPerformanceOverrideInfoINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceOverrideInfoINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkPerformanceOverrideTypeINTEL = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enable: u32 = {d},\n", .{value.enable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    parameter: u64 = {d},\n", .{value.parameter});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceConfigurationAcquireInfoINTEL(name: []const u8, value: *const vk.VkPerformanceConfigurationAcquireInfoINTEL, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceConfigurationAcquireInfoINTEL = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkPerformanceConfigurationTypeINTEL = {t},\n", .{value.type});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderClockFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderClockFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupClock: u32 = {d},\n", .{value.shaderSubgroupClock});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDeviceClock: u32 = {d},\n", .{value.shaderDeviceClock});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceIndexTypeUint8Features(name: []const u8, value: *const vk.VkPhysicalDeviceIndexTypeUint8Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceIndexTypeUint8Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexTypeUint8: u32 = {d},\n", .{value.indexTypeUint8});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSMCount: u32 = {d},\n", .{value.shaderSMCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderWarpsPerSM: u32 = {d},\n", .{value.shaderWarpsPerSM});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSMBuiltins: u32 = {d},\n", .{value.shaderSMBuiltins});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShaderSampleInterlock: u32 = {d},\n", .{value.fragmentShaderSampleInterlock});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShaderPixelInterlock: u32 = {d},\n", .{value.fragmentShaderPixelInterlock});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShaderShadingRateInterlock: u32 = {d},\n", .{value.fragmentShaderShadingRateInterlock});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    separateDepthStencilLayouts: u32 = {d},\n", .{value.separateDepthStencilLayouts});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentReferenceStencilLayout(name: []const u8, value: *const vk.VkAttachmentReferenceStencilLayout, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentReferenceStencilLayout = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilLayout: VkImageLayout = {t},\n", .{value.stencilLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveTopologyListRestart: u32 = {d},\n", .{value.primitiveTopologyListRestart});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveTopologyPatchListRestart: u32 = {d},\n", .{value.primitiveTopologyPatchListRestart});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentDescriptionStencilLayout(name: []const u8, value: *const vk.VkAttachmentDescriptionStencilLayout, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentDescriptionStencilLayout = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilInitialLayout: VkImageLayout = {t},\n", .{value.stencilInitialLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilFinalLayout: VkImageLayout = {t},\n", .{value.stencilFinalLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineExecutableInfo: u32 = {d},\n", .{value.pipelineExecutableInfo});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineInfoKHR(name: []const u8, value: *const vk.VkPipelineInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineExecutablePropertiesKHR(name: []const u8, value: *const vk.VkPipelineExecutablePropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineExecutablePropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stages: VkShaderStageFlags = {any},\n", .{value.stages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    name: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.name});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupSize: u32 = {d},\n", .{value.subgroupSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineExecutableInfoKHR(name: []const u8, value: *const vk.VkPipelineExecutableInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineExecutableInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    executableIndex: u32 = {d},\n", .{value.executableIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineExecutableStatisticKHR(name: []const u8, value: *const vk.VkPipelineExecutableStatisticKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineExecutableStatisticKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    name: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.name});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkPipelineExecutableStatisticFormatKHR = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.format) {
        .VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR => log.output("    value: VkPipelineExecutableStatisticValueKHR = {any},\n", .{value.value.b32}),
        .VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR => log.output("    value: VkPipelineExecutableStatisticValueKHR = {any},\n", .{value.value.i64}),
        .VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR => log.output("    value: VkPipelineExecutableStatisticValueKHR = {any},\n", .{value.value.u64}),
        .VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR => log.output("    value: VkPipelineExecutableStatisticValueKHR = {any},\n", .{value.value.f64}),
        else => log.output("    value: VkPipelineExecutableStatisticValueKHR = ???,\n", .{}),
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineExecutableInternalRepresentationKHR(name: []const u8, value: *const vk.VkPipelineExecutableInternalRepresentationKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineExecutableInternalRepresentationKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    name: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.name});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    isText: u32 = {d},\n", .{value.isText});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u64 = {d},\n", .{value.dataSize});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDemoteToHelperInvocation: u32 = {d},\n", .{value.shaderDemoteToHelperInvocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    texelBufferAlignment: u32 = {d},\n", .{value.texelBufferAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTexelBufferAlignmentProperties(name: []const u8, value: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTexelBufferAlignmentProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageTexelBufferOffsetAlignmentBytes: u64 = {d},\n", .{value.storageTexelBufferOffsetAlignmentBytes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageTexelBufferOffsetSingleTexelAlignment: u32 = {d},\n", .{value.storageTexelBufferOffsetSingleTexelAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformTexelBufferOffsetAlignmentBytes: u64 = {d},\n", .{value.uniformTexelBufferOffsetAlignmentBytes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformTexelBufferOffsetSingleTexelAlignment: u32 = {d},\n", .{value.uniformTexelBufferOffsetSingleTexelAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSubgroupSizeControlFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSubgroupSizeControlFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupSizeControl: u32 = {d},\n", .{value.subgroupSizeControl});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeFullSubgroups: u32 = {d},\n", .{value.computeFullSubgroups});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSubgroupSizeControlProperties(name: []const u8, value: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSubgroupSizeControlProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minSubgroupSize: u32 = {d},\n", .{value.minSubgroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSubgroupSize: u32 = {d},\n", .{value.maxSubgroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxComputeWorkgroupSubgroups: u32 = {d},\n", .{value.maxComputeWorkgroupSubgroups});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiredSubgroupSizeStages: VkShaderStageFlags = {any},\n", .{value.requiredSubgroupSizeStages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(name: []const u8, value: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiredSubgroupSize: u32 = {d},\n", .{value.requiredSubgroupSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassShadingPipelineCreateInfoHUAWEI(name: []const u8, value: *const vk.VkSubpassShadingPipelineCreateInfoHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassShadingPipelineCreateInfoHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderPass: VkRenderPass = {},\n", .{value.renderPass});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpass: u32 = {d},\n", .{value.subpass});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(name: []const u8, value: *const vk.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSubpassShadingPropertiesHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSubpassShadingWorkgroupSizeAspectRatio: u32 = {d},\n", .{value.maxSubpassShadingWorkgroupSizeAspectRatio});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(name: []const u8, value: *const vk.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxWorkGroupCount: [3]u32 = {any},\n", .{value.maxWorkGroupCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxWorkGroupSize: [3]u32 = {any},\n", .{value.maxWorkGroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxOutputClusterCount: u32 = {d},\n", .{value.maxOutputClusterCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectBufferOffsetAlignment: u64 = {d},\n", .{value.indirectBufferOffsetAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryOpaqueCaptureAddressAllocateInfo(name: []const u8, value: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryOpaqueCaptureAddressAllocateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opaqueCaptureAddress: u64 = {d},\n", .{value.opaqueCaptureAddress});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceMemoryOpaqueCaptureAddressInfo(name: []const u8, value: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceMemoryOpaqueCaptureAddressInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLineRasterizationFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceLineRasterizationFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLineRasterizationFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rectangularLines: u32 = {d},\n", .{value.rectangularLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bresenhamLines: u32 = {d},\n", .{value.bresenhamLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    smoothLines: u32 = {d},\n", .{value.smoothLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stippledRectangularLines: u32 = {d},\n", .{value.stippledRectangularLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stippledBresenhamLines: u32 = {d},\n", .{value.stippledBresenhamLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stippledSmoothLines: u32 = {d},\n", .{value.stippledSmoothLines});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLineRasterizationProperties(name: []const u8, value: *const vk.VkPhysicalDeviceLineRasterizationProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLineRasterizationProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineSubPixelPrecisionBits: u32 = {d},\n", .{value.lineSubPixelPrecisionBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRasterizationLineStateCreateInfo(name: []const u8, value: *const vk.VkPipelineRasterizationLineStateCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRasterizationLineStateCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineRasterizationMode: VkLineRasterizationMode = {t},\n", .{value.lineRasterizationMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stippledLineEnable: u32 = {d},\n", .{value.stippledLineEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineStippleFactor: u32 = {d},\n", .{value.lineStippleFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineStipplePattern: u16 = {d},\n", .{value.lineStipplePattern});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineCreationCacheControlFeatures(name: []const u8, value: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineCreationCacheControlFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCreationCacheControl: u32 = {d},\n", .{value.pipelineCreationCacheControl});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan11Features(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan11Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan11Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageBuffer16BitAccess: u32 = {d},\n", .{value.storageBuffer16BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformAndStorageBuffer16BitAccess: u32 = {d},\n", .{value.uniformAndStorageBuffer16BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storagePushConstant16: u32 = {d},\n", .{value.storagePushConstant16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageInputOutput16: u32 = {d},\n", .{value.storageInputOutput16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiview: u32 = {d},\n", .{value.multiview});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewGeometryShader: u32 = {d},\n", .{value.multiviewGeometryShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewTessellationShader: u32 = {d},\n", .{value.multiviewTessellationShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    variablePointersStorageBuffer: u32 = {d},\n", .{value.variablePointersStorageBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    variablePointers: u32 = {d},\n", .{value.variablePointers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    protectedMemory: u32 = {d},\n", .{value.protectedMemory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerYcbcrConversion: u32 = {d},\n", .{value.samplerYcbcrConversion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDrawParameters: u32 = {d},\n", .{value.shaderDrawParameters});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan11Properties(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan11Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan11Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.deviceUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.driverUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceLUID: [VK_LUID_SIZE]u8 = {any},\n", .{value.deviceLUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceNodeMask: u32 = {d},\n", .{value.deviceNodeMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceLUIDValid: u32 = {d},\n", .{value.deviceLUIDValid});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupSize: u32 = {d},\n", .{value.subgroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupSupportedStages: VkShaderStageFlags = {any},\n", .{value.subgroupSupportedStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupSupportedOperations: VkSubgroupFeatureFlags = {any},\n", .{value.subgroupSupportedOperations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupQuadOperationsInAllStages: u32 = {d},\n", .{value.subgroupQuadOperationsInAllStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pointClippingBehavior: VkPointClippingBehavior = {t},\n", .{value.pointClippingBehavior});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMultiviewViewCount: u32 = {d},\n", .{value.maxMultiviewViewCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMultiviewInstanceIndex: u32 = {d},\n", .{value.maxMultiviewInstanceIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    protectedNoFault: u32 = {d},\n", .{value.protectedNoFault});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerSetDescriptors: u32 = {d},\n", .{value.maxPerSetDescriptors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxMemoryAllocationSize: u64 = {d},\n", .{value.maxMemoryAllocationSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan12Features(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan12Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan12Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerMirrorClampToEdge: u32 = {d},\n", .{value.samplerMirrorClampToEdge});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drawIndirectCount: u32 = {d},\n", .{value.drawIndirectCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageBuffer8BitAccess: u32 = {d},\n", .{value.storageBuffer8BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformAndStorageBuffer8BitAccess: u32 = {d},\n", .{value.uniformAndStorageBuffer8BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storagePushConstant8: u32 = {d},\n", .{value.storagePushConstant8});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBufferInt64Atomics: u32 = {d},\n", .{value.shaderBufferInt64Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSharedInt64Atomics: u32 = {d},\n", .{value.shaderSharedInt64Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloat16: u32 = {d},\n", .{value.shaderFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInt8: u32 = {d},\n", .{value.shaderInt8});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorIndexing: u32 = {d},\n", .{value.descriptorIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInputAttachmentArrayDynamicIndexing: u32 = {d},\n", .{value.shaderInputAttachmentArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformTexelBufferArrayDynamicIndexing: u32 = {d},\n", .{value.shaderUniformTexelBufferArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageTexelBufferArrayDynamicIndexing: u32 = {d},\n", .{value.shaderStorageTexelBufferArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderUniformBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSampledImageArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderSampledImageArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderStorageBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderStorageImageArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInputAttachmentArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderInputAttachmentArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformTexelBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderUniformTexelBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageTexelBufferArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderStorageTexelBufferArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingUniformBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingUniformBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingSampledImageUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingSampledImageUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingStorageImageUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingStorageImageUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingStorageBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingStorageBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingUniformTexelBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingUniformTexelBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingStorageTexelBufferUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingStorageTexelBufferUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingUpdateUnusedWhilePending: u32 = {d},\n", .{value.descriptorBindingUpdateUnusedWhilePending});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingPartiallyBound: u32 = {d},\n", .{value.descriptorBindingPartiallyBound});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingVariableDescriptorCount: u32 = {d},\n", .{value.descriptorBindingVariableDescriptorCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    runtimeDescriptorArray: u32 = {d},\n", .{value.runtimeDescriptorArray});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerFilterMinmax: u32 = {d},\n", .{value.samplerFilterMinmax});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scalarBlockLayout: u32 = {d},\n", .{value.scalarBlockLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imagelessFramebuffer: u32 = {d},\n", .{value.imagelessFramebuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformBufferStandardLayout: u32 = {d},\n", .{value.uniformBufferStandardLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupExtendedTypes: u32 = {d},\n", .{value.shaderSubgroupExtendedTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    separateDepthStencilLayouts: u32 = {d},\n", .{value.separateDepthStencilLayouts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hostQueryReset: u32 = {d},\n", .{value.hostQueryReset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timelineSemaphore: u32 = {d},\n", .{value.timelineSemaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddress: u32 = {d},\n", .{value.bufferDeviceAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddressCaptureReplay: u32 = {d},\n", .{value.bufferDeviceAddressCaptureReplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferDeviceAddressMultiDevice: u32 = {d},\n", .{value.bufferDeviceAddressMultiDevice});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vulkanMemoryModel: u32 = {d},\n", .{value.vulkanMemoryModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vulkanMemoryModelDeviceScope: u32 = {d},\n", .{value.vulkanMemoryModelDeviceScope});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vulkanMemoryModelAvailabilityVisibilityChains: u32 = {d},\n", .{value.vulkanMemoryModelAvailabilityVisibilityChains});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderOutputViewportIndex: u32 = {d},\n", .{value.shaderOutputViewportIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderOutputLayer: u32 = {d},\n", .{value.shaderOutputLayer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupBroadcastDynamicId: u32 = {d},\n", .{value.subgroupBroadcastDynamicId});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan12Properties(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan12Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan12Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverID: VkDriverId = {t},\n", .{value.driverID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverName: [VK_MAX_DRIVER_NAME_SIZE]u8 = {any},\n", .{value.driverName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverInfo: [VK_MAX_DRIVER_INFO_SIZE]u8 = {any},\n", .{value.driverInfo});
    print_VkConformanceVersion("conformanceVersion", &value.conformanceVersion, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    denormBehaviorIndependence: VkShaderFloatControlsIndependence = {t},\n", .{value.denormBehaviorIndependence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    roundingModeIndependence: VkShaderFloatControlsIndependence = {t},\n", .{value.roundingModeIndependence});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSignedZeroInfNanPreserveFloat16: u32 = {d},\n", .{value.shaderSignedZeroInfNanPreserveFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSignedZeroInfNanPreserveFloat32: u32 = {d},\n", .{value.shaderSignedZeroInfNanPreserveFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSignedZeroInfNanPreserveFloat64: u32 = {d},\n", .{value.shaderSignedZeroInfNanPreserveFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormPreserveFloat16: u32 = {d},\n", .{value.shaderDenormPreserveFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormPreserveFloat32: u32 = {d},\n", .{value.shaderDenormPreserveFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormPreserveFloat64: u32 = {d},\n", .{value.shaderDenormPreserveFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormFlushToZeroFloat16: u32 = {d},\n", .{value.shaderDenormFlushToZeroFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormFlushToZeroFloat32: u32 = {d},\n", .{value.shaderDenormFlushToZeroFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDenormFlushToZeroFloat64: u32 = {d},\n", .{value.shaderDenormFlushToZeroFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTEFloat16: u32 = {d},\n", .{value.shaderRoundingModeRTEFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTEFloat32: u32 = {d},\n", .{value.shaderRoundingModeRTEFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTEFloat64: u32 = {d},\n", .{value.shaderRoundingModeRTEFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTZFloat16: u32 = {d},\n", .{value.shaderRoundingModeRTZFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTZFloat32: u32 = {d},\n", .{value.shaderRoundingModeRTZFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRoundingModeRTZFloat64: u32 = {d},\n", .{value.shaderRoundingModeRTZFloat64});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxUpdateAfterBindDescriptorsInAllPools: u32 = {d},\n", .{value.maxUpdateAfterBindDescriptorsInAllPools});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformBufferArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderUniformBufferArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSampledImageArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderSampledImageArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageBufferArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderStorageBufferArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageImageArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderStorageImageArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderInputAttachmentArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderInputAttachmentArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustBufferAccessUpdateAfterBind: u32 = {d},\n", .{value.robustBufferAccessUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    quadDivergentImplicitLod: u32 = {d},\n", .{value.quadDivergentImplicitLod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindSamplers: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindSampledImages: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindSampledImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindStorageImages: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindStorageImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindInputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageUpdateAfterBindResources: u32 = {d},\n", .{value.maxPerStageUpdateAfterBindResources});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindSamplers: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindUniformBuffers: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindStorageBuffers: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindSampledImages: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindSampledImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindStorageImages: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindStorageImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindInputAttachments: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindInputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedDepthResolveModes: VkResolveModeFlags = {any},\n", .{value.supportedDepthResolveModes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedStencilResolveModes: VkResolveModeFlags = {any},\n", .{value.supportedStencilResolveModes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    independentResolveNone: u32 = {d},\n", .{value.independentResolveNone});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    independentResolve: u32 = {d},\n", .{value.independentResolve});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filterMinmaxSingleComponentFormats: u32 = {d},\n", .{value.filterMinmaxSingleComponentFormats});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filterMinmaxImageComponentMapping: u32 = {d},\n", .{value.filterMinmaxImageComponentMapping});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTimelineSemaphoreValueDifference: u64 = {d},\n", .{value.maxTimelineSemaphoreValueDifference});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebufferIntegerColorSampleCounts: VkSampleCountFlags = {any},\n", .{value.framebufferIntegerColorSampleCounts});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan13Features(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan13Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan13Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustImageAccess: u32 = {d},\n", .{value.robustImageAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inlineUniformBlock: u32 = {d},\n", .{value.inlineUniformBlock});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingInlineUniformBlockUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingInlineUniformBlockUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCreationCacheControl: u32 = {d},\n", .{value.pipelineCreationCacheControl});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    privateData: u32 = {d},\n", .{value.privateData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderDemoteToHelperInvocation: u32 = {d},\n", .{value.shaderDemoteToHelperInvocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTerminateInvocation: u32 = {d},\n", .{value.shaderTerminateInvocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subgroupSizeControl: u32 = {d},\n", .{value.subgroupSizeControl});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeFullSubgroups: u32 = {d},\n", .{value.computeFullSubgroups});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    synchronization2: u32 = {d},\n", .{value.synchronization2});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureCompressionASTC_HDR: u32 = {d},\n", .{value.textureCompressionASTC_HDR});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderZeroInitializeWorkgroupMemory: u32 = {d},\n", .{value.shaderZeroInitializeWorkgroupMemory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicRendering: u32 = {d},\n", .{value.dynamicRendering});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderIntegerDotProduct: u32 = {d},\n", .{value.shaderIntegerDotProduct});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance4: u32 = {d},\n", .{value.maintenance4});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan13Properties(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan13Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan13Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minSubgroupSize: u32 = {d},\n", .{value.minSubgroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSubgroupSize: u32 = {d},\n", .{value.maxSubgroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxComputeWorkgroupSubgroups: u32 = {d},\n", .{value.maxComputeWorkgroupSubgroups});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiredSubgroupSizeStages: VkShaderStageFlags = {any},\n", .{value.requiredSubgroupSizeStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInlineUniformBlockSize: u32 = {d},\n", .{value.maxInlineUniformBlockSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorInlineUniformBlocks: u32 = {d},\n", .{value.maxPerStageDescriptorInlineUniformBlocks});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetInlineUniformBlocks: u32 = {d},\n", .{value.maxDescriptorSetInlineUniformBlocks});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindInlineUniformBlocks});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInlineUniformTotalSize: u32 = {d},\n", .{value.maxInlineUniformTotalSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct8BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct8BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct8BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct8BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct8BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct8BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct4x8BitPackedUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct4x8BitPackedUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct4x8BitPackedSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct4x8BitPackedSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct4x8BitPackedMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct4x8BitPackedMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct16BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct16BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct16BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct16BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct16BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct16BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct32BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct32BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct32BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct32BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct32BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct32BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct64BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct64BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct64BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct64BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct64BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct64BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating8BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating8BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating16BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating16BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating32BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating32BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating64BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating64BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageTexelBufferOffsetAlignmentBytes: u64 = {d},\n", .{value.storageTexelBufferOffsetAlignmentBytes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageTexelBufferOffsetSingleTexelAlignment: u32 = {d},\n", .{value.storageTexelBufferOffsetSingleTexelAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformTexelBufferOffsetAlignmentBytes: u64 = {d},\n", .{value.uniformTexelBufferOffsetAlignmentBytes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformTexelBufferOffsetSingleTexelAlignment: u32 = {d},\n", .{value.uniformTexelBufferOffsetSingleTexelAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBufferSize: u64 = {d},\n", .{value.maxBufferSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan14Features(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan14Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan14Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    globalPriorityQuery: u32 = {d},\n", .{value.globalPriorityQuery});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupRotate: u32 = {d},\n", .{value.shaderSubgroupRotate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupRotateClustered: u32 = {d},\n", .{value.shaderSubgroupRotateClustered});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloatControls2: u32 = {d},\n", .{value.shaderFloatControls2});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderExpectAssume: u32 = {d},\n", .{value.shaderExpectAssume});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rectangularLines: u32 = {d},\n", .{value.rectangularLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bresenhamLines: u32 = {d},\n", .{value.bresenhamLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    smoothLines: u32 = {d},\n", .{value.smoothLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stippledRectangularLines: u32 = {d},\n", .{value.stippledRectangularLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stippledBresenhamLines: u32 = {d},\n", .{value.stippledBresenhamLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stippledSmoothLines: u32 = {d},\n", .{value.stippledSmoothLines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexAttributeInstanceRateDivisor: u32 = {d},\n", .{value.vertexAttributeInstanceRateDivisor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexAttributeInstanceRateZeroDivisor: u32 = {d},\n", .{value.vertexAttributeInstanceRateZeroDivisor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexTypeUint8: u32 = {d},\n", .{value.indexTypeUint8});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicRenderingLocalRead: u32 = {d},\n", .{value.dynamicRenderingLocalRead});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance5: u32 = {d},\n", .{value.maintenance5});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maintenance6: u32 = {d},\n", .{value.maintenance6});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineProtectedAccess: u32 = {d},\n", .{value.pipelineProtectedAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineRobustness: u32 = {d},\n", .{value.pipelineRobustness});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hostImageCopy: u32 = {d},\n", .{value.hostImageCopy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushDescriptor: u32 = {d},\n", .{value.pushDescriptor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkan14Properties(name: []const u8, value: *const vk.VkPhysicalDeviceVulkan14Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkan14Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lineSubPixelPrecisionBits: u32 = {d},\n", .{value.lineSubPixelPrecisionBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertexAttribDivisor: u32 = {d},\n", .{value.maxVertexAttribDivisor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportsNonZeroFirstInstance: u32 = {d},\n", .{value.supportsNonZeroFirstInstance});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPushDescriptors: u32 = {d},\n", .{value.maxPushDescriptors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicRenderingLocalReadDepthStencilAttachments: u32 = {d},\n", .{value.dynamicRenderingLocalReadDepthStencilAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicRenderingLocalReadMultisampledAttachments: u32 = {d},\n", .{value.dynamicRenderingLocalReadMultisampledAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    earlyFragmentMultisampleCoverageAfterSampleCounting: u32 = {d},\n", .{value.earlyFragmentMultisampleCoverageAfterSampleCounting});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    earlyFragmentSampleMaskTestBeforeSampleCounting: u32 = {d},\n", .{value.earlyFragmentSampleMaskTestBeforeSampleCounting});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthStencilSwizzleOneSupport: u32 = {d},\n", .{value.depthStencilSwizzleOneSupport});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    polygonModePointSize: u32 = {d},\n", .{value.polygonModePointSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nonStrictSinglePixelWideLinesUseParallelogram: u32 = {d},\n", .{value.nonStrictSinglePixelWideLinesUseParallelogram});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nonStrictWideLinesUseParallelogram: u32 = {d},\n", .{value.nonStrictWideLinesUseParallelogram});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockTexelViewCompatibleMultipleLayers: u32 = {d},\n", .{value.blockTexelViewCompatibleMultipleLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCombinedImageSamplerDescriptorCount: u32 = {d},\n", .{value.maxCombinedImageSamplerDescriptorCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateClampCombinerInputs: u32 = {d},\n", .{value.fragmentShadingRateClampCombinerInputs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.defaultRobustnessStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.defaultRobustnessUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.defaultRobustnessVertexInputs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessImages: VkPipelineRobustnessImageBehavior = {t},\n", .{value.defaultRobustnessImages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    copySrcLayoutCount: u32 = {d},\n", .{value.copySrcLayoutCount});
    if (value.pCopySrcLayouts) |v| {
        for (v[0..value.copySrcLayoutCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCopySrcLayouts: [*]VkImageLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCopySrcLayouts: [*]VkImageLayout = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    copyDstLayoutCount: u32 = {d},\n", .{value.copyDstLayoutCount});
    if (value.pCopyDstLayouts) |v| {
        for (v[0..value.copyDstLayoutCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCopyDstLayouts: [*]VkImageLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCopyDstLayouts: [*]VkImageLayout = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalTilingLayoutUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.optimalTilingLayoutUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identicalMemoryTypeRequirements: u32 = {d},\n", .{value.identicalMemoryTypeRequirements});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineCompilerControlCreateInfoAMD(name: []const u8, value: *const vk.VkPipelineCompilerControlCreateInfoAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineCompilerControlCreateInfoAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compilerControlFlags: VkPipelineCompilerControlFlagsAMD = {any},\n", .{value.compilerControlFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCoherentMemoryFeaturesAMD(name: []const u8, value: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCoherentMemoryFeaturesAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceCoherentMemory: u32 = {d},\n", .{value.deviceCoherentMemory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFaultData(name: []const u8, value: *const vk.VkFaultData, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFaultData = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    faultLevel: VkFaultLevel = {t},\n", .{value.faultLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    faultType: VkFaultType = {t},\n", .{value.faultType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFaultCallbackInfo(name: []const u8, value: *const vk.VkFaultCallbackInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFaultCallbackInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    faultCount: u32 = {d},\n", .{value.faultCount});
    if (value.pFaults) |v| {
        for (v[0..value.faultCount]) |*vv| {
            print_VkFaultData("pFaults", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFaults: [*]VkFaultData = null,\n", .{});
    }
    if (value.pfnFaultCallback) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnFaultCallback: *const vkFaultCallbackFunction = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnFaultCallback: *const vkFaultCallbackFunction = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceToolProperties(name: []const u8, value: *const vk.VkPhysicalDeviceToolProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceToolProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    name: [VK_MAX_EXTENSION_NAME_SIZE]u8 = {any},\n", .{value.name});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    version: [VK_MAX_EXTENSION_NAME_SIZE]u8 = {any},\n", .{value.version});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    purposes: VkToolPurposeFlags = {any},\n", .{value.purposes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layer: [VK_MAX_EXTENSION_NAME_SIZE]u8 = {any},\n", .{value.layer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerCustomBorderColorCreateInfoEXT(name: []const u8, value: *const vk.VkSamplerCustomBorderColorCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerCustomBorderColorCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    customBorderColor: VkClearColorValue = {any},\n", .{value.customBorderColor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCustomBorderColorPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCustomBorderColorPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCustomBorderColorSamplers: u32 = {d},\n", .{value.maxCustomBorderColorSamplers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCustomBorderColorFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCustomBorderColorFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    customBorderColors: u32 = {d},\n", .{value.customBorderColors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    customBorderColorWithoutFormat: u32 = {d},\n", .{value.customBorderColorWithoutFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerBorderColorComponentMappingCreateInfoEXT(name: []const u8, value: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerBorderColorComponentMappingCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkComponentMapping("components", &value.components, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srgb: u32 = {d},\n", .{value.srgb});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    borderColorSwizzle: u32 = {d},\n", .{value.borderColorSwizzle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    borderColorSwizzleFromImage: u32 = {d},\n", .{value.borderColorSwizzleFromImage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureGeometryTrianglesDataKHR(name: []const u8, value: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureGeometryTrianglesDataKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexFormat: VkFormat = {t},\n", .{value.vertexFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.vertexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexStride: u64 = {d},\n", .{value.vertexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxVertex: u32 = {d},\n", .{value.maxVertex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.indexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.transformData});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureGeometryAabbsDataKHR(name: []const u8, value: *const vk.VkAccelerationStructureGeometryAabbsDataKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureGeometryAabbsDataKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    data: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.data});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u64 = {d},\n", .{value.stride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureGeometryInstancesDataKHR(name: []const u8, value: *const vk.VkAccelerationStructureGeometryInstancesDataKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureGeometryInstancesDataKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    arrayOfPointers: u32 = {d},\n", .{value.arrayOfPointers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    data: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.data});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureGeometryLinearSweptSpheresDataNV(name: []const u8, value: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureGeometryLinearSweptSpheresDataNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexFormat: VkFormat = {t},\n", .{value.vertexFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.vertexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexStride: u64 = {d},\n", .{value.vertexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    radiusFormat: VkFormat = {t},\n", .{value.radiusFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    radiusData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.radiusData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    radiusStride: u64 = {d},\n", .{value.radiusStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.indexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexStride: u64 = {d},\n", .{value.indexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexingMode: VkRayTracingLssIndexingModeNV = {t},\n", .{value.indexingMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    endCapsMode: VkRayTracingLssPrimitiveEndCapsModeNV = {t},\n", .{value.endCapsMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureGeometrySpheresDataNV(name: []const u8, value: *const vk.VkAccelerationStructureGeometrySpheresDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureGeometrySpheresDataNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexFormat: VkFormat = {t},\n", .{value.vertexFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.vertexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexStride: u64 = {d},\n", .{value.vertexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    radiusFormat: VkFormat = {t},\n", .{value.radiusFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    radiusData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.radiusData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    radiusStride: u64 = {d},\n", .{value.radiusStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.indexData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexStride: u64 = {d},\n", .{value.indexStride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureGeometryKHR(name: []const u8, value: *const vk.VkAccelerationStructureGeometryKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureGeometryKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryType: VkGeometryTypeKHR = {t},\n", .{value.geometryType});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.geometryType) {
        .VK_GEOMETRY_TYPE_TRIANGLES_KHR => log.output("    geometry: VkAccelerationStructureGeometryDataKHR = {any},\n", .{value.geometry.triangles}),
        .VK_GEOMETRY_TYPE_AABBS_KHR => log.output("    geometry: VkAccelerationStructureGeometryDataKHR = {any},\n", .{value.geometry.aabbs}),
        .VK_GEOMETRY_TYPE_INSTANCES_KHR => log.output("    geometry: VkAccelerationStructureGeometryDataKHR = {any},\n", .{value.geometry.instances}),
        else => log.output("    geometry: VkAccelerationStructureGeometryDataKHR = ???,\n", .{}),
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkGeometryFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureBuildGeometryInfoKHR(name: []const u8, value: *const vk.VkAccelerationStructureBuildGeometryInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureBuildGeometryInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkAccelerationStructureTypeKHR = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkBuildAccelerationStructureFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkBuildAccelerationStructureModeKHR = {t},\n", .{value.mode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccelerationStructure: VkAccelerationStructureKHR = {},\n", .{value.srcAccelerationStructure});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccelerationStructure: VkAccelerationStructureKHR = {},\n", .{value.dstAccelerationStructure});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    geometryCount: u32 = {d},\n", .{value.geometryCount});
    if (value.pGeometries) |v| {
        for (v[0..value.geometryCount]) |*vv| {
            print_VkAccelerationStructureGeometryKHR("pGeometries", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pGeometries: [*]const VkAccelerationStructureGeometryKHR = null,\n", .{});
    }
    if (value.ppGeometries) |v| {
        for (v[0..value.geometryCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppGeometries: [*]const *const VkAccelerationStructureGeometryKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppGeometries: [*]const *const VkAccelerationStructureGeometryKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scratchData: VkDeviceOrHostAddressKHR = {any},\n", .{value.scratchData});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureBuildRangeInfoKHR(name: []const u8, value: *const vk.VkAccelerationStructureBuildRangeInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureBuildRangeInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveCount: u32 = {d},\n", .{value.primitiveCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveOffset: u32 = {d},\n", .{value.primitiveOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstVertex: u32 = {d},\n", .{value.firstVertex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformOffset: u32 = {d},\n", .{value.transformOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureCreateInfoKHR(name: []const u8, value: *const vk.VkAccelerationStructureCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    createFlags: VkAccelerationStructureCreateFlagsKHR = {any},\n", .{value.createFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkAccelerationStructureTypeKHR = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceAddress: u64 = {d},\n", .{value.deviceAddress});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAabbPositionsKHR(name: []const u8, value: *const vk.VkAabbPositionsKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAabbPositionsKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minX: f32 = {d},\n", .{value.minX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minY: f32 = {d},\n", .{value.minY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minZ: f32 = {d},\n", .{value.minZ});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxX: f32 = {d},\n", .{value.maxX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxY: f32 = {d},\n", .{value.maxY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxZ: f32 = {d},\n", .{value.maxZ});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTransformMatrixKHR(name: []const u8, value: *const vk.VkTransformMatrixKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTransformMatrixKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    matrix: [3][4]f32 = {any},\n", .{value.matrix});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureInstanceKHR(name: []const u8, value: *const vk.VkAccelerationStructureInstanceKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureInstanceKHR = .{{\n", .{ name });
    print_VkTransformMatrixKHR("transform", &value.transform, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    packed_field0: <packed> = {any},\n", .{value.packed_field0});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureReference: u64 = {d},\n", .{value.accelerationStructureReference});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureDeviceAddressInfoKHR(name: []const u8, value: *const vk.VkAccelerationStructureDeviceAddressInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureDeviceAddressInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructure: VkAccelerationStructureKHR = {},\n", .{value.accelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureVersionInfoKHR(name: []const u8, value: *const vk.VkAccelerationStructureVersionInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureVersionInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pVersionData) |v| {
        for (v[0..2 * vk.VK_UUID_SIZE]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pVersionData: [*]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVersionData: [*]const u8 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyAccelerationStructureInfoKHR(name: []const u8, value: *const vk.VkCopyAccelerationStructureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyAccelerationStructureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    src: VkAccelerationStructureKHR = {},\n", .{value.src});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dst: VkAccelerationStructureKHR = {},\n", .{value.dst});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkCopyAccelerationStructureModeKHR = {t},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyAccelerationStructureToMemoryInfoKHR(name: []const u8, value: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyAccelerationStructureToMemoryInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    src: VkAccelerationStructureKHR = {},\n", .{value.src});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dst: VkDeviceOrHostAddressKHR = {any},\n", .{value.dst});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkCopyAccelerationStructureModeKHR = {t},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMemoryToAccelerationStructureInfoKHR(name: []const u8, value: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMemoryToAccelerationStructureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    src: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.src});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dst: VkAccelerationStructureKHR = {},\n", .{value.dst});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkCopyAccelerationStructureModeKHR = {t},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRayTracingPipelineInterfaceCreateInfoKHR(name: []const u8, value: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRayTracingPipelineInterfaceCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPipelineRayPayloadSize: u32 = {d},\n", .{value.maxPipelineRayPayloadSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPipelineRayHitAttributeSize: u32 = {d},\n", .{value.maxPipelineRayHitAttributeSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineLibraryCreateInfoKHR(name: []const u8, value: *const vk.VkPipelineLibraryCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineLibraryCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    libraryCount: u32 = {d},\n", .{value.libraryCount});
    if (value.pLibraries) |v| {
        for (v[0..value.libraryCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pLibraries: [*]const VkPipeline = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLibraries: [*]const VkPipeline = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRefreshObjectKHR(name: []const u8, value: *const vk.VkRefreshObjectKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRefreshObjectKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectType: VkObjectType = {t},\n", .{value.objectType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectHandle: u64 = {d},\n", .{value.objectHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkRefreshObjectFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRefreshObjectListKHR(name: []const u8, value: *const vk.VkRefreshObjectListKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRefreshObjectListKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectCount: u32 = {d},\n", .{value.objectCount});
    if (value.pObjects) |v| {
        for (v[0..value.objectCount]) |*vv| {
            print_VkRefreshObjectKHR("pObjects", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pObjects: [*]const VkRefreshObjectKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState: u32 = {d},\n", .{value.extendedDynamicState});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState2: u32 = {d},\n", .{value.extendedDynamicState2});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState2LogicOp: u32 = {d},\n", .{value.extendedDynamicState2LogicOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState2PatchControlPoints: u32 = {d},\n", .{value.extendedDynamicState2PatchControlPoints});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3TessellationDomainOrigin: u32 = {d},\n", .{value.extendedDynamicState3TessellationDomainOrigin});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3DepthClampEnable: u32 = {d},\n", .{value.extendedDynamicState3DepthClampEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3PolygonMode: u32 = {d},\n", .{value.extendedDynamicState3PolygonMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3RasterizationSamples: u32 = {d},\n", .{value.extendedDynamicState3RasterizationSamples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3SampleMask: u32 = {d},\n", .{value.extendedDynamicState3SampleMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3AlphaToCoverageEnable: u32 = {d},\n", .{value.extendedDynamicState3AlphaToCoverageEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3AlphaToOneEnable: u32 = {d},\n", .{value.extendedDynamicState3AlphaToOneEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3LogicOpEnable: u32 = {d},\n", .{value.extendedDynamicState3LogicOpEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ColorBlendEnable: u32 = {d},\n", .{value.extendedDynamicState3ColorBlendEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ColorBlendEquation: u32 = {d},\n", .{value.extendedDynamicState3ColorBlendEquation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ColorWriteMask: u32 = {d},\n", .{value.extendedDynamicState3ColorWriteMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3RasterizationStream: u32 = {d},\n", .{value.extendedDynamicState3RasterizationStream});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ConservativeRasterizationMode: u32 = {d},\n", .{value.extendedDynamicState3ConservativeRasterizationMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ExtraPrimitiveOverestimationSize: u32 = {d},\n", .{value.extendedDynamicState3ExtraPrimitiveOverestimationSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3DepthClipEnable: u32 = {d},\n", .{value.extendedDynamicState3DepthClipEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3SampleLocationsEnable: u32 = {d},\n", .{value.extendedDynamicState3SampleLocationsEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ColorBlendAdvanced: u32 = {d},\n", .{value.extendedDynamicState3ColorBlendAdvanced});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ProvokingVertexMode: u32 = {d},\n", .{value.extendedDynamicState3ProvokingVertexMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3LineRasterizationMode: u32 = {d},\n", .{value.extendedDynamicState3LineRasterizationMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3LineStippleEnable: u32 = {d},\n", .{value.extendedDynamicState3LineStippleEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3DepthClipNegativeOneToOne: u32 = {d},\n", .{value.extendedDynamicState3DepthClipNegativeOneToOne});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ViewportWScalingEnable: u32 = {d},\n", .{value.extendedDynamicState3ViewportWScalingEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ViewportSwizzle: u32 = {d},\n", .{value.extendedDynamicState3ViewportSwizzle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3CoverageToColorEnable: u32 = {d},\n", .{value.extendedDynamicState3CoverageToColorEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3CoverageToColorLocation: u32 = {d},\n", .{value.extendedDynamicState3CoverageToColorLocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3CoverageModulationMode: u32 = {d},\n", .{value.extendedDynamicState3CoverageModulationMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3CoverageModulationTableEnable: u32 = {d},\n", .{value.extendedDynamicState3CoverageModulationTableEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3CoverageModulationTable: u32 = {d},\n", .{value.extendedDynamicState3CoverageModulationTable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3CoverageReductionMode: u32 = {d},\n", .{value.extendedDynamicState3CoverageReductionMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3RepresentativeFragmentTestEnable: u32 = {d},\n", .{value.extendedDynamicState3RepresentativeFragmentTestEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedDynamicState3ShadingRateImageEnable: u32 = {d},\n", .{value.extendedDynamicState3ShadingRateImageEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicPrimitiveTopologyUnrestricted: u32 = {d},\n", .{value.dynamicPrimitiveTopologyUnrestricted});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkColorBlendEquationEXT(name: []const u8, value: *const vk.VkColorBlendEquationEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkColorBlendEquationEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcColorBlendFactor: VkBlendFactor = {t},\n", .{value.srcColorBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstColorBlendFactor: VkBlendFactor = {t},\n", .{value.dstColorBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorBlendOp: VkBlendOp = {t},\n", .{value.colorBlendOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAlphaBlendFactor: VkBlendFactor = {t},\n", .{value.srcAlphaBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAlphaBlendFactor: VkBlendFactor = {t},\n", .{value.dstAlphaBlendFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alphaBlendOp: VkBlendOp = {t},\n", .{value.alphaBlendOp});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkColorBlendAdvancedEXT(name: []const u8, value: *const vk.VkColorBlendAdvancedEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkColorBlendAdvancedEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    advancedBlendOp: VkBlendOp = {t},\n", .{value.advancedBlendOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcPremultiplied: u32 = {d},\n", .{value.srcPremultiplied});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstPremultiplied: u32 = {d},\n", .{value.dstPremultiplied});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blendOverlap: VkBlendOverlapEXT = {t},\n", .{value.blendOverlap});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clampResults: u32 = {d},\n", .{value.clampResults});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassTransformBeginInfoQCOM(name: []const u8, value: *const vk.VkRenderPassTransformBeginInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassTransformBeginInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transform: VkSurfaceTransformFlagsKHR = {any},\n", .{value.transform});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyCommandTransformInfoQCOM(name: []const u8, value: *const vk.VkCopyCommandTransformInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyCommandTransformInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transform: VkSurfaceTransformFlagsKHR = {any},\n", .{value.transform});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(name: []const u8, value: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferInheritanceRenderPassTransformInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transform: VkSurfaceTransformFlagsKHR = {any},\n", .{value.transform});
    print_VkRect2D("renderArea", &value.renderArea, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    partitionedAccelerationStructure: u32 = {d},\n", .{value.partitionedAccelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(name: []const u8, value: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPartitionCount: u32 = {d},\n", .{value.maxPartitionCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBuildPartitionedAccelerationStructureIndirectCommandNV(name: []const u8, value: *const vk.VkBuildPartitionedAccelerationStructureIndirectCommandNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBuildPartitionedAccelerationStructureIndirectCommandNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opType: VkPartitionedAccelerationStructureOpTypeNV = {t},\n", .{value.opType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    argCount: u32 = {d},\n", .{value.argCount});
    print_VkStridedDeviceAddressNV("argData", &value.argData, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPartitionedAccelerationStructureFlagsNV(name: []const u8, value: *const vk.VkPartitionedAccelerationStructureFlagsNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPartitionedAccelerationStructureFlagsNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enablePartitionTranslation: u32 = {d},\n", .{value.enablePartitionTranslation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPartitionedAccelerationStructureWriteInstanceDataNV(name: []const u8, value: *const vk.VkPartitionedAccelerationStructureWriteInstanceDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPartitionedAccelerationStructureWriteInstanceDataNV = .{{\n", .{ name });
    print_VkTransformMatrixKHR("transform", &value.transform, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    explicitAABB: [6]f32 = {any},\n", .{value.explicitAABB});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceID: u32 = {d},\n", .{value.instanceID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceMask: u32 = {d},\n", .{value.instanceMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceContributionToHitGroupIndex: u32 = {d},\n", .{value.instanceContributionToHitGroupIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceFlags: VkPartitionedAccelerationStructureInstanceFlagsNV = {any},\n", .{value.instanceFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceIndex: u32 = {d},\n", .{value.instanceIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    partitionIndex: u32 = {d},\n", .{value.partitionIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructure: u64 = {d},\n", .{value.accelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPartitionedAccelerationStructureUpdateInstanceDataNV(name: []const u8, value: *const vk.VkPartitionedAccelerationStructureUpdateInstanceDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPartitionedAccelerationStructureUpdateInstanceDataNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceIndex: u32 = {d},\n", .{value.instanceIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceContributionToHitGroupIndex: u32 = {d},\n", .{value.instanceContributionToHitGroupIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructure: u64 = {d},\n", .{value.accelerationStructure});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV(name: []const u8, value: *const vk.VkPartitionedAccelerationStructureWritePartitionTranslationDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPartitionedAccelerationStructureWritePartitionTranslationDataNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    partitionIndex: u32 = {d},\n", .{value.partitionIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    partitionTranslation: [3]f32 = {any},\n", .{value.partitionTranslation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteDescriptorSetPartitionedAccelerationStructureNV(name: []const u8, value: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteDescriptorSetPartitionedAccelerationStructureNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureCount: u32 = {d},\n", .{value.accelerationStructureCount});
    if (value.pAccelerationStructures) |v| {
        for (v[0..value.accelerationStructureCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pAccelerationStructures: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAccelerationStructures: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPartitionedAccelerationStructureInstancesInputNV(name: []const u8, value: *const vk.VkPartitionedAccelerationStructureInstancesInputNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPartitionedAccelerationStructureInstancesInputNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkBuildAccelerationStructureFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    instanceCount: u32 = {d},\n", .{value.instanceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInstancePerPartitionCount: u32 = {d},\n", .{value.maxInstancePerPartitionCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    partitionCount: u32 = {d},\n", .{value.partitionCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInstanceInGlobalPartitionCount: u32 = {d},\n", .{value.maxInstanceInGlobalPartitionCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBuildPartitionedAccelerationStructureInfoNV(name: []const u8, value: *const vk.VkBuildPartitionedAccelerationStructureInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBuildPartitionedAccelerationStructureInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkPartitionedAccelerationStructureInstancesInputNV("input", &value.input, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccelerationStructureData: u64 = {d},\n", .{value.srcAccelerationStructureData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccelerationStructureData: u64 = {d},\n", .{value.dstAccelerationStructureData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scratchData: u64 = {d},\n", .{value.scratchData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcInfos: u64 = {d},\n", .{value.srcInfos});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcInfosCount: u64 = {d},\n", .{value.srcInfosCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDiagnosticsConfigFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    diagnosticsConfig: u32 = {d},\n", .{value.diagnosticsConfig});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceDiagnosticsConfigCreateInfoNV(name: []const u8, value: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceDiagnosticsConfigCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDeviceDiagnosticsConfigFlagsNV = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineOfflineCreateInfo(name: []const u8, value: *const vk.VkPipelineOfflineCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineOfflineCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineIdentifier: [VK_UUID_SIZE]u8 = {any},\n", .{value.pipelineIdentifier});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    matchControl: VkPipelineMatchControl = {t},\n", .{value.matchControl});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    poolEntrySize: u64 = {d},\n", .{value.poolEntrySize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderZeroInitializeWorkgroupMemory: u32 = {d},\n", .{value.shaderZeroInitializeWorkgroupMemory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupUniformControlFlow: u32 = {d},\n", .{value.shaderSubgroupUniformControlFlow});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRobustness2FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRobustness2FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustBufferAccess2: u32 = {d},\n", .{value.robustBufferAccess2});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustImageAccess2: u32 = {d},\n", .{value.robustImageAccess2});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nullDescriptor: u32 = {d},\n", .{value.nullDescriptor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRobustness2PropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRobustness2PropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustStorageBufferAccessSizeAlignment: u64 = {d},\n", .{value.robustStorageBufferAccessSizeAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustUniformBufferAccessSizeAlignment: u64 = {d},\n", .{value.robustUniformBufferAccessSizeAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageRobustnessFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceImageRobustnessFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageRobustnessFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustImageAccess: u32 = {d},\n", .{value.robustImageAccess});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    workgroupMemoryExplicitLayout: u32 = {d},\n", .{value.workgroupMemoryExplicitLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    workgroupMemoryExplicitLayoutScalarBlockLayout: u32 = {d},\n", .{value.workgroupMemoryExplicitLayoutScalarBlockLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    workgroupMemoryExplicitLayout8BitAccess: u32 = {d},\n", .{value.workgroupMemoryExplicitLayout8BitAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    workgroupMemoryExplicitLayout16BitAccess: u32 = {d},\n", .{value.workgroupMemoryExplicitLayout16BitAccess});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePortabilitySubsetFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePortabilitySubsetFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePortabilitySubsetFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    constantAlphaColorBlendFactors: u32 = {d},\n", .{value.constantAlphaColorBlendFactors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    events: u32 = {d},\n", .{value.events});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageViewFormatReinterpretation: u32 = {d},\n", .{value.imageViewFormatReinterpretation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageViewFormatSwizzle: u32 = {d},\n", .{value.imageViewFormatSwizzle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView2DOn3DImage: u32 = {d},\n", .{value.imageView2DOn3DImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multisampleArrayImage: u32 = {d},\n", .{value.multisampleArrayImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mutableComparisonSamplers: u32 = {d},\n", .{value.mutableComparisonSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pointPolygons: u32 = {d},\n", .{value.pointPolygons});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerMipLodBias: u32 = {d},\n", .{value.samplerMipLodBias});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    separateStencilMaskRef: u32 = {d},\n", .{value.separateStencilMaskRef});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSampleRateInterpolationFunctions: u32 = {d},\n", .{value.shaderSampleRateInterpolationFunctions});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tessellationIsolines: u32 = {d},\n", .{value.tessellationIsolines});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tessellationPointMode: u32 = {d},\n", .{value.tessellationPointMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    triangleFans: u32 = {d},\n", .{value.triangleFans});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexAttributeAccessBeyondStride: u32 = {d},\n", .{value.vertexAttributeAccessBeyondStride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePortabilitySubsetPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePortabilitySubsetPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePortabilitySubsetPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minVertexInputBindingStrideAlignment: u32 = {d},\n", .{value.minVertexInputBindingStrideAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevice4444FormatsFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevice4444FormatsFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatA4R4G4B4: u32 = {d},\n", .{value.formatA4R4G4B4});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatA4B4G4R4: u32 = {d},\n", .{value.formatA4B4G4R4});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(name: []const u8, value: *const vk.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassShading: u32 = {d},\n", .{value.subpassShading});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(name: []const u8, value: *const vk.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clustercullingShader: u32 = {d},\n", .{value.clustercullingShader});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewClusterCullingShader: u32 = {d},\n", .{value.multiviewClusterCullingShader});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(name: []const u8, value: *const vk.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clusterShadingRate: u32 = {d},\n", .{value.clusterShadingRate});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCopy2(name: []const u8, value: *const vk.VkBufferCopy2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCopy2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcOffset: u64 = {d},\n", .{value.srcOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstOffset: u64 = {d},\n", .{value.dstOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageCopy2(name: []const u8, value: *const vk.VkImageCopy2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageCopy2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkImageSubresourceLayers("srcSubresource", &value.srcSubresource, offset + 1);
    print_VkOffset3D("srcOffset", &value.srcOffset, offset + 1);
    print_VkImageSubresourceLayers("dstSubresource", &value.dstSubresource, offset + 1);
    print_VkOffset3D("dstOffset", &value.dstOffset, offset + 1);
    print_VkExtent3D("extent", &value.extent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageBlit2(name: []const u8, value: *const vk.VkImageBlit2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageBlit2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkImageSubresourceLayers("srcSubresource", &value.srcSubresource, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcOffsets: [2]VkOffset3D = {any},\n", .{value.srcOffsets});
    print_VkImageSubresourceLayers("dstSubresource", &value.dstSubresource, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstOffsets: [2]VkOffset3D = {any},\n", .{value.dstOffsets});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferImageCopy2(name: []const u8, value: *const vk.VkBufferImageCopy2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferImageCopy2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferOffset: u64 = {d},\n", .{value.bufferOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferRowLength: u32 = {d},\n", .{value.bufferRowLength});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferImageHeight: u32 = {d},\n", .{value.bufferImageHeight});
    print_VkImageSubresourceLayers("imageSubresource", &value.imageSubresource, offset + 1);
    print_VkOffset3D("imageOffset", &value.imageOffset, offset + 1);
    print_VkExtent3D("imageExtent", &value.imageExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageResolve2(name: []const u8, value: *const vk.VkImageResolve2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageResolve2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkImageSubresourceLayers("srcSubresource", &value.srcSubresource, offset + 1);
    print_VkOffset3D("srcOffset", &value.srcOffset, offset + 1);
    print_VkImageSubresourceLayers("dstSubresource", &value.dstSubresource, offset + 1);
    print_VkOffset3D("dstOffset", &value.dstOffset, offset + 1);
    print_VkExtent3D("extent", &value.extent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyBufferInfo2(name: []const u8, value: *const vk.VkCopyBufferInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyBufferInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcBuffer: VkBuffer = {},\n", .{value.srcBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBuffer: VkBuffer = {},\n", .{value.dstBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkBufferCopy2("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkBufferCopy2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyImageInfo2(name: []const u8, value: *const vk.VkCopyImageInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyImageInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImage: VkImage = {},\n", .{value.srcImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImageLayout: VkImageLayout = {t},\n", .{value.srcImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImage: VkImage = {},\n", .{value.dstImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImageLayout: VkImageLayout = {t},\n", .{value.dstImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkImageCopy2("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkImageCopy2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBlitImageInfo2(name: []const u8, value: *const vk.VkBlitImageInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBlitImageInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImage: VkImage = {},\n", .{value.srcImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImageLayout: VkImageLayout = {t},\n", .{value.srcImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImage: VkImage = {},\n", .{value.dstImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImageLayout: VkImageLayout = {t},\n", .{value.dstImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkImageBlit2("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkImageBlit2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filter: VkFilter = {t},\n", .{value.filter});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyBufferToImageInfo2(name: []const u8, value: *const vk.VkCopyBufferToImageInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyBufferToImageInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcBuffer: VkBuffer = {},\n", .{value.srcBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImage: VkImage = {},\n", .{value.dstImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImageLayout: VkImageLayout = {t},\n", .{value.dstImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkBufferImageCopy2("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkBufferImageCopy2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyImageToBufferInfo2(name: []const u8, value: *const vk.VkCopyImageToBufferInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyImageToBufferInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImage: VkImage = {},\n", .{value.srcImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImageLayout: VkImageLayout = {t},\n", .{value.srcImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBuffer: VkBuffer = {},\n", .{value.dstBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkBufferImageCopy2("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkBufferImageCopy2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkResolveImageInfo2(name: []const u8, value: *const vk.VkResolveImageInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkResolveImageInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImage: VkImage = {},\n", .{value.srcImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImageLayout: VkImageLayout = {t},\n", .{value.srcImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImage: VkImage = {},\n", .{value.dstImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImageLayout: VkImageLayout = {t},\n", .{value.dstImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkImageResolve2("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkImageResolve2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderImageInt64Atomics: u32 = {d},\n", .{value.shaderImageInt64Atomics});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sparseImageInt64Atomics: u32 = {d},\n", .{value.sparseImageInt64Atomics});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFragmentShadingRateAttachmentInfoKHR(name: []const u8, value: *const vk.VkFragmentShadingRateAttachmentInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFragmentShadingRateAttachmentInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pFragmentShadingRateAttachment) |v| {
        print_VkAttachmentReference2("pFragmentShadingRateAttachment", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFragmentShadingRateAttachment: *const VkAttachmentReference2 = null,\n", .{});
    }
    print_VkExtent2D("shadingRateAttachmentTexelSize", &value.shadingRateAttachmentTexelSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineFragmentShadingRateStateCreateInfoKHR(name: []const u8, value: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineFragmentShadingRateStateCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("fragmentSize", &value.fragmentSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    combinerOps: [2]VkFragmentShadingRateCombinerOpKHR = {any},\n", .{value.combinerOps});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShadingRateFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineFragmentShadingRate: u32 = {d},\n", .{value.pipelineFragmentShadingRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveFragmentShadingRate: u32 = {d},\n", .{value.primitiveFragmentShadingRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentFragmentShadingRate: u32 = {d},\n", .{value.attachmentFragmentShadingRate});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShadingRatePropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("minFragmentShadingRateAttachmentTexelSize", &value.minFragmentShadingRateAttachmentTexelSize, offset + 1);
    print_VkExtent2D("maxFragmentShadingRateAttachmentTexelSize", &value.maxFragmentShadingRateAttachmentTexelSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32 = {d},\n", .{value.maxFragmentShadingRateAttachmentTexelSizeAspectRatio});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitiveFragmentShadingRateWithMultipleViewports: u32 = {d},\n", .{value.primitiveFragmentShadingRateWithMultipleViewports});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layeredShadingRateAttachments: u32 = {d},\n", .{value.layeredShadingRateAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateNonTrivialCombinerOps: u32 = {d},\n", .{value.fragmentShadingRateNonTrivialCombinerOps});
    print_VkExtent2D("maxFragmentSize", &value.maxFragmentSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentSizeAspectRatio: u32 = {d},\n", .{value.maxFragmentSizeAspectRatio});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentShadingRateCoverageSamples: u32 = {d},\n", .{value.maxFragmentShadingRateCoverageSamples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentShadingRateRasterizationSamples: VkSampleCountFlags = {any},\n", .{value.maxFragmentShadingRateRasterizationSamples});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateWithShaderDepthStencilWrites: u32 = {d},\n", .{value.fragmentShadingRateWithShaderDepthStencilWrites});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateWithSampleMask: u32 = {d},\n", .{value.fragmentShadingRateWithSampleMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateWithShaderSampleMask: u32 = {d},\n", .{value.fragmentShadingRateWithShaderSampleMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateWithConservativeRasterization: u32 = {d},\n", .{value.fragmentShadingRateWithConservativeRasterization});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateWithFragmentShaderInterlock: u32 = {d},\n", .{value.fragmentShadingRateWithFragmentShaderInterlock});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateWithCustomSampleLocations: u32 = {d},\n", .{value.fragmentShadingRateWithCustomSampleLocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateStrictMultiplyCombiner: u32 = {d},\n", .{value.fragmentShadingRateStrictMultiplyCombiner});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShadingRateKHR(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShadingRateKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShadingRateKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampleCounts: VkSampleCountFlags = {any},\n", .{value.sampleCounts});
    print_VkExtent2D("fragmentSize", &value.fragmentSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderTerminateInvocationFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderTerminateInvocationFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTerminateInvocation: u32 = {d},\n", .{value.shaderTerminateInvocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShadingRateEnums: u32 = {d},\n", .{value.fragmentShadingRateEnums});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supersampleFragmentShadingRates: u32 = {d},\n", .{value.supersampleFragmentShadingRates});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    noInvocationFragmentShadingRates: u32 = {d},\n", .{value.noInvocationFragmentShadingRates});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentShadingRateInvocationCount: VkSampleCountFlags = {any},\n", .{value.maxFragmentShadingRateInvocationCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(name: []const u8, value: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineFragmentShadingRateEnumStateCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRateType: VkFragmentShadingRateTypeNV = {t},\n", .{value.shadingRateType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shadingRate: VkFragmentShadingRateNV = {t},\n", .{value.shadingRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    combinerOps: [2]VkFragmentShadingRateCombinerOpKHR = {any},\n", .{value.combinerOps});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureBuildSizesInfoKHR(name: []const u8, value: *const vk.VkAccelerationStructureBuildSizesInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureBuildSizesInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureSize: u64 = {d},\n", .{value.accelerationStructureSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    updateScratchSize: u64 = {d},\n", .{value.updateScratchSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buildScratchSize: u64 = {d},\n", .{value.buildScratchSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image2DViewOf3D: u32 = {d},\n", .{value.image2DViewOf3D});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampler2DViewOf3D: u32 = {d},\n", .{value.sampler2DViewOf3D});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageSlicedViewOf3D: u32 = {d},\n", .{value.imageSlicedViewOf3D});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentFeedbackLoopDynamicState: u32 = {d},\n", .{value.attachmentFeedbackLoopDynamicState});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    legacyVertexAttributes: u32 = {d},\n", .{value.legacyVertexAttributes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nativeUnalignedPerformance: u32 = {d},\n", .{value.nativeUnalignedPerformance});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mutableDescriptorType: u32 = {d},\n", .{value.mutableDescriptorType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMutableDescriptorTypeListEXT(name: []const u8, value: *const vk.VkMutableDescriptorTypeListEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMutableDescriptorTypeListEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorTypeCount: u32 = {d},\n", .{value.descriptorTypeCount});
    if (value.pDescriptorTypes) |v| {
        for (v[0..value.descriptorTypeCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDescriptorTypes: [*]const VkDescriptorType = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDescriptorTypes: [*]const VkDescriptorType = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMutableDescriptorTypeCreateInfoEXT(name: []const u8, value: *const vk.VkMutableDescriptorTypeCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMutableDescriptorTypeCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mutableDescriptorTypeListCount: u32 = {d},\n", .{value.mutableDescriptorTypeListCount});
    if (value.pMutableDescriptorTypeLists) |v| {
        for (v[0..value.mutableDescriptorTypeListCount]) |*vv| {
            print_VkMutableDescriptorTypeListEXT("pMutableDescriptorTypeLists", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pMutableDescriptorTypeLists: [*]const VkMutableDescriptorTypeListEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDepthClipControlFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDepthClipControlFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClipControl: u32 = {d},\n", .{value.depthClipControl});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    zeroInitializeDeviceMemory: u32 = {d},\n", .{value.zeroInitializeDeviceMemory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBeginCustomResolveInfoEXT(name: []const u8, value: *const vk.VkBeginCustomResolveInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBeginCustomResolveInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCustomResolveFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceCustomResolveFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCustomResolveFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    customResolve: u32 = {d},\n", .{value.customResolve});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCustomResolveCreateInfoEXT(name: []const u8, value: *const vk.VkCustomResolveCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCustomResolveCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    customResolve: u32 = {d},\n", .{value.customResolve});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachmentFormats) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorAttachmentFormats: [*]const VkFormat = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachmentFormats: [*]const VkFormat = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthAttachmentFormat: VkFormat = {t},\n", .{value.depthAttachmentFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilAttachmentFormat: VkFormat = {t},\n", .{value.stencilAttachmentFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceGeneratedCommands: u32 = {d},\n", .{value.deviceGeneratedCommands});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicGeneratedPipelineLayout: u32 = {d},\n", .{value.dynamicGeneratedPipelineLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectPipelineCount: u32 = {d},\n", .{value.maxIndirectPipelineCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectShaderObjectCount: u32 = {d},\n", .{value.maxIndirectShaderObjectCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectSequenceCount: u32 = {d},\n", .{value.maxIndirectSequenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectCommandsTokenCount: u32 = {d},\n", .{value.maxIndirectCommandsTokenCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectCommandsTokenOffset: u32 = {d},\n", .{value.maxIndirectCommandsTokenOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIndirectCommandsIndirectStride: u32 = {d},\n", .{value.maxIndirectCommandsIndirectStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedIndirectCommandsInputModes: VkIndirectCommandsInputModeFlagsEXT = {any},\n", .{value.supportedIndirectCommandsInputModes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedIndirectCommandsShaderStages: VkShaderStageFlags = {any},\n", .{value.supportedIndirectCommandsShaderStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedIndirectCommandsShaderStagesPipelineBinding: VkShaderStageFlags = {any},\n", .{value.supportedIndirectCommandsShaderStagesPipelineBinding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedIndirectCommandsShaderStagesShaderBinding: VkShaderStageFlags = {any},\n", .{value.supportedIndirectCommandsShaderStagesShaderBinding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceGeneratedCommandsTransformFeedback: u32 = {d},\n", .{value.deviceGeneratedCommandsTransformFeedback});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceGeneratedCommandsMultiDrawIndirectCount: u32 = {d},\n", .{value.deviceGeneratedCommandsMultiDrawIndirectCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeneratedCommandsPipelineInfoEXT(name: []const u8, value: *const vk.VkGeneratedCommandsPipelineInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeneratedCommandsPipelineInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeneratedCommandsShaderInfoEXT(name: []const u8, value: *const vk.VkGeneratedCommandsShaderInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeneratedCommandsShaderInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCount: u32 = {d},\n", .{value.shaderCount});
    if (value.pShaders) |v| {
        for (v[0..value.shaderCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pShaders: [*]const VkShaderEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pShaders: [*]const VkShaderEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeneratedCommandsMemoryRequirementsInfoEXT(name: []const u8, value: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeneratedCommandsMemoryRequirementsInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectExecutionSet: VkIndirectExecutionSetEXT = {},\n", .{value.indirectExecutionSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectCommandsLayout: VkIndirectCommandsLayoutEXT = {},\n", .{value.indirectCommandsLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSequenceCount: u32 = {d},\n", .{value.maxSequenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDrawCount: u32 = {d},\n", .{value.maxDrawCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectExecutionSetPipelineInfoEXT(name: []const u8, value: *const vk.VkIndirectExecutionSetPipelineInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectExecutionSetPipelineInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialPipeline: VkPipeline = {},\n", .{value.initialPipeline});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPipelineCount: u32 = {d},\n", .{value.maxPipelineCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectExecutionSetShaderLayoutInfoEXT(name: []const u8, value: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectExecutionSetShaderLayoutInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    setLayoutCount: u32 = {d},\n", .{value.setLayoutCount});
    if (value.pSetLayouts) |v| {
        for (v[0..value.setLayoutCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectExecutionSetShaderInfoEXT(name: []const u8, value: *const vk.VkIndirectExecutionSetShaderInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectExecutionSetShaderInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCount: u32 = {d},\n", .{value.shaderCount});
    if (value.pInitialShaders) |v| {
        for (v[0..value.shaderCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pInitialShaders: [*]const VkShaderEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pInitialShaders: [*]const VkShaderEXT = null,\n", .{});
    }
    if (value.pSetLayoutInfos) |v| {
        for (v[0..value.shaderCount]) |*vv| {
            print_VkIndirectExecutionSetShaderLayoutInfoEXT("pSetLayoutInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSetLayoutInfos: [*]const VkIndirectExecutionSetShaderLayoutInfoEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxShaderCount: u32 = {d},\n", .{value.maxShaderCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushConstantRangeCount: u32 = {d},\n", .{value.pushConstantRangeCount});
    if (value.pPushConstantRanges) |v| {
        for (v[0..value.pushConstantRangeCount]) |*vv| {
            print_VkPushConstantRange("pPushConstantRanges", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPushConstantRanges: [*]const VkPushConstantRange = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectExecutionSetCreateInfoEXT(name: []const u8, value: *const vk.VkIndirectExecutionSetCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectExecutionSetCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkIndirectExecutionSetInfoTypeEXT = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.type) {
        .VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT => log.output("    info: VkIndirectExecutionSetInfoEXT = {any},\n", .{value.info.pPipelineInfo}),
        .VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT => log.output("    info: VkIndirectExecutionSetInfoEXT = {any},\n", .{value.info.pShaderInfo}),
        else => log.output("    info: VkIndirectExecutionSetInfoEXT = ???,\n", .{}),
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGeneratedCommandsInfoEXT(name: []const u8, value: *const vk.VkGeneratedCommandsInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGeneratedCommandsInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStages: VkShaderStageFlags = {any},\n", .{value.shaderStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectExecutionSet: VkIndirectExecutionSetEXT = {},\n", .{value.indirectExecutionSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectCommandsLayout: VkIndirectCommandsLayoutEXT = {},\n", .{value.indirectCommandsLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectAddress: u64 = {d},\n", .{value.indirectAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectAddressSize: u64 = {d},\n", .{value.indirectAddressSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preprocessAddress: u64 = {d},\n", .{value.preprocessAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preprocessSize: u64 = {d},\n", .{value.preprocessSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSequenceCount: u32 = {d},\n", .{value.maxSequenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sequenceCountAddress: u64 = {d},\n", .{value.sequenceCountAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDrawCount: u32 = {d},\n", .{value.maxDrawCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteIndirectExecutionSetPipelineEXT(name: []const u8, value: *const vk.VkWriteIndirectExecutionSetPipelineEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteIndirectExecutionSetPipelineEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    index: u32 = {d},\n", .{value.index});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipeline: VkPipeline = {},\n", .{value.pipeline});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteIndirectExecutionSetShaderEXT(name: []const u8, value: *const vk.VkWriteIndirectExecutionSetShaderEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteIndirectExecutionSetShaderEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    index: u32 = {d},\n", .{value.index});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shader: VkShaderEXT = {},\n", .{value.shader});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsLayoutCreateInfoEXT(name: []const u8, value: *const vk.VkIndirectCommandsLayoutCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsLayoutCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkIndirectCommandsLayoutUsageFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStages: VkShaderStageFlags = {any},\n", .{value.shaderStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indirectStride: u32 = {d},\n", .{value.indirectStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineLayout: VkPipelineLayout = {},\n", .{value.pipelineLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tokenCount: u32 = {d},\n", .{value.tokenCount});
    if (value.pTokens) |v| {
        for (v[0..value.tokenCount]) |*vv| {
            print_VkIndirectCommandsLayoutTokenEXT("pTokens", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTokens: [*]const VkIndirectCommandsLayoutTokenEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsLayoutTokenEXT(name: []const u8, value: *const vk.VkIndirectCommandsLayoutTokenEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsLayoutTokenEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkIndirectCommandsTokenTypeEXT = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.type) {
        .VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT => log.output("    data: VkIndirectCommandsTokenDataEXT = {any},\n", .{value.data.pExecutionSet}),
        .VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT => log.output("    data: VkIndirectCommandsTokenDataEXT = {any},\n", .{value.data.pIndexBuffer}),
        .VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT => log.output("    data: VkIndirectCommandsTokenDataEXT = {any},\n", .{value.data.pVertexBuffer}),
        else => log.output("    data: VkIndirectCommandsTokenDataEXT = ???,\n", .{}),
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u32 = {d},\n", .{value.offset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrawIndirectCountIndirectCommandEXT(name: []const u8, value: *const vk.VkDrawIndirectCountIndirectCommandEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrawIndirectCountIndirectCommandEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferAddress: u64 = {d},\n", .{value.bufferAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u32 = {d},\n", .{value.stride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandCount: u32 = {d},\n", .{value.commandCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsVertexBufferTokenEXT(name: []const u8, value: *const vk.VkIndirectCommandsVertexBufferTokenEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsVertexBufferTokenEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexBindingUnit: u32 = {d},\n", .{value.vertexBindingUnit});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindVertexBufferIndirectCommandEXT(name: []const u8, value: *const vk.VkBindVertexBufferIndirectCommandEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindVertexBufferIndirectCommandEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferAddress: u64 = {d},\n", .{value.bufferAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u32 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u32 = {d},\n", .{value.stride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsIndexBufferTokenEXT(name: []const u8, value: *const vk.VkIndirectCommandsIndexBufferTokenEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsIndexBufferTokenEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkIndirectCommandsInputModeFlagsEXT = {any},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindIndexBufferIndirectCommandEXT(name: []const u8, value: *const vk.VkBindIndexBufferIndirectCommandEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindIndexBufferIndirectCommandEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferAddress: u64 = {d},\n", .{value.bufferAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u32 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsPushConstantTokenEXT(name: []const u8, value: *const vk.VkIndirectCommandsPushConstantTokenEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsPushConstantTokenEXT = .{{\n", .{ name });
    print_VkPushConstantRange("updateRange", &value.updateRange, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkIndirectCommandsExecutionSetTokenEXT(name: []const u8, value: *const vk.VkIndirectCommandsExecutionSetTokenEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkIndirectCommandsExecutionSetTokenEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkIndirectExecutionSetInfoTypeEXT = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStages: VkShaderStageFlags = {any},\n", .{value.shaderStages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportDepthClipControlCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportDepthClipControlCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    negativeOneToOne: u32 = {d},\n", .{value.negativeOneToOne});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDepthClampControlFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDepthClampControlFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClampControl: u32 = {d},\n", .{value.depthClampControl});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineViewportDepthClampControlCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineViewportDepthClampControlCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClampMode: VkDepthClampModeEXT = {t},\n", .{value.depthClampMode});
    if (value.pDepthClampRange) |v| {
        print_VkDepthClampRangeEXT("pDepthClampRange", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthClampRange: *const VkDepthClampRangeEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexInputDynamicState: u32 = {d},\n", .{value.vertexInputDynamicState});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalMemoryRDMA: u32 = {d},\n", .{value.externalMemoryRDMA});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRelaxedExtendedInstruction: u32 = {d},\n", .{value.shaderRelaxedExtendedInstruction});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVertexInputBindingDescription2EXT(name: []const u8, value: *const vk.VkVertexInputBindingDescription2EXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVertexInputBindingDescription2EXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u32 = {d},\n", .{value.stride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputRate: VkVertexInputRate = {t},\n", .{value.inputRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    divisor: u32 = {d},\n", .{value.divisor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVertexInputAttributeDescription2EXT(name: []const u8, value: *const vk.VkVertexInputAttributeDescription2EXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVertexInputAttributeDescription2EXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    location: u32 = {d},\n", .{value.location});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u32 = {d},\n", .{value.offset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceColorWriteEnableFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceColorWriteEnableFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorWriteEnable: u32 = {d},\n", .{value.colorWriteEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineColorWriteCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineColorWriteCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineColorWriteCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentCount: u32 = {d},\n", .{value.attachmentCount});
    if (value.pColorWriteEnables) |v| {
        for (v[0..value.attachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorWriteEnables: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorWriteEnables: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryBarrier2(name: []const u8, value: *const vk.VkMemoryBarrier2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryBarrier2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcStageMask: VkPipelineStageFlags2 = {any},\n", .{value.srcStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags2 = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstStageMask: VkPipelineStageFlags2 = {any},\n", .{value.dstStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags2 = {any},\n", .{value.dstAccessMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageMemoryBarrier2(name: []const u8, value: *const vk.VkImageMemoryBarrier2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageMemoryBarrier2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcStageMask: VkPipelineStageFlags2 = {any},\n", .{value.srcStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags2 = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstStageMask: VkPipelineStageFlags2 = {any},\n", .{value.dstStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags2 = {any},\n", .{value.dstAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    oldLayout: VkImageLayout = {t},\n", .{value.oldLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    newLayout: VkImageLayout = {t},\n", .{value.newLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcQueueFamilyIndex: u32 = {d},\n", .{value.srcQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstQueueFamilyIndex: u32 = {d},\n", .{value.dstQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    print_VkImageSubresourceRange("subresourceRange", &value.subresourceRange, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferMemoryBarrier2(name: []const u8, value: *const vk.VkBufferMemoryBarrier2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferMemoryBarrier2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcStageMask: VkPipelineStageFlags2 = {any},\n", .{value.srcStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags2 = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstStageMask: VkPipelineStageFlags2 = {any},\n", .{value.dstStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags2 = {any},\n", .{value.dstAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcQueueFamilyIndex: u32 = {d},\n", .{value.srcQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstQueueFamilyIndex: u32 = {d},\n", .{value.dstQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryBarrierAccessFlags3KHR(name: []const u8, value: *const vk.VkMemoryBarrierAccessFlags3KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryBarrierAccessFlags3KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask3: VkAccessFlags3KHR = {any},\n", .{value.srcAccessMask3});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask3: VkAccessFlags3KHR = {any},\n", .{value.dstAccessMask3});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDependencyInfo(name: []const u8, value: *const vk.VkDependencyInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDependencyInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dependencyFlags: VkDependencyFlags = {any},\n", .{value.dependencyFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryBarrierCount: u32 = {d},\n", .{value.memoryBarrierCount});
    if (value.pMemoryBarriers) |v| {
        for (v[0..value.memoryBarrierCount]) |*vv| {
            print_VkMemoryBarrier2("pMemoryBarriers", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pMemoryBarriers: [*]const VkMemoryBarrier2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferMemoryBarrierCount: u32 = {d},\n", .{value.bufferMemoryBarrierCount});
    if (value.pBufferMemoryBarriers) |v| {
        for (v[0..value.bufferMemoryBarrierCount]) |*vv| {
            print_VkBufferMemoryBarrier2("pBufferMemoryBarriers", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBufferMemoryBarriers: [*]const VkBufferMemoryBarrier2 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageMemoryBarrierCount: u32 = {d},\n", .{value.imageMemoryBarrierCount});
    if (value.pImageMemoryBarriers) |v| {
        for (v[0..value.imageMemoryBarrierCount]) |*vv| {
            print_VkImageMemoryBarrier2("pImageMemoryBarriers", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImageMemoryBarriers: [*]const VkImageMemoryBarrier2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSemaphoreSubmitInfo(name: []const u8, value: *const vk.VkSemaphoreSubmitInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSemaphoreSubmitInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    value: u64 = {d},\n", .{value.value});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageMask: VkPipelineStageFlags2 = {any},\n", .{value.stageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceIndex: u32 = {d},\n", .{value.deviceIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferSubmitInfo(name: []const u8, value: *const vk.VkCommandBufferSubmitInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferSubmitInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBuffer: VkCommandBuffer = {},\n", .{value.commandBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceMask: u32 = {d},\n", .{value.deviceMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubmitInfo2(name: []const u8, value: *const vk.VkSubmitInfo2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubmitInfo2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSubmitFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    waitSemaphoreInfoCount: u32 = {d},\n", .{value.waitSemaphoreInfoCount});
    if (value.pWaitSemaphoreInfos) |v| {
        for (v[0..value.waitSemaphoreInfoCount]) |*vv| {
            print_VkSemaphoreSubmitInfo("pWaitSemaphoreInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pWaitSemaphoreInfos: [*]const VkSemaphoreSubmitInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferInfoCount: u32 = {d},\n", .{value.commandBufferInfoCount});
    if (value.pCommandBufferInfos) |v| {
        for (v[0..value.commandBufferInfoCount]) |*vv| {
            print_VkCommandBufferSubmitInfo("pCommandBufferInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCommandBufferInfos: [*]const VkCommandBufferSubmitInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    signalSemaphoreInfoCount: u32 = {d},\n", .{value.signalSemaphoreInfoCount});
    if (value.pSignalSemaphoreInfos) |v| {
        for (v[0..value.signalSemaphoreInfoCount]) |*vv| {
            print_VkSemaphoreSubmitInfo("pSignalSemaphoreInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSignalSemaphoreInfos: [*]const VkSemaphoreSubmitInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyCheckpointProperties2NV(name: []const u8, value: *const vk.VkQueueFamilyCheckpointProperties2NV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyCheckpointProperties2NV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    checkpointExecutionStageMask: VkPipelineStageFlags2 = {any},\n", .{value.checkpointExecutionStageMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCheckpointData2NV(name: []const u8, value: *const vk.VkCheckpointData2NV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCheckpointData2NV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stage: VkPipelineStageFlags2 = {any},\n", .{value.stage});
    if (value.pCheckpointMarker) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCheckpointMarker: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCheckpointMarker: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSynchronization2Features(name: []const u8, value: *const vk.VkPhysicalDeviceSynchronization2Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSynchronization2Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    synchronization2: u32 = {d},\n", .{value.synchronization2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    unifiedImageLayouts: u32 = {d},\n", .{value.unifiedImageLayouts});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    unifiedImageLayoutsVideo: u32 = {d},\n", .{value.unifiedImageLayoutsVideo});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceHostImageCopyFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceHostImageCopyFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceHostImageCopyFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hostImageCopy: u32 = {d},\n", .{value.hostImageCopy});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceHostImageCopyProperties(name: []const u8, value: *const vk.VkPhysicalDeviceHostImageCopyProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceHostImageCopyProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    copySrcLayoutCount: u32 = {d},\n", .{value.copySrcLayoutCount});
    if (value.pCopySrcLayouts) |v| {
        for (v[0..value.copySrcLayoutCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCopySrcLayouts: [*]VkImageLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCopySrcLayouts: [*]VkImageLayout = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    copyDstLayoutCount: u32 = {d},\n", .{value.copyDstLayoutCount});
    if (value.pCopyDstLayouts) |v| {
        for (v[0..value.copyDstLayoutCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pCopyDstLayouts: [*]VkImageLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCopyDstLayouts: [*]VkImageLayout = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalTilingLayoutUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.optimalTilingLayoutUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identicalMemoryTypeRequirements: u32 = {d},\n", .{value.identicalMemoryTypeRequirements});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryToImageCopy(name: []const u8, value: *const vk.VkMemoryToImageCopy, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryToImageCopy = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pHostPointer) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pHostPointer: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pHostPointer: *const anyopaque = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryRowLength: u32 = {d},\n", .{value.memoryRowLength});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryImageHeight: u32 = {d},\n", .{value.memoryImageHeight});
    print_VkImageSubresourceLayers("imageSubresource", &value.imageSubresource, offset + 1);
    print_VkOffset3D("imageOffset", &value.imageOffset, offset + 1);
    print_VkExtent3D("imageExtent", &value.imageExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageToMemoryCopy(name: []const u8, value: *const vk.VkImageToMemoryCopy, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageToMemoryCopy = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pHostPointer) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pHostPointer: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pHostPointer: *anyopaque = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryRowLength: u32 = {d},\n", .{value.memoryRowLength});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryImageHeight: u32 = {d},\n", .{value.memoryImageHeight});
    print_VkImageSubresourceLayers("imageSubresource", &value.imageSubresource, offset + 1);
    print_VkOffset3D("imageOffset", &value.imageOffset, offset + 1);
    print_VkExtent3D("imageExtent", &value.imageExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMemoryToImageInfo(name: []const u8, value: *const vk.VkCopyMemoryToImageInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMemoryToImageInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkHostImageCopyFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImage: VkImage = {},\n", .{value.dstImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImageLayout: VkImageLayout = {t},\n", .{value.dstImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkMemoryToImageCopy("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkMemoryToImageCopy = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyImageToMemoryInfo(name: []const u8, value: *const vk.VkCopyImageToMemoryInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyImageToMemoryInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkHostImageCopyFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImage: VkImage = {},\n", .{value.srcImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImageLayout: VkImageLayout = {t},\n", .{value.srcImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkImageToMemoryCopy("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkImageToMemoryCopy = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyImageToImageInfo(name: []const u8, value: *const vk.VkCopyImageToImageInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyImageToImageInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkHostImageCopyFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImage: VkImage = {},\n", .{value.srcImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcImageLayout: VkImageLayout = {t},\n", .{value.srcImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImage: VkImage = {},\n", .{value.dstImage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstImageLayout: VkImageLayout = {t},\n", .{value.dstImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkImageCopy2("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkImageCopy2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkHostImageLayoutTransitionInfo(name: []const u8, value: *const vk.VkHostImageLayoutTransitionInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkHostImageLayoutTransitionInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    oldLayout: VkImageLayout = {t},\n", .{value.oldLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    newLayout: VkImageLayout = {t},\n", .{value.newLayout});
    print_VkImageSubresourceRange("subresourceRange", &value.subresourceRange, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubresourceHostMemcpySize(name: []const u8, value: *const vk.VkSubresourceHostMemcpySize, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubresourceHostMemcpySize = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkHostImageCopyDevicePerformanceQuery(name: []const u8, value: *const vk.VkHostImageCopyDevicePerformanceQuery, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkHostImageCopyDevicePerformanceQuery = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalDeviceAccess: u32 = {d},\n", .{value.optimalDeviceAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identicalMemoryLayout: u32 = {d},\n", .{value.identicalMemoryLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkanSC10Properties(name: []const u8, value: *const vk.VkPhysicalDeviceVulkanSC10Properties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkanSC10Properties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceNoDynamicHostAllocations: u32 = {d},\n", .{value.deviceNoDynamicHostAllocations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceDestroyFreesMemory: u32 = {d},\n", .{value.deviceDestroyFreesMemory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPoolMultipleCommandBuffersRecording: u32 = {d},\n", .{value.commandPoolMultipleCommandBuffersRecording});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPoolResetCommandBuffer: u32 = {d},\n", .{value.commandPoolResetCommandBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferSimultaneousUse: u32 = {d},\n", .{value.commandBufferSimultaneousUse});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    secondaryCommandBufferNullOrImagelessFramebuffer: u32 = {d},\n", .{value.secondaryCommandBufferNullOrImagelessFramebuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    recycleDescriptorSetMemory: u32 = {d},\n", .{value.recycleDescriptorSetMemory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    recyclePipelineMemory: u32 = {d},\n", .{value.recyclePipelineMemory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRenderPassSubpasses: u32 = {d},\n", .{value.maxRenderPassSubpasses});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRenderPassDependencies: u32 = {d},\n", .{value.maxRenderPassDependencies});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSubpassInputAttachments: u32 = {d},\n", .{value.maxSubpassInputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSubpassPreserveAttachments: u32 = {d},\n", .{value.maxSubpassPreserveAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFramebufferAttachments: u32 = {d},\n", .{value.maxFramebufferAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetLayoutBindings: u32 = {d},\n", .{value.maxDescriptorSetLayoutBindings});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQueryFaultCount: u32 = {d},\n", .{value.maxQueryFaultCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCallbackFaultCount: u32 = {d},\n", .{value.maxCallbackFaultCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCommandPoolCommandBuffers: u32 = {d},\n", .{value.maxCommandPoolCommandBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCommandBufferSize: u64 = {d},\n", .{value.maxCommandBufferSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelinePoolSize(name: []const u8, value: *const vk.VkPipelinePoolSize, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelinePoolSize = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    poolEntrySize: u64 = {d},\n", .{value.poolEntrySize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    poolEntryCount: u32 = {d},\n", .{value.poolEntryCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceObjectReservationCreateInfo(name: []const u8, value: *const vk.VkDeviceObjectReservationCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceObjectReservationCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCacheCreateInfoCount: u32 = {d},\n", .{value.pipelineCacheCreateInfoCount});
    if (value.pPipelineCacheCreateInfos) |v| {
        for (v[0..value.pipelineCacheCreateInfoCount]) |*vv| {
            print_VkPipelineCacheCreateInfo("pPipelineCacheCreateInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelineCacheCreateInfos: [*]const VkPipelineCacheCreateInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelinePoolSizeCount: u32 = {d},\n", .{value.pipelinePoolSizeCount});
    if (value.pPipelinePoolSizes) |v| {
        for (v[0..value.pipelinePoolSizeCount]) |*vv| {
            print_VkPipelinePoolSize("pPipelinePoolSizes", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPipelinePoolSizes: [*]const VkPipelinePoolSize = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphoreRequestCount: u32 = {d},\n", .{value.semaphoreRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferRequestCount: u32 = {d},\n", .{value.commandBufferRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fenceRequestCount: u32 = {d},\n", .{value.fenceRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceMemoryRequestCount: u32 = {d},\n", .{value.deviceMemoryRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferRequestCount: u32 = {d},\n", .{value.bufferRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageRequestCount: u32 = {d},\n", .{value.imageRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    eventRequestCount: u32 = {d},\n", .{value.eventRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queryPoolRequestCount: u32 = {d},\n", .{value.queryPoolRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferViewRequestCount: u32 = {d},\n", .{value.bufferViewRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageViewRequestCount: u32 = {d},\n", .{value.imageViewRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layeredImageViewRequestCount: u32 = {d},\n", .{value.layeredImageViewRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCacheRequestCount: u32 = {d},\n", .{value.pipelineCacheRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineLayoutRequestCount: u32 = {d},\n", .{value.pipelineLayoutRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderPassRequestCount: u32 = {d},\n", .{value.renderPassRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    graphicsPipelineRequestCount: u32 = {d},\n", .{value.graphicsPipelineRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computePipelineRequestCount: u32 = {d},\n", .{value.computePipelineRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetLayoutRequestCount: u32 = {d},\n", .{value.descriptorSetLayoutRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerRequestCount: u32 = {d},\n", .{value.samplerRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorPoolRequestCount: u32 = {d},\n", .{value.descriptorPoolRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetRequestCount: u32 = {d},\n", .{value.descriptorSetRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framebufferRequestCount: u32 = {d},\n", .{value.framebufferRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPoolRequestCount: u32 = {d},\n", .{value.commandPoolRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerYcbcrConversionRequestCount: u32 = {d},\n", .{value.samplerYcbcrConversionRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    surfaceRequestCount: u32 = {d},\n", .{value.surfaceRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainRequestCount: u32 = {d},\n", .{value.swapchainRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displayModeRequestCount: u32 = {d},\n", .{value.displayModeRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassDescriptionRequestCount: u32 = {d},\n", .{value.subpassDescriptionRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentDescriptionRequestCount: u32 = {d},\n", .{value.attachmentDescriptionRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetLayoutBindingRequestCount: u32 = {d},\n", .{value.descriptorSetLayoutBindingRequestCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetLayoutBindingLimit: u32 = {d},\n", .{value.descriptorSetLayoutBindingLimit});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageViewMipLevels: u32 = {d},\n", .{value.maxImageViewMipLevels});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImageViewArrayLayers: u32 = {d},\n", .{value.maxImageViewArrayLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxLayeredImageViewMipLevels: u32 = {d},\n", .{value.maxLayeredImageViewMipLevels});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxOcclusionQueriesPerPool: u32 = {d},\n", .{value.maxOcclusionQueriesPerPool});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPipelineStatisticsQueriesPerPool: u32 = {d},\n", .{value.maxPipelineStatisticsQueriesPerPool});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTimestampQueriesPerPool: u32 = {d},\n", .{value.maxTimestampQueriesPerPool});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxImmutableSamplersPerDescriptorSetLayout: u32 = {d},\n", .{value.maxImmutableSamplersPerDescriptorSetLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandPoolMemoryReservationCreateInfo(name: []const u8, value: *const vk.VkCommandPoolMemoryReservationCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandPoolMemoryReservationCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPoolReservedSize: u64 = {d},\n", .{value.commandPoolReservedSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPoolMaxCommandBuffers: u32 = {d},\n", .{value.commandPoolMaxCommandBuffers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandPoolMemoryConsumption(name: []const u8, value: *const vk.VkCommandPoolMemoryConsumption, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandPoolMemoryConsumption = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPoolAllocated: u64 = {d},\n", .{value.commandPoolAllocated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandPoolReservedSize: u64 = {d},\n", .{value.commandPoolReservedSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferAllocated: u64 = {d},\n", .{value.commandBufferAllocated});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVulkanSC10Features(name: []const u8, value: *const vk.VkPhysicalDeviceVulkanSC10Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVulkanSC10Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderAtomicInstructions: u32 = {d},\n", .{value.shaderAtomicInstructions});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitivesGeneratedQuery: u32 = {d},\n", .{value.primitivesGeneratedQuery});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitivesGeneratedQueryWithRasterizerDiscard: u32 = {d},\n", .{value.primitivesGeneratedQueryWithRasterizerDiscard});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primitivesGeneratedQueryWithNonZeroStreams: u32 = {d},\n", .{value.primitivesGeneratedQueryWithNonZeroStreams});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLegacyDitheringFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLegacyDitheringFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    legacyDithering: u32 = {d},\n", .{value.legacyDithering});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multisampledRenderToSingleSampled: u32 = {d},\n", .{value.multisampledRenderToSingleSampled});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCapabilitiesPresentId2KHR(name: []const u8, value: *const vk.VkSurfaceCapabilitiesPresentId2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCapabilitiesPresentId2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentId2Supported: u32 = {d},\n", .{value.presentId2Supported});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCapabilitiesPresentWait2KHR(name: []const u8, value: *const vk.VkSurfaceCapabilitiesPresentWait2KHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCapabilitiesPresentWait2KHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentWait2Supported: u32 = {d},\n", .{value.presentWait2Supported});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubpassResolvePerformanceQueryEXT(name: []const u8, value: *const vk.VkSubpassResolvePerformanceQueryEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubpassResolvePerformanceQueryEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimal: u32 = {d},\n", .{value.optimal});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMultisampledRenderToSingleSampledInfoEXT(name: []const u8, value: *const vk.VkMultisampledRenderToSingleSampledInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMultisampledRenderToSingleSampledInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multisampledRenderToSingleSampledEnable: u32 = {d},\n", .{value.multisampledRenderToSingleSampledEnable});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationSamples: VkSampleCountFlags = {any},\n", .{value.rasterizationSamples});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineProtectedAccessFeatures(name: []const u8, value: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineProtectedAccessFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineProtectedAccess: u32 = {d},\n", .{value.pipelineProtectedAccess});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyVideoPropertiesKHR(name: []const u8, value: *const vk.VkQueueFamilyVideoPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyVideoPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoCodecOperations: VkVideoCodecOperationFlagsKHR = {any},\n", .{value.videoCodecOperations});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyQueryResultStatusPropertiesKHR(name: []const u8, value: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyQueryResultStatusPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queryResultStatusSupport: u32 = {d},\n", .{value.queryResultStatusSupport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoProfileListInfoKHR(name: []const u8, value: *const vk.VkVideoProfileListInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoProfileListInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    profileCount: u32 = {d},\n", .{value.profileCount});
    if (value.pProfiles) |v| {
        for (v[0..value.profileCount]) |*vv| {
            print_VkVideoProfileInfoKHR("pProfiles", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pProfiles: [*]const VkVideoProfileInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoFormatInfoKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoFormatInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoFormatInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageUsage: VkImageUsageFlags = {any},\n", .{value.imageUsage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoFormatPropertiesKHR(name: []const u8, value: *const vk.VkVideoFormatPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoFormatPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    print_VkComponentMapping("componentMapping", &value.componentMapping, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCreateFlags: VkImageCreateFlags = {any},\n", .{value.imageCreateFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageType: VkImageType = {t},\n", .{value.imageType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageTiling: VkImageTiling = {t},\n", .{value.imageTiling});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageUsageFlags: VkImageUsageFlags = {any},\n", .{value.imageUsageFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeQuantizationMapCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeQuantizationMapCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("maxQuantizationMapExtent", &value.maxQuantizationMapExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeH264QuantizationMapCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264QuantizationMapCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minQpDelta: i32 = {d},\n", .{value.minQpDelta});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQpDelta: i32 = {d},\n", .{value.maxQpDelta});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeH265QuantizationMapCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265QuantizationMapCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minQpDelta: i32 = {d},\n", .{value.minQpDelta});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQpDelta: i32 = {d},\n", .{value.maxQpDelta});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1QuantizationMapCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minQIndexDelta: i32 = {d},\n", .{value.minQIndexDelta});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQIndexDelta: i32 = {d},\n", .{value.maxQIndexDelta});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoFormatQuantizationMapPropertiesKHR(name: []const u8, value: *const vk.VkVideoFormatQuantizationMapPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoFormatQuantizationMapPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("quantizationMapTexelSize", &value.quantizationMapTexelSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoFormatH265QuantizationMapPropertiesKHR(name: []const u8, value: *const vk.VkVideoFormatH265QuantizationMapPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoFormatH265QuantizationMapPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compatibleCtbSizes: VkVideoEncodeH265CtbSizeFlagsKHR = {any},\n", .{value.compatibleCtbSizes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoFormatAV1QuantizationMapPropertiesKHR(name: []const u8, value: *const vk.VkVideoFormatAV1QuantizationMapPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoFormatAV1QuantizationMapPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compatibleSuperblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR = {any},\n", .{value.compatibleSuperblockSizes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoProfileInfoKHR(name: []const u8, value: *const vk.VkVideoProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoCodecOperation: VkVideoCodecOperationFlagsKHR = {any},\n", .{value.videoCodecOperation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    chromaSubsampling: VkVideoChromaSubsamplingFlagsKHR = {any},\n", .{value.chromaSubsampling});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lumaBitDepth: VkVideoComponentBitDepthFlagsKHR = {any},\n", .{value.lumaBitDepth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    chromaBitDepth: VkVideoComponentBitDepthFlagsKHR = {any},\n", .{value.chromaBitDepth});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoCapabilityFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minBitstreamBufferOffsetAlignment: u64 = {d},\n", .{value.minBitstreamBufferOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minBitstreamBufferSizeAlignment: u64 = {d},\n", .{value.minBitstreamBufferSizeAlignment});
    print_VkExtent2D("pictureAccessGranularity", &value.pictureAccessGranularity, offset + 1);
    print_VkExtent2D("minCodedExtent", &value.minCodedExtent, offset + 1);
    print_VkExtent2D("maxCodedExtent", &value.maxCodedExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDpbSlots: u32 = {d},\n", .{value.maxDpbSlots});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxActiveReferencePictures: u32 = {d},\n", .{value.maxActiveReferencePictures});
    print_VkExtensionProperties("stdHeaderVersion", &value.stdHeaderVersion, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoSessionMemoryRequirementsKHR(name: []const u8, value: *const vk.VkVideoSessionMemoryRequirementsKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoSessionMemoryRequirementsKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryBindIndex: u32 = {d},\n", .{value.memoryBindIndex});
    print_VkMemoryRequirements("memoryRequirements", &value.memoryRequirements, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindVideoSessionMemoryInfoKHR(name: []const u8, value: *const vk.VkBindVideoSessionMemoryInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindVideoSessionMemoryInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryBindIndex: u32 = {d},\n", .{value.memoryBindIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memorySize: u64 = {d},\n", .{value.memorySize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoPictureResourceInfoKHR(name: []const u8, value: *const vk.VkVideoPictureResourceInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoPictureResourceInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkOffset2D("codedOffset", &value.codedOffset, offset + 1);
    print_VkExtent2D("codedExtent", &value.codedExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseArrayLayer: u32 = {d},\n", .{value.baseArrayLayer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageViewBinding: VkImageView = {},\n", .{value.imageViewBinding});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoReferenceSlotInfoKHR(name: []const u8, value: *const vk.VkVideoReferenceSlotInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoReferenceSlotInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    slotIndex: i32 = {d},\n", .{value.slotIndex});
    if (value.pPictureResource) |v| {
        print_VkVideoPictureResourceInfoKHR("pPictureResource", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPictureResource: *const VkVideoPictureResourceInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoDecodeCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoDecodeCapabilityFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeUsageInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeUsageInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeUsageInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoUsageHints: VkVideoDecodeUsageFlagsKHR = {any},\n", .{value.videoUsageHints});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoDecodeFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcBuffer: VkBuffer = {},\n", .{value.srcBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcBufferOffset: u64 = {d},\n", .{value.srcBufferOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcBufferRange: u64 = {d},\n", .{value.srcBufferRange});
    print_VkVideoPictureResourceInfoKHR("dstPictureResource", &value.dstPictureResource, offset + 1);
    if (value.pSetupReferenceSlot) |v| {
        print_VkVideoReferenceSlotInfoKHR("pSetupReferenceSlot", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSetupReferenceSlot: *const VkVideoReferenceSlotInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    referenceSlotCount: u32 = {d},\n", .{value.referenceSlotCount});
    if (value.pReferenceSlots) |v| {
        for (v[0..value.referenceSlotCount]) |*vv| {
            print_VkVideoReferenceSlotInfoKHR("pReferenceSlots", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pReferenceSlots: [*]const VkVideoReferenceSlotInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoMaintenance1FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoMaintenance1: u32 = {d},\n", .{value.videoMaintenance1});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoMaintenance2FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoMaintenance2: u32 = {d},\n", .{value.videoMaintenance2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoInlineQueryInfoKHR(name: []const u8, value: *const vk.VkVideoInlineQueryInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoInlineQueryInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queryPool: VkQueryPool = {},\n", .{value.queryPool});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstQuery: u32 = {d},\n", .{value.firstQuery});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queryCount: u32 = {d},\n", .{value.queryCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH264ProfileInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH264ProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH264ProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pictureLayout: VkVideoDecodeH264PictureLayoutFlagsKHR = {any},\n", .{value.pictureLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH264CapabilitiesKHR(name: []const u8, value: *const vk.VkVideoDecodeH264CapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH264CapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkOffset2D("fieldOffsetGranularity", &value.fieldOffsetGranularity, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH264SessionParametersAddInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH264SessionParametersAddInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH264SessionParametersAddInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSPSCount: u32 = {d},\n", .{value.stdSPSCount});
    if (value.pStdSPSs) |v| {
        for (v[0..value.stdSPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdSPSs: [*]const StdVideoH264SequenceParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPSs: [*]const StdVideoH264SequenceParameterSet = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdPPSCount: u32 = {d},\n", .{value.stdPPSCount});
    if (value.pStdPPSs) |v| {
        for (v[0..value.stdPPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdPPSs: [*]const StdVideoH264PictureParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPSs: [*]const StdVideoH264PictureParameterSet = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH264SessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH264SessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH264SessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdSPSCount: u32 = {d},\n", .{value.maxStdSPSCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdPPSCount: u32 = {d},\n", .{value.maxStdPPSCount});
    if (value.pParametersAddInfo) |v| {
        print_VkVideoDecodeH264SessionParametersAddInfoKHR("pParametersAddInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pParametersAddInfo: *const VkVideoDecodeH264SessionParametersAddInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH264InlineSessionParametersInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH264InlineSessionParametersInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH264InlineSessionParametersInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdSPS) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPS: *const StdVideoH264SequenceParameterSet = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPS: *const StdVideoH264SequenceParameterSet = null,\n", .{});
    }
    if (value.pStdPPS) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPS: *const StdVideoH264PictureParameterSet = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPS: *const StdVideoH264PictureParameterSet = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH264PictureInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH264PictureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH264PictureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdPictureInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeH264PictureInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeH264PictureInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sliceCount: u32 = {d},\n", .{value.sliceCount});
    if (value.pSliceOffsets) |v| {
        for (v[0..value.sliceCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSliceOffsets: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSliceOffsets: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH264DpbSlotInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH264DpbSlotInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH264DpbSlotInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdReferenceInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoDecodeH264ReferenceInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoDecodeH264ReferenceInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH265ProfileInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH265ProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH265ProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH265CapabilitiesKHR(name: []const u8, value: *const vk.VkVideoDecodeH265CapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH265CapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH265SessionParametersAddInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH265SessionParametersAddInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH265SessionParametersAddInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdVPSCount: u32 = {d},\n", .{value.stdVPSCount});
    if (value.pStdVPSs) |v| {
        for (v[0..value.stdVPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdVPSs: [*]const StdVideoH265VideoParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdVPSs: [*]const StdVideoH265VideoParameterSet = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSPSCount: u32 = {d},\n", .{value.stdSPSCount});
    if (value.pStdSPSs) |v| {
        for (v[0..value.stdSPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdSPSs: [*]const StdVideoH265SequenceParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPSs: [*]const StdVideoH265SequenceParameterSet = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdPPSCount: u32 = {d},\n", .{value.stdPPSCount});
    if (value.pStdPPSs) |v| {
        for (v[0..value.stdPPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdPPSs: [*]const StdVideoH265PictureParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPSs: [*]const StdVideoH265PictureParameterSet = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH265SessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH265SessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH265SessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdVPSCount: u32 = {d},\n", .{value.maxStdVPSCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdSPSCount: u32 = {d},\n", .{value.maxStdSPSCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdPPSCount: u32 = {d},\n", .{value.maxStdPPSCount});
    if (value.pParametersAddInfo) |v| {
        print_VkVideoDecodeH265SessionParametersAddInfoKHR("pParametersAddInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pParametersAddInfo: *const VkVideoDecodeH265SessionParametersAddInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH265InlineSessionParametersInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH265InlineSessionParametersInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH265InlineSessionParametersInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdVPS) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdVPS: *const StdVideoH265VideoParameterSet = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdVPS: *const StdVideoH265VideoParameterSet = null,\n", .{});
    }
    if (value.pStdSPS) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPS: *const StdVideoH265SequenceParameterSet = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPS: *const StdVideoH265SequenceParameterSet = null,\n", .{});
    }
    if (value.pStdPPS) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPS: *const StdVideoH265PictureParameterSet = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPS: *const StdVideoH265PictureParameterSet = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH265PictureInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH265PictureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH265PictureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdPictureInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeH265PictureInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeH265PictureInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sliceSegmentCount: u32 = {d},\n", .{value.sliceSegmentCount});
    if (value.pSliceSegmentOffsets) |v| {
        for (v[0..value.sliceSegmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSliceSegmentOffsets: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSliceSegmentOffsets: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeH265DpbSlotInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeH265DpbSlotInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeH265DpbSlotInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdReferenceInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoDecodeH265ReferenceInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoDecodeH265ReferenceInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoDecodeVP9FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoDecodeVP9: u32 = {d},\n", .{value.videoDecodeVP9});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeVP9ProfileInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeVP9ProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeVP9ProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeVP9CapabilitiesKHR(name: []const u8, value: *const vk.VkVideoDecodeVP9CapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeVP9CapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeVP9PictureInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeVP9PictureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeVP9PictureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdPictureInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeVP9PictureInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeVP9PictureInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    referenceNameSlotIndices: [VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR]i32 = {any},\n", .{value.referenceNameSlotIndices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uncompressedHeaderOffset: u32 = {d},\n", .{value.uncompressedHeaderOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compressedHeaderOffset: u32 = {d},\n", .{value.compressedHeaderOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tilesOffset: u32 = {d},\n", .{value.tilesOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeAV1ProfileInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeAV1ProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeAV1ProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    filmGrainSupport: u32 = {d},\n", .{value.filmGrainSupport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeAV1CapabilitiesKHR(name: []const u8, value: *const vk.VkVideoDecodeAV1CapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeAV1CapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeAV1SessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeAV1SessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeAV1SessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdSequenceHeader) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSequenceHeader: *const StdVideoAV1SequenceHeader = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSequenceHeader: *const StdVideoAV1SequenceHeader = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeAV1InlineSessionParametersInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeAV1InlineSessionParametersInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeAV1InlineSessionParametersInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdSequenceHeader) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSequenceHeader: *const StdVideoAV1SequenceHeader = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSequenceHeader: *const StdVideoAV1SequenceHeader = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeAV1PictureInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeAV1PictureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeAV1PictureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdPictureInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeAV1PictureInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoDecodeAV1PictureInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    referenceNameSlotIndices: [VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32 = {any},\n", .{value.referenceNameSlotIndices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameHeaderOffset: u32 = {d},\n", .{value.frameHeaderOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileCount: u32 = {d},\n", .{value.tileCount});
    if (value.pTileOffsets) |v| {
        for (v[0..value.tileCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pTileOffsets: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTileOffsets: [*]const u32 = null,\n", .{});
    }
    if (value.pTileSizes) |v| {
        for (v[0..value.tileCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pTileSizes: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTileSizes: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoDecodeAV1DpbSlotInfoKHR(name: []const u8, value: *const vk.VkVideoDecodeAV1DpbSlotInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoDecodeAV1DpbSlotInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdReferenceInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoDecodeAV1ReferenceInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoDecodeAV1ReferenceInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoSessionCreateInfoKHR(name: []const u8, value: *const vk.VkVideoSessionCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoSessionCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndex: u32 = {d},\n", .{value.queueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoSessionCreateFlagsKHR = {any},\n", .{value.flags});
    if (value.pVideoProfile) |v| {
        print_VkVideoProfileInfoKHR("pVideoProfile", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVideoProfile: *const VkVideoProfileInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pictureFormat: VkFormat = {t},\n", .{value.pictureFormat});
    print_VkExtent2D("maxCodedExtent", &value.maxCodedExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    referencePictureFormat: VkFormat = {t},\n", .{value.referencePictureFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDpbSlots: u32 = {d},\n", .{value.maxDpbSlots});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxActiveReferencePictures: u32 = {d},\n", .{value.maxActiveReferencePictures});
    if (value.pStdHeaderVersion) |v| {
        print_VkExtensionProperties("pStdHeaderVersion", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdHeaderVersion: *const VkExtensionProperties = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoSessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoSessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoSessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoSessionParametersCreateFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoSessionParametersTemplate: VkVideoSessionParametersKHR = {},\n", .{value.videoSessionParametersTemplate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoSession: VkVideoSessionKHR = {},\n", .{value.videoSession});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoSessionParametersUpdateInfoKHR(name: []const u8, value: *const vk.VkVideoSessionParametersUpdateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoSessionParametersUpdateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    updateSequenceCount: u32 = {d},\n", .{value.updateSequenceCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeSessionParametersGetInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeSessionParametersGetInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeSessionParametersGetInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoSessionParameters: VkVideoSessionParametersKHR = {},\n", .{value.videoSessionParameters});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeSessionParametersFeedbackInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeSessionParametersFeedbackInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasOverrides: u32 = {d},\n", .{value.hasOverrides});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoBeginCodingInfoKHR(name: []const u8, value: *const vk.VkVideoBeginCodingInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoBeginCodingInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoBeginCodingFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoSession: VkVideoSessionKHR = {},\n", .{value.videoSession});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoSessionParameters: VkVideoSessionParametersKHR = {},\n", .{value.videoSessionParameters});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    referenceSlotCount: u32 = {d},\n", .{value.referenceSlotCount});
    if (value.pReferenceSlots) |v| {
        for (v[0..value.referenceSlotCount]) |*vv| {
            print_VkVideoReferenceSlotInfoKHR("pReferenceSlots", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pReferenceSlots: [*]const VkVideoReferenceSlotInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEndCodingInfoKHR(name: []const u8, value: *const vk.VkVideoEndCodingInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEndCodingInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEndCodingFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoCodingControlInfoKHR(name: []const u8, value: *const vk.VkVideoCodingControlInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoCodingControlInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoCodingControlFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeUsageInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeUsageInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeUsageInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoUsageHints: VkVideoEncodeUsageFlagsKHR = {any},\n", .{value.videoUsageHints});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoContentHints: VkVideoEncodeContentFlagsKHR = {any},\n", .{value.videoContentHints});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tuningMode: VkVideoEncodeTuningModeKHR = {t},\n", .{value.tuningMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBuffer: VkBuffer = {},\n", .{value.dstBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBufferOffset: u64 = {d},\n", .{value.dstBufferOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstBufferRange: u64 = {d},\n", .{value.dstBufferRange});
    print_VkVideoPictureResourceInfoKHR("srcPictureResource", &value.srcPictureResource, offset + 1);
    if (value.pSetupReferenceSlot) |v| {
        print_VkVideoReferenceSlotInfoKHR("pSetupReferenceSlot", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSetupReferenceSlot: *const VkVideoReferenceSlotInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    referenceSlotCount: u32 = {d},\n", .{value.referenceSlotCount});
    if (value.pReferenceSlots) |v| {
        for (v[0..value.referenceSlotCount]) |*vv| {
            print_VkVideoReferenceSlotInfoKHR("pReferenceSlots", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pReferenceSlots: [*]const VkVideoReferenceSlotInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    precedingExternallyEncodedBytes: u32 = {d},\n", .{value.precedingExternallyEncodedBytes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeQuantizationMapInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeQuantizationMapInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeQuantizationMapInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    quantizationMap: VkImageView = {},\n", .{value.quantizationMap});
    print_VkExtent2D("quantizationMapExtent", &value.quantizationMapExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("quantizationMapTexelSize", &value.quantizationMapTexelSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoEncodeQuantizationMap: u32 = {d},\n", .{value.videoEncodeQuantizationMap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(name: []const u8, value: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    encodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR = {any},\n", .{value.encodeFeedbackFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeQualityLevelInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeQualityLevelInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeQualityLevelInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qualityLevel: u32 = {d},\n", .{value.qualityLevel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pVideoProfile) |v| {
        print_VkVideoProfileInfoKHR("pVideoProfile", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVideoProfile: *const VkVideoProfileInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qualityLevel: u32 = {d},\n", .{value.qualityLevel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeQualityLevelPropertiesKHR(name: []const u8, value: *const vk.VkVideoEncodeQualityLevelPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeQualityLevelPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredRateControlMode: VkVideoEncodeRateControlModeFlagsKHR = {any},\n", .{value.preferredRateControlMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredRateControlLayerCount: u32 = {d},\n", .{value.preferredRateControlLayerCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeRateControlInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeRateControlInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeRateControlInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeRateControlFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rateControlMode: VkVideoEncodeRateControlModeFlagsKHR = {any},\n", .{value.rateControlMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layerCount: u32 = {d},\n", .{value.layerCount});
    if (value.pLayers) |v| {
        for (v[0..value.layerCount]) |*vv| {
            print_VkVideoEncodeRateControlLayerInfoKHR("pLayers", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLayers: [*]const VkVideoEncodeRateControlLayerInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    virtualBufferSizeInMs: u32 = {d},\n", .{value.virtualBufferSizeInMs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    initialVirtualBufferSizeInMs: u32 = {d},\n", .{value.initialVirtualBufferSizeInMs});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeRateControlLayerInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeRateControlLayerInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeRateControlLayerInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    averageBitrate: u64 = {d},\n", .{value.averageBitrate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBitrate: u64 = {d},\n", .{value.maxBitrate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameRateNumerator: u32 = {d},\n", .{value.frameRateNumerator});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameRateDenominator: u32 = {d},\n", .{value.frameRateDenominator});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeCapabilityFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rateControlModes: VkVideoEncodeRateControlModeFlagsKHR = {any},\n", .{value.rateControlModes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRateControlLayers: u32 = {d},\n", .{value.maxRateControlLayers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBitrate: u64 = {d},\n", .{value.maxBitrate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQualityLevels: u32 = {d},\n", .{value.maxQualityLevels});
    print_VkExtent2D("encodeInputPictureGranularity", &value.encodeInputPictureGranularity, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedEncodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR = {any},\n", .{value.supportedEncodeFeedbackFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264CapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeH264CapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264CapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeH264CapabilityFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSliceCount: u32 = {d},\n", .{value.maxSliceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPPictureL0ReferenceCount: u32 = {d},\n", .{value.maxPPictureL0ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBPictureL0ReferenceCount: u32 = {d},\n", .{value.maxBPictureL0ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxL1ReferenceCount: u32 = {d},\n", .{value.maxL1ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTemporalLayerCount: u32 = {d},\n", .{value.maxTemporalLayerCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    expectDyadicTemporalLayerPattern: u32 = {d},\n", .{value.expectDyadicTemporalLayerPattern});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minQp: i32 = {d},\n", .{value.minQp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQp: i32 = {d},\n", .{value.maxQp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersGopRemainingFrames: u32 = {d},\n", .{value.prefersGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiresGopRemainingFrames: u32 = {d},\n", .{value.requiresGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSyntaxFlags: VkVideoEncodeH264StdFlagsKHR = {any},\n", .{value.stdSyntaxFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264QualityLevelPropertiesKHR(name: []const u8, value: *const vk.VkVideoEncodeH264QualityLevelPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264QualityLevelPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredRateControlFlags: VkVideoEncodeH264RateControlFlagsKHR = {any},\n", .{value.preferredRateControlFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredGopFrameCount: u32 = {d},\n", .{value.preferredGopFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredIdrPeriod: u32 = {d},\n", .{value.preferredIdrPeriod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredConsecutiveBFrameCount: u32 = {d},\n", .{value.preferredConsecutiveBFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredTemporalLayerCount: u32 = {d},\n", .{value.preferredTemporalLayerCount});
    print_VkVideoEncodeH264QpKHR("preferredConstantQp", &value.preferredConstantQp, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxL0ReferenceCount: u32 = {d},\n", .{value.preferredMaxL0ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxL1ReferenceCount: u32 = {d},\n", .{value.preferredMaxL1ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredStdEntropyCodingModeFlag: u32 = {d},\n", .{value.preferredStdEntropyCodingModeFlag});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264SessionCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264SessionCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264SessionCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxLevelIdc: u32 = {d},\n", .{value.useMaxLevelIdc});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264SessionParametersAddInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264SessionParametersAddInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264SessionParametersAddInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSPSCount: u32 = {d},\n", .{value.stdSPSCount});
    if (value.pStdSPSs) |v| {
        for (v[0..value.stdSPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdSPSs: [*]const StdVideoH264SequenceParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPSs: [*]const StdVideoH264SequenceParameterSet = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdPPSCount: u32 = {d},\n", .{value.stdPPSCount});
    if (value.pStdPPSs) |v| {
        for (v[0..value.stdPPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdPPSs: [*]const StdVideoH264PictureParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPSs: [*]const StdVideoH264PictureParameterSet = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264SessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264SessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264SessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdSPSCount: u32 = {d},\n", .{value.maxStdSPSCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdPPSCount: u32 = {d},\n", .{value.maxStdPPSCount});
    if (value.pParametersAddInfo) |v| {
        print_VkVideoEncodeH264SessionParametersAddInfoKHR("pParametersAddInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pParametersAddInfo: *const VkVideoEncodeH264SessionParametersAddInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264SessionParametersGetInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264SessionParametersGetInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264SessionParametersGetInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    writeStdSPS: u32 = {d},\n", .{value.writeStdSPS});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    writeStdPPS: u32 = {d},\n", .{value.writeStdPPS});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSPSId: u32 = {d},\n", .{value.stdSPSId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdPPSId: u32 = {d},\n", .{value.stdPPSId});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264SessionParametersFeedbackInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264SessionParametersFeedbackInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasStdSPSOverrides: u32 = {d},\n", .{value.hasStdSPSOverrides});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasStdPPSOverrides: u32 = {d},\n", .{value.hasStdPPSOverrides});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264DpbSlotInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264DpbSlotInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264DpbSlotInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdReferenceInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoEncodeH264ReferenceInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoEncodeH264ReferenceInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264PictureInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264PictureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264PictureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    naluSliceEntryCount: u32 = {d},\n", .{value.naluSliceEntryCount});
    if (value.pNaluSliceEntries) |v| {
        for (v[0..value.naluSliceEntryCount]) |*vv| {
            print_VkVideoEncodeH264NaluSliceInfoKHR("pNaluSliceEntries", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pNaluSliceEntries: [*]const VkVideoEncodeH264NaluSliceInfoKHR = null,\n", .{});
    }
    if (value.pStdPictureInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoEncodeH264PictureInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoEncodeH264PictureInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    generatePrefixNalu: u32 = {d},\n", .{value.generatePrefixNalu});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264ProfileInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264ProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264ProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264NaluSliceInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264NaluSliceInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264NaluSliceInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    constantQp: i32 = {d},\n", .{value.constantQp});
    if (value.pStdSliceHeader) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSliceHeader: *const StdVideoEncodeH264SliceHeader = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSliceHeader: *const StdVideoEncodeH264SliceHeader = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264RateControlInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264RateControlInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264RateControlInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeH264RateControlFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopFrameCount: u32 = {d},\n", .{value.gopFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    idrPeriod: u32 = {d},\n", .{value.idrPeriod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    consecutiveBFrameCount: u32 = {d},\n", .{value.consecutiveBFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    temporalLayerCount: u32 = {d},\n", .{value.temporalLayerCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264QpKHR(name: []const u8, value: *const vk.VkVideoEncodeH264QpKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264QpKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qpI: i32 = {d},\n", .{value.qpI});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qpP: i32 = {d},\n", .{value.qpP});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qpB: i32 = {d},\n", .{value.qpB});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264FrameSizeKHR(name: []const u8, value: *const vk.VkVideoEncodeH264FrameSizeKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264FrameSizeKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameISize: u32 = {d},\n", .{value.frameISize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framePSize: u32 = {d},\n", .{value.framePSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameBSize: u32 = {d},\n", .{value.frameBSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264GopRemainingFrameInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264GopRemainingFrameInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264GopRemainingFrameInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useGopRemainingFrames: u32 = {d},\n", .{value.useGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingI: u32 = {d},\n", .{value.gopRemainingI});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingP: u32 = {d},\n", .{value.gopRemainingP});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingB: u32 = {d},\n", .{value.gopRemainingB});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH264RateControlLayerInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH264RateControlLayerInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH264RateControlLayerInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMinQp: u32 = {d},\n", .{value.useMinQp});
    print_VkVideoEncodeH264QpKHR("minQp", &value.minQp, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxQp: u32 = {d},\n", .{value.useMaxQp});
    print_VkVideoEncodeH264QpKHR("maxQp", &value.maxQp, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxFrameSize: u32 = {d},\n", .{value.useMaxFrameSize});
    print_VkVideoEncodeH264FrameSizeKHR("maxFrameSize", &value.maxFrameSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265CapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeH265CapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265CapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeH265CapabilityFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSliceSegmentCount: u32 = {d},\n", .{value.maxSliceSegmentCount});
    print_VkExtent2D("maxTiles", &value.maxTiles, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ctbSizes: VkVideoEncodeH265CtbSizeFlagsKHR = {any},\n", .{value.ctbSizes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformBlockSizes: VkVideoEncodeH265TransformBlockSizeFlagsKHR = {any},\n", .{value.transformBlockSizes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPPictureL0ReferenceCount: u32 = {d},\n", .{value.maxPPictureL0ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBPictureL0ReferenceCount: u32 = {d},\n", .{value.maxBPictureL0ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxL1ReferenceCount: u32 = {d},\n", .{value.maxL1ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSubLayerCount: u32 = {d},\n", .{value.maxSubLayerCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    expectDyadicTemporalSubLayerPattern: u32 = {d},\n", .{value.expectDyadicTemporalSubLayerPattern});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minQp: i32 = {d},\n", .{value.minQp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQp: i32 = {d},\n", .{value.maxQp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersGopRemainingFrames: u32 = {d},\n", .{value.prefersGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiresGopRemainingFrames: u32 = {d},\n", .{value.requiresGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSyntaxFlags: VkVideoEncodeH265StdFlagsKHR = {any},\n", .{value.stdSyntaxFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265QualityLevelPropertiesKHR(name: []const u8, value: *const vk.VkVideoEncodeH265QualityLevelPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265QualityLevelPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredRateControlFlags: VkVideoEncodeH265RateControlFlagsKHR = {any},\n", .{value.preferredRateControlFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredGopFrameCount: u32 = {d},\n", .{value.preferredGopFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredIdrPeriod: u32 = {d},\n", .{value.preferredIdrPeriod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredConsecutiveBFrameCount: u32 = {d},\n", .{value.preferredConsecutiveBFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredSubLayerCount: u32 = {d},\n", .{value.preferredSubLayerCount});
    print_VkVideoEncodeH265QpKHR("preferredConstantQp", &value.preferredConstantQp, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxL0ReferenceCount: u32 = {d},\n", .{value.preferredMaxL0ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxL1ReferenceCount: u32 = {d},\n", .{value.preferredMaxL1ReferenceCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265SessionCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265SessionCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265SessionCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxLevelIdc: u32 = {d},\n", .{value.useMaxLevelIdc});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265SessionParametersAddInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265SessionParametersAddInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265SessionParametersAddInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdVPSCount: u32 = {d},\n", .{value.stdVPSCount});
    if (value.pStdVPSs) |v| {
        for (v[0..value.stdVPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdVPSs: [*]const StdVideoH265VideoParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdVPSs: [*]const StdVideoH265VideoParameterSet = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSPSCount: u32 = {d},\n", .{value.stdSPSCount});
    if (value.pStdSPSs) |v| {
        for (v[0..value.stdSPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdSPSs: [*]const StdVideoH265SequenceParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSPSs: [*]const StdVideoH265SequenceParameterSet = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdPPSCount: u32 = {d},\n", .{value.stdPPSCount});
    if (value.pStdPPSs) |v| {
        for (v[0..value.stdPPSCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdPPSs: [*]const StdVideoH265PictureParameterSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPPSs: [*]const StdVideoH265PictureParameterSet = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265SessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265SessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265SessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdVPSCount: u32 = {d},\n", .{value.maxStdVPSCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdSPSCount: u32 = {d},\n", .{value.maxStdSPSCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxStdPPSCount: u32 = {d},\n", .{value.maxStdPPSCount});
    if (value.pParametersAddInfo) |v| {
        print_VkVideoEncodeH265SessionParametersAddInfoKHR("pParametersAddInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pParametersAddInfo: *const VkVideoEncodeH265SessionParametersAddInfoKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265SessionParametersGetInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265SessionParametersGetInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265SessionParametersGetInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    writeStdVPS: u32 = {d},\n", .{value.writeStdVPS});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    writeStdSPS: u32 = {d},\n", .{value.writeStdSPS});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    writeStdPPS: u32 = {d},\n", .{value.writeStdPPS});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdVPSId: u32 = {d},\n", .{value.stdVPSId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSPSId: u32 = {d},\n", .{value.stdSPSId});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdPPSId: u32 = {d},\n", .{value.stdPPSId});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265SessionParametersFeedbackInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265SessionParametersFeedbackInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasStdVPSOverrides: u32 = {d},\n", .{value.hasStdVPSOverrides});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasStdSPSOverrides: u32 = {d},\n", .{value.hasStdSPSOverrides});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasStdPPSOverrides: u32 = {d},\n", .{value.hasStdPPSOverrides});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265PictureInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265PictureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265PictureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    naluSliceSegmentEntryCount: u32 = {d},\n", .{value.naluSliceSegmentEntryCount});
    if (value.pNaluSliceSegmentEntries) |v| {
        for (v[0..value.naluSliceSegmentEntryCount]) |*vv| {
            print_VkVideoEncodeH265NaluSliceSegmentInfoKHR("pNaluSliceSegmentEntries", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pNaluSliceSegmentEntries: [*]const VkVideoEncodeH265NaluSliceSegmentInfoKHR = null,\n", .{});
    }
    if (value.pStdPictureInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoEncodeH265PictureInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoEncodeH265PictureInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265NaluSliceSegmentInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265NaluSliceSegmentInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265NaluSliceSegmentInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    constantQp: i32 = {d},\n", .{value.constantQp});
    if (value.pStdSliceSegmentHeader) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSliceSegmentHeader: *const StdVideoEncodeH265SliceSegmentHeader = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSliceSegmentHeader: *const StdVideoEncodeH265SliceSegmentHeader = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265RateControlInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265RateControlInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265RateControlInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeH265RateControlFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopFrameCount: u32 = {d},\n", .{value.gopFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    idrPeriod: u32 = {d},\n", .{value.idrPeriod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    consecutiveBFrameCount: u32 = {d},\n", .{value.consecutiveBFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subLayerCount: u32 = {d},\n", .{value.subLayerCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265QpKHR(name: []const u8, value: *const vk.VkVideoEncodeH265QpKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265QpKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qpI: i32 = {d},\n", .{value.qpI});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qpP: i32 = {d},\n", .{value.qpP});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qpB: i32 = {d},\n", .{value.qpB});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265FrameSizeKHR(name: []const u8, value: *const vk.VkVideoEncodeH265FrameSizeKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265FrameSizeKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameISize: u32 = {d},\n", .{value.frameISize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    framePSize: u32 = {d},\n", .{value.framePSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameBSize: u32 = {d},\n", .{value.frameBSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265GopRemainingFrameInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265GopRemainingFrameInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265GopRemainingFrameInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useGopRemainingFrames: u32 = {d},\n", .{value.useGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingI: u32 = {d},\n", .{value.gopRemainingI});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingP: u32 = {d},\n", .{value.gopRemainingP});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingB: u32 = {d},\n", .{value.gopRemainingB});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265RateControlLayerInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265RateControlLayerInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265RateControlLayerInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMinQp: u32 = {d},\n", .{value.useMinQp});
    print_VkVideoEncodeH265QpKHR("minQp", &value.minQp, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxQp: u32 = {d},\n", .{value.useMaxQp});
    print_VkVideoEncodeH265QpKHR("maxQp", &value.maxQp, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxFrameSize: u32 = {d},\n", .{value.useMaxFrameSize});
    print_VkVideoEncodeH265FrameSizeKHR("maxFrameSize", &value.maxFrameSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265ProfileInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265ProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265ProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeH265DpbSlotInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeH265DpbSlotInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeH265DpbSlotInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdReferenceInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoEncodeH265ReferenceInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoEncodeH265ReferenceInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1CapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1CapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1CapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeAV1CapabilityFlagsKHR = {any},\n", .{value.flags});
    print_VkExtent2D("codedPictureAlignment", &value.codedPictureAlignment, offset + 1);
    print_VkExtent2D("maxTiles", &value.maxTiles, offset + 1);
    print_VkExtent2D("minTileSize", &value.minTileSize, offset + 1);
    print_VkExtent2D("maxTileSize", &value.maxTileSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    superblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR = {any},\n", .{value.superblockSizes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSingleReferenceCount: u32 = {d},\n", .{value.maxSingleReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    singleReferenceNameMask: u32 = {d},\n", .{value.singleReferenceNameMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxUnidirectionalCompoundReferenceCount: u32 = {d},\n", .{value.maxUnidirectionalCompoundReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxUnidirectionalCompoundGroup1ReferenceCount: u32 = {d},\n", .{value.maxUnidirectionalCompoundGroup1ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    unidirectionalCompoundReferenceNameMask: u32 = {d},\n", .{value.unidirectionalCompoundReferenceNameMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBidirectionalCompoundReferenceCount: u32 = {d},\n", .{value.maxBidirectionalCompoundReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBidirectionalCompoundGroup1ReferenceCount: u32 = {d},\n", .{value.maxBidirectionalCompoundGroup1ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBidirectionalCompoundGroup2ReferenceCount: u32 = {d},\n", .{value.maxBidirectionalCompoundGroup2ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bidirectionalCompoundReferenceNameMask: u32 = {d},\n", .{value.bidirectionalCompoundReferenceNameMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTemporalLayerCount: u32 = {d},\n", .{value.maxTemporalLayerCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSpatialLayerCount: u32 = {d},\n", .{value.maxSpatialLayerCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxOperatingPoints: u32 = {d},\n", .{value.maxOperatingPoints});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minQIndex: u32 = {d},\n", .{value.minQIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxQIndex: u32 = {d},\n", .{value.maxQIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    prefersGopRemainingFrames: u32 = {d},\n", .{value.prefersGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiresGopRemainingFrames: u32 = {d},\n", .{value.requiresGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdSyntaxFlags: VkVideoEncodeAV1StdFlagsKHR = {any},\n", .{value.stdSyntaxFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1QualityLevelPropertiesKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1QualityLevelPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1QualityLevelPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredRateControlFlags: VkVideoEncodeAV1RateControlFlagsKHR = {any},\n", .{value.preferredRateControlFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredGopFrameCount: u32 = {d},\n", .{value.preferredGopFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredKeyFramePeriod: u32 = {d},\n", .{value.preferredKeyFramePeriod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredConsecutiveBipredictiveFrameCount: u32 = {d},\n", .{value.preferredConsecutiveBipredictiveFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredTemporalLayerCount: u32 = {d},\n", .{value.preferredTemporalLayerCount});
    print_VkVideoEncodeAV1QIndexKHR("preferredConstantQIndex", &value.preferredConstantQIndex, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxSingleReferenceCount: u32 = {d},\n", .{value.preferredMaxSingleReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredSingleReferenceNameMask: u32 = {d},\n", .{value.preferredSingleReferenceNameMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxUnidirectionalCompoundReferenceCount: u32 = {d},\n", .{value.preferredMaxUnidirectionalCompoundReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxUnidirectionalCompoundGroup1ReferenceCount: u32 = {d},\n", .{value.preferredMaxUnidirectionalCompoundGroup1ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredUnidirectionalCompoundReferenceNameMask: u32 = {d},\n", .{value.preferredUnidirectionalCompoundReferenceNameMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxBidirectionalCompoundReferenceCount: u32 = {d},\n", .{value.preferredMaxBidirectionalCompoundReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxBidirectionalCompoundGroup1ReferenceCount: u32 = {d},\n", .{value.preferredMaxBidirectionalCompoundGroup1ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredMaxBidirectionalCompoundGroup2ReferenceCount: u32 = {d},\n", .{value.preferredMaxBidirectionalCompoundGroup2ReferenceCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredBidirectionalCompoundReferenceNameMask: u32 = {d},\n", .{value.preferredBidirectionalCompoundReferenceNameMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoEncodeAV1FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoEncodeAV1: u32 = {d},\n", .{value.videoEncodeAV1});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1SessionCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1SessionCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1SessionCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxLevel: u32 = {d},\n", .{value.useMaxLevel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1SessionParametersCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1SessionParametersCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1SessionParametersCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdSequenceHeader) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSequenceHeader: *const StdVideoAV1SequenceHeader = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdSequenceHeader: *const StdVideoAV1SequenceHeader = null,\n", .{});
    }
    if (value.pStdDecoderModelInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdDecoderModelInfo: *const StdVideoEncodeAV1DecoderModelInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdDecoderModelInfo: *const StdVideoEncodeAV1DecoderModelInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stdOperatingPointCount: u32 = {d},\n", .{value.stdOperatingPointCount});
    if (value.pStdOperatingPoints) |v| {
        for (v[0..value.stdOperatingPointCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStdOperatingPoints: [*]const StdVideoEncodeAV1OperatingPointInfo = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdOperatingPoints: [*]const StdVideoEncodeAV1OperatingPointInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1DpbSlotInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1DpbSlotInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1DpbSlotInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pStdReferenceInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoEncodeAV1ReferenceInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdReferenceInfo: *const StdVideoEncodeAV1ReferenceInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1PictureInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1PictureInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1PictureInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    predictionMode: VkVideoEncodeAV1PredictionModeKHR = {t},\n", .{value.predictionMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rateControlGroup: VkVideoEncodeAV1RateControlGroupKHR = {t},\n", .{value.rateControlGroup});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    constantQIndex: u32 = {d},\n", .{value.constantQIndex});
    if (value.pStdPictureInfo) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoEncodeAV1PictureInfo = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStdPictureInfo: *const StdVideoEncodeAV1PictureInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    referenceNameSlotIndices: [VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32 = {any},\n", .{value.referenceNameSlotIndices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primaryReferenceCdfOnly: u32 = {d},\n", .{value.primaryReferenceCdfOnly});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    generateObuExtensionHeader: u32 = {d},\n", .{value.generateObuExtensionHeader});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1ProfileInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1ProfileInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1ProfileInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1RateControlInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1RateControlInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1RateControlInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkVideoEncodeAV1RateControlFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopFrameCount: u32 = {d},\n", .{value.gopFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    keyFramePeriod: u32 = {d},\n", .{value.keyFramePeriod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    consecutiveBipredictiveFrameCount: u32 = {d},\n", .{value.consecutiveBipredictiveFrameCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    temporalLayerCount: u32 = {d},\n", .{value.temporalLayerCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1QIndexKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1QIndexKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1QIndexKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intraQIndex: u32 = {d},\n", .{value.intraQIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    predictiveQIndex: u32 = {d},\n", .{value.predictiveQIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bipredictiveQIndex: u32 = {d},\n", .{value.bipredictiveQIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1FrameSizeKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1FrameSizeKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1FrameSizeKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intraFrameSize: u32 = {d},\n", .{value.intraFrameSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    predictiveFrameSize: u32 = {d},\n", .{value.predictiveFrameSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bipredictiveFrameSize: u32 = {d},\n", .{value.bipredictiveFrameSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1GopRemainingFrameInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1GopRemainingFrameInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1GopRemainingFrameInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useGopRemainingFrames: u32 = {d},\n", .{value.useGopRemainingFrames});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingIntra: u32 = {d},\n", .{value.gopRemainingIntra});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingPredictive: u32 = {d},\n", .{value.gopRemainingPredictive});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gopRemainingBipredictive: u32 = {d},\n", .{value.gopRemainingBipredictive});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeAV1RateControlLayerInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeAV1RateControlLayerInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeAV1RateControlLayerInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMinQIndex: u32 = {d},\n", .{value.useMinQIndex});
    print_VkVideoEncodeAV1QIndexKHR("minQIndex", &value.minQIndex, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxQIndex: u32 = {d},\n", .{value.useMaxQIndex});
    print_VkVideoEncodeAV1QIndexKHR("maxQIndex", &value.maxQIndex, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    useMaxFrameSize: u32 = {d},\n", .{value.useMaxFrameSize});
    print_VkVideoEncodeAV1FrameSizeKHR("maxFrameSize", &value.maxFrameSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceInheritedViewportScissorFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inheritedViewportScissor2D: u32 = {d},\n", .{value.inheritedViewportScissor2D});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferInheritanceViewportScissorInfoNV(name: []const u8, value: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferInheritanceViewportScissorInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportScissor2D: u32 = {d},\n", .{value.viewportScissor2D});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewportDepthCount: u32 = {d},\n", .{value.viewportDepthCount});
    if (value.pViewportDepths) |v| {
        print_VkViewport("pViewportDepths", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pViewportDepths: *const VkViewport = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ycbcr2plane444Formats: u32 = {d},\n", .{value.ycbcr2plane444Formats});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceProvokingVertexFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceProvokingVertexFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    provokingVertexLast: u32 = {d},\n", .{value.provokingVertexLast});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformFeedbackPreservesProvokingVertex: u32 = {d},\n", .{value.transformFeedbackPreservesProvokingVertex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceProvokingVertexPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceProvokingVertexPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    provokingVertexModePerPipeline: u32 = {d},\n", .{value.provokingVertexModePerPipeline});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transformFeedbackPreservesTriangleFanProvokingVertex: u32 = {d},\n", .{value.transformFeedbackPreservesTriangleFanProvokingVertex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    provokingVertexMode: VkProvokingVertexModeEXT = {t},\n", .{value.provokingVertexMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeIntraRefreshCapabilitiesKHR(name: []const u8, value: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeIntraRefreshCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intraRefreshModes: VkVideoEncodeIntraRefreshModeFlagsKHR = {any},\n", .{value.intraRefreshModes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIntraRefreshCycleDuration: u32 = {d},\n", .{value.maxIntraRefreshCycleDuration});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxIntraRefreshActiveReferencePictures: u32 = {d},\n", .{value.maxIntraRefreshActiveReferencePictures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    partitionIndependentIntraRefreshRegions: u32 = {d},\n", .{value.partitionIndependentIntraRefreshRegions});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nonRectangularIntraRefreshRegions: u32 = {d},\n", .{value.nonRectangularIntraRefreshRegions});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeSessionIntraRefreshCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intraRefreshMode: VkVideoEncodeIntraRefreshModeFlagsKHR = {any},\n", .{value.intraRefreshMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeIntraRefreshInfoKHR(name: []const u8, value: *const vk.VkVideoEncodeIntraRefreshInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeIntraRefreshInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intraRefreshCycleDuration: u32 = {d},\n", .{value.intraRefreshCycleDuration});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    intraRefreshIndex: u32 = {d},\n", .{value.intraRefreshIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoReferenceIntraRefreshInfoKHR(name: []const u8, value: *const vk.VkVideoReferenceIntraRefreshInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoReferenceIntraRefreshInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dirtyIntraRefreshRegions: u32 = {d},\n", .{value.dirtyIntraRefreshRegions});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoEncodeIntraRefresh: u32 = {d},\n", .{value.videoEncodeIntraRefresh});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCuModuleCreateInfoNVX(name: []const u8, value: *const vk.VkCuModuleCreateInfoNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCuModuleCreateInfoNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u64 = {d},\n", .{value.dataSize});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCuModuleTexturingModeCreateInfoNVX(name: []const u8, value: *const vk.VkCuModuleTexturingModeCreateInfoNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCuModuleTexturingModeCreateInfoNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    use64bitTexturing: u32 = {d},\n", .{value.use64bitTexturing});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCuFunctionCreateInfoNVX(name: []const u8, value: *const vk.VkCuFunctionCreateInfoNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCuFunctionCreateInfoNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    module: VkCuModuleNVX = {},\n", .{value.module});
    if (value.pName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCuLaunchInfoNVX(name: []const u8, value: *const vk.VkCuLaunchInfoNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCuLaunchInfoNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    function: VkCuFunctionNVX = {},\n", .{value.function});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gridDimX: u32 = {d},\n", .{value.gridDimX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gridDimY: u32 = {d},\n", .{value.gridDimY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gridDimZ: u32 = {d},\n", .{value.gridDimZ});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockDimX: u32 = {d},\n", .{value.blockDimX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockDimY: u32 = {d},\n", .{value.blockDimY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockDimZ: u32 = {d},\n", .{value.blockDimZ});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharedMemBytes: u32 = {d},\n", .{value.sharedMemBytes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    paramCount: u64 = {d},\n", .{value.paramCount});
    if (value.pParams) |v| {
        for (v[0..value.paramCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pParams: [*]const *const anyopaque = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pParams: [*]const *const anyopaque = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extraCount: u64 = {d},\n", .{value.extraCount});
    if (value.pExtras) |v| {
        for (v[0..value.extraCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pExtras: [*]const *const anyopaque = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pExtras: [*]const *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorBufferFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorBufferFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBuffer: u32 = {d},\n", .{value.descriptorBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBufferCaptureReplay: u32 = {d},\n", .{value.descriptorBufferCaptureReplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBufferImageLayoutIgnored: u32 = {d},\n", .{value.descriptorBufferImageLayoutIgnored});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBufferPushDescriptors: u32 = {d},\n", .{value.descriptorBufferPushDescriptors});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorBufferPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorBufferPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    combinedImageSamplerDescriptorSingleArray: u32 = {d},\n", .{value.combinedImageSamplerDescriptorSingleArray});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferlessPushDescriptors: u32 = {d},\n", .{value.bufferlessPushDescriptors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    allowSamplerImageViewPostSubmitCreation: u32 = {d},\n", .{value.allowSamplerImageViewPostSubmitCreation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBufferOffsetAlignment: u64 = {d},\n", .{value.descriptorBufferOffsetAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorBufferBindings: u32 = {d},\n", .{value.maxDescriptorBufferBindings});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxResourceDescriptorBufferBindings: u32 = {d},\n", .{value.maxResourceDescriptorBufferBindings});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSamplerDescriptorBufferBindings: u32 = {d},\n", .{value.maxSamplerDescriptorBufferBindings});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxEmbeddedImmutableSamplerBindings: u32 = {d},\n", .{value.maxEmbeddedImmutableSamplerBindings});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxEmbeddedImmutableSamplers: u32 = {d},\n", .{value.maxEmbeddedImmutableSamplers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferCaptureReplayDescriptorDataSize: u64 = {d},\n", .{value.bufferCaptureReplayDescriptorDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCaptureReplayDescriptorDataSize: u64 = {d},\n", .{value.imageCaptureReplayDescriptorDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageViewCaptureReplayDescriptorDataSize: u64 = {d},\n", .{value.imageViewCaptureReplayDescriptorDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerCaptureReplayDescriptorDataSize: u64 = {d},\n", .{value.samplerCaptureReplayDescriptorDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureCaptureReplayDescriptorDataSize: u64 = {d},\n", .{value.accelerationStructureCaptureReplayDescriptorDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerDescriptorSize: u64 = {d},\n", .{value.samplerDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    combinedImageSamplerDescriptorSize: u64 = {d},\n", .{value.combinedImageSamplerDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampledImageDescriptorSize: u64 = {d},\n", .{value.sampledImageDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageImageDescriptorSize: u64 = {d},\n", .{value.storageImageDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformTexelBufferDescriptorSize: u64 = {d},\n", .{value.uniformTexelBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustUniformTexelBufferDescriptorSize: u64 = {d},\n", .{value.robustUniformTexelBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageTexelBufferDescriptorSize: u64 = {d},\n", .{value.storageTexelBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustStorageTexelBufferDescriptorSize: u64 = {d},\n", .{value.robustStorageTexelBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformBufferDescriptorSize: u64 = {d},\n", .{value.uniformBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustUniformBufferDescriptorSize: u64 = {d},\n", .{value.robustUniformBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageBufferDescriptorSize: u64 = {d},\n", .{value.storageBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    robustStorageBufferDescriptorSize: u64 = {d},\n", .{value.robustStorageBufferDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputAttachmentDescriptorSize: u64 = {d},\n", .{value.inputAttachmentDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureDescriptorSize: u64 = {d},\n", .{value.accelerationStructureDescriptorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSamplerDescriptorBufferRange: u64 = {d},\n", .{value.maxSamplerDescriptorBufferRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxResourceDescriptorBufferRange: u64 = {d},\n", .{value.maxResourceDescriptorBufferRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    samplerDescriptorBufferAddressSpaceSize: u64 = {d},\n", .{value.samplerDescriptorBufferAddressSpaceSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resourceDescriptorBufferAddressSpaceSize: u64 = {d},\n", .{value.resourceDescriptorBufferAddressSpaceSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBufferAddressSpaceSize: u64 = {d},\n", .{value.descriptorBufferAddressSpaceSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    combinedImageSamplerDensityMapDescriptorSize: u64 = {d},\n", .{value.combinedImageSamplerDensityMapDescriptorSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorAddressInfoEXT(name: []const u8, value: *const vk.VkDescriptorAddressInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorAddressInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    address: u64 = {d},\n", .{value.address});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    range: u64 = {d},\n", .{value.range});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorBufferBindingInfoEXT(name: []const u8, value: *const vk.VkDescriptorBufferBindingInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorBufferBindingInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    address: u64 = {d},\n", .{value.address});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkBufferUsageFlags = {any},\n", .{value.usage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(name: []const u8, value: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorGetInfoEXT(name: []const u8, value: *const vk.VkDescriptorGetInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorGetInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkDescriptorType = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.type) {
        .VK_DESCRIPTOR_TYPE_SAMPLER => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pSampler}),
        .VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pCombinedImageSampler}),
        .VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pSampledImage}),
        .VK_DESCRIPTOR_TYPE_STORAGE_IMAGE => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pStorageImage}),
        .VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pUniformTexelBuffer}),
        .VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pStorageTexelBuffer}),
        .VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pUniformBuffer}),
        .VK_DESCRIPTOR_TYPE_STORAGE_BUFFER => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pStorageBuffer}),
        .VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT => log.output("    data: VkDescriptorDataEXT = {any},\n", .{value.data.pInputAttachmentImage}),
        else => log.output("    data: VkDescriptorDataEXT = ???,\n", .{}),
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCaptureDescriptorDataInfoEXT(name: []const u8, value: *const vk.VkBufferCaptureDescriptorDataInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCaptureDescriptorDataInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageCaptureDescriptorDataInfoEXT(name: []const u8, value: *const vk.VkImageCaptureDescriptorDataInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageCaptureDescriptorDataInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewCaptureDescriptorDataInfoEXT(name: []const u8, value: *const vk.VkImageViewCaptureDescriptorDataInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewCaptureDescriptorDataInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView: VkImageView = {},\n", .{value.imageView});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerCaptureDescriptorDataInfoEXT(name: []const u8, value: *const vk.VkSamplerCaptureDescriptorDataInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerCaptureDescriptorDataInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sampler: VkSampler = {},\n", .{value.sampler});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureCaptureDescriptorDataInfoEXT(name: []const u8, value: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureCaptureDescriptorDataInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructure: VkAccelerationStructureKHR = {},\n", .{value.accelerationStructure});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureNV: VkAccelerationStructureNV = {},\n", .{value.accelerationStructureNV});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOpaqueCaptureDescriptorDataCreateInfoEXT(name: []const u8, value: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOpaqueCaptureDescriptorDataCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.opaqueCaptureDescriptorData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    opaqueCaptureDescriptorData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    opaqueCaptureDescriptorData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderIntegerDotProductFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderIntegerDotProductFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderIntegerDotProduct: u32 = {d},\n", .{value.shaderIntegerDotProduct});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderIntegerDotProductProperties(name: []const u8, value: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderIntegerDotProductProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct8BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct8BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct8BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct8BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct8BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct8BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct4x8BitPackedUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct4x8BitPackedUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct4x8BitPackedSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct4x8BitPackedSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct4x8BitPackedMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct4x8BitPackedMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct16BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct16BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct16BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct16BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct16BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct16BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct32BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct32BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct32BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct32BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct32BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct32BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct64BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProduct64BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct64BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProduct64BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProduct64BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProduct64BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating8BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating8BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating16BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating16BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating32BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating32BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating64BitSignedAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating64BitSignedAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: u32 = {d},\n", .{value.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDrmPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDrmPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDrmPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasPrimary: u32 = {d},\n", .{value.hasPrimary});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hasRender: u32 = {d},\n", .{value.hasRender});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primaryMajor: i64 = {d},\n", .{value.primaryMajor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    primaryMinor: i64 = {d},\n", .{value.primaryMinor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderMajor: i64 = {d},\n", .{value.renderMajor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderMinor: i64 = {d},\n", .{value.renderMinor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentShaderBarycentric: u32 = {d},\n", .{value.fragmentShaderBarycentric});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    triStripVertexOrderIndependentOfProvokingVertex: u32 = {d},\n", .{value.triStripVertexOrderIndependentOfProvokingVertex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderFmaFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderFmaFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderFmaFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFmaFloat16: u32 = {d},\n", .{value.shaderFmaFloat16});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFmaFloat32: u32 = {d},\n", .{value.shaderFmaFloat32});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFmaFloat64: u32 = {d},\n", .{value.shaderFmaFloat64});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingMotionBlur: u32 = {d},\n", .{value.rayTracingMotionBlur});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingMotionBlurPipelineTraceRaysIndirect: u32 = {d},\n", .{value.rayTracingMotionBlurPipelineTraceRaysIndirect});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingValidationFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingValidationFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingValidation: u32 = {d},\n", .{value.rayTracingValidation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    spheres: u32 = {d},\n", .{value.spheres});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    linearSweptSpheres: u32 = {d},\n", .{value.linearSweptSpheres});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureGeometryMotionTrianglesDataNV(name: []const u8, value: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureGeometryMotionTrianglesDataNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.vertexData});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureMotionInfoNV(name: []const u8, value: *const vk.VkAccelerationStructureMotionInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureMotionInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxInstances: u32 = {d},\n", .{value.maxInstances});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkAccelerationStructureMotionInfoFlagsNV = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSRTDataNV(name: []const u8, value: *const vk.VkSRTDataNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSRTDataNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sx: f32 = {d},\n", .{value.sx});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    a: f32 = {d},\n", .{value.a});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    b: f32 = {d},\n", .{value.b});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pvx: f32 = {d},\n", .{value.pvx});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sy: f32 = {d},\n", .{value.sy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    c: f32 = {d},\n", .{value.c});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pvy: f32 = {d},\n", .{value.pvy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sz: f32 = {d},\n", .{value.sz});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pvz: f32 = {d},\n", .{value.pvz});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qx: f32 = {d},\n", .{value.qx});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qy: f32 = {d},\n", .{value.qy});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qz: f32 = {d},\n", .{value.qz});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    qw: f32 = {d},\n", .{value.qw});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tx: f32 = {d},\n", .{value.tx});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ty: f32 = {d},\n", .{value.ty});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tz: f32 = {d},\n", .{value.tz});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureSRTMotionInstanceNV(name: []const u8, value: *const vk.VkAccelerationStructureSRTMotionInstanceNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureSRTMotionInstanceNV = .{{\n", .{ name });
    print_VkSRTDataNV("transformT0", &value.transformT0, offset + 1);
    print_VkSRTDataNV("transformT1", &value.transformT1, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    packed_field0: <packed> = {any},\n", .{value.packed_field0});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureReference: u64 = {d},\n", .{value.accelerationStructureReference});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureMatrixMotionInstanceNV(name: []const u8, value: *const vk.VkAccelerationStructureMatrixMotionInstanceNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureMatrixMotionInstanceNV = .{{\n", .{ name });
    print_VkTransformMatrixKHR("transformT0", &value.transformT0, offset + 1);
    print_VkTransformMatrixKHR("transformT1", &value.transformT1, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    packed_field0: <packed> = {any},\n", .{value.packed_field0});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    accelerationStructureReference: u64 = {d},\n", .{value.accelerationStructureReference});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureMotionInstanceNV(name: []const u8, value: *const vk.VkAccelerationStructureMotionInstanceNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureMotionInstanceNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkAccelerationStructureMotionInstanceTypeNV = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkAccelerationStructureMotionInstanceFlagsNV = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    switch (value.type) {
        .VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV => log.output("    data: VkAccelerationStructureMotionInstanceDataNV = {any},\n", .{value.data.staticInstance}),
        .VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV => log.output("    data: VkAccelerationStructureMotionInstanceDataNV = {any},\n", .{value.data.matrixMotionInstance}),
        .VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV => log.output("    data: VkAccelerationStructureMotionInstanceDataNV = {any},\n", .{value.data.srtMotionInstance}),
        else => log.output("    data: VkAccelerationStructureMotionInstanceDataNV = ???,\n", .{}),
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetRemoteAddressInfoNV(name: []const u8, value: *const vk.VkMemoryGetRemoteAddressInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetRemoteAddressInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMemoryBufferCollectionFUCHSIA(name: []const u8, value: *const vk.VkImportMemoryBufferCollectionFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMemoryBufferCollectionFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    collection: VkBufferCollectionFUCHSIA = {},\n", .{value.collection});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    index: u32 = {d},\n", .{value.index});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCollectionImageCreateInfoFUCHSIA(name: []const u8, value: *const vk.VkBufferCollectionImageCreateInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCollectionImageCreateInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    collection: VkBufferCollectionFUCHSIA = {},\n", .{value.collection});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    index: u32 = {d},\n", .{value.index});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCollectionBufferCreateInfoFUCHSIA(name: []const u8, value: *const vk.VkBufferCollectionBufferCreateInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCollectionBufferCreateInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    collection: VkBufferCollectionFUCHSIA = {},\n", .{value.collection});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    index: u32 = {d},\n", .{value.index});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCollectionCreateInfoFUCHSIA(name: []const u8, value: *const vk.VkBufferCollectionCreateInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCollectionCreateInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCollectionPropertiesFUCHSIA(name: []const u8, value: *const vk.VkBufferCollectionPropertiesFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCollectionPropertiesFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferCount: u32 = {d},\n", .{value.bufferCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    createInfoIndex: u32 = {d},\n", .{value.createInfoIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sysmemPixelFormat: u64 = {d},\n", .{value.sysmemPixelFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatFeatures: VkFormatFeatureFlags = {any},\n", .{value.formatFeatures});
    print_VkSysmemColorSpaceFUCHSIA("sysmemColorSpaceIndex", &value.sysmemColorSpaceIndex, offset + 1);
    print_VkComponentMapping("samplerYcbcrConversionComponents", &value.samplerYcbcrConversionComponents, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = {t},\n", .{value.suggestedYcbcrModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrRange: VkSamplerYcbcrRange = {t},\n", .{value.suggestedYcbcrRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedXChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedXChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedYChromaOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferConstraintsInfoFUCHSIA(name: []const u8, value: *const vk.VkBufferConstraintsInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferConstraintsInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkBufferCreateInfo("createInfo", &value.createInfo, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiredFormatFeatures: VkFormatFeatureFlags = {any},\n", .{value.requiredFormatFeatures});
    print_VkBufferCollectionConstraintsInfoFUCHSIA("bufferCollectionConstraints", &value.bufferCollectionConstraints, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSysmemColorSpaceFUCHSIA(name: []const u8, value: *const vk.VkSysmemColorSpaceFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSysmemColorSpaceFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorSpace: u32 = {d},\n", .{value.colorSpace});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageFormatConstraintsInfoFUCHSIA(name: []const u8, value: *const vk.VkImageFormatConstraintsInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageFormatConstraintsInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkImageCreateInfo("imageCreateInfo", &value.imageCreateInfo, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    requiredFormatFeatures: VkFormatFeatureFlags = {any},\n", .{value.requiredFormatFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImageFormatConstraintsFlagsFUCHSIA = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sysmemPixelFormat: u64 = {d},\n", .{value.sysmemPixelFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorSpaceCount: u32 = {d},\n", .{value.colorSpaceCount});
    if (value.pColorSpaces) |v| {
        for (v[0..value.colorSpaceCount]) |*vv| {
            print_VkSysmemColorSpaceFUCHSIA("pColorSpaces", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorSpaces: [*]const VkSysmemColorSpaceFUCHSIA = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageConstraintsInfoFUCHSIA(name: []const u8, value: *const vk.VkImageConstraintsInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageConstraintsInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatConstraintsCount: u32 = {d},\n", .{value.formatConstraintsCount});
    if (value.pFormatConstraints) |v| {
        for (v[0..value.formatConstraintsCount]) |*vv| {
            print_VkImageFormatConstraintsInfoFUCHSIA("pFormatConstraints", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFormatConstraints: [*]const VkImageFormatConstraintsInfoFUCHSIA = null,\n", .{});
    }
    print_VkBufferCollectionConstraintsInfoFUCHSIA("bufferCollectionConstraints", &value.bufferCollectionConstraints, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImageConstraintsInfoFlagsFUCHSIA = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBufferCollectionConstraintsInfoFUCHSIA(name: []const u8, value: *const vk.VkBufferCollectionConstraintsInfoFUCHSIA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBufferCollectionConstraintsInfoFUCHSIA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minBufferCount: u32 = {d},\n", .{value.minBufferCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxBufferCount: u32 = {d},\n", .{value.maxBufferCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minBufferCountForCamping: u32 = {d},\n", .{value.minBufferCountForCamping});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minBufferCountForDedicatedSlack: u32 = {d},\n", .{value.minBufferCountForDedicatedSlack});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minBufferCountForSharedSlack: u32 = {d},\n", .{value.minBufferCountForSharedSlack});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCudaModuleCreateInfoNV(name: []const u8, value: *const vk.VkCudaModuleCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCudaModuleCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u64 = {d},\n", .{value.dataSize});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCudaFunctionCreateInfoNV(name: []const u8, value: *const vk.VkCudaFunctionCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCudaFunctionCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    module: VkCudaModuleNV = {},\n", .{value.module});
    if (value.pName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCudaLaunchInfoNV(name: []const u8, value: *const vk.VkCudaLaunchInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCudaLaunchInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    function: VkCudaFunctionNV = {},\n", .{value.function});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gridDimX: u32 = {d},\n", .{value.gridDimX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gridDimY: u32 = {d},\n", .{value.gridDimY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gridDimZ: u32 = {d},\n", .{value.gridDimZ});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockDimX: u32 = {d},\n", .{value.blockDimX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockDimY: u32 = {d},\n", .{value.blockDimY});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    blockDimZ: u32 = {d},\n", .{value.blockDimZ});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharedMemBytes: u32 = {d},\n", .{value.sharedMemBytes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    paramCount: u64 = {d},\n", .{value.paramCount});
    if (value.pParams) |v| {
        for (v[0..value.paramCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pParams: [*]const *const anyopaque = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pParams: [*]const *const anyopaque = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extraCount: u64 = {d},\n", .{value.extraCount});
    if (value.pExtras) |v| {
        for (v[0..value.extraCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pExtras: [*]const *const anyopaque = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pExtras: [*]const *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatRgba10x6WithoutYCbCrSampler: u32 = {d},\n", .{value.formatRgba10x6WithoutYCbCrSampler});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFormatProperties3(name: []const u8, value: *const vk.VkFormatProperties3, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFormatProperties3 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    linearTilingFeatures: VkFormatFeatureFlags2 = {any},\n", .{value.linearTilingFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalTilingFeatures: VkFormatFeatureFlags2 = {any},\n", .{value.optimalTilingFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferFeatures: VkFormatFeatureFlags2 = {any},\n", .{value.bufferFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrmFormatModifierPropertiesList2EXT(name: []const u8, value: *const vk.VkDrmFormatModifierPropertiesList2EXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrmFormatModifierPropertiesList2EXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierCount: u32 = {d},\n", .{value.drmFormatModifierCount});
    if (value.pDrmFormatModifierProperties) |v| {
        for (v[0..value.drmFormatModifierCount]) |*vv| {
            print_VkDrmFormatModifierProperties2EXT("pDrmFormatModifierProperties", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDrmFormatModifierProperties: [*]VkDrmFormatModifierProperties2EXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDrmFormatModifierProperties2EXT(name: []const u8, value: *const vk.VkDrmFormatModifierProperties2EXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDrmFormatModifierProperties2EXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifier: u64 = {d},\n", .{value.drmFormatModifier});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierPlaneCount: u32 = {d},\n", .{value.drmFormatModifierPlaneCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    drmFormatModifierTilingFeatures: VkFormatFeatureFlags2 = {any},\n", .{value.drmFormatModifierTilingFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAndroidHardwareBufferFormatProperties2ANDROID(name: []const u8, value: *const vk.VkAndroidHardwareBufferFormatProperties2ANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAndroidHardwareBufferFormatProperties2ANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormat: u64 = {d},\n", .{value.externalFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatFeatures: VkFormatFeatureFlags2 = {any},\n", .{value.formatFeatures});
    print_VkComponentMapping("samplerYcbcrConversionComponents", &value.samplerYcbcrConversionComponents, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = {t},\n", .{value.suggestedYcbcrModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrRange: VkSamplerYcbcrRange = {t},\n", .{value.suggestedYcbcrRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedXChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedXChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedYChromaOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRenderingCreateInfo(name: []const u8, value: *const vk.VkPipelineRenderingCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRenderingCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewMask: u32 = {d},\n", .{value.viewMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachmentFormats) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorAttachmentFormats: [*]const VkFormat = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachmentFormats: [*]const VkFormat = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthAttachmentFormat: VkFormat = {t},\n", .{value.depthAttachmentFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilAttachmentFormat: VkFormat = {t},\n", .{value.stencilAttachmentFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingInfo(name: []const u8, value: *const vk.VkRenderingInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkRenderingFlags = {any},\n", .{value.flags});
    print_VkRect2D("renderArea", &value.renderArea, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layerCount: u32 = {d},\n", .{value.layerCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewMask: u32 = {d},\n", .{value.viewMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachments) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            print_VkRenderingAttachmentInfo("pColorAttachments", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachments: [*]const VkRenderingAttachmentInfo = null,\n", .{});
    }
    if (value.pDepthAttachment) |v| {
        print_VkRenderingAttachmentInfo("pDepthAttachment", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthAttachment: *const VkRenderingAttachmentInfo = null,\n", .{});
    }
    if (value.pStencilAttachment) |v| {
        print_VkRenderingAttachmentInfo("pStencilAttachment", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStencilAttachment: *const VkRenderingAttachmentInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingEndInfoKHR(name: []const u8, value: *const vk.VkRenderingEndInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingEndInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingAttachmentInfo(name: []const u8, value: *const vk.VkRenderingAttachmentInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingAttachmentInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView: VkImageView = {},\n", .{value.imageView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageLayout: VkImageLayout = {t},\n", .{value.imageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resolveMode: VkResolveModeFlags = {any},\n", .{value.resolveMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resolveImageView: VkImageView = {},\n", .{value.resolveImageView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resolveImageLayout: VkImageLayout = {t},\n", .{value.resolveImageLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    loadOp: VkAttachmentLoadOp = {t},\n", .{value.loadOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storeOp: VkAttachmentStoreOp = {t},\n", .{value.storeOp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    clearValue: VkClearValue = {any},\n", .{value.clearValue});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingFragmentShadingRateAttachmentInfoKHR(name: []const u8, value: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingFragmentShadingRateAttachmentInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView: VkImageView = {},\n", .{value.imageView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageLayout: VkImageLayout = {t},\n", .{value.imageLayout});
    print_VkExtent2D("shadingRateAttachmentTexelSize", &value.shadingRateAttachmentTexelSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingFragmentDensityMapAttachmentInfoEXT(name: []const u8, value: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingFragmentDensityMapAttachmentInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView: VkImageView = {},\n", .{value.imageView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageLayout: VkImageLayout = {t},\n", .{value.imageLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDynamicRenderingFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceDynamicRenderingFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDynamicRenderingFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicRendering: u32 = {d},\n", .{value.dynamicRendering});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCommandBufferInheritanceRenderingInfo(name: []const u8, value: *const vk.VkCommandBufferInheritanceRenderingInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCommandBufferInheritanceRenderingInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkRenderingFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    viewMask: u32 = {d},\n", .{value.viewMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachmentFormats) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorAttachmentFormats: [*]const VkFormat = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachmentFormats: [*]const VkFormat = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthAttachmentFormat: VkFormat = {t},\n", .{value.depthAttachmentFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilAttachmentFormat: VkFormat = {t},\n", .{value.stencilAttachmentFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationSamples: VkSampleCountFlags = {any},\n", .{value.rasterizationSamples});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentSampleCountInfoAMD(name: []const u8, value: *const vk.VkAttachmentSampleCountInfoAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentSampleCountInfoAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachmentSamples) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorAttachmentSamples: [*]const VkSampleCountFlags = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachmentSamples: [*]const VkSampleCountFlags = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthStencilAttachmentSamples: VkSampleCountFlags = {any},\n", .{value.depthStencilAttachmentSamples});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMultiviewPerViewAttributesInfoNVX(name: []const u8, value: *const vk.VkMultiviewPerViewAttributesInfoNVX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMultiviewPerViewAttributesInfoNVX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    perViewAttributes: u32 = {d},\n", .{value.perViewAttributes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    perViewAttributesPositionXOnly: u32 = {d},\n", .{value.perViewAttributesPositionXOnly});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageViewMinLodFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceImageViewMinLodFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageViewMinLodFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minLod: u32 = {d},\n", .{value.minLod});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewMinLodCreateInfoEXT(name: []const u8, value: *const vk.VkImageViewMinLodCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewMinLodCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minLod: f32 = {d},\n", .{value.minLod});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationOrderColorAttachmentAccess: u32 = {d},\n", .{value.rasterizationOrderColorAttachmentAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationOrderDepthAttachmentAccess: u32 = {d},\n", .{value.rasterizationOrderDepthAttachmentAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rasterizationOrderStencilAttachmentAccess: u32 = {d},\n", .{value.rasterizationOrderStencilAttachmentAccess});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLinearColorAttachmentFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    linearColorAttachment: u32 = {d},\n", .{value.linearColorAttachment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    graphicsPipelineLibrary: u32 = {d},\n", .{value.graphicsPipelineLibrary});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineBinaryFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineBinaryFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinaries: u32 = {d},\n", .{value.pipelineBinaries});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDevicePipelineBinaryInternalCacheControlKHR(name: []const u8, value: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDevicePipelineBinaryInternalCacheControlKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    disableInternalCache: u32 = {d},\n", .{value.disableInternalCache});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineBinaryPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineBinaryPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinaryInternalCache: u32 = {d},\n", .{value.pipelineBinaryInternalCache});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinaryInternalCacheControl: u32 = {d},\n", .{value.pipelineBinaryInternalCacheControl});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinaryPrefersInternalCache: u32 = {d},\n", .{value.pipelineBinaryPrefersInternalCache});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinaryPrecompiledInternalCache: u32 = {d},\n", .{value.pipelineBinaryPrecompiledInternalCache});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineBinaryCompressedData: u32 = {d},\n", .{value.pipelineBinaryCompressedData});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    graphicsPipelineLibraryFastLinking: u32 = {d},\n", .{value.graphicsPipelineLibraryFastLinking});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    graphicsPipelineLibraryIndependentInterpolationDecoration: u32 = {d},\n", .{value.graphicsPipelineLibraryIndependentInterpolationDecoration});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGraphicsPipelineLibraryCreateInfoEXT(name: []const u8, value: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGraphicsPipelineLibraryCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkGraphicsPipelineLibraryFlagsEXT = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetHostMapping: u32 = {d},\n", .{value.descriptorSetHostMapping});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetBindingReferenceVALVE(name: []const u8, value: *const vk.VkDescriptorSetBindingReferenceVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetBindingReferenceVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetLayout: VkDescriptorSetLayout = {},\n", .{value.descriptorSetLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorSetLayoutHostMappingInfoVALVE(name: []const u8, value: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorSetLayoutHostMappingInfoVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorOffset: u64 = {d},\n", .{value.descriptorOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSize: u32 = {d},\n", .{value.descriptorSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceNestedCommandBufferFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nestedCommandBuffer: u32 = {d},\n", .{value.nestedCommandBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nestedCommandBufferRendering: u32 = {d},\n", .{value.nestedCommandBufferRendering});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nestedCommandBufferSimultaneousUse: u32 = {d},\n", .{value.nestedCommandBufferSimultaneousUse});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceNestedCommandBufferPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCommandBufferNestingLevel: u32 = {d},\n", .{value.maxCommandBufferNestingLevel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderModuleIdentifier: u32 = {d},\n", .{value.shaderModuleIdentifier});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderModuleIdentifierAlgorithmUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.shaderModuleIdentifierAlgorithmUUID});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(name: []const u8, value: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineShaderStageModuleIdentifierCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identifierSize: u32 = {d},\n", .{value.identifierSize});
    if (value.pIdentifier) |v| {
        for (v[0..value.identifierSize]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pIdentifier: [*]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pIdentifier: [*]const u8 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkShaderModuleIdentifierEXT(name: []const u8, value: *const vk.VkShaderModuleIdentifierEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkShaderModuleIdentifierEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identifierSize: u32 = {d},\n", .{value.identifierSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identifier: [VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]u8 = {any},\n", .{value.identifier});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageCompressionControlEXT(name: []const u8, value: *const vk.VkImageCompressionControlEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageCompressionControlEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkImageCompressionFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compressionControlPlaneCount: u32 = {d},\n", .{value.compressionControlPlaneCount});
    if (value.pFixedRateFlags) |v| {
        for (v[0..value.compressionControlPlaneCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pFixedRateFlags: [*]VkImageCompressionFixedRateFlagsEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFixedRateFlags: [*]VkImageCompressionFixedRateFlagsEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageCompressionControlFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageCompressionControlFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCompressionControl: u32 = {d},\n", .{value.imageCompressionControl});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageCompressionPropertiesEXT(name: []const u8, value: *const vk.VkImageCompressionPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageCompressionPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCompressionFlags: VkImageCompressionFlagsEXT = {any},\n", .{value.imageCompressionFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT = {any},\n", .{value.imageCompressionFixedRateFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCompressionControlSwapchain: u32 = {d},\n", .{value.imageCompressionControlSwapchain});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageSubresource2(name: []const u8, value: *const vk.VkImageSubresource2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageSubresource2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkImageSubresource("imageSubresource", &value.imageSubresource, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSubresourceLayout2(name: []const u8, value: *const vk.VkSubresourceLayout2, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSubresourceLayout2 = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkSubresourceLayout("subresourceLayout", &value.subresourceLayout, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassCreationControlEXT(name: []const u8, value: *const vk.VkRenderPassCreationControlEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassCreationControlEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    disallowMerging: u32 = {d},\n", .{value.disallowMerging});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassCreationFeedbackInfoEXT(name: []const u8, value: *const vk.VkRenderPassCreationFeedbackInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassCreationFeedbackInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    postMergeSubpassCount: u32 = {d},\n", .{value.postMergeSubpassCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassCreationFeedbackCreateInfoEXT(name: []const u8, value: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassCreationFeedbackCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pRenderPassFeedback) |v| {
        print_VkRenderPassCreationFeedbackInfoEXT("pRenderPassFeedback", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRenderPassFeedback: *VkRenderPassCreationFeedbackInfoEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassSubpassFeedbackInfoEXT(name: []const u8, value: *const vk.VkRenderPassSubpassFeedbackInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassSubpassFeedbackInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassMergeStatus: VkSubpassMergeStatusEXT = {t},\n", .{value.subpassMergeStatus});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    postMergeIndex: u32 = {d},\n", .{value.postMergeIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassSubpassFeedbackCreateInfoEXT(name: []const u8, value: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassSubpassFeedbackCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pSubpassFeedback) |v| {
        print_VkRenderPassSubpassFeedbackInfoEXT("pSubpassFeedback", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSubpassFeedback: *VkRenderPassSubpassFeedbackInfoEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subpassMergeFeedback: u32 = {d},\n", .{value.subpassMergeFeedback});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMicromapBuildInfoEXT(name: []const u8, value: *const vk.VkMicromapBuildInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMicromapBuildInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkMicromapTypeEXT = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkBuildMicromapFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkBuildMicromapModeEXT = {t},\n", .{value.mode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstMicromap: VkMicromapEXT = {},\n", .{value.dstMicromap});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usageCountsCount: u32 = {d},\n", .{value.usageCountsCount});
    if (value.pUsageCounts) |v| {
        for (v[0..value.usageCountsCount]) |*vv| {
            print_VkMicromapUsageEXT("pUsageCounts", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUsageCounts: [*]const VkMicromapUsageEXT = null,\n", .{});
    }
    if (value.ppUsageCounts) |v| {
        for (v[0..value.usageCountsCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppUsageCounts: [*]const *const VkMicromapUsageEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppUsageCounts: [*]const *const VkMicromapUsageEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    data: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.data});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scratchData: VkDeviceOrHostAddressKHR = {any},\n", .{value.scratchData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    triangleArray: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.triangleArray});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    triangleArrayStride: u64 = {d},\n", .{value.triangleArrayStride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMicromapCreateInfoEXT(name: []const u8, value: *const vk.VkMicromapCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMicromapCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    createFlags: VkMicromapCreateFlagsEXT = {any},\n", .{value.createFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buffer: VkBuffer = {},\n", .{value.buffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkMicromapTypeEXT = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceAddress: u64 = {d},\n", .{value.deviceAddress});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMicromapVersionInfoEXT(name: []const u8, value: *const vk.VkMicromapVersionInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMicromapVersionInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pVersionData) |v| {
        for (v[0..2 * vk.VK_UUID_SIZE]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pVersionData: [*]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVersionData: [*]const u8 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMicromapInfoEXT(name: []const u8, value: *const vk.VkCopyMicromapInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMicromapInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    src: VkMicromapEXT = {},\n", .{value.src});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dst: VkMicromapEXT = {},\n", .{value.dst});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkCopyMicromapModeEXT = {t},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMicromapToMemoryInfoEXT(name: []const u8, value: *const vk.VkCopyMicromapToMemoryInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMicromapToMemoryInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    src: VkMicromapEXT = {},\n", .{value.src});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dst: VkDeviceOrHostAddressKHR = {any},\n", .{value.dst});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkCopyMicromapModeEXT = {t},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyMemoryToMicromapInfoEXT(name: []const u8, value: *const vk.VkCopyMemoryToMicromapInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyMemoryToMicromapInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    src: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.src});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dst: VkMicromapEXT = {},\n", .{value.dst});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkCopyMicromapModeEXT = {t},\n", .{value.mode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMicromapBuildSizesInfoEXT(name: []const u8, value: *const vk.VkMicromapBuildSizesInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMicromapBuildSizesInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    micromapSize: u64 = {d},\n", .{value.micromapSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    buildScratchSize: u64 = {d},\n", .{value.buildScratchSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    discardable: u32 = {d},\n", .{value.discardable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMicromapUsageEXT(name: []const u8, value: *const vk.VkMicromapUsageEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMicromapUsageEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    count: u32 = {d},\n", .{value.count});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subdivisionLevel: u32 = {d},\n", .{value.subdivisionLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: u32 = {d},\n", .{value.format});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMicromapTriangleEXT(name: []const u8, value: *const vk.VkMicromapTriangleEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMicromapTriangleEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataOffset: u32 = {d},\n", .{value.dataOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    subdivisionLevel: u16 = {d},\n", .{value.subdivisionLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: u16 = {d},\n", .{value.format});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceOpacityMicromapFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceOpacityMicromapFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    micromap: u32 = {d},\n", .{value.micromap});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    micromapCaptureReplay: u32 = {d},\n", .{value.micromapCaptureReplay});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    micromapHostCommands: u32 = {d},\n", .{value.micromapHostCommands});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceOpacityMicromapPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceOpacityMicromapPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxOpacity2StateSubdivisionLevel: u32 = {d},\n", .{value.maxOpacity2StateSubdivisionLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxOpacity4StateSubdivisionLevel: u32 = {d},\n", .{value.maxOpacity4StateSubdivisionLevel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureTrianglesOpacityMicromapEXT(name: []const u8, value: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureTrianglesOpacityMicromapEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexBuffer: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.indexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexStride: u64 = {d},\n", .{value.indexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseTriangle: u32 = {d},\n", .{value.baseTriangle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usageCountsCount: u32 = {d},\n", .{value.usageCountsCount});
    if (value.pUsageCounts) |v| {
        for (v[0..value.usageCountsCount]) |*vv| {
            print_VkMicromapUsageEXT("pUsageCounts", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUsageCounts: [*]const VkMicromapUsageEXT = null,\n", .{});
    }
    if (value.ppUsageCounts) |v| {
        for (v[0..value.usageCountsCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppUsageCounts: [*]const *const VkMicromapUsageEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppUsageCounts: [*]const *const VkMicromapUsageEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    micromap: VkMicromapEXT = {},\n", .{value.micromap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDisplacementMicromapFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDisplacementMicromapFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDisplacementMicromapFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacementMicromap: u32 = {d},\n", .{value.displacementMicromap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDisplacementMicromapPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDisplacementMicromapPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDisplacementMicromapPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDisplacementMicromapSubdivisionLevel: u32 = {d},\n", .{value.maxDisplacementMicromapSubdivisionLevel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureTrianglesDisplacementMicromapNV(name: []const u8, value: *const vk.VkAccelerationStructureTrianglesDisplacementMicromapNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureTrianglesDisplacementMicromapNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacementBiasAndScaleFormat: VkFormat = {t},\n", .{value.displacementBiasAndScaleFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacementVectorFormat: VkFormat = {t},\n", .{value.displacementVectorFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacementBiasAndScaleBuffer: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.displacementBiasAndScaleBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacementBiasAndScaleStride: u64 = {d},\n", .{value.displacementBiasAndScaleStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacementVectorBuffer: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.displacementVectorBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacementVectorStride: u64 = {d},\n", .{value.displacementVectorStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacedMicromapPrimitiveFlags: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.displacedMicromapPrimitiveFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    displacedMicromapPrimitiveFlagsStride: u64 = {d},\n", .{value.displacedMicromapPrimitiveFlagsStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexType: VkIndexType = {t},\n", .{value.indexType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexBuffer: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.indexBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    indexStride: u64 = {d},\n", .{value.indexStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseTriangle: u32 = {d},\n", .{value.baseTriangle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usageCountsCount: u32 = {d},\n", .{value.usageCountsCount});
    if (value.pUsageCounts) |v| {
        for (v[0..value.usageCountsCount]) |*vv| {
            print_VkMicromapUsageEXT("pUsageCounts", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pUsageCounts: [*]const VkMicromapUsageEXT = null,\n", .{});
    }
    if (value.ppUsageCounts) |v| {
        for (v[0..value.usageCountsCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    ppUsageCounts: [*]const *const VkMicromapUsageEXT = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    ppUsageCounts: [*]const *const VkMicromapUsageEXT = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    micromap: VkMicromapEXT = {},\n", .{value.micromap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelinePropertiesIdentifierEXT(name: []const u8, value: *const vk.VkPipelinePropertiesIdentifierEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelinePropertiesIdentifierEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineIdentifier: [VK_UUID_SIZE]u8 = {any},\n", .{value.pipelineIdentifier});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelinePropertiesFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelinePropertiesFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelinePropertiesIdentifier: u32 = {d},\n", .{value.pipelinePropertiesIdentifier});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(name: []const u8, value: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderEarlyAndLateFragmentTests: u32 = {d},\n", .{value.shaderEarlyAndLateFragmentTests});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalMemoryAcquireUnmodifiedEXT(name: []const u8, value: *const vk.VkExternalMemoryAcquireUnmodifiedEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalMemoryAcquireUnmodifiedEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    acquireUnmodifiedMemory: u32 = {d},\n", .{value.acquireUnmodifiedMemory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalObjectCreateInfoEXT(name: []const u8, value: *const vk.VkExportMetalObjectCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalObjectCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    exportObjectType: VkExportMetalObjectTypeFlagsEXT = {any},\n", .{value.exportObjectType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalObjectsInfoEXT(name: []const u8, value: *const vk.VkExportMetalObjectsInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalObjectsInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalDeviceInfoEXT(name: []const u8, value: *const vk.VkExportMetalDeviceInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalDeviceInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalCommandQueueInfoEXT(name: []const u8, value: *const vk.VkExportMetalCommandQueueInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalCommandQueueInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queue: VkQueue = {},\n", .{value.queue});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalBufferInfoEXT(name: []const u8, value: *const vk.VkExportMetalBufferInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalBufferInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMetalBufferInfoEXT(name: []const u8, value: *const vk.VkImportMetalBufferInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMetalBufferInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalTextureInfoEXT(name: []const u8, value: *const vk.VkExportMetalTextureInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalTextureInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageView: VkImageView = {},\n", .{value.imageView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferView: VkBufferView = {},\n", .{value.bufferView});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    plane: VkImageAspectFlags = {any},\n", .{value.plane});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMetalTextureInfoEXT(name: []const u8, value: *const vk.VkImportMetalTextureInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMetalTextureInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    plane: VkImageAspectFlags = {any},\n", .{value.plane});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalIOSurfaceInfoEXT(name: []const u8, value: *const vk.VkExportMetalIOSurfaceInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalIOSurfaceInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    image: VkImage = {},\n", .{value.image});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMetalIOSurfaceInfoEXT(name: []const u8, value: *const vk.VkImportMetalIOSurfaceInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMetalIOSurfaceInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExportMetalSharedEventInfoEXT(name: []const u8, value: *const vk.VkExportMetalSharedEventInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExportMetalSharedEventInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    semaphore: VkSemaphore = {},\n", .{value.semaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    event: VkEvent = {},\n", .{value.event});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportMetalSharedEventInfoEXT(name: []const u8, value: *const vk.VkImportMetalSharedEventInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportMetalSharedEventInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nonSeamlessCubeMap: u32 = {d},\n", .{value.nonSeamlessCubeMap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineRobustnessFeatures(name: []const u8, value: *const vk.VkPhysicalDevicePipelineRobustnessFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineRobustnessFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineRobustness: u32 = {d},\n", .{value.pipelineRobustness});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineRobustnessCreateInfo(name: []const u8, value: *const vk.VkPipelineRobustnessCreateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineRobustnessCreateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    storageBuffers: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.storageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    uniformBuffers: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.uniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexInputs: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.vertexInputs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    images: VkPipelineRobustnessImageBehavior = {t},\n", .{value.images});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineRobustnessProperties(name: []const u8, value: *const vk.VkPhysicalDevicePipelineRobustnessProperties, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineRobustnessProperties = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.defaultRobustnessStorageBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.defaultRobustnessUniformBuffers});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior = {t},\n", .{value.defaultRobustnessVertexInputs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    defaultRobustnessImages: VkPipelineRobustnessImageBehavior = {t},\n", .{value.defaultRobustnessImages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageViewSampleWeightCreateInfoQCOM(name: []const u8, value: *const vk.VkImageViewSampleWeightCreateInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageViewSampleWeightCreateInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkOffset2D("filterCenter", &value.filterCenter, offset + 1);
    print_VkExtent2D("filterSize", &value.filterSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numPhases: u32 = {d},\n", .{value.numPhases});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageProcessingFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageProcessingFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureSampleWeighted: u32 = {d},\n", .{value.textureSampleWeighted});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureBoxFilter: u32 = {d},\n", .{value.textureBoxFilter});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureBlockMatch: u32 = {d},\n", .{value.textureBlockMatch});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageProcessingPropertiesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageProcessingPropertiesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxWeightFilterPhases: u32 = {d},\n", .{value.maxWeightFilterPhases});
    print_VkExtent2D("maxWeightFilterDimension", &value.maxWeightFilterDimension, offset + 1);
    print_VkExtent2D("maxBlockMatchRegion", &value.maxBlockMatchRegion, offset + 1);
    print_VkExtent2D("maxBoxFilterBlockSize", &value.maxBoxFilterBlockSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTilePropertiesFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTilePropertiesFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileProperties: u32 = {d},\n", .{value.tileProperties});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTilePropertiesQCOM(name: []const u8, value: *const vk.VkTilePropertiesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTilePropertiesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent3D("tileSize", &value.tileSize, offset + 1);
    print_VkExtent2D("apronSize", &value.apronSize, offset + 1);
    print_VkOffset2D("origin", &value.origin, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTileMemoryBindInfoQCOM(name: []const u8, value: *const vk.VkTileMemoryBindInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTileMemoryBindInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceAmigoProfilingFeaturesSEC(name: []const u8, value: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceAmigoProfilingFeaturesSEC = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    amigoProfiling: u32 = {d},\n", .{value.amigoProfiling});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAmigoProfilingSubmitInfoSEC(name: []const u8, value: *const vk.VkAmigoProfilingSubmitInfoSEC, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAmigoProfilingSubmitInfoSEC = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstDrawTimestamp: u64 = {d},\n", .{value.firstDrawTimestamp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapBufferTimestamp: u64 = {d},\n", .{value.swapBufferTimestamp});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    attachmentFeedbackLoopLayout: u32 = {d},\n", .{value.attachmentFeedbackLoopLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAttachmentFeedbackLoopInfoEXT(name: []const u8, value: *const vk.VkAttachmentFeedbackLoopInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAttachmentFeedbackLoopInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    feedbackLoopEnable: u32 = {d},\n", .{value.feedbackLoopEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceAddressBindingReportFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceAddressBindingReportFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    reportAddressBinding: u32 = {d},\n", .{value.reportAddressBinding});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingAttachmentFlagsInfoKHR(name: []const u8, value: *const vk.VkRenderingAttachmentFlagsInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingAttachmentFlagsInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkRenderingAttachmentFlagsKHR = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkResolveImageModeInfoKHR(name: []const u8, value: *const vk.VkResolveImageModeInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkResolveImageModeInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkResolveImageFlagsKHR = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resolveMode: VkResolveModeFlags = {any},\n", .{value.resolveMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stencilResolveMode: VkResolveModeFlags = {any},\n", .{value.stencilResolveMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceAddressBindingCallbackDataEXT(name: []const u8, value: *const vk.VkDeviceAddressBindingCallbackDataEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceAddressBindingCallbackDataEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDeviceAddressBindingFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    baseAddress: u64 = {d},\n", .{value.baseAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindingType: VkDeviceAddressBindingTypeEXT = {t},\n", .{value.bindingType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceOpticalFlowFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceOpticalFlowFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    opticalFlow: u32 = {d},\n", .{value.opticalFlow});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceOpticalFlowPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceOpticalFlowPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV = {any},\n", .{value.supportedOutputGridSizes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV = {any},\n", .{value.supportedHintGridSizes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hintSupported: u32 = {d},\n", .{value.hintSupported});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    costSupported: u32 = {d},\n", .{value.costSupported});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bidirectionalFlowSupported: u32 = {d},\n", .{value.bidirectionalFlowSupported});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    globalFlowSupported: u32 = {d},\n", .{value.globalFlowSupported});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minWidth: u32 = {d},\n", .{value.minWidth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minHeight: u32 = {d},\n", .{value.minHeight});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxWidth: u32 = {d},\n", .{value.maxWidth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxHeight: u32 = {d},\n", .{value.maxHeight});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxNumRegionsOfInterest: u32 = {d},\n", .{value.maxNumRegionsOfInterest});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOpticalFlowImageFormatInfoNV(name: []const u8, value: *const vk.VkOpticalFlowImageFormatInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOpticalFlowImageFormatInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkOpticalFlowUsageFlagsNV = {any},\n", .{value.usage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOpticalFlowImageFormatPropertiesNV(name: []const u8, value: *const vk.VkOpticalFlowImageFormatPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOpticalFlowImageFormatPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOpticalFlowSessionCreateInfoNV(name: []const u8, value: *const vk.VkOpticalFlowSessionCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOpticalFlowSessionCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    width: u32 = {d},\n", .{value.width});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    height: u32 = {d},\n", .{value.height});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageFormat: VkFormat = {t},\n", .{value.imageFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flowVectorFormat: VkFormat = {t},\n", .{value.flowVectorFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    costFormat: VkFormat = {t},\n", .{value.costFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    outputGridSize: VkOpticalFlowGridSizeFlagsNV = {any},\n", .{value.outputGridSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hintGridSize: VkOpticalFlowGridSizeFlagsNV = {any},\n", .{value.hintGridSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    performanceLevel: VkOpticalFlowPerformanceLevelNV = {t},\n", .{value.performanceLevel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkOpticalFlowSessionCreateFlagsNV = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOpticalFlowSessionCreatePrivateDataInfoNV(name: []const u8, value: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOpticalFlowSessionCreatePrivateDataInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    id: u32 = {d},\n", .{value.id});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u32 = {d},\n", .{value.size});
    if (value.pPrivateData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPrivateData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPrivateData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOpticalFlowExecuteInfoNV(name: []const u8, value: *const vk.VkOpticalFlowExecuteInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOpticalFlowExecuteInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkOpticalFlowExecuteFlagsNV = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkRect2D("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkRect2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFaultFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFaultFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFaultFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceFault: u32 = {d},\n", .{value.deviceFault});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceFaultVendorBinary: u32 = {d},\n", .{value.deviceFaultVendorBinary});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceFaultAddressInfoEXT(name: []const u8, value: *const vk.VkDeviceFaultAddressInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceFaultAddressInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    addressType: VkDeviceFaultAddressTypeEXT = {t},\n", .{value.addressType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    reportedAddress: u64 = {d},\n", .{value.reportedAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    addressPrecision: u64 = {d},\n", .{value.addressPrecision});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceFaultVendorInfoEXT(name: []const u8, value: *const vk.VkDeviceFaultVendorInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceFaultVendorInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorFaultCode: u64 = {d},\n", .{value.vendorFaultCode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorFaultData: u64 = {d},\n", .{value.vendorFaultData});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceFaultCountsEXT(name: []const u8, value: *const vk.VkDeviceFaultCountsEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceFaultCountsEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    addressInfoCount: u32 = {d},\n", .{value.addressInfoCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorInfoCount: u32 = {d},\n", .{value.vendorInfoCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorBinarySize: u64 = {d},\n", .{value.vendorBinarySize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceFaultInfoEXT(name: []const u8, value: *const vk.VkDeviceFaultInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceFaultInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    description: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.description});
    if (value.pAddressInfos) |v| {
        print_VkDeviceFaultAddressInfoEXT("pAddressInfos", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pAddressInfos: *VkDeviceFaultAddressInfoEXT = null,\n", .{});
    }
    if (value.pVendorInfos) |v| {
        print_VkDeviceFaultVendorInfoEXT("pVendorInfos", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVendorInfos: *VkDeviceFaultVendorInfoEXT = null,\n", .{});
    }
    if (value.pVendorBinaryData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVendorBinaryData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVendorBinaryData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(name: []const u8, value: *const vk.VkDeviceFaultVendorBinaryHeaderVersionOneEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceFaultVendorBinaryHeaderVersionOneEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    headerSize: u32 = {d},\n", .{value.headerSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT = {t},\n", .{value.headerVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vendorID: u32 = {d},\n", .{value.vendorID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceID: u32 = {d},\n", .{value.deviceID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverVersion: u32 = {any},\n", .{value.driverVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCacheUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.pipelineCacheUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    applicationNameOffset: u32 = {d},\n", .{value.applicationNameOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    applicationVersion: u32 = {any},\n", .{value.applicationVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    engineNameOffset: u32 = {d},\n", .{value.engineNameOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    engineVersion: u32 = {any},\n", .{value.engineVersion});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    apiVersion: u32 = {any},\n", .{value.apiVersion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineLibraryGroupHandles: u32 = {d},\n", .{value.pipelineLibraryGroupHandles});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDepthBiasInfoEXT(name: []const u8, value: *const vk.VkDepthBiasInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDepthBiasInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasConstantFactor: f32 = {d},\n", .{value.depthBiasConstantFactor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasClamp: f32 = {d},\n", .{value.depthBiasClamp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasSlopeFactor: f32 = {d},\n", .{value.depthBiasSlopeFactor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDepthBiasRepresentationInfoEXT(name: []const u8, value: *const vk.VkDepthBiasRepresentationInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDepthBiasRepresentationInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasRepresentation: VkDepthBiasRepresentationEXT = {t},\n", .{value.depthBiasRepresentation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasExact: u32 = {d},\n", .{value.depthBiasExact});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDecompressMemoryRegionNV(name: []const u8, value: *const vk.VkDecompressMemoryRegionNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDecompressMemoryRegionNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAddress: u64 = {d},\n", .{value.srcAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAddress: u64 = {d},\n", .{value.dstAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compressedSize: u64 = {d},\n", .{value.compressedSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    decompressedSize: u64 = {d},\n", .{value.decompressedSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDecompressMemoryRegionEXT(name: []const u8, value: *const vk.VkDecompressMemoryRegionEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDecompressMemoryRegionEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAddress: u64 = {d},\n", .{value.srcAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAddress: u64 = {d},\n", .{value.dstAddress});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compressedSize: u64 = {d},\n", .{value.compressedSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    decompressedSize: u64 = {d},\n", .{value.decompressedSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDecompressMemoryInfoEXT(name: []const u8, value: *const vk.VkDecompressMemoryInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDecompressMemoryInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    decompressionMethod: VkMemoryDecompressionMethodFlagsEXT = {any},\n", .{value.decompressionMethod});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkDecompressMemoryRegionEXT("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkDecompressMemoryRegionEXT = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(name: []const u8, value: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCoreMask: u64 = {d},\n", .{value.shaderCoreMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCoreCount: u32 = {d},\n", .{value.shaderCoreCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderWarpsPerCore: u32 = {d},\n", .{value.shaderWarpsPerCore});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCoreBuiltins: u32 = {d},\n", .{value.shaderCoreBuiltins});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFrameBoundaryEXT(name: []const u8, value: *const vk.VkFrameBoundaryEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFrameBoundaryEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkFrameBoundaryFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameID: u64 = {d},\n", .{value.frameID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageCount: u32 = {d},\n", .{value.imageCount});
    if (value.pImages) |v| {
        for (v[0..value.imageCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pImages: [*]const VkImage = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImages: [*]const VkImage = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bufferCount: u32 = {d},\n", .{value.bufferCount});
    if (value.pBuffers) |v| {
        for (v[0..value.bufferCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pBuffers: [*]const VkBuffer = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBuffers: [*]const VkBuffer = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tagName: u64 = {d},\n", .{value.tagName});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tagSize: u64 = {d},\n", .{value.tagSize});
    if (value.pTag) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTag: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTag: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFrameBoundaryFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFrameBoundaryFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameBoundary: u32 = {d},\n", .{value.frameBoundary});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicRenderingUnusedAttachments: u32 = {d},\n", .{value.dynamicRenderingUnusedAttachments});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfacePresentModeKHR(name: []const u8, value: *const vk.VkSurfacePresentModeKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfacePresentModeKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentMode: VkPresentModeKHR = {t},\n", .{value.presentMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfacePresentScalingCapabilitiesKHR(name: []const u8, value: *const vk.VkSurfacePresentScalingCapabilitiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfacePresentScalingCapabilitiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedPresentScaling: VkPresentScalingFlagsKHR = {any},\n", .{value.supportedPresentScaling});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedPresentGravityX: VkPresentGravityFlagsKHR = {any},\n", .{value.supportedPresentGravityX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedPresentGravityY: VkPresentGravityFlagsKHR = {any},\n", .{value.supportedPresentGravityY});
    print_VkExtent2D("minScaledImageExtent", &value.minScaledImageExtent, offset + 1);
    print_VkExtent2D("maxScaledImageExtent", &value.maxScaledImageExtent, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfacePresentModeCompatibilityKHR(name: []const u8, value: *const vk.VkSurfacePresentModeCompatibilityKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfacePresentModeCompatibilityKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentModeCount: u32 = {d},\n", .{value.presentModeCount});
    if (value.pPresentModes) |v| {
        for (v[0..value.presentModeCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPresentModes: [*]VkPresentModeKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentModes: [*]VkPresentModeKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainMaintenance1: u32 = {d},\n", .{value.swapchainMaintenance1});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainPresentFenceInfoKHR(name: []const u8, value: *const vk.VkSwapchainPresentFenceInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainPresentFenceInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pFences) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pFences: [*]const VkFence = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pFences: [*]const VkFence = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainPresentModesCreateInfoKHR(name: []const u8, value: *const vk.VkSwapchainPresentModesCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainPresentModesCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentModeCount: u32 = {d},\n", .{value.presentModeCount});
    if (value.pPresentModes) |v| {
        for (v[0..value.presentModeCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPresentModes: [*]const VkPresentModeKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentModes: [*]const VkPresentModeKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainPresentModeInfoKHR(name: []const u8, value: *const vk.VkSwapchainPresentModeInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainPresentModeInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchainCount: u32 = {d},\n", .{value.swapchainCount});
    if (value.pPresentModes) |v| {
        for (v[0..value.swapchainCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPresentModes: [*]const VkPresentModeKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentModes: [*]const VkPresentModeKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainPresentScalingCreateInfoKHR(name: []const u8, value: *const vk.VkSwapchainPresentScalingCreateInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainPresentScalingCreateInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scalingBehavior: VkPresentScalingFlagsKHR = {any},\n", .{value.scalingBehavior});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentGravityX: VkPresentGravityFlagsKHR = {any},\n", .{value.presentGravityX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentGravityY: VkPresentGravityFlagsKHR = {any},\n", .{value.presentGravityY});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkReleaseSwapchainImagesInfoKHR(name: []const u8, value: *const vk.VkReleaseSwapchainImagesInfoKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkReleaseSwapchainImagesInfoKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    swapchain: VkSwapchainKHR = {},\n", .{value.swapchain});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageIndexCount: u32 = {d},\n", .{value.imageIndexCount});
    if (value.pImageIndices) |v| {
        for (v[0..value.imageIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pImageIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pImageIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDepthBiasControlFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDepthBiasControlFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasControl: u32 = {d},\n", .{value.depthBiasControl});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    leastRepresentableValueForceUnormRepresentation: u32 = {d},\n", .{value.leastRepresentableValueForceUnormRepresentation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    floatRepresentation: u32 = {d},\n", .{value.floatRepresentation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthBiasExact: u32 = {d},\n", .{value.depthBiasExact});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingInvocationReorder: u32 = {d},\n", .{value.rayTracingInvocationReorder});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingInvocationReorder: u32 = {d},\n", .{value.rayTracingInvocationReorder});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT = {t},\n", .{value.rayTracingInvocationReorderReorderingHint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxShaderBindingTableRecordIndex: u32 = {d},\n", .{value.maxShaderBindingTableRecordIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT = {t},\n", .{value.rayTracingInvocationReorderReorderingHint});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedSparseAddressSpace: u32 = {d},\n", .{value.extendedSparseAddressSpace});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedSparseAddressSpaceSize: u64 = {d},\n", .{value.extendedSparseAddressSpaceSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedSparseImageUsageFlags: VkImageUsageFlags = {any},\n", .{value.extendedSparseImageUsageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    extendedSparseBufferUsageFlags: VkBufferUsageFlags = {any},\n", .{value.extendedSparseBufferUsageFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDirectDriverLoadingInfoLUNARG(name: []const u8, value: *const vk.VkDirectDriverLoadingInfoLUNARG, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDirectDriverLoadingInfoLUNARG = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDirectDriverLoadingFlagsLUNARG = {any},\n", .{value.flags});
    if (value.pfnGetInstanceProcAddr) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnGetInstanceProcAddr: *const vkGetInstanceProcAddrLUNARG = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pfnGetInstanceProcAddr: *const vkGetInstanceProcAddrLUNARG = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDirectDriverLoadingListLUNARG(name: []const u8, value: *const vk.VkDirectDriverLoadingListLUNARG, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDirectDriverLoadingListLUNARG = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkDirectDriverLoadingModeLUNARG = {t},\n", .{value.mode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverCount: u32 = {d},\n", .{value.driverCount});
    if (value.pDrivers) |v| {
        for (v[0..value.driverCount]) |*vv| {
            print_VkDirectDriverLoadingInfoLUNARG("pDrivers", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDrivers: [*]const VkDirectDriverLoadingInfoLUNARG = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewPerViewViewports: u32 = {d},\n", .{value.multiviewPerViewViewports});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rayTracingPositionFetch: u32 = {d},\n", .{value.rayTracingPositionFetch});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceImageSubresourceInfo(name: []const u8, value: *const vk.VkDeviceImageSubresourceInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceImageSubresourceInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pCreateInfo) |v| {
        print_VkImageCreateInfo("pCreateInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCreateInfo: *const VkImageCreateInfo = null,\n", .{});
    }
    if (value.pSubresource) |v| {
        print_VkImageSubresource2("pSubresource", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSubresource: *const VkImageSubresource2 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderCorePropertiesARM(name: []const u8, value: *const vk.VkPhysicalDeviceShaderCorePropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderCorePropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pixelRate: u32 = {d},\n", .{value.pixelRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    texelRate: u32 = {d},\n", .{value.texelRate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fmaRate: u32 = {d},\n", .{value.fmaRate});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    multiviewPerViewRenderAreas: u32 = {d},\n", .{value.multiviewPerViewRenderAreas});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(name: []const u8, value: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    perViewRenderAreaCount: u32 = {d},\n", .{value.perViewRenderAreaCount});
    if (value.pPerViewRenderAreas) |v| {
        for (v[0..value.perViewRenderAreaCount]) |*vv| {
            print_VkRect2D("pPerViewRenderAreas", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPerViewRenderAreas: [*]const VkRect2D = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueryLowLatencySupportNV(name: []const u8, value: *const vk.VkQueryLowLatencySupportNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueryLowLatencySupportNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pQueriedLowLatencyData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueriedLowLatencyData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueriedLowLatencyData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryMapInfo(name: []const u8, value: *const vk.VkMemoryMapInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryMapInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkMemoryMapFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u64 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryUnmapInfo(name: []const u8, value: *const vk.VkMemoryUnmapInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryUnmapInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkMemoryUnmapFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderObjectFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderObjectFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderObject: u32 = {d},\n", .{value.shaderObject});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderObjectPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderObjectPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBinaryUUID: [VK_UUID_SIZE]u8 = {any},\n", .{value.shaderBinaryUUID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBinaryVersion: u32 = {any},\n", .{value.shaderBinaryVersion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkShaderCreateInfoEXT(name: []const u8, value: *const vk.VkShaderCreateInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkShaderCreateInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkShaderCreateFlagsEXT = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stage: VkShaderStageFlags = {any},\n", .{value.stage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nextStage: VkShaderStageFlags = {any},\n", .{value.nextStage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    codeType: VkShaderCodeTypeEXT = {t},\n", .{value.codeType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    codeSize: u64 = {d},\n", .{value.codeSize});
    if (value.pCode) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCode: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCode: *const anyopaque = null,\n", .{});
    }
    if (value.pName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    setLayoutCount: u32 = {d},\n", .{value.setLayoutCount});
    if (value.pSetLayouts) |v| {
        for (v[0..value.setLayoutCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSetLayouts: [*]const VkDescriptorSetLayout = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pushConstantRangeCount: u32 = {d},\n", .{value.pushConstantRangeCount});
    if (value.pPushConstantRanges) |v| {
        for (v[0..value.pushConstantRangeCount]) |*vv| {
            print_VkPushConstantRange("pPushConstantRanges", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPushConstantRanges: [*]const VkPushConstantRange = null,\n", .{});
    }
    if (value.pSpecializationInfo) |v| {
        print_VkSpecializationInfo("pSpecializationInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSpecializationInfo: *const VkSpecializationInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderTileImageFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderTileImageFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTileImageColorReadAccess: u32 = {d},\n", .{value.shaderTileImageColorReadAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTileImageDepthReadAccess: u32 = {d},\n", .{value.shaderTileImageDepthReadAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTileImageStencilReadAccess: u32 = {d},\n", .{value.shaderTileImageStencilReadAccess});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderTileImagePropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderTileImagePropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTileImageCoherentReadAccelerated: u32 = {d},\n", .{value.shaderTileImageCoherentReadAccelerated});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTileImageReadSampleFromPixelRateInvocation: u32 = {d},\n", .{value.shaderTileImageReadSampleFromPixelRateInvocation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTileImageReadFromHelperInvocation: u32 = {d},\n", .{value.shaderTileImageReadFromHelperInvocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportScreenBufferInfoQNX(name: []const u8, value: *const vk.VkImportScreenBufferInfoQNX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportScreenBufferInfoQNX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.buffer) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    buffer: *_screen_buffer = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    buffer: *_screen_buffer = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkScreenBufferPropertiesQNX(name: []const u8, value: *const vk.VkScreenBufferPropertiesQNX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkScreenBufferPropertiesQNX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    allocationSize: u64 = {d},\n", .{value.allocationSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkScreenBufferFormatPropertiesQNX(name: []const u8, value: *const vk.VkScreenBufferFormatPropertiesQNX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkScreenBufferFormatPropertiesQNX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormat: u64 = {d},\n", .{value.externalFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    screenUsage: u64 = {d},\n", .{value.screenUsage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatFeatures: VkFormatFeatureFlags = {any},\n", .{value.formatFeatures});
    print_VkComponentMapping("samplerYcbcrConversionComponents", &value.samplerYcbcrConversionComponents, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = {t},\n", .{value.suggestedYcbcrModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrRange: VkSamplerYcbcrRange = {t},\n", .{value.suggestedYcbcrRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedXChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedXChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedYChromaOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalFormatQNX(name: []const u8, value: *const vk.VkExternalFormatQNX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalFormatQNX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormat: u64 = {d},\n", .{value.externalFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(name: []const u8, value: *const vk.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    screenBufferImport: u32 = {d},\n", .{value.screenBufferImport});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeMatrixFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrix: u32 = {d},\n", .{value.cooperativeMatrix});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixRobustBufferAccess: u32 = {d},\n", .{value.cooperativeMatrixRobustBufferAccess});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCooperativeMatrixPropertiesKHR(name: []const u8, value: *const vk.VkCooperativeMatrixPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCooperativeMatrixPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    MSize: u32 = {d},\n", .{value.MSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    NSize: u32 = {d},\n", .{value.NSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    KSize: u32 = {d},\n", .{value.KSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    AType: VkComponentTypeKHR = {t},\n", .{value.AType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    BType: VkComponentTypeKHR = {t},\n", .{value.BType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    CType: VkComponentTypeKHR = {t},\n", .{value.CType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ResultType: VkComponentTypeKHR = {t},\n", .{value.ResultType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    saturatingAccumulation: u32 = {d},\n", .{value.saturatingAccumulation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scope: VkScopeKHR = {t},\n", .{value.scope});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeMatrixPropertiesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixSupportedStages: VkShaderStageFlags = {any},\n", .{value.cooperativeMatrixSupportedStages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderEnqueuePropertiesAMDX(name: []const u8, value: *const vk.VkPhysicalDeviceShaderEnqueuePropertiesAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderEnqueuePropertiesAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExecutionGraphDepth: u32 = {d},\n", .{value.maxExecutionGraphDepth});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExecutionGraphShaderOutputNodes: u32 = {d},\n", .{value.maxExecutionGraphShaderOutputNodes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExecutionGraphShaderPayloadSize: u32 = {d},\n", .{value.maxExecutionGraphShaderPayloadSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExecutionGraphShaderPayloadCount: u32 = {d},\n", .{value.maxExecutionGraphShaderPayloadCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    executionGraphDispatchAddressAlignment: u32 = {d},\n", .{value.executionGraphDispatchAddressAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExecutionGraphWorkgroupCount: [3]u32 = {any},\n", .{value.maxExecutionGraphWorkgroupCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExecutionGraphWorkgroups: u32 = {d},\n", .{value.maxExecutionGraphWorkgroups});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderEnqueueFeaturesAMDX(name: []const u8, value: *const vk.VkPhysicalDeviceShaderEnqueueFeaturesAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderEnqueueFeaturesAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderEnqueue: u32 = {d},\n", .{value.shaderEnqueue});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderMeshEnqueue: u32 = {d},\n", .{value.shaderMeshEnqueue});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExecutionGraphPipelineCreateInfoAMDX(name: []const u8, value: *const vk.VkExecutionGraphPipelineCreateInfoAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExecutionGraphPipelineCreateInfoAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPipelineCreateFlags = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageCount: u32 = {d},\n", .{value.stageCount});
    if (value.pStages) |v| {
        for (v[0..value.stageCount]) |*vv| {
            print_VkPipelineShaderStageCreateInfo("pStages", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStages: [*]const VkPipelineShaderStageCreateInfo = null,\n", .{});
    }
    if (value.pLibraryInfo) |v| {
        print_VkPipelineLibraryCreateInfoKHR("pLibraryInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pLibraryInfo: *const VkPipelineLibraryCreateInfoKHR = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineHandle: VkPipeline = {},\n", .{value.basePipelineHandle});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    basePipelineIndex: i32 = {d},\n", .{value.basePipelineIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineShaderStageNodeCreateInfoAMDX(name: []const u8, value: *const vk.VkPipelineShaderStageNodeCreateInfoAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineShaderStageNodeCreateInfoAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pName: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    index: u32 = {d},\n", .{value.index});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExecutionGraphPipelineScratchSizeAMDX(name: []const u8, value: *const vk.VkExecutionGraphPipelineScratchSizeAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExecutionGraphPipelineScratchSizeAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minSize: u64 = {d},\n", .{value.minSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxSize: u64 = {d},\n", .{value.maxSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sizeGranularity: u64 = {d},\n", .{value.sizeGranularity});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDispatchGraphInfoAMDX(name: []const u8, value: *const vk.VkDispatchGraphInfoAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDispatchGraphInfoAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nodeIndex: u32 = {d},\n", .{value.nodeIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    payloadCount: u32 = {d},\n", .{value.payloadCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    payloads: VkDeviceOrHostAddressConstAMDX = {any},\n", .{value.payloads});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    payloadStride: u64 = {d},\n", .{value.payloadStride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDispatchGraphCountInfoAMDX(name: []const u8, value: *const vk.VkDispatchGraphCountInfoAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDispatchGraphCountInfoAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    count: u32 = {d},\n", .{value.count});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    infos: VkDeviceOrHostAddressConstAMDX = {any},\n", .{value.infos});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stride: u64 = {d},\n", .{value.stride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceAntiLagFeaturesAMD(name: []const u8, value: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceAntiLagFeaturesAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    antiLag: u32 = {d},\n", .{value.antiLag});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAntiLagDataAMD(name: []const u8, value: *const vk.VkAntiLagDataAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAntiLagDataAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    mode: VkAntiLagModeAMD = {t},\n", .{value.mode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFPS: u32 = {d},\n", .{value.maxFPS});
    if (value.pPresentationInfo) |v| {
        print_VkAntiLagPresentationInfoAMD("pPresentationInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentationInfo: *const VkAntiLagPresentationInfoAMD = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAntiLagPresentationInfoAMD(name: []const u8, value: *const vk.VkAntiLagPresentationInfoAMD, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAntiLagPresentationInfoAMD = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stage: VkAntiLagStageAMD = {t},\n", .{value.stage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    frameIndex: u64 = {d},\n", .{value.frameIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindMemoryStatus(name: []const u8, value: *const vk.VkBindMemoryStatus, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindMemoryStatus = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pResult) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pResult: *VkResult = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pResult: *VkResult = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileMemoryHeap: u32 = {d},\n", .{value.tileMemoryHeap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueSubmitBoundary: u32 = {d},\n", .{value.queueSubmitBoundary});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileBufferTransfers: u32 = {d},\n", .{value.tileBufferTransfers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTileMemorySizeInfoQCOM(name: []const u8, value: *const vk.VkTileMemorySizeInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTileMemorySizeInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTileMemoryRequirementsQCOM(name: []const u8, value: *const vk.VkTileMemoryRequirementsQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTileMemoryRequirementsQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u64 = {d},\n", .{value.size});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    alignment: u64 = {d},\n", .{value.alignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindDescriptorSetsInfo(name: []const u8, value: *const vk.VkBindDescriptorSetsInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindDescriptorSetsInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageFlags: VkShaderStageFlags = {any},\n", .{value.stageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstSet: u32 = {d},\n", .{value.firstSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSetCount: u32 = {d},\n", .{value.descriptorSetCount});
    if (value.pDescriptorSets) |v| {
        for (v[0..value.descriptorSetCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDescriptorSets: [*]const VkDescriptorSet = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDescriptorSets: [*]const VkDescriptorSet = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicOffsetCount: u32 = {d},\n", .{value.dynamicOffsetCount});
    if (value.pDynamicOffsets) |v| {
        for (v[0..value.dynamicOffsetCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDynamicOffsets: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDynamicOffsets: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPushConstantsInfo(name: []const u8, value: *const vk.VkPushConstantsInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPushConstantsInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageFlags: VkShaderStageFlags = {any},\n", .{value.stageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    offset: u32 = {d},\n", .{value.offset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    size: u32 = {d},\n", .{value.size});
    if (value.pValues) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pValues: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pValues: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPushDescriptorSetInfo(name: []const u8, value: *const vk.VkPushDescriptorSetInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPushDescriptorSetInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageFlags: VkShaderStageFlags = {any},\n", .{value.stageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    set: u32 = {d},\n", .{value.set});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorWriteCount: u32 = {d},\n", .{value.descriptorWriteCount});
    if (value.pDescriptorWrites) |v| {
        for (v[0..value.descriptorWriteCount]) |*vv| {
            print_VkWriteDescriptorSet("pDescriptorWrites", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDescriptorWrites: [*]const VkWriteDescriptorSet = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPushDescriptorSetWithTemplateInfo(name: []const u8, value: *const vk.VkPushDescriptorSetWithTemplateInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPushDescriptorSetWithTemplateInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorUpdateTemplate: VkDescriptorUpdateTemplate = {},\n", .{value.descriptorUpdateTemplate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    set: u32 = {d},\n", .{value.set});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSetDescriptorBufferOffsetsInfoEXT(name: []const u8, value: *const vk.VkSetDescriptorBufferOffsetsInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSetDescriptorBufferOffsetsInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageFlags: VkShaderStageFlags = {any},\n", .{value.stageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    firstSet: u32 = {d},\n", .{value.firstSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    setCount: u32 = {d},\n", .{value.setCount});
    if (value.pBufferIndices) |v| {
        for (v[0..value.setCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pBufferIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pBufferIndices: [*]const u32 = null,\n", .{});
    }
    if (value.pOffsets) |v| {
        for (v[0..value.setCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pOffsets: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pOffsets: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(name: []const u8, value: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindDescriptorBufferEmbeddedSamplersInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stageFlags: VkShaderStageFlags = {any},\n", .{value.stageFlags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    set: u32 = {d},\n", .{value.set});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCubicClampFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCubicClampFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cubicRangeClamp: u32 = {d},\n", .{value.cubicRangeClamp});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ycbcrDegamma: u32 = {d},\n", .{value.ycbcrDegamma});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(name: []const u8, value: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enableYDegamma: u32 = {d},\n", .{value.enableYDegamma});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    enableCbCrDegamma: u32 = {d},\n", .{value.enableCbCrDegamma});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCubicWeightsFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCubicWeightsFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    selectableCubicWeights: u32 = {d},\n", .{value.selectableCubicWeights});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerCubicWeightsCreateInfoQCOM(name: []const u8, value: *const vk.VkSamplerCubicWeightsCreateInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerCubicWeightsCreateInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cubicWeights: VkCubicFilterWeightsQCOM = {t},\n", .{value.cubicWeights});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBlitImageCubicWeightsInfoQCOM(name: []const u8, value: *const vk.VkBlitImageCubicWeightsInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBlitImageCubicWeightsInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cubicWeights: VkCubicFilterWeightsQCOM = {t},\n", .{value.cubicWeights});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageProcessing2FeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageProcessing2FeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    textureBlockMatch2: u32 = {d},\n", .{value.textureBlockMatch2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageProcessing2PropertiesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageProcessing2PropertiesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("maxBlockMatchWindow", &value.maxBlockMatchWindow, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSamplerBlockMatchWindowCreateInfoQCOM(name: []const u8, value: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSamplerBlockMatchWindowCreateInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("windowExtent", &value.windowExtent, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    windowCompareMode: VkBlockMatchWindowCompareModeQCOM = {t},\n", .{value.windowCompareMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorPoolOverallocation: u32 = {d},\n", .{value.descriptorPoolOverallocation});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceLayeredDriverPropertiesMSFT(name: []const u8, value: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceLayeredDriverPropertiesMSFT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    underlyingAPI: VkLayeredDriverUnderlyingApiMSFT = {t},\n", .{value.underlyingAPI});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePerStageDescriptorSetFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePerStageDescriptorSetFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    perStageDescriptorSet: u32 = {d},\n", .{value.perStageDescriptorSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicPipelineLayout: u32 = {d},\n", .{value.dynamicPipelineLayout});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(name: []const u8, value: *const vk.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalFormatResolveFeaturesANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormatResolve: u32 = {d},\n", .{value.externalFormatResolve});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(name: []const u8, value: *const vk.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalFormatResolvePropertiesANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    nullColorAttachmentWithExternalFormatResolve: u32 = {d},\n", .{value.nullColorAttachmentWithExternalFormatResolve});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormatResolveChromaOffsetX: VkChromaLocation = {t},\n", .{value.externalFormatResolveChromaOffsetX});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormatResolveChromaOffsetY: VkChromaLocation = {t},\n", .{value.externalFormatResolveChromaOffsetY});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(name: []const u8, value: *const vk.VkAndroidHardwareBufferFormatResolvePropertiesANDROID, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAndroidHardwareBufferFormatResolvePropertiesANDROID = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentFormat: VkFormat = {t},\n", .{value.colorAttachmentFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLatencySleepModeInfoNV(name: []const u8, value: *const vk.VkLatencySleepModeInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLatencySleepModeInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lowLatencyMode: u32 = {d},\n", .{value.lowLatencyMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    lowLatencyBoost: u32 = {d},\n", .{value.lowLatencyBoost});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minimumIntervalUs: u32 = {d},\n", .{value.minimumIntervalUs});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLatencySleepInfoNV(name: []const u8, value: *const vk.VkLatencySleepInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLatencySleepInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    signalSemaphore: VkSemaphore = {},\n", .{value.signalSemaphore});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    value: u64 = {d},\n", .{value.value});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSetLatencyMarkerInfoNV(name: []const u8, value: *const vk.VkSetLatencyMarkerInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSetLatencyMarkerInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentID: u64 = {d},\n", .{value.presentID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    marker: VkLatencyMarkerNV = {t},\n", .{value.marker});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkGetLatencyMarkerInfoNV(name: []const u8, value: *const vk.VkGetLatencyMarkerInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkGetLatencyMarkerInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    timingCount: u32 = {d},\n", .{value.timingCount});
    if (value.pTimings) |v| {
        for (v[0..value.timingCount]) |*vv| {
            print_VkLatencyTimingsFrameReportNV("pTimings", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTimings: [*]VkLatencyTimingsFrameReportNV = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLatencyTimingsFrameReportNV(name: []const u8, value: *const vk.VkLatencyTimingsFrameReportNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLatencyTimingsFrameReportNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentID: u64 = {d},\n", .{value.presentID});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputSampleTimeUs: u64 = {d},\n", .{value.inputSampleTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    simStartTimeUs: u64 = {d},\n", .{value.simStartTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    simEndTimeUs: u64 = {d},\n", .{value.simEndTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderSubmitStartTimeUs: u64 = {d},\n", .{value.renderSubmitStartTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderSubmitEndTimeUs: u64 = {d},\n", .{value.renderSubmitEndTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentStartTimeUs: u64 = {d},\n", .{value.presentStartTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentEndTimeUs: u64 = {d},\n", .{value.presentEndTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverStartTimeUs: u64 = {d},\n", .{value.driverStartTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    driverEndTimeUs: u64 = {d},\n", .{value.driverEndTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    osRenderQueueStartTimeUs: u64 = {d},\n", .{value.osRenderQueueStartTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    osRenderQueueEndTimeUs: u64 = {d},\n", .{value.osRenderQueueEndTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gpuRenderStartTimeUs: u64 = {d},\n", .{value.gpuRenderStartTimeUs});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    gpuRenderEndTimeUs: u64 = {d},\n", .{value.gpuRenderEndTimeUs});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkOutOfBandQueueTypeInfoNV(name: []const u8, value: *const vk.VkOutOfBandQueueTypeInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkOutOfBandQueueTypeInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueType: VkOutOfBandQueueTypeNV = {t},\n", .{value.queueType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLatencySubmissionPresentIdNV(name: []const u8, value: *const vk.VkLatencySubmissionPresentIdNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLatencySubmissionPresentIdNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentID: u64 = {d},\n", .{value.presentID});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainLatencyCreateInfoNV(name: []const u8, value: *const vk.VkSwapchainLatencyCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainLatencyCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    latencyModeEnable: u32 = {d},\n", .{value.latencyModeEnable});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkLatencySurfaceCapabilitiesNV(name: []const u8, value: *const vk.VkLatencySurfaceCapabilitiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkLatencySurfaceCapabilitiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentModeCount: u32 = {d},\n", .{value.presentModeCount});
    if (value.pPresentModes) |v| {
        for (v[0..value.presentModeCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pPresentModes: [*]VkPresentModeKHR = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPresentModes: [*]VkPresentModeKHR = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCudaKernelLaunchFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCudaKernelLaunchFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCudaKernelLaunchFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cudaKernelLaunchFeatures: u32 = {d},\n", .{value.cudaKernelLaunchFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCudaKernelLaunchPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCudaKernelLaunchPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCudaKernelLaunchPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeCapabilityMinor: u32 = {d},\n", .{value.computeCapabilityMinor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeCapabilityMajor: u32 = {d},\n", .{value.computeCapabilityMajor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceQueueShaderCoreControlCreateInfoARM(name: []const u8, value: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceQueueShaderCoreControlCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderCoreCount: u32 = {d},\n", .{value.shaderCoreCount});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSchedulingControlsFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSchedulingControlsFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    schedulingControls: u32 = {d},\n", .{value.schedulingControls});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceSchedulingControlsPropertiesARM(name: []const u8, value: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceSchedulingControlsPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    schedulingControlsFlags: VkPhysicalDeviceSchedulingControlsFlagsARM = {any},\n", .{value.schedulingControlsFlags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(name: []const u8, value: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    relaxedLineRasterization: u32 = {d},\n", .{value.relaxedLineRasterization});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRenderPassStripedFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRenderPassStripedFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    renderPassStriped: u32 = {d},\n", .{value.renderPassStriped});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRenderPassStripedPropertiesARM(name: []const u8, value: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRenderPassStripedPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExtent2D("renderPassStripeGranularity", &value.renderPassStripeGranularity, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxRenderPassStripes: u32 = {d},\n", .{value.maxRenderPassStripes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassStripeInfoARM(name: []const u8, value: *const vk.VkRenderPassStripeInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassStripeInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkRect2D("stripeArea", &value.stripeArea, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassStripeBeginInfoARM(name: []const u8, value: *const vk.VkRenderPassStripeBeginInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassStripeBeginInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stripeInfoCount: u32 = {d},\n", .{value.stripeInfoCount});
    if (value.pStripeInfos) |v| {
        for (v[0..value.stripeInfoCount]) |*vv| {
            print_VkRenderPassStripeInfoARM("pStripeInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStripeInfos: [*]const VkRenderPassStripeInfoARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassStripeSubmitInfoARM(name: []const u8, value: *const vk.VkRenderPassStripeSubmitInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassStripeSubmitInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    stripeSemaphoreInfoCount: u32 = {d},\n", .{value.stripeSemaphoreInfoCount});
    if (value.pStripeSemaphoreInfos) |v| {
        for (v[0..value.stripeSemaphoreInfoCount]) |*vv| {
            print_VkSemaphoreSubmitInfo("pStripeSemaphoreInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStripeSemaphoreInfos: [*]const VkSemaphoreSubmitInfo = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineOpacityMicromap: u32 = {d},\n", .{value.pipelineOpacityMicromap});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderMaximalReconvergence: u32 = {d},\n", .{value.shaderMaximalReconvergence});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderSubgroupRotateFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderSubgroupRotateFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupRotate: u32 = {d},\n", .{value.shaderSubgroupRotate});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderSubgroupRotateClustered: u32 = {d},\n", .{value.shaderSubgroupRotateClustered});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderExpectAssumeFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderExpectAssumeFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderExpectAssume: u32 = {d},\n", .{value.shaderExpectAssume});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderFloatControls2Features(name: []const u8, value: *const vk.VkPhysicalDeviceShaderFloatControls2Features, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderFloatControls2Features = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloatControls2: u32 = {d},\n", .{value.shaderFloatControls2});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(name: []const u8, value: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDynamicRenderingLocalReadFeatures = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dynamicRenderingLocalRead: u32 = {d},\n", .{value.dynamicRenderingLocalRead});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingAttachmentLocationInfo(name: []const u8, value: *const vk.VkRenderingAttachmentLocationInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingAttachmentLocationInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachmentLocations) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorAttachmentLocations: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachmentLocations: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderingInputAttachmentIndexInfo(name: []const u8, value: *const vk.VkRenderingInputAttachmentIndexInfo, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderingInputAttachmentIndexInfo = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    colorAttachmentCount: u32 = {d},\n", .{value.colorAttachmentCount});
    if (value.pColorAttachmentInputIndices) |v| {
        for (v[0..value.colorAttachmentCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pColorAttachmentInputIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pColorAttachmentInputIndices: [*]const u32 = null,\n", .{});
    }
    if (value.pDepthInputAttachmentIndex) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthInputAttachmentIndex: *const u32 = {d},\n", .{v.*});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDepthInputAttachmentIndex: *const u32 = null,\n", .{});
    }
    if (value.pStencilInputAttachmentIndex) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStencilInputAttachmentIndex: *const u32 = {d},\n", .{v.*});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStencilInputAttachmentIndex: *const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderQuadControlFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderQuadControlFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderQuadControl: u32 = {d},\n", .{value.shaderQuadControl});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloat16VectorAtomics: u32 = {d},\n", .{value.shaderFloat16VectorAtomics});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryMapPlaced: u32 = {d},\n", .{value.memoryMapPlaced});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryMapRangePlaced: u32 = {d},\n", .{value.memoryMapRangePlaced});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryUnmapReserve: u32 = {d},\n", .{value.memoryUnmapReserve});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minPlacedMemoryMapAlignment: u64 = {d},\n", .{value.minPlacedMemoryMapAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryMapPlacedInfoEXT(name: []const u8, value: *const vk.VkMemoryMapPlacedInfoEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryMapPlacedInfoEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pPlacedAddress) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPlacedAddress: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pPlacedAddress: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderBfloat16FeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderBfloat16FeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBFloat16Type: u32 = {d},\n", .{value.shaderBFloat16Type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBFloat16DotProduct: u32 = {d},\n", .{value.shaderBFloat16DotProduct});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderBFloat16CooperativeMatrix: u32 = {d},\n", .{value.shaderBFloat16CooperativeMatrix});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceRawAccessChainsFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceRawAccessChainsFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderRawAccessChains: u32 = {d},\n", .{value.shaderRawAccessChains});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    commandBufferInheritance: u32 = {d},\n", .{value.commandBufferInheritance});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(name: []const u8, value: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageAlignmentControlFeaturesMESA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    imageAlignmentControl: u32 = {d},\n", .{value.imageAlignmentControl});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(name: []const u8, value: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceImageAlignmentControlPropertiesMESA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    supportedImageAlignmentMask: u32 = {d},\n", .{value.supportedImageAlignmentMask});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImageAlignmentControlCreateInfoMESA(name: []const u8, value: *const vk.VkImageAlignmentControlCreateInfoMESA, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImageAlignmentControlCreateInfoMESA = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maximumRequestedAlignment: u32 = {d},\n", .{value.maximumRequestedAlignment});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderReplicatedComposites: u32 = {d},\n", .{value.shaderReplicatedComposites});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentModeFifoLatestReady: u32 = {d},\n", .{value.presentModeFifoLatestReady});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDepthClampRangeEXT(name: []const u8, value: *const vk.VkDepthClampRangeEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDepthClampRangeEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    minDepthClamp: f32 = {d},\n", .{value.minDepthClamp});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDepthClamp: f32 = {d},\n", .{value.maxDepthClamp});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeMatrix2FeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeMatrix2FeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixWorkgroupScope: u32 = {d},\n", .{value.cooperativeMatrixWorkgroupScope});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixFlexibleDimensions: u32 = {d},\n", .{value.cooperativeMatrixFlexibleDimensions});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixReductions: u32 = {d},\n", .{value.cooperativeMatrixReductions});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixConversions: u32 = {d},\n", .{value.cooperativeMatrixConversions});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixPerElementOperations: u32 = {d},\n", .{value.cooperativeMatrixPerElementOperations});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixTensorAddressing: u32 = {d},\n", .{value.cooperativeMatrixTensorAddressing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixBlockLoads: u32 = {d},\n", .{value.cooperativeMatrixBlockLoads});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeMatrix2PropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeMatrix2PropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixWorkgroupScopeMaxWorkgroupSize: u32 = {d},\n", .{value.cooperativeMatrixWorkgroupScopeMaxWorkgroupSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixFlexibleDimensionsMaxDimension: u32 = {d},\n", .{value.cooperativeMatrixFlexibleDimensionsMaxDimension});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeMatrixWorkgroupScopeReservedSharedMemory: u32 = {d},\n", .{value.cooperativeMatrixWorkgroupScopeReservedSharedMemory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCooperativeMatrixFlexibleDimensionsPropertiesNV(name: []const u8, value: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCooperativeMatrixFlexibleDimensionsPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    MGranularity: u32 = {d},\n", .{value.MGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    NGranularity: u32 = {d},\n", .{value.NGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    KGranularity: u32 = {d},\n", .{value.KGranularity});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    AType: VkComponentTypeKHR = {t},\n", .{value.AType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    BType: VkComponentTypeKHR = {t},\n", .{value.BType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    CType: VkComponentTypeKHR = {t},\n", .{value.CType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    ResultType: VkComponentTypeKHR = {t},\n", .{value.ResultType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    saturatingAccumulation: u32 = {d},\n", .{value.saturatingAccumulation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    scope: VkScopeKHR = {t},\n", .{value.scope});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    workgroupInvocations: u32 = {d},\n", .{value.workgroupInvocations});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceHdrVividFeaturesHUAWEI(name: []const u8, value: *const vk.VkPhysicalDeviceHdrVividFeaturesHUAWEI, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceHdrVividFeaturesHUAWEI = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    hdrVivid: u32 = {d},\n", .{value.hdrVivid});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    vertexAttributeRobustness: u32 = {d},\n", .{value.vertexAttributeRobustness});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX(name: []const u8, value: *const vk.VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    denseGeometryFormat: u32 = {d},\n", .{value.denseGeometryFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX(name: []const u8, value: *const vk.VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    compressedData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.compressedData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u64 = {d},\n", .{value.dataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numTriangles: u32 = {d},\n", .{value.numTriangles});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numVertices: u32 = {d},\n", .{value.numVertices});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPrimitiveIndex: u32 = {d},\n", .{value.maxPrimitiveIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxGeometryIndex: u32 = {d},\n", .{value.maxGeometryIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkCompressedTriangleFormatAMDX = {t},\n", .{value.format});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    depthClampZeroOne: u32 = {d},\n", .{value.depthClampZeroOne});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeVectorFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeVectorFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeVector: u32 = {d},\n", .{value.cooperativeVector});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeVectorTraining: u32 = {d},\n", .{value.cooperativeVectorTraining});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCooperativeVectorPropertiesNV(name: []const u8, value: *const vk.VkCooperativeVectorPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCooperativeVectorPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputType: VkComponentTypeKHR = {t},\n", .{value.inputType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    inputInterpretation: VkComponentTypeKHR = {t},\n", .{value.inputInterpretation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    matrixInterpretation: VkComponentTypeKHR = {t},\n", .{value.matrixInterpretation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    biasInterpretation: VkComponentTypeKHR = {t},\n", .{value.biasInterpretation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resultType: VkComponentTypeKHR = {t},\n", .{value.resultType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    transpose: u32 = {d},\n", .{value.transpose});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceCooperativeVectorPropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceCooperativeVectorPropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeVectorSupportedStages: VkShaderStageFlags = {any},\n", .{value.cooperativeVectorSupportedStages});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeVectorTrainingFloat16Accumulation: u32 = {d},\n", .{value.cooperativeVectorTrainingFloat16Accumulation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    cooperativeVectorTrainingFloat32Accumulation: u32 = {d},\n", .{value.cooperativeVectorTrainingFloat32Accumulation});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxCooperativeVectorComponents: u32 = {d},\n", .{value.maxCooperativeVectorComponents});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkConvertCooperativeVectorMatrixInfoNV(name: []const u8, value: *const vk.VkConvertCooperativeVectorMatrixInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkConvertCooperativeVectorMatrixInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcSize: u64 = {d},\n", .{value.srcSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcData: VkDeviceOrHostAddressConstKHR = {any},\n", .{value.srcData});
    if (value.pDstSize) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDstSize: *u64 = {d},\n", .{v.*});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDstSize: *u64 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstData: VkDeviceOrHostAddressKHR = {any},\n", .{value.dstData});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcComponentType: VkComponentTypeKHR = {t},\n", .{value.srcComponentType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstComponentType: VkComponentTypeKHR = {t},\n", .{value.dstComponentType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numRows: u32 = {d},\n", .{value.numRows});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numColumns: u32 = {d},\n", .{value.numColumns});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcLayout: VkCooperativeVectorMatrixLayoutNV = {t},\n", .{value.srcLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcStride: u64 = {d},\n", .{value.srcStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstLayout: VkCooperativeVectorMatrixLayoutNV = {t},\n", .{value.dstLayout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstStride: u64 = {d},\n", .{value.dstStride});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTileShadingFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTileShadingFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShading: u32 = {d},\n", .{value.tileShading});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingFragmentStage: u32 = {d},\n", .{value.tileShadingFragmentStage});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingColorAttachments: u32 = {d},\n", .{value.tileShadingColorAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingDepthAttachments: u32 = {d},\n", .{value.tileShadingDepthAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingStencilAttachments: u32 = {d},\n", .{value.tileShadingStencilAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingInputAttachments: u32 = {d},\n", .{value.tileShadingInputAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingSampledAttachments: u32 = {d},\n", .{value.tileShadingSampledAttachments});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingPerTileDraw: u32 = {d},\n", .{value.tileShadingPerTileDraw});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingPerTileDispatch: u32 = {d},\n", .{value.tileShadingPerTileDispatch});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingDispatchTile: u32 = {d},\n", .{value.tileShadingDispatchTile});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingApron: u32 = {d},\n", .{value.tileShadingApron});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingAnisotropicApron: u32 = {d},\n", .{value.tileShadingAnisotropicApron});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingAtomicOps: u32 = {d},\n", .{value.tileShadingAtomicOps});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tileShadingImageProcessing: u32 = {d},\n", .{value.tileShadingImageProcessing});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTileShadingPropertiesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTileShadingPropertiesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxApronSize: u32 = {d},\n", .{value.maxApronSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferNonCoherent: u32 = {d},\n", .{value.preferNonCoherent});
    print_VkExtent2D("tileGranularity", &value.tileGranularity, offset + 1);
    print_VkExtent2D("maxTileShadingRate", &value.maxTileShadingRate, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassTileShadingCreateInfoQCOM(name: []const u8, value: *const vk.VkRenderPassTileShadingCreateInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassTileShadingCreateInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkTileShadingRenderPassFlagsQCOM = {any},\n", .{value.flags});
    print_VkExtent2D("tileApronSize", &value.tileApronSize, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerTileBeginInfoQCOM(name: []const u8, value: *const vk.VkPerTileBeginInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerTileBeginInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerTileEndInfoQCOM(name: []const u8, value: *const vk.VkPerTileEndInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerTileEndInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDispatchTileInfoQCOM(name: []const u8, value: *const vk.VkDispatchTileInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDispatchTileInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentDensityMapLayers: u32 = {d},\n", .{value.maxFragmentDensityMapLayers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(name: []const u8, value: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    fragmentDensityMapLayered: u32 = {d},\n", .{value.fragmentDensityMapLayered});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(name: []const u8, value: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxFragmentDensityMapLayers: u32 = {d},\n", .{value.maxFragmentDensityMapLayers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSetPresentConfigNV(name: []const u8, value: *const vk.VkSetPresentConfigNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSetPresentConfigNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numFramesPerBatch: u32 = {d},\n", .{value.numFramesPerBatch});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentConfigFeedback: u32 = {d},\n", .{value.presentConfigFeedback});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentMeteringFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDevicePresentMeteringFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentMeteringFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    presentMetering: u32 = {d},\n", .{value.presentMetering});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalComputeQueueDeviceCreateInfoNV(name: []const u8, value: *const vk.VkExternalComputeQueueDeviceCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalComputeQueueDeviceCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    reservedExternalQueues: u32 = {d},\n", .{value.reservedExternalQueues});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalComputeQueueCreateInfoNV(name: []const u8, value: *const vk.VkExternalComputeQueueCreateInfoNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalComputeQueueCreateInfoNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    preferredQueue: VkQueue = {},\n", .{value.preferredQueue});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalComputeQueueDataParamsNV(name: []const u8, value: *const vk.VkExternalComputeQueueDataParamsNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalComputeQueueDataParamsNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    deviceIndex: u32 = {d},\n", .{value.deviceIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalComputeQueuePropertiesNV(name: []const u8, value: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalComputeQueuePropertiesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalDataSize: u32 = {d},\n", .{value.externalDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxExternalQueues: u32 = {d},\n", .{value.maxExternalQueues});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUniformBufferUnsizedArray: u32 = {d},\n", .{value.shaderUniformBufferUnsizedArray});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceFormatPackFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDeviceFormatPackFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceFormatPackFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatPack: u32 = {d},\n", .{value.formatPack});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorDescriptionARM(name: []const u8, value: *const vk.VkTensorDescriptionARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorDescriptionARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tiling: VkTensorTilingARM = {t},\n", .{value.tiling});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dimensionCount: u32 = {d},\n", .{value.dimensionCount});
    if (value.pDimensions) |v| {
        for (v[0..value.dimensionCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDimensions: [*]const i64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDimensions: [*]const i64 = null,\n", .{});
    }
    if (value.pStrides) |v| {
        for (v[0..value.dimensionCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pStrides: [*]const i64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pStrides: [*]const i64 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkTensorUsageFlagsARM = {any},\n", .{value.usage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorCreateInfoARM(name: []const u8, value: *const vk.VkTensorCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkTensorCreateFlagsARM = {any},\n", .{value.flags});
    if (value.pDescription) |v| {
        print_VkTensorDescriptionARM("pDescription", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDescription: *const VkTensorDescriptionARM = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharingMode: VkSharingMode = {t},\n", .{value.sharingMode});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndexCount: u32 = {d},\n", .{value.queueFamilyIndexCount});
    if (value.pQueueFamilyIndices) |v| {
        for (v[0..value.queueFamilyIndexCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pQueueFamilyIndices: [*]const u32 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pQueueFamilyIndices: [*]const u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorViewCreateInfoARM(name: []const u8, value: *const vk.VkTensorViewCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorViewCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkTensorViewCreateFlagsARM = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensor: VkTensorARM = {},\n", .{value.tensor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorMemoryRequirementsInfoARM(name: []const u8, value: *const vk.VkTensorMemoryRequirementsInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorMemoryRequirementsInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensor: VkTensorARM = {},\n", .{value.tensor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindTensorMemoryInfoARM(name: []const u8, value: *const vk.VkBindTensorMemoryInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindTensorMemoryInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensor: VkTensorARM = {},\n", .{value.tensor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkWriteDescriptorSetTensorARM(name: []const u8, value: *const vk.VkWriteDescriptorSetTensorARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkWriteDescriptorSetTensorARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorViewCount: u32 = {d},\n", .{value.tensorViewCount});
    if (value.pTensorViews) |v| {
        for (v[0..value.tensorViewCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pTensorViews: [*]const VkTensorViewARM = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTensorViews: [*]const VkTensorViewARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorFormatPropertiesARM(name: []const u8, value: *const vk.VkTensorFormatPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorFormatPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    optimalTilingTensorFeatures: VkFormatFeatureFlags2 = {any},\n", .{value.optimalTilingTensorFeatures});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    linearTilingTensorFeatures: VkFormatFeatureFlags2 = {any},\n", .{value.linearTilingTensorFeatures});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTensorPropertiesARM(name: []const u8, value: *const vk.VkPhysicalDeviceTensorPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTensorPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTensorDimensionCount: u32 = {d},\n", .{value.maxTensorDimensionCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTensorElements: u64 = {d},\n", .{value.maxTensorElements});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerDimensionTensorElements: u64 = {d},\n", .{value.maxPerDimensionTensorElements});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTensorStride: i64 = {d},\n", .{value.maxTensorStride});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTensorSize: u64 = {d},\n", .{value.maxTensorSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTensorShaderAccessArrayLength: u32 = {d},\n", .{value.maxTensorShaderAccessArrayLength});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxTensorShaderAccessSize: u32 = {d},\n", .{value.maxTensorShaderAccessSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetStorageTensors: u32 = {d},\n", .{value.maxDescriptorSetStorageTensors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorSetStorageTensors: u32 = {d},\n", .{value.maxPerStageDescriptorSetStorageTensors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxDescriptorSetUpdateAfterBindStorageTensors: u32 = {d},\n", .{value.maxDescriptorSetUpdateAfterBindStorageTensors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerStageDescriptorUpdateAfterBindStorageTensors: u32 = {d},\n", .{value.maxPerStageDescriptorUpdateAfterBindStorageTensors});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageTensorArrayNonUniformIndexingNative: u32 = {d},\n", .{value.shaderStorageTensorArrayNonUniformIndexingNative});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTensorSupportedStages: VkShaderStageFlags = {any},\n", .{value.shaderTensorSupportedStages});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorMemoryBarrierARM(name: []const u8, value: *const vk.VkTensorMemoryBarrierARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorMemoryBarrierARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcStageMask: VkPipelineStageFlags2 = {any},\n", .{value.srcStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcAccessMask: VkAccessFlags2 = {any},\n", .{value.srcAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstStageMask: VkPipelineStageFlags2 = {any},\n", .{value.dstStageMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstAccessMask: VkAccessFlags2 = {any},\n", .{value.dstAccessMask});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcQueueFamilyIndex: u32 = {d},\n", .{value.srcQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstQueueFamilyIndex: u32 = {d},\n", .{value.dstQueueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensor: VkTensorARM = {},\n", .{value.tensor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorDependencyInfoARM(name: []const u8, value: *const vk.VkTensorDependencyInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorDependencyInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorMemoryBarrierCount: u32 = {d},\n", .{value.tensorMemoryBarrierCount});
    if (value.pTensorMemoryBarriers) |v| {
        print_VkTensorMemoryBarrierARM("pTensorMemoryBarriers", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTensorMemoryBarriers: *const VkTensorMemoryBarrierARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceTensorFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDeviceTensorFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceTensorFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorNonPacked: u32 = {d},\n", .{value.tensorNonPacked});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderTensorAccess: u32 = {d},\n", .{value.shaderTensorAccess});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageTensorArrayDynamicIndexing: u32 = {d},\n", .{value.shaderStorageTensorArrayDynamicIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderStorageTensorArrayNonUniformIndexing: u32 = {d},\n", .{value.shaderStorageTensorArrayNonUniformIndexing});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBindingStorageTensorUpdateAfterBind: u32 = {d},\n", .{value.descriptorBindingStorageTensorUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensors: u32 = {d},\n", .{value.tensors});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDeviceTensorMemoryRequirementsARM(name: []const u8, value: *const vk.VkDeviceTensorMemoryRequirementsARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDeviceTensorMemoryRequirementsARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pCreateInfo) |v| {
        print_VkTensorCreateInfoARM("pCreateInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCreateInfo: *const VkTensorCreateInfoARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkCopyTensorInfoARM(name: []const u8, value: *const vk.VkCopyTensorInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkCopyTensorInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    srcTensor: VkTensorARM = {},\n", .{value.srcTensor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dstTensor: VkTensorARM = {},\n", .{value.dstTensor});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionCount: u32 = {d},\n", .{value.regionCount});
    if (value.pRegions) |v| {
        for (v[0..value.regionCount]) |*vv| {
            print_VkTensorCopyARM("pRegions", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pRegions: [*]const VkTensorCopyARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorCopyARM(name: []const u8, value: *const vk.VkTensorCopyARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorCopyARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dimensionCount: u32 = {d},\n", .{value.dimensionCount});
    if (value.pSrcOffset) |v| {
        for (v[0..value.dimensionCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pSrcOffset: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSrcOffset: [*]const u64 = null,\n", .{});
    }
    if (value.pDstOffset) |v| {
        for (v[0..value.dimensionCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pDstOffset: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDstOffset: [*]const u64 = null,\n", .{});
    }
    if (value.pExtent) |v| {
        for (v[0..value.dimensionCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pExtent: [*]const u64 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pExtent: [*]const u64 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryDedicatedAllocateInfoTensorARM(name: []const u8, value: *const vk.VkMemoryDedicatedAllocateInfoTensorARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryDedicatedAllocateInfoTensorARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensor: VkTensorARM = {},\n", .{value.tensor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorBufferTensorPropertiesARM(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorCaptureReplayDescriptorDataSize: u64 = {d},\n", .{value.tensorCaptureReplayDescriptorDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorViewCaptureReplayDescriptorDataSize: u64 = {d},\n", .{value.tensorViewCaptureReplayDescriptorDataSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorDescriptorSize: u64 = {d},\n", .{value.tensorDescriptorSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDescriptorBufferTensorFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorBufferTensorDescriptors: u32 = {d},\n", .{value.descriptorBufferTensorDescriptors});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorCaptureDescriptorDataInfoARM(name: []const u8, value: *const vk.VkTensorCaptureDescriptorDataInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorCaptureDescriptorDataInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensor: VkTensorARM = {},\n", .{value.tensor});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkTensorViewCaptureDescriptorDataInfoARM(name: []const u8, value: *const vk.VkTensorViewCaptureDescriptorDataInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkTensorViewCaptureDescriptorDataInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorView: VkTensorViewARM = {},\n", .{value.tensorView});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDescriptorGetTensorInfoARM(name: []const u8, value: *const vk.VkDescriptorGetTensorInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDescriptorGetTensorInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorView: VkTensorViewARM = {},\n", .{value.tensorView});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkFrameBoundaryTensorsARM(name: []const u8, value: *const vk.VkFrameBoundaryTensorsARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkFrameBoundaryTensorsARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    tensorCount: u32 = {d},\n", .{value.tensorCount});
    if (value.pTensors) |v| {
        for (v[0..value.tensorCount]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pTensors: [*]const VkTensorARM = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pTensors: [*]const VkTensorARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceExternalTensorInfoARM(name: []const u8, value: *const vk.VkPhysicalDeviceExternalTensorInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceExternalTensorInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkTensorCreateFlagsARM = {any},\n", .{value.flags});
    if (value.pDescription) |v| {
        print_VkTensorDescriptionARM("pDescription", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pDescription: *const VkTensorDescriptionARM = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleType: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalTensorPropertiesARM(name: []const u8, value: *const vk.VkExternalTensorPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalTensorPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkExternalMemoryProperties("externalMemoryProperties", &value.externalMemoryProperties, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalMemoryTensorCreateInfoARM(name: []const u8, value: *const vk.VkExternalMemoryTensorCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalMemoryTensorCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    handleTypes: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.handleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderFloat8FeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderFloat8FeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloat8: u32 = {d},\n", .{value.shaderFloat8});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderFloat8CooperativeMatrix: u32 = {d},\n", .{value.shaderFloat8CooperativeMatrix});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSurfaceCreateInfoOHOS(name: []const u8, value: *const vk.VkSurfaceCreateInfoOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSurfaceCreateInfoOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkSurfaceCreateFlagsOHOS = {any},\n", .{value.flags});
    if (value.window) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *OHNativeWindow = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    window: *OHNativeWindow = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDataGraphFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDeviceDataGraphFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDataGraphFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraph: u32 = {d},\n", .{value.dataGraph});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraphUpdateAfterBind: u32 = {d},\n", .{value.dataGraphUpdateAfterBind});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraphSpecializationConstants: u32 = {d},\n", .{value.dataGraphSpecializationConstants});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraphDescriptorBuffer: u32 = {d},\n", .{value.dataGraphDescriptorBuffer});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraphShaderModule: u32 = {d},\n", .{value.dataGraphShaderModule});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dimension: u32 = {d},\n", .{value.dimension});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    zeroCount: u32 = {d},\n", .{value.zeroCount});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    groupSize: u32 = {d},\n", .{value.groupSize});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineConstantARM(name: []const u8, value: *const vk.VkDataGraphPipelineConstantARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineConstantARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    id: u32 = {d},\n", .{value.id});
    if (value.pConstantData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pConstantData: *const anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pConstantData: *const anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineResourceInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineResourceInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineResourceInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    descriptorSet: u32 = {d},\n", .{value.descriptorSet});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    binding: u32 = {d},\n", .{value.binding});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    arrayElement: u32 = {d},\n", .{value.arrayElement});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineCompilerControlCreateInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineCompilerControlCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pVendorOptions) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pVendorOptions: [*:0]const u8 = {s}n", .{v});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineCreateInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    layout: VkPipelineLayout = {},\n", .{value.layout});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    resourceInfoCount: u32 = {d},\n", .{value.resourceInfoCount});
    if (value.pResourceInfos) |v| {
        for (v[0..value.resourceInfoCount]) |*vv| {
            print_VkDataGraphPipelineResourceInfoARM("pResourceInfos", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pResourceInfos: [*]const VkDataGraphPipelineResourceInfoARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineShaderModuleCreateInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineShaderModuleCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    module: VkShaderModule = {},\n", .{value.module});
    if (value.pName) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pName: [*:0]const u8 = {s}n", .{v});
    }
    if (value.pSpecializationInfo) |v| {
        print_VkSpecializationInfo("pSpecializationInfo", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pSpecializationInfo: *const VkSpecializationInfo = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    constantCount: u32 = {d},\n", .{value.constantCount});
    if (value.pConstants) |v| {
        for (v[0..value.constantCount]) |*vv| {
            print_VkDataGraphPipelineConstantARM("pConstants", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pConstants: [*]const VkDataGraphPipelineConstantARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineSessionCreateInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineSessionCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineSessionCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDataGraphPipelineSessionCreateFlagsARM = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraphPipeline: VkPipeline = {},\n", .{value.dataGraphPipeline});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineSessionBindPointRequirementsInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineSessionBindPointRequirementsInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    session: VkDataGraphPipelineSessionARM = {},\n", .{value.session});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineSessionBindPointRequirementARM(name: []const u8, value: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineSessionBindPointRequirementARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindPoint: VkDataGraphPipelineSessionBindPointARM = {t},\n", .{value.bindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindPointType: VkDataGraphPipelineSessionBindPointTypeARM = {t},\n", .{value.bindPointType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    numObjects: u32 = {d},\n", .{value.numObjects});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineSessionMemoryRequirementsInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineSessionMemoryRequirementsInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    session: VkDataGraphPipelineSessionARM = {},\n", .{value.session});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindPoint: VkDataGraphPipelineSessionBindPointARM = {t},\n", .{value.bindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectIndex: u32 = {d},\n", .{value.objectIndex});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkBindDataGraphPipelineSessionMemoryInfoARM(name: []const u8, value: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkBindDataGraphPipelineSessionMemoryInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    session: VkDataGraphPipelineSessionARM = {},\n", .{value.session});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    bindPoint: VkDataGraphPipelineSessionBindPointARM = {t},\n", .{value.bindPoint});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    objectIndex: u32 = {d},\n", .{value.objectIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryOffset: u64 = {d},\n", .{value.memoryOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraphPipeline: VkPipeline = {},\n", .{value.dataGraphPipeline});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelinePropertyQueryResultARM(name: []const u8, value: *const vk.VkDataGraphPipelinePropertyQueryResultARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelinePropertyQueryResultARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    property: VkDataGraphPipelinePropertyARM = {t},\n", .{value.property});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    isText: u32 = {d},\n", .{value.isText});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataSize: u64 = {d},\n", .{value.dataSize});
    if (value.pData) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *anyopaque = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pData: *anyopaque = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineIdentifierCreateInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineIdentifierCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identifierSize: u32 = {d},\n", .{value.identifierSize});
    if (value.pIdentifier) |v| {
        for (v[0..value.identifierSize]) |*vv| {
            for (0..offset + 1) |_| log.output("    ", .{});
            log.output("    pIdentifier: [*]const u8 = {any},\n", .{vv});
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pIdentifier: [*]const u8 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineDispatchInfoARM(name: []const u8, value: *const vk.VkDataGraphPipelineDispatchInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineDispatchInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkDataGraphPipelineDispatchFlagsARM = {any},\n", .{value.flags});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDataGraphProcessingEngineARM(name: []const u8, value: *const vk.VkPhysicalDeviceDataGraphProcessingEngineARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDataGraphProcessingEngineARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    type: VkPhysicalDeviceDataGraphProcessingEngineTypeARM = {t},\n", .{value.type});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    isForeign: u32 = {d},\n", .{value.isForeign});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDataGraphOperationSupportARM(name: []const u8, value: *const vk.VkPhysicalDeviceDataGraphOperationSupportARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDataGraphOperationSupportARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    operationType: VkPhysicalDeviceDataGraphOperationTypeARM = {t},\n", .{value.operationType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    name: [VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM]u8 = {any},\n", .{value.name});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    version: u32 = {d},\n", .{value.version});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyDataGraphPropertiesARM(name: []const u8, value: *const vk.VkQueueFamilyDataGraphPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyDataGraphPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    print_VkPhysicalDeviceDataGraphProcessingEngineARM("engine", &value.engine, offset + 1);
    print_VkPhysicalDeviceDataGraphOperationSupportARM("operation", &value.operation, offset + 1);
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM(name: []const u8, value: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    queueFamilyIndex: u32 = {d},\n", .{value.queueFamilyIndex});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    engineType: VkPhysicalDeviceDataGraphProcessingEngineTypeARM = {t},\n", .{value.engineType});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkQueueFamilyDataGraphProcessingEnginePropertiesARM(name: []const u8, value: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkQueueFamilyDataGraphProcessingEnginePropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    foreignSemaphoreHandleTypes: VkExternalSemaphoreHandleTypeFlags = {any},\n", .{value.foreignSemaphoreHandleTypes});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    foreignMemoryHandleTypes: VkExternalMemoryHandleTypeFlags = {any},\n", .{value.foreignMemoryHandleTypes});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphProcessingEngineCreateInfoARM(name: []const u8, value: *const vk.VkDataGraphProcessingEngineCreateInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphProcessingEngineCreateInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    processingEngineCount: u32 = {d},\n", .{value.processingEngineCount});
    if (value.pProcessingEngines) |v| {
        for (v[0..value.processingEngineCount]) |*vv| {
            print_VkPhysicalDeviceDataGraphProcessingEngineARM("pProcessingEngines", vv, offset + 1);
        }
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pProcessingEngines: [*]VkPhysicalDeviceDataGraphProcessingEngineARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC(name: []const u8, value: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    pipelineCacheIncrementalMode: u32 = {d},\n", .{value.pipelineCacheIncrementalMode});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkDataGraphPipelineBuiltinModelCreateInfoQCOM(name: []const u8, value: *const vk.VkDataGraphPipelineBuiltinModelCreateInfoQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkDataGraphPipelineBuiltinModelCreateInfoQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.pOperation) |v| {
        print_VkPhysicalDeviceDataGraphOperationSupportARM("pOperation", v, offset + 1);
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pOperation: *const VkPhysicalDeviceDataGraphOperationSupportARM = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceDataGraphModelFeaturesQCOM(name: []const u8, value: *const vk.VkPhysicalDeviceDataGraphModelFeaturesQCOM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceDataGraphModelFeaturesQCOM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    dataGraphModel: u32 = {d},\n", .{value.dataGraphModel});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShaderUntypedPointersFeaturesKHR(name: []const u8, value: *const vk.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShaderUntypedPointersFeaturesKHR = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shaderUntypedPointers: u32 = {d},\n", .{value.shaderUntypedPointers});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkNativeBufferOHOS(name: []const u8, value: *const vk.VkNativeBufferOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkNativeBufferOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.handle) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *OHBufferHandle = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    handle: *OHBufferHandle = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkSwapchainImageCreateInfoOHOS(name: []const u8, value: *const vk.VkSwapchainImageCreateInfoOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkSwapchainImageCreateInfoOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    usage: VkSwapchainImageUsageFlagsOHOS = {any},\n", .{value.usage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePresentationPropertiesOHOS(name: []const u8, value: *const vk.VkPhysicalDevicePresentationPropertiesOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePresentationPropertiesOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sharedImage: u32 = {d},\n", .{value.sharedImage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE(name: []const u8, value: *const vk.VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    videoEncodeRgbConversion: u32 = {d},\n", .{value.videoEncodeRgbConversion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeRgbConversionCapabilitiesVALVE(name: []const u8, value: *const vk.VkVideoEncodeRgbConversionCapabilitiesVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeRgbConversionCapabilitiesVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rgbModels: VkVideoEncodeRgbModelConversionFlagsVALVE = {any},\n", .{value.rgbModels});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rgbRanges: VkVideoEncodeRgbRangeCompressionFlagsVALVE = {any},\n", .{value.rgbRanges});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    xChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE = {any},\n", .{value.xChromaOffsets});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    yChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE = {any},\n", .{value.yChromaOffsets});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeProfileRgbConversionInfoVALVE(name: []const u8, value: *const vk.VkVideoEncodeProfileRgbConversionInfoVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeProfileRgbConversionInfoVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    performEncodeRgbConversion: u32 = {d},\n", .{value.performEncodeRgbConversion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkVideoEncodeSessionRgbConversionCreateInfoVALVE(name: []const u8, value: *const vk.VkVideoEncodeSessionRgbConversionCreateInfoVALVE, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkVideoEncodeSessionRgbConversionCreateInfoVALVE = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rgbModel: VkVideoEncodeRgbModelConversionFlagsVALVE = {any},\n", .{value.rgbModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rgbRange: VkVideoEncodeRgbRangeCompressionFlagsVALVE = {any},\n", .{value.rgbRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    xChromaOffset: VkVideoEncodeRgbChromaOffsetFlagsVALVE = {any},\n", .{value.xChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    yChromaOffset: VkVideoEncodeRgbChromaOffsetFlagsVALVE = {any},\n", .{value.yChromaOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceShader64BitIndexingFeaturesEXT(name: []const u8, value: *const vk.VkPhysicalDeviceShader64BitIndexingFeaturesEXT, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceShader64BitIndexingFeaturesEXT = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    shader64BitIndexing: u32 = {d},\n", .{value.shader64BitIndexing});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkNativeBufferUsageOHOS(name: []const u8, value: *const vk.VkNativeBufferUsageOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkNativeBufferUsageOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    OHOSNativeBufferUsage: u64 = {d},\n", .{value.OHOSNativeBufferUsage});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkNativeBufferPropertiesOHOS(name: []const u8, value: *const vk.VkNativeBufferPropertiesOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkNativeBufferPropertiesOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    allocationSize: u64 = {d},\n", .{value.allocationSize});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memoryTypeBits: u32 = {d},\n", .{value.memoryTypeBits});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkNativeBufferFormatPropertiesOHOS(name: []const u8, value: *const vk.VkNativeBufferFormatPropertiesOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkNativeBufferFormatPropertiesOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    format: VkFormat = {t},\n", .{value.format});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormat: u64 = {d},\n", .{value.externalFormat});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    formatFeatures: VkFormatFeatureFlags = {any},\n", .{value.formatFeatures});
    print_VkComponentMapping("samplerYcbcrConversionComponents", &value.samplerYcbcrConversionComponents, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = {t},\n", .{value.suggestedYcbcrModel});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYcbcrRange: VkSamplerYcbcrRange = {t},\n", .{value.suggestedYcbcrRange});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedXChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedXChromaOffset});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    suggestedYChromaOffset: VkChromaLocation = {t},\n", .{value.suggestedYChromaOffset});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkImportNativeBufferInfoOHOS(name: []const u8, value: *const vk.VkImportNativeBufferInfoOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkImportNativeBufferInfoOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    if (value.buffer) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    buffer: *OH_NativeBuffer = {*},\n", .{v});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    buffer: *OH_NativeBuffer = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkMemoryGetNativeBufferInfoOHOS(name: []const u8, value: *const vk.VkMemoryGetNativeBufferInfoOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkMemoryGetNativeBufferInfoOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    memory: VkDeviceMemory = {},\n", .{value.memory});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkExternalFormatOHOS(name: []const u8, value: *const vk.VkExternalFormatOHOS, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkExternalFormatOHOS = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    externalFormat: u64 = {d},\n", .{value.externalFormat});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePerformanceCountersByRegionFeaturesARM(name: []const u8, value: *const vk.VkPhysicalDevicePerformanceCountersByRegionFeaturesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePerformanceCountersByRegionFeaturesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    performanceCountersByRegion: u32 = {d},\n", .{value.performanceCountersByRegion});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDevicePerformanceCountersByRegionPropertiesARM(name: []const u8, value: *const vk.VkPhysicalDevicePerformanceCountersByRegionPropertiesARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDevicePerformanceCountersByRegionPropertiesARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    maxPerRegionPerformanceCounters: u32 = {d},\n", .{value.maxPerRegionPerformanceCounters});
    print_VkExtent2D("performanceCounterRegionSize", &value.performanceCounterRegionSize, offset + 1);
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    rowStrideAlignment: u32 = {d},\n", .{value.rowStrideAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    regionAlignment: u32 = {d},\n", .{value.regionAlignment});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    identityTransformOrder: u32 = {d},\n", .{value.identityTransformOrder});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceCounterARM(name: []const u8, value: *const vk.VkPerformanceCounterARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceCounterARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    counterID: u32 = {d},\n", .{value.counterID});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPerformanceCounterDescriptionARM(name: []const u8, value: *const vk.VkPerformanceCounterDescriptionARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPerformanceCounterDescriptionARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    flags: VkPerformanceCounterDescriptionFlagsARM = {any},\n", .{value.flags});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    name: [VK_MAX_DESCRIPTION_SIZE]u8 = {any},\n", .{value.name});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkRenderPassPerformanceCountersByRegionBeginInfoARM(name: []const u8, value: *const vk.VkRenderPassPerformanceCountersByRegionBeginInfoARM, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkRenderPassPerformanceCountersByRegionBeginInfoARM = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    counterAddressCount: u32 = {d},\n", .{value.counterAddressCount});
    if (value.pCounterAddresses) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCounterAddresses: *const u64 = {d},\n", .{v.*});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCounterAddresses: *const u64 = null,\n", .{});
    }
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    serializeRegions: u32 = {d},\n", .{value.serializeRegions});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    counterIndexCount: u32 = {d},\n", .{value.counterIndexCount});
    if (value.pCounterIndices) |v| {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCounterIndices: *u32 = {d},\n", .{v.*});
    } else {
        for (0..offset + 1) |_| log.output("    ", .{});
        log.output("    pCounterIndices: *u32 = null,\n", .{});
    }
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkComputeOccupancyPriorityParametersNV(name: []const u8, value: *const vk.VkComputeOccupancyPriorityParametersNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkComputeOccupancyPriorityParametersNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    occupancyPriority: f32 = {d},\n", .{value.occupancyPriority});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    occupancyThrottling: f32 = {d},\n", .{value.occupancyThrottling});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV(name: []const u8, value: *const vk.VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV, offset: u32) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output("{s}: VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV = .{{\n", .{ name });
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    sType: VkStructureType = {t},\n", .{value.sType});
    for (0..offset + 1) |_| log.output("    ", .{});
    log.output("    computeOccupancyPriority: u32 = {d},\n", .{value.computeOccupancyPriority});
    for (0..offset) |_| log.output("    ", .{});
    log.output("}}\n", .{});
}
pub fn print_struct(value: anytype, follow_pnext: bool) void {
    var base: *const vk.VkBaseOutStructure = @ptrCast(value);
    blk: switch (base.sType) {
        .VK_STRUCTURE_TYPE_APPLICATION_INFO => {
            print_VkApplicationInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO => {
            print_VkDeviceQueueCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO => {
            print_VkDeviceCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO => {
            print_VkInstanceCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO => {
            print_VkMemoryAllocateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE => {
            print_VkMappedMemoryRange("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET => {
            print_VkWriteDescriptorSet("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET => {
            print_VkCopyDescriptorSet("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO => {
            print_VkBufferUsageFlags2CreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO => {
            print_VkBufferCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO => {
            print_VkBufferViewCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_BARRIER => {
            print_VkMemoryBarrier("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER => {
            print_VkBufferMemoryBarrier("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER => {
            print_VkImageMemoryBarrier("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO => {
            print_VkImageCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO => {
            print_VkImageViewCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_SPARSE_INFO => {
            print_VkBindSparseInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR => {
            print_VkCopyMemoryIndirectInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR => {
            print_VkCopyMemoryToImageIndirectInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO => {
            print_VkShaderModuleCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO => {
            print_VkDescriptorSetLayoutCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO => {
            print_VkDescriptorPoolCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO => {
            print_VkDescriptorSetAllocateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO => {
            print_VkPipelineShaderStageCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO => {
            print_VkComputePipelineCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV => {
            print_VkComputePipelineIndirectBufferInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO => {
            print_VkPipelineCreateFlags2CreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO => {
            print_VkPipelineVertexInputStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO => {
            print_VkPipelineInputAssemblyStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO => {
            print_VkPipelineTessellationStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO => {
            print_VkPipelineViewportStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO => {
            print_VkPipelineRasterizationStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO => {
            print_VkPipelineMultisampleStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO => {
            print_VkPipelineColorBlendStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO => {
            print_VkPipelineDynamicStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO => {
            print_VkPipelineDepthStencilStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO => {
            print_VkGraphicsPipelineCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO => {
            print_VkPipelineCacheCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR => {
            print_VkPipelineBinaryCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR => {
            print_VkPipelineBinaryHandlesInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR => {
            print_VkPipelineBinaryKeyKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR => {
            print_VkPipelineBinaryInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR => {
            print_VkReleaseCapturedPipelineDataInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR => {
            print_VkPipelineBinaryDataInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR => {
            print_VkPipelineCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO => {
            print_VkPipelineLayoutCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO => {
            print_VkSamplerCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO => {
            print_VkCommandPoolCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO => {
            print_VkCommandBufferAllocateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO => {
            print_VkCommandBufferInheritanceInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO => {
            print_VkCommandBufferBeginInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO => {
            print_VkRenderPassBeginInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO => {
            print_VkRenderPassCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EVENT_CREATE_INFO => {
            print_VkEventCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FENCE_CREATE_INFO => {
            print_VkFenceCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO => {
            print_VkSemaphoreCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO => {
            print_VkQueryPoolCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO => {
            print_VkFramebufferCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBMIT_INFO => {
            print_VkSubmitInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR => {
            print_VkDisplayModeCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR => {
            print_VkDisplaySurfaceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV => {
            print_VkDisplaySurfaceStereoCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR => {
            print_VkDisplayPresentInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR => {
            print_VkAndroidSurfaceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN => {
            print_VkViSurfaceCreateInfoNN("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR => {
            print_VkWaylandSurfaceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR => {
            print_VkWin32SurfaceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR => {
            print_VkXlibSurfaceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR => {
            print_VkXcbSurfaceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT => {
            print_VkDirectFBSurfaceCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA => {
            print_VkImagePipeSurfaceCreateInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP => {
            print_VkStreamDescriptorSurfaceCreateInfoGGP("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX => {
            print_VkScreenSurfaceCreateInfoQNX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR => {
            print_VkSwapchainCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_INFO_KHR => {
            print_VkPresentInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT => {
            print_VkDebugReportCallbackCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT => {
            print_VkValidationFlagsEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT => {
            print_VkValidationFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT => {
            print_VkLayerSettingsCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT => {
            print_VkApplicationParametersEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD => {
            print_VkPipelineRasterizationStateRasterizationOrderAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT => {
            print_VkDebugMarkerObjectNameInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT => {
            print_VkDebugMarkerObjectTagInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT => {
            print_VkDebugMarkerMarkerInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV => {
            print_VkDedicatedAllocationImageCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV => {
            print_VkDedicatedAllocationBufferCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV => {
            print_VkDedicatedAllocationMemoryAllocateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV => {
            print_VkExternalMemoryImageCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV => {
            print_VkExportMemoryAllocateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV => {
            print_VkImportMemoryWin32HandleInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV => {
            print_VkExportMemoryWin32HandleInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV => {
            print_VkExportMemorySciBufInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV => {
            print_VkImportMemorySciBufInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV => {
            print_VkMemoryGetSciBufInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV => {
            print_VkMemorySciBufPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV => {
            print_VkPhysicalDeviceExternalMemorySciBufFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV => {
            print_VkWin32KeyedMutexAcquireReleaseInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV => {
            print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV => {
            print_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO => {
            print_VkDevicePrivateDataCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO => {
            print_VkPrivateDataSlotCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES => {
            print_VkPhysicalDevicePrivateDataFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV => {
            print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV => {
            print_VkPhysicalDeviceClusterAccelerationStructureFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
            print_VkPhysicalDeviceClusterAccelerationStructurePropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
            print_VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV => {
            print_VkClusterAccelerationStructureClustersBottomLevelInputNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV => {
            print_VkClusterAccelerationStructureTriangleClusterInputNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV => {
            print_VkClusterAccelerationStructureMoveObjectsInputNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV => {
            print_VkClusterAccelerationStructureInputInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV => {
            print_VkClusterAccelerationStructureCommandsInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT => {
            print_VkPhysicalDeviceMultiDrawPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV => {
            print_VkGraphicsShaderGroupCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV => {
            print_VkGraphicsPipelineShaderGroupsCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV => {
            print_VkIndirectCommandsLayoutTokenNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV => {
            print_VkIndirectCommandsLayoutCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV => {
            print_VkGeneratedCommandsInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV => {
            print_VkGeneratedCommandsMemoryRequirementsInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV => {
            print_VkPipelineIndirectDeviceAddressInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 => {
            print_VkPhysicalDeviceFeatures2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 => {
            print_VkPhysicalDeviceProperties2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 => {
            print_VkFormatProperties2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 => {
            print_VkImageFormatProperties2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 => {
            print_VkPhysicalDeviceImageFormatInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 => {
            print_VkQueueFamilyProperties2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 => {
            print_VkPhysicalDeviceMemoryProperties2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 => {
            print_VkSparseImageFormatProperties2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 => {
            print_VkPhysicalDeviceSparseImageFormatInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES => {
            print_VkPhysicalDevicePushDescriptorProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES => {
            print_VkPhysicalDeviceDriverProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR => {
            print_VkPresentRegionsKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES => {
            print_VkPhysicalDeviceVariablePointersFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO => {
            print_VkPhysicalDeviceExternalImageFormatInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES => {
            print_VkExternalImageFormatProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO => {
            print_VkPhysicalDeviceExternalBufferInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES => {
            print_VkExternalBufferProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES => {
            print_VkPhysicalDeviceIDProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO => {
            print_VkExternalMemoryImageCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO => {
            print_VkExternalMemoryBufferCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO => {
            print_VkExportMemoryAllocateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR => {
            print_VkImportMemoryWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR => {
            print_VkExportMemoryWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA => {
            print_VkImportMemoryZirconHandleInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA => {
            print_VkMemoryZirconHandlePropertiesFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA => {
            print_VkMemoryGetZirconHandleInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR => {
            print_VkMemoryWin32HandlePropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR => {
            print_VkMemoryGetWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR => {
            print_VkImportMemoryFdInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR => {
            print_VkMemoryFdPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR => {
            print_VkMemoryGetFdInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR => {
            print_VkWin32KeyedMutexAcquireReleaseInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT => {
            print_VkImportMemoryMetalHandleInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT => {
            print_VkMemoryMetalHandlePropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT => {
            print_VkMemoryGetMetalHandleInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO => {
            print_VkPhysicalDeviceExternalSemaphoreInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES => {
            print_VkExternalSemaphoreProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO => {
            print_VkExportSemaphoreCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR => {
            print_VkImportSemaphoreWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR => {
            print_VkExportSemaphoreWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR => {
            print_VkD3D12FenceSubmitInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR => {
            print_VkSemaphoreGetWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR => {
            print_VkImportSemaphoreFdInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR => {
            print_VkSemaphoreGetFdInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA => {
            print_VkImportSemaphoreZirconHandleInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA => {
            print_VkSemaphoreGetZirconHandleInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO => {
            print_VkPhysicalDeviceExternalFenceInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES => {
            print_VkExternalFenceProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO => {
            print_VkExportFenceCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR => {
            print_VkImportFenceWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR => {
            print_VkExportFenceWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR => {
            print_VkFenceGetWin32HandleInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR => {
            print_VkImportFenceFdInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR => {
            print_VkFenceGetFdInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV => {
            print_VkExportFenceSciSyncInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV => {
            print_VkImportFenceSciSyncInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV => {
            print_VkFenceGetSciSyncInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV => {
            print_VkExportSemaphoreSciSyncInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV => {
            print_VkImportSemaphoreSciSyncInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV => {
            print_VkSemaphoreGetSciSyncInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV => {
            print_VkSciSyncAttributesInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV => {
            print_VkPhysicalDeviceExternalSciSyncFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV => {
            print_VkPhysicalDeviceExternalSciSync2FeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV => {
            print_VkSemaphoreSciSyncPoolCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV => {
            print_VkSemaphoreSciSyncCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV => {
            print_VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES => {
            print_VkPhysicalDeviceMultiviewFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES => {
            print_VkPhysicalDeviceMultiviewProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO => {
            print_VkRenderPassMultiviewCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT => {
            print_VkSurfaceCapabilities2EXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT => {
            print_VkDisplayPowerInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT => {
            print_VkDeviceEventInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT => {
            print_VkDisplayEventInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT => {
            print_VkSwapchainCounterCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES => {
            print_VkPhysicalDeviceGroupProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO => {
            print_VkMemoryAllocateFlagsInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO => {
            print_VkBindBufferMemoryInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO => {
            print_VkBindBufferMemoryDeviceGroupInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO => {
            print_VkBindImageMemoryInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO => {
            print_VkBindImageMemoryDeviceGroupInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO => {
            print_VkDeviceGroupRenderPassBeginInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO => {
            print_VkDeviceGroupCommandBufferBeginInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO => {
            print_VkDeviceGroupSubmitInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO => {
            print_VkDeviceGroupBindSparseInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR => {
            print_VkDeviceGroupPresentCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR => {
            print_VkImageSwapchainCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR => {
            print_VkBindImageMemorySwapchainInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR => {
            print_VkAcquireNextImageInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR => {
            print_VkDeviceGroupPresentInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO => {
            print_VkDeviceGroupDeviceCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR => {
            print_VkDeviceGroupSwapchainCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO => {
            print_VkDescriptorUpdateTemplateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR => {
            print_VkPhysicalDevicePresentIdFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_ID_KHR => {
            print_VkPresentIdKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR => {
            print_VkPhysicalDevicePresentId2FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR => {
            print_VkPresentId2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR => {
            print_VkPresentWait2InfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR => {
            print_VkPhysicalDevicePresentWaitFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR => {
            print_VkPhysicalDevicePresentWait2FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT => {
            print_VkPhysicalDevicePresentTimingFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT => {
            print_VkPresentTimingSurfaceCapabilitiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT => {
            print_VkSwapchainTimingPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT => {
            print_VkSwapchainTimeDomainPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT => {
            print_VkPastPresentationTimingInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT => {
            print_VkPastPresentationTimingPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT => {
            print_VkPastPresentationTimingEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT => {
            print_VkPresentTimingsInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT => {
            print_VkPresentTimingInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT => {
            print_VkSwapchainCalibratedTimestampInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_HDR_METADATA_EXT => {
            print_VkHdrMetadataEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI => {
            print_VkHdrVividDynamicMetadataHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD => {
            print_VkDisplayNativeHdrSurfaceCapabilitiesAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD => {
            print_VkSwapchainDisplayNativeHdrCreateInfoAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE => {
            print_VkPresentTimesInfoGOOGLE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK => {
            print_VkIOSSurfaceCreateInfoMVK("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK => {
            print_VkMacOSSurfaceCreateInfoMVK("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT => {
            print_VkMetalSurfaceCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV => {
            print_VkPipelineViewportWScalingStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV => {
            print_VkPipelineViewportSwizzleStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT => {
            print_VkPhysicalDeviceDiscardRectanglePropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT => {
            print_VkPipelineDiscardRectangleStateCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX => {
            print_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO => {
            print_VkRenderPassInputAttachmentAspectCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR => {
            print_VkPhysicalDeviceSurfaceInfo2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR => {
            print_VkSurfaceCapabilities2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR => {
            print_VkSurfaceFormat2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR => {
            print_VkDisplayProperties2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR => {
            print_VkDisplayPlaneProperties2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR => {
            print_VkDisplayModeProperties2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV => {
            print_VkDisplayModeStereoPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR => {
            print_VkDisplayPlaneInfo2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR => {
            print_VkDisplayPlaneCapabilities2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR => {
            print_VkSharedPresentSurfaceCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES => {
            print_VkPhysicalDevice16BitStorageFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES => {
            print_VkPhysicalDeviceSubgroupProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES => {
            print_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 => {
            print_VkBufferMemoryRequirementsInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS => {
            print_VkDeviceBufferMemoryRequirements("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 => {
            print_VkImageMemoryRequirementsInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 => {
            print_VkImageSparseMemoryRequirementsInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS => {
            print_VkDeviceImageMemoryRequirements("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 => {
            print_VkMemoryRequirements2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 => {
            print_VkSparseImageMemoryRequirements2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES => {
            print_VkPhysicalDevicePointClippingProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS => {
            print_VkMemoryDedicatedRequirements("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO => {
            print_VkMemoryDedicatedAllocateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO => {
            print_VkImageViewUsageCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT => {
            print_VkImageViewSlicedCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO => {
            print_VkPipelineTessellationDomainOriginStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO => {
            print_VkSamplerYcbcrConversionInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO => {
            print_VkSamplerYcbcrConversionCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO => {
            print_VkBindImagePlaneMemoryInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO => {
            print_VkImagePlaneMemoryRequirementsInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES => {
            print_VkPhysicalDeviceSamplerYcbcrConversionFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES => {
            print_VkSamplerYcbcrConversionImageFormatProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD => {
            print_VkTextureLODGatherFormatPropertiesAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT => {
            print_VkConditionalRenderingBeginInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO => {
            print_VkProtectedSubmitInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES => {
            print_VkPhysicalDeviceProtectedMemoryFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES => {
            print_VkPhysicalDeviceProtectedMemoryProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 => {
            print_VkDeviceQueueInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV => {
            print_VkPipelineCoverageToColorStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES => {
            print_VkPhysicalDeviceSamplerFilterMinmaxProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT => {
            print_VkSampleLocationsInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT => {
            print_VkRenderPassSampleLocationsBeginInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT => {
            print_VkPipelineSampleLocationsStateCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT => {
            print_VkPhysicalDeviceSampleLocationsPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT => {
            print_VkMultisamplePropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO => {
            print_VkSamplerReductionModeCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT => {
            print_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT => {
            print_VkPhysicalDeviceMultiDrawFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT => {
            print_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT => {
            print_VkPipelineColorBlendAdvancedStateCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES => {
            print_VkPhysicalDeviceInlineUniformBlockFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES => {
            print_VkPhysicalDeviceInlineUniformBlockProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK => {
            print_VkWriteDescriptorSetInlineUniformBlock("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO => {
            print_VkDescriptorPoolInlineUniformBlockCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV => {
            print_VkPipelineCoverageModulationStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO => {
            print_VkImageFormatListCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT => {
            print_VkValidationCacheCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT => {
            print_VkShaderModuleValidationCacheCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES => {
            print_VkPhysicalDeviceMaintenance3Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES => {
            print_VkPhysicalDeviceMaintenance4Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES => {
            print_VkPhysicalDeviceMaintenance4Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES => {
            print_VkPhysicalDeviceMaintenance5Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES => {
            print_VkPhysicalDeviceMaintenance5Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES => {
            print_VkPhysicalDeviceMaintenance6Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES => {
            print_VkPhysicalDeviceMaintenance6Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR => {
            print_VkPhysicalDeviceMaintenance7FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR => {
            print_VkPhysicalDeviceMaintenance7PropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR => {
            print_VkPhysicalDeviceLayeredApiPropertiesListKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR => {
            print_VkPhysicalDeviceLayeredApiPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR => {
            print_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR => {
            print_VkPhysicalDeviceMaintenance8FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR => {
            print_VkPhysicalDeviceMaintenance9FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR => {
            print_VkPhysicalDeviceMaintenance9PropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR => {
            print_VkPhysicalDeviceMaintenance10PropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR => {
            print_VkPhysicalDeviceMaintenance10FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR => {
            print_VkQueueFamilyOwnershipTransferPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_AREA_INFO => {
            print_VkRenderingAreaInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT => {
            print_VkDescriptorSetLayoutSupport("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES => {
            print_VkPhysicalDeviceShaderDrawParametersFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES => {
            print_VkPhysicalDeviceShaderFloat16Int8Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES => {
            print_VkPhysicalDeviceFloatControlsProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES => {
            print_VkPhysicalDeviceHostQueryResetFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO => {
            print_VkDeviceQueueGlobalPriorityCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES => {
            print_VkPhysicalDeviceGlobalPriorityQueryFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES => {
            print_VkQueueFamilyGlobalPriorityProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT => {
            print_VkDebugUtilsObjectNameInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT => {
            print_VkDebugUtilsObjectTagInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT => {
            print_VkDebugUtilsLabelEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT => {
            print_VkDebugUtilsMessengerCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT => {
            print_VkDebugUtilsMessengerCallbackDataEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT => {
            print_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT => {
            print_VkDeviceDeviceMemoryReportCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT => {
            print_VkDeviceMemoryReportCallbackDataEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT => {
            print_VkImportMemoryHostPointerInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT => {
            print_VkMemoryHostPointerPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT => {
            print_VkPhysicalDeviceExternalMemoryHostPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT => {
            print_VkPhysicalDeviceConservativeRasterizationPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR => {
            print_VkCalibratedTimestampInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD => {
            print_VkPhysicalDeviceShaderCorePropertiesAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD => {
            print_VkPhysicalDeviceShaderCoreProperties2AMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT => {
            print_VkPipelineRasterizationConservativeStateCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES => {
            print_VkPhysicalDeviceDescriptorIndexingFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES => {
            print_VkPhysicalDeviceDescriptorIndexingProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO => {
            print_VkDescriptorSetLayoutBindingFlagsCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO => {
            print_VkDescriptorSetVariableDescriptorCountAllocateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT => {
            print_VkDescriptorSetVariableDescriptorCountLayoutSupport("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 => {
            print_VkAttachmentDescription2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 => {
            print_VkAttachmentReference2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 => {
            print_VkSubpassDescription2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 => {
            print_VkSubpassDependency2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 => {
            print_VkRenderPassCreateInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO => {
            print_VkSubpassBeginInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBPASS_END_INFO => {
            print_VkSubpassEndInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES => {
            print_VkPhysicalDeviceTimelineSemaphoreFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES => {
            print_VkPhysicalDeviceTimelineSemaphoreProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO => {
            print_VkSemaphoreTypeCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO => {
            print_VkTimelineSemaphoreSubmitInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO => {
            print_VkSemaphoreWaitInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO => {
            print_VkSemaphoreSignalInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO => {
            print_VkPipelineVertexInputDivisorStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT => {
            print_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES => {
            print_VkPhysicalDeviceVertexAttributeDivisorProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT => {
            print_VkPhysicalDevicePCIBusInfoPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID => {
            print_VkImportAndroidHardwareBufferInfoANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID => {
            print_VkAndroidHardwareBufferUsageANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID => {
            print_VkAndroidHardwareBufferPropertiesANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID => {
            print_VkMemoryGetAndroidHardwareBufferInfoANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID => {
            print_VkAndroidHardwareBufferFormatPropertiesANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT => {
            print_VkCommandBufferInheritanceConditionalRenderingInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID => {
            print_VkExternalFormatANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES => {
            print_VkPhysicalDevice8BitStorageFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT => {
            print_VkPhysicalDeviceConditionalRenderingFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES => {
            print_VkPhysicalDeviceVulkanMemoryModelFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES => {
            print_VkPhysicalDeviceShaderAtomicInt64Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES => {
            print_VkPhysicalDeviceVertexAttributeDivisorFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV => {
            print_VkQueueFamilyCheckpointPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV => {
            print_VkCheckpointDataNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES => {
            print_VkPhysicalDeviceDepthStencilResolveProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE => {
            print_VkSubpassDescriptionDepthStencilResolve("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT => {
            print_VkImageViewASTCDecodeModeEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT => {
            print_VkPhysicalDeviceASTCDecodeFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT => {
            print_VkPhysicalDeviceTransformFeedbackFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT => {
            print_VkPhysicalDeviceTransformFeedbackPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT => {
            print_VkPipelineRasterizationStateStreamCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV => {
            print_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV => {
            print_VkPipelineRepresentativeFragmentTestStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV => {
            print_VkPhysicalDeviceExclusiveScissorFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV => {
            print_VkPipelineViewportExclusiveScissorStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV => {
            print_VkPhysicalDeviceCornerSampledImageFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR => {
            print_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR => {
            print_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV => {
            print_VkPhysicalDeviceShaderImageFootprintFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV => {
            print_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR => {
            print_VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV => {
            print_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR => {
            print_VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT => {
            print_VkPhysicalDeviceMemoryDecompressionFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT => {
            print_VkPhysicalDeviceMemoryDecompressionPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV => {
            print_VkPipelineViewportShadingRateImageStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV => {
            print_VkPhysicalDeviceShadingRateImageFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV => {
            print_VkPhysicalDeviceShadingRateImagePropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI => {
            print_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV => {
            print_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV => {
            print_VkPhysicalDeviceMeshShaderFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV => {
            print_VkPhysicalDeviceMeshShaderPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT => {
            print_VkPhysicalDeviceMeshShaderFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT => {
            print_VkPhysicalDeviceMeshShaderPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV => {
            print_VkRayTracingShaderGroupCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR => {
            print_VkRayTracingShaderGroupCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV => {
            print_VkRayTracingPipelineCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR => {
            print_VkRayTracingPipelineCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV => {
            print_VkGeometryTrianglesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV => {
            print_VkGeometryAABBNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GEOMETRY_NV => {
            print_VkGeometryNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV => {
            print_VkAccelerationStructureInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
            print_VkAccelerationStructureCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV => {
            print_VkBindAccelerationStructureMemoryInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR => {
            print_VkWriteDescriptorSetAccelerationStructureKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV => {
            print_VkWriteDescriptorSetAccelerationStructureNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV => {
            print_VkAccelerationStructureMemoryRequirementsInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR => {
            print_VkPhysicalDeviceAccelerationStructureFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR => {
            print_VkPhysicalDeviceRayTracingPipelineFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR => {
            print_VkPhysicalDeviceRayQueryFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR => {
            print_VkPhysicalDeviceAccelerationStructurePropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR => {
            print_VkPhysicalDeviceRayTracingPipelinePropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV => {
            print_VkPhysicalDeviceRayTracingPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR => {
            print_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT => {
            print_VkDrmFormatModifierPropertiesListEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT => {
            print_VkPhysicalDeviceImageDrmFormatModifierInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT => {
            print_VkImageDrmFormatModifierListCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT => {
            print_VkImageDrmFormatModifierExplicitCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT => {
            print_VkImageDrmFormatModifierPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO => {
            print_VkImageStencilUsageCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD => {
            print_VkDeviceMemoryOverallocationCreateInfoAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT => {
            print_VkPhysicalDeviceFragmentDensityMapFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT => {
            print_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT => {
            print_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT => {
            print_VkPhysicalDeviceFragmentDensityMapPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT => {
            print_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT => {
            print_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT => {
            print_VkRenderPassFragmentDensityMapCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT => {
            print_VkRenderPassFragmentDensityMapOffsetEndInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES => {
            print_VkPhysicalDeviceScalarBlockLayoutFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR => {
            print_VkSurfaceProtectedCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES => {
            print_VkPhysicalDeviceUniformBufferStandardLayoutFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT => {
            print_VkPhysicalDeviceDepthClipEnableFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT => {
            print_VkPipelineRasterizationDepthClipStateCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT => {
            print_VkPhysicalDeviceMemoryBudgetPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT => {
            print_VkPhysicalDeviceMemoryPriorityFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT => {
            print_VkMemoryPriorityAllocateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT => {
            print_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES => {
            print_VkPhysicalDeviceBufferDeviceAddressFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT => {
            print_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO => {
            print_VkBufferDeviceAddressInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO => {
            print_VkBufferOpaqueCaptureAddressCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT => {
            print_VkBufferDeviceAddressCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT => {
            print_VkPhysicalDeviceImageViewImageFormatInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT => {
            print_VkFilterCubicImageViewImageFormatPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES => {
            print_VkPhysicalDeviceImagelessFramebufferFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO => {
            print_VkFramebufferAttachmentsCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO => {
            print_VkFramebufferAttachmentImageInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO => {
            print_VkRenderPassAttachmentBeginInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES => {
            print_VkPhysicalDeviceTextureCompressionASTCHDRFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV => {
            print_VkPhysicalDeviceCooperativeMatrixFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
            print_VkPhysicalDeviceCooperativeMatrixPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
            print_VkCooperativeMatrixPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT => {
            print_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX => {
            print_VkImageViewHandleInfoNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX => {
            print_VkImageViewAddressPropertiesNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP => {
            print_VkPresentFrameTokenGGP("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO => {
            print_VkPipelineCreationFeedbackCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT => {
            print_VkSurfaceFullScreenExclusiveInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT => {
            print_VkSurfaceFullScreenExclusiveWin32InfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT => {
            print_VkSurfaceCapabilitiesFullScreenExclusiveEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV => {
            print_VkPhysicalDevicePresentBarrierFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV => {
            print_VkSurfaceCapabilitiesPresentBarrierNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV => {
            print_VkSwapchainPresentBarrierCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR => {
            print_VkPhysicalDevicePerformanceQueryFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR => {
            print_VkPhysicalDevicePerformanceQueryPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR => {
            print_VkPerformanceCounterKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR => {
            print_VkPerformanceCounterDescriptionKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR => {
            print_VkQueryPoolPerformanceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR => {
            print_VkAcquireProfilingLockInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR => {
            print_VkPerformanceQuerySubmitInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR => {
            print_VkPerformanceQueryReservationInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT => {
            print_VkHeadlessSurfaceCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV => {
            print_VkPhysicalDeviceCoverageReductionModeFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV => {
            print_VkPipelineCoverageReductionStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV => {
            print_VkFramebufferMixedSamplesCombinationNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL => {
            print_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL => {
            print_VkInitializePerformanceApiInfoINTEL("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL => {
            print_VkQueryPoolPerformanceQueryCreateInfoINTEL("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL => {
            print_VkPerformanceMarkerInfoINTEL("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL => {
            print_VkPerformanceStreamMarkerInfoINTEL("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL => {
            print_VkPerformanceOverrideInfoINTEL("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL => {
            print_VkPerformanceConfigurationAcquireInfoINTEL("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderClockFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES => {
            print_VkPhysicalDeviceIndexTypeUint8Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV => {
            print_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV => {
            print_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT => {
            print_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES => {
            print_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT => {
            print_VkAttachmentReferenceStencilLayout("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT => {
            print_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT => {
            print_VkAttachmentDescriptionStencilLayout("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR => {
            print_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR => {
            print_VkPipelineInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR => {
            print_VkPipelineExecutablePropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR => {
            print_VkPipelineExecutableInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR => {
            print_VkPipelineExecutableStatisticKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR => {
            print_VkPipelineExecutableInternalRepresentationKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES => {
            print_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT => {
            print_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES => {
            print_VkPhysicalDeviceTexelBufferAlignmentProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES => {
            print_VkPhysicalDeviceSubgroupSizeControlFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES => {
            print_VkPhysicalDeviceSubgroupSizeControlProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO => {
            print_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI => {
            print_VkSubpassShadingPipelineCreateInfoHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI => {
            print_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI => {
            print_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO => {
            print_VkMemoryOpaqueCaptureAddressAllocateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO => {
            print_VkDeviceMemoryOpaqueCaptureAddressInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES => {
            print_VkPhysicalDeviceLineRasterizationFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES => {
            print_VkPhysicalDeviceLineRasterizationProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO => {
            print_VkPipelineRasterizationLineStateCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES => {
            print_VkPhysicalDevicePipelineCreationCacheControlFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES => {
            print_VkPhysicalDeviceVulkan11Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES => {
            print_VkPhysicalDeviceVulkan11Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES => {
            print_VkPhysicalDeviceVulkan12Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES => {
            print_VkPhysicalDeviceVulkan12Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES => {
            print_VkPhysicalDeviceVulkan13Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES => {
            print_VkPhysicalDeviceVulkan13Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES => {
            print_VkPhysicalDeviceVulkan14Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES => {
            print_VkPhysicalDeviceVulkan14Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD => {
            print_VkPipelineCompilerControlCreateInfoAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD => {
            print_VkPhysicalDeviceCoherentMemoryFeaturesAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FAULT_DATA => {
            print_VkFaultData("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO => {
            print_VkFaultCallbackInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES => {
            print_VkPhysicalDeviceToolProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT => {
            print_VkSamplerCustomBorderColorCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT => {
            print_VkPhysicalDeviceCustomBorderColorPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT => {
            print_VkPhysicalDeviceCustomBorderColorFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT => {
            print_VkSamplerBorderColorComponentMappingCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT => {
            print_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR => {
            print_VkAccelerationStructureGeometryTrianglesDataKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR => {
            print_VkAccelerationStructureGeometryAabbsDataKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR => {
            print_VkAccelerationStructureGeometryInstancesDataKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV => {
            print_VkAccelerationStructureGeometryLinearSweptSpheresDataNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV => {
            print_VkAccelerationStructureGeometrySpheresDataNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR => {
            print_VkAccelerationStructureGeometryKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR => {
            print_VkAccelerationStructureBuildGeometryInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR => {
            print_VkAccelerationStructureCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR => {
            print_VkAccelerationStructureDeviceAddressInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR => {
            print_VkAccelerationStructureVersionInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR => {
            print_VkCopyAccelerationStructureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR => {
            print_VkCopyAccelerationStructureToMemoryInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR => {
            print_VkCopyMemoryToAccelerationStructureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR => {
            print_VkRayTracingPipelineInterfaceCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR => {
            print_VkPipelineLibraryCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR => {
            print_VkRefreshObjectListKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT => {
            print_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT => {
            print_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT => {
            print_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT => {
            print_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM => {
            print_VkRenderPassTransformBeginInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM => {
            print_VkCopyCommandTransformInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM => {
            print_VkCommandBufferInheritanceRenderPassTransformInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV => {
            print_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
            print_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV => {
            print_VkPartitionedAccelerationStructureFlagsNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV => {
            print_VkWriteDescriptorSetPartitionedAccelerationStructureNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV => {
            print_VkPartitionedAccelerationStructureInstancesInputNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV => {
            print_VkBuildPartitionedAccelerationStructureInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV => {
            print_VkPhysicalDeviceDiagnosticsConfigFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV => {
            print_VkDeviceDiagnosticsConfigCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO => {
            print_VkPipelineOfflineCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES => {
            print_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR => {
            print_VkPhysicalDeviceRobustness2FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR => {
            print_VkPhysicalDeviceRobustness2PropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES => {
            print_VkPhysicalDeviceImageRobustnessFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR => {
            print_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR => {
            print_VkPhysicalDevicePortabilitySubsetFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR => {
            print_VkPhysicalDevicePortabilitySubsetPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT => {
            print_VkPhysicalDevice4444FormatsFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI => {
            print_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI => {
            print_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI => {
            print_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_COPY_2 => {
            print_VkBufferCopy2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_COPY_2 => {
            print_VkImageCopy2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_BLIT_2 => {
            print_VkImageBlit2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 => {
            print_VkBufferImageCopy2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 => {
            print_VkImageResolve2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 => {
            print_VkCopyBufferInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 => {
            print_VkCopyImageInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 => {
            print_VkBlitImageInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 => {
            print_VkCopyBufferToImageInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 => {
            print_VkCopyImageToBufferInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 => {
            print_VkResolveImageInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
            print_VkFragmentShadingRateAttachmentInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR => {
            print_VkPipelineFragmentShadingRateStateCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR => {
            print_VkPhysicalDeviceFragmentShadingRateFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR => {
            print_VkPhysicalDeviceFragmentShadingRatePropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR => {
            print_VkPhysicalDeviceFragmentShadingRateKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES => {
            print_VkPhysicalDeviceShaderTerminateInvocationFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV => {
            print_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV => {
            print_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV => {
            print_VkPipelineFragmentShadingRateEnumStateCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR => {
            print_VkAccelerationStructureBuildSizesInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT => {
            print_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT => {
            print_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT => {
            print_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT => {
            print_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT => {
            print_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT => {
            print_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT => {
            print_VkMutableDescriptorTypeCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT => {
            print_VkPhysicalDeviceDepthClipControlFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT => {
            print_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT => {
            print_VkBeginCustomResolveInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT => {
            print_VkPhysicalDeviceCustomResolveFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT => {
            print_VkCustomResolveCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT => {
            print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT => {
            print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT => {
            print_VkGeneratedCommandsPipelineInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT => {
            print_VkGeneratedCommandsShaderInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT => {
            print_VkGeneratedCommandsMemoryRequirementsInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT => {
            print_VkIndirectExecutionSetPipelineInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT => {
            print_VkIndirectExecutionSetShaderLayoutInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT => {
            print_VkIndirectExecutionSetShaderInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT => {
            print_VkIndirectExecutionSetCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT => {
            print_VkGeneratedCommandsInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT => {
            print_VkWriteIndirectExecutionSetPipelineEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT => {
            print_VkWriteIndirectExecutionSetShaderEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT => {
            print_VkIndirectCommandsLayoutCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT => {
            print_VkIndirectCommandsLayoutTokenEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT => {
            print_VkPipelineViewportDepthClipControlCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT => {
            print_VkPhysicalDeviceDepthClampControlFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT => {
            print_VkPipelineViewportDepthClampControlCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT => {
            print_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV => {
            print_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT => {
            print_VkVertexInputBindingDescription2EXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT => {
            print_VkVertexInputAttributeDescription2EXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT => {
            print_VkPhysicalDeviceColorWriteEnableFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT => {
            print_VkPipelineColorWriteCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 => {
            print_VkMemoryBarrier2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 => {
            print_VkImageMemoryBarrier2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 => {
            print_VkBufferMemoryBarrier2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR => {
            print_VkMemoryBarrierAccessFlags3KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEPENDENCY_INFO => {
            print_VkDependencyInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO => {
            print_VkSemaphoreSubmitInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO => {
            print_VkCommandBufferSubmitInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBMIT_INFO_2 => {
            print_VkSubmitInfo2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV => {
            print_VkQueueFamilyCheckpointProperties2NV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV => {
            print_VkCheckpointData2NV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES => {
            print_VkPhysicalDeviceSynchronization2Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR => {
            print_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES => {
            print_VkPhysicalDeviceHostImageCopyFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES => {
            print_VkPhysicalDeviceHostImageCopyProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY => {
            print_VkMemoryToImageCopy("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY => {
            print_VkImageToMemoryCopy("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO => {
            print_VkCopyMemoryToImageInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO => {
            print_VkCopyImageToMemoryInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO => {
            print_VkCopyImageToImageInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO => {
            print_VkHostImageLayoutTransitionInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE => {
            print_VkSubresourceHostMemcpySize("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY => {
            print_VkHostImageCopyDevicePerformanceQuery("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES => {
            print_VkPhysicalDeviceVulkanSC10Properties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE => {
            print_VkPipelinePoolSize("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO => {
            print_VkDeviceObjectReservationCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO => {
            print_VkCommandPoolMemoryReservationCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION => {
            print_VkCommandPoolMemoryConsumption("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES => {
            print_VkPhysicalDeviceVulkanSC10Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT => {
            print_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT => {
            print_VkPhysicalDeviceLegacyDitheringFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT => {
            print_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR => {
            print_VkSurfaceCapabilitiesPresentId2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR => {
            print_VkSurfaceCapabilitiesPresentWait2KHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT => {
            print_VkSubpassResolvePerformanceQueryEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT => {
            print_VkMultisampledRenderToSingleSampledInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES => {
            print_VkPhysicalDevicePipelineProtectedAccessFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR => {
            print_VkQueueFamilyVideoPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR => {
            print_VkQueueFamilyQueryResultStatusPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR => {
            print_VkVideoProfileListInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR => {
            print_VkPhysicalDeviceVideoFormatInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR => {
            print_VkVideoFormatPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR => {
            print_VkVideoEncodeQuantizationMapCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR => {
            print_VkVideoEncodeH264QuantizationMapCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR => {
            print_VkVideoEncodeH265QuantizationMapCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR => {
            print_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR => {
            print_VkVideoFormatQuantizationMapPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR => {
            print_VkVideoFormatH265QuantizationMapPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR => {
            print_VkVideoFormatAV1QuantizationMapPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR => {
            print_VkVideoProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR => {
            print_VkVideoCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR => {
            print_VkVideoSessionMemoryRequirementsKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR => {
            print_VkBindVideoSessionMemoryInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR => {
            print_VkVideoPictureResourceInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR => {
            print_VkVideoReferenceSlotInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR => {
            print_VkVideoDecodeCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR => {
            print_VkVideoDecodeUsageInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR => {
            print_VkVideoDecodeInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR => {
            print_VkPhysicalDeviceVideoMaintenance1FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR => {
            print_VkPhysicalDeviceVideoMaintenance2FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR => {
            print_VkVideoInlineQueryInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR => {
            print_VkVideoDecodeH264ProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR => {
            print_VkVideoDecodeH264CapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR => {
            print_VkVideoDecodeH264SessionParametersAddInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoDecodeH264SessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR => {
            print_VkVideoDecodeH264InlineSessionParametersInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR => {
            print_VkVideoDecodeH264PictureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR => {
            print_VkVideoDecodeH264DpbSlotInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR => {
            print_VkVideoDecodeH265ProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR => {
            print_VkVideoDecodeH265CapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR => {
            print_VkVideoDecodeH265SessionParametersAddInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoDecodeH265SessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR => {
            print_VkVideoDecodeH265InlineSessionParametersInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR => {
            print_VkVideoDecodeH265PictureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR => {
            print_VkVideoDecodeH265DpbSlotInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR => {
            print_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR => {
            print_VkVideoDecodeVP9ProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR => {
            print_VkVideoDecodeVP9CapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR => {
            print_VkVideoDecodeVP9PictureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR => {
            print_VkVideoDecodeAV1ProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR => {
            print_VkVideoDecodeAV1CapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoDecodeAV1SessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR => {
            print_VkVideoDecodeAV1InlineSessionParametersInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR => {
            print_VkVideoDecodeAV1PictureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR => {
            print_VkVideoDecodeAV1DpbSlotInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR => {
            print_VkVideoSessionCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoSessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR => {
            print_VkVideoSessionParametersUpdateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR => {
            print_VkVideoEncodeSessionParametersGetInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
            print_VkVideoEncodeSessionParametersFeedbackInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR => {
            print_VkVideoBeginCodingInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR => {
            print_VkVideoEndCodingInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR => {
            print_VkVideoCodingControlInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR => {
            print_VkVideoEncodeUsageInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR => {
            print_VkVideoEncodeInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR => {
            print_VkVideoEncodeQuantizationMapInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR => {
            print_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR => {
            print_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
            print_VkVideoEncodeQualityLevelInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
            print_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR => {
            print_VkVideoEncodeQualityLevelPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR => {
            print_VkVideoEncodeRateControlInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR => {
            print_VkVideoEncodeRateControlLayerInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR => {
            print_VkVideoEncodeCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR => {
            print_VkVideoEncodeH264CapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR => {
            print_VkVideoEncodeH264QualityLevelPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR => {
            print_VkVideoEncodeH264SessionCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR => {
            print_VkVideoEncodeH264SessionParametersAddInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoEncodeH264SessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR => {
            print_VkVideoEncodeH264SessionParametersGetInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
            print_VkVideoEncodeH264SessionParametersFeedbackInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR => {
            print_VkVideoEncodeH264DpbSlotInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR => {
            print_VkVideoEncodeH264PictureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR => {
            print_VkVideoEncodeH264ProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR => {
            print_VkVideoEncodeH264NaluSliceInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR => {
            print_VkVideoEncodeH264RateControlInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR => {
            print_VkVideoEncodeH264GopRemainingFrameInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR => {
            print_VkVideoEncodeH264RateControlLayerInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR => {
            print_VkVideoEncodeH265CapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR => {
            print_VkVideoEncodeH265QualityLevelPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR => {
            print_VkVideoEncodeH265SessionCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR => {
            print_VkVideoEncodeH265SessionParametersAddInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoEncodeH265SessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR => {
            print_VkVideoEncodeH265SessionParametersGetInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
            print_VkVideoEncodeH265SessionParametersFeedbackInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR => {
            print_VkVideoEncodeH265PictureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR => {
            print_VkVideoEncodeH265NaluSliceSegmentInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR => {
            print_VkVideoEncodeH265RateControlInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR => {
            print_VkVideoEncodeH265GopRemainingFrameInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR => {
            print_VkVideoEncodeH265RateControlLayerInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR => {
            print_VkVideoEncodeH265ProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR => {
            print_VkVideoEncodeH265DpbSlotInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR => {
            print_VkVideoEncodeAV1CapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR => {
            print_VkVideoEncodeAV1QualityLevelPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR => {
            print_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR => {
            print_VkVideoEncodeAV1SessionCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR => {
            print_VkVideoEncodeAV1SessionParametersCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR => {
            print_VkVideoEncodeAV1DpbSlotInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR => {
            print_VkVideoEncodeAV1PictureInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR => {
            print_VkVideoEncodeAV1ProfileInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR => {
            print_VkVideoEncodeAV1RateControlInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR => {
            print_VkVideoEncodeAV1GopRemainingFrameInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR => {
            print_VkVideoEncodeAV1RateControlLayerInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV => {
            print_VkPhysicalDeviceInheritedViewportScissorFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV => {
            print_VkCommandBufferInheritanceViewportScissorInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT => {
            print_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT => {
            print_VkPhysicalDeviceProvokingVertexFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT => {
            print_VkPhysicalDeviceProvokingVertexPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT => {
            print_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR => {
            print_VkVideoEncodeIntraRefreshCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR => {
            print_VkVideoEncodeSessionIntraRefreshCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR => {
            print_VkVideoEncodeIntraRefreshInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR => {
            print_VkVideoReferenceIntraRefreshInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR => {
            print_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX => {
            print_VkCuModuleCreateInfoNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX => {
            print_VkCuModuleTexturingModeCreateInfoNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX => {
            print_VkCuFunctionCreateInfoNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX => {
            print_VkCuLaunchInfoNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT => {
            print_VkPhysicalDeviceDescriptorBufferFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT => {
            print_VkPhysicalDeviceDescriptorBufferPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT => {
            print_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT => {
            print_VkDescriptorAddressInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT => {
            print_VkDescriptorBufferBindingInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT => {
            print_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT => {
            print_VkDescriptorGetInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
            print_VkBufferCaptureDescriptorDataInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
            print_VkImageCaptureDescriptorDataInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
            print_VkImageViewCaptureDescriptorDataInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
            print_VkSamplerCaptureDescriptorDataInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
            print_VkAccelerationStructureCaptureDescriptorDataInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT => {
            print_VkOpaqueCaptureDescriptorDataCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES => {
            print_VkPhysicalDeviceShaderIntegerDotProductFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES => {
            print_VkPhysicalDeviceShaderIntegerDotProductProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT => {
            print_VkPhysicalDeviceDrmPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR => {
            print_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR => {
            print_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderFmaFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV => {
            print_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV => {
            print_VkPhysicalDeviceRayTracingValidationFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV => {
            print_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV => {
            print_VkAccelerationStructureGeometryMotionTrianglesDataNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV => {
            print_VkAccelerationStructureMotionInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV => {
            print_VkMemoryGetRemoteAddressInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA => {
            print_VkImportMemoryBufferCollectionFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA => {
            print_VkBufferCollectionImageCreateInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA => {
            print_VkBufferCollectionBufferCreateInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA => {
            print_VkBufferCollectionCreateInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA => {
            print_VkBufferCollectionPropertiesFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA => {
            print_VkBufferConstraintsInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA => {
            print_VkSysmemColorSpaceFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA => {
            print_VkImageFormatConstraintsInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA => {
            print_VkImageConstraintsInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA => {
            print_VkBufferCollectionConstraintsInfoFUCHSIA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV => {
            print_VkCudaModuleCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV => {
            print_VkCudaFunctionCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV => {
            print_VkCudaLaunchInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT => {
            print_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 => {
            print_VkFormatProperties3("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT => {
            print_VkDrmFormatModifierPropertiesList2EXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID => {
            print_VkAndroidHardwareBufferFormatProperties2ANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO => {
            print_VkPipelineRenderingCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_INFO => {
            print_VkRenderingInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR => {
            print_VkRenderingEndInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO => {
            print_VkRenderingAttachmentInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
            print_VkRenderingFragmentShadingRateAttachmentInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT => {
            print_VkRenderingFragmentDensityMapAttachmentInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES => {
            print_VkPhysicalDeviceDynamicRenderingFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO => {
            print_VkCommandBufferInheritanceRenderingInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD => {
            print_VkAttachmentSampleCountInfoAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX => {
            print_VkMultiviewPerViewAttributesInfoNVX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT => {
            print_VkPhysicalDeviceImageViewMinLodFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT => {
            print_VkImageViewMinLodCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT => {
            print_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV => {
            print_VkPhysicalDeviceLinearColorAttachmentFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT => {
            print_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR => {
            print_VkPhysicalDevicePipelineBinaryFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR => {
            print_VkDevicePipelineBinaryInternalCacheControlKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR => {
            print_VkPhysicalDevicePipelineBinaryPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT => {
            print_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT => {
            print_VkGraphicsPipelineLibraryCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE => {
            print_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE => {
            print_VkDescriptorSetBindingReferenceVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE => {
            print_VkDescriptorSetLayoutHostMappingInfoVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT => {
            print_VkPhysicalDeviceNestedCommandBufferFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT => {
            print_VkPhysicalDeviceNestedCommandBufferPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT => {
            print_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT => {
            print_VkPipelineShaderStageModuleIdentifierCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT => {
            print_VkShaderModuleIdentifierEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT => {
            print_VkImageCompressionControlEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT => {
            print_VkPhysicalDeviceImageCompressionControlFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT => {
            print_VkImageCompressionPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT => {
            print_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 => {
            print_VkImageSubresource2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 => {
            print_VkSubresourceLayout2("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT => {
            print_VkRenderPassCreationControlEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT => {
            print_VkRenderPassCreationFeedbackCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT => {
            print_VkRenderPassSubpassFeedbackCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT => {
            print_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT => {
            print_VkMicromapBuildInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT => {
            print_VkMicromapCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT => {
            print_VkMicromapVersionInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT => {
            print_VkCopyMicromapInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT => {
            print_VkCopyMicromapToMemoryInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT => {
            print_VkCopyMemoryToMicromapInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT => {
            print_VkMicromapBuildSizesInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT => {
            print_VkPhysicalDeviceOpacityMicromapFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT => {
            print_VkPhysicalDeviceOpacityMicromapPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT => {
            print_VkAccelerationStructureTrianglesOpacityMicromapEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV => {
            print_VkPhysicalDeviceDisplacementMicromapFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV => {
            print_VkPhysicalDeviceDisplacementMicromapPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV => {
            print_VkAccelerationStructureTrianglesDisplacementMicromapNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT => {
            print_VkPipelinePropertiesIdentifierEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT => {
            print_VkPhysicalDevicePipelinePropertiesFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD => {
            print_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT => {
            print_VkExternalMemoryAcquireUnmodifiedEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT => {
            print_VkExportMetalObjectCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT => {
            print_VkExportMetalObjectsInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT => {
            print_VkExportMetalDeviceInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT => {
            print_VkExportMetalCommandQueueInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT => {
            print_VkExportMetalBufferInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT => {
            print_VkImportMetalBufferInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT => {
            print_VkExportMetalTextureInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT => {
            print_VkImportMetalTextureInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT => {
            print_VkExportMetalIOSurfaceInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT => {
            print_VkImportMetalIOSurfaceInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT => {
            print_VkExportMetalSharedEventInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT => {
            print_VkImportMetalSharedEventInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT => {
            print_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES => {
            print_VkPhysicalDevicePipelineRobustnessFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO => {
            print_VkPipelineRobustnessCreateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES => {
            print_VkPhysicalDevicePipelineRobustnessProperties("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM => {
            print_VkImageViewSampleWeightCreateInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM => {
            print_VkPhysicalDeviceImageProcessingFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM => {
            print_VkPhysicalDeviceImageProcessingPropertiesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM => {
            print_VkPhysicalDeviceTilePropertiesFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM => {
            print_VkTilePropertiesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM => {
            print_VkTileMemoryBindInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC => {
            print_VkPhysicalDeviceAmigoProfilingFeaturesSEC("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC => {
            print_VkAmigoProfilingSubmitInfoSEC("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT => {
            print_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT => {
            print_VkAttachmentFeedbackLoopInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT => {
            print_VkPhysicalDeviceAddressBindingReportFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR => {
            print_VkRenderingAttachmentFlagsInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR => {
            print_VkResolveImageModeInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT => {
            print_VkDeviceAddressBindingCallbackDataEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV => {
            print_VkPhysicalDeviceOpticalFlowFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV => {
            print_VkPhysicalDeviceOpticalFlowPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV => {
            print_VkOpticalFlowImageFormatInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV => {
            print_VkOpticalFlowImageFormatPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV => {
            print_VkOpticalFlowSessionCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV => {
            print_VkOpticalFlowSessionCreatePrivateDataInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV => {
            print_VkOpticalFlowExecuteInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT => {
            print_VkPhysicalDeviceFaultFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT => {
            print_VkDeviceFaultCountsEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT => {
            print_VkDeviceFaultInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT => {
            print_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT => {
            print_VkDepthBiasInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT => {
            print_VkDepthBiasRepresentationInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT => {
            print_VkDecompressMemoryInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM => {
            print_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM => {
            print_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT => {
            print_VkFrameBoundaryEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT => {
            print_VkPhysicalDeviceFrameBoundaryFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT => {
            print_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR => {
            print_VkSurfacePresentModeKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR => {
            print_VkSurfacePresentScalingCapabilitiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR => {
            print_VkSurfacePresentModeCompatibilityKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR => {
            print_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR => {
            print_VkSwapchainPresentFenceInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR => {
            print_VkSwapchainPresentModesCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR => {
            print_VkSwapchainPresentModeInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR => {
            print_VkSwapchainPresentScalingCreateInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR => {
            print_VkReleaseSwapchainImagesInfoKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT => {
            print_VkPhysicalDeviceDepthBiasControlFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT => {
            print_VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV => {
            print_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT => {
            print_VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV => {
            print_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV => {
            print_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV => {
            print_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG => {
            print_VkDirectDriverLoadingInfoLUNARG("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG => {
            print_VkDirectDriverLoadingListLUNARG("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM => {
            print_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR => {
            print_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO => {
            print_VkDeviceImageSubresourceInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM => {
            print_VkPhysicalDeviceShaderCorePropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM => {
            print_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM => {
            print_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV => {
            print_VkQueryLowLatencySupportNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_MAP_INFO => {
            print_VkMemoryMapInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO => {
            print_VkMemoryUnmapInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderObjectFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT => {
            print_VkPhysicalDeviceShaderObjectPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT => {
            print_VkShaderCreateInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderTileImageFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT => {
            print_VkPhysicalDeviceShaderTileImagePropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX => {
            print_VkImportScreenBufferInfoQNX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX => {
            print_VkScreenBufferPropertiesQNX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX => {
            print_VkScreenBufferFormatPropertiesQNX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX => {
            print_VkExternalFormatQNX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX => {
            print_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR => {
            print_VkPhysicalDeviceCooperativeMatrixFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
            print_VkCooperativeMatrixPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
            print_VkPhysicalDeviceCooperativeMatrixPropertiesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX => {
            print_VkPhysicalDeviceShaderEnqueuePropertiesAMDX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX => {
            print_VkPhysicalDeviceShaderEnqueueFeaturesAMDX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX => {
            print_VkExecutionGraphPipelineCreateInfoAMDX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX => {
            print_VkPipelineShaderStageNodeCreateInfoAMDX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX => {
            print_VkExecutionGraphPipelineScratchSizeAMDX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD => {
            print_VkPhysicalDeviceAntiLagFeaturesAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD => {
            print_VkAntiLagDataAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD => {
            print_VkAntiLagPresentationInfoAMD("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS => {
            print_VkBindMemoryStatus("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM => {
            print_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM => {
            print_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM => {
            print_VkTileMemorySizeInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM => {
            print_VkTileMemoryRequirementsQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO => {
            print_VkBindDescriptorSetsInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO => {
            print_VkPushConstantsInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO => {
            print_VkPushDescriptorSetInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO => {
            print_VkPushDescriptorSetWithTemplateInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT => {
            print_VkSetDescriptorBufferOffsetsInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT => {
            print_VkBindDescriptorBufferEmbeddedSamplersInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM => {
            print_VkPhysicalDeviceCubicClampFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM => {
            print_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM => {
            print_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM => {
            print_VkPhysicalDeviceCubicWeightsFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM => {
            print_VkSamplerCubicWeightsCreateInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM => {
            print_VkBlitImageCubicWeightsInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM => {
            print_VkPhysicalDeviceImageProcessing2FeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM => {
            print_VkPhysicalDeviceImageProcessing2PropertiesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM => {
            print_VkSamplerBlockMatchWindowCreateInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV => {
            print_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT => {
            print_VkPhysicalDeviceLayeredDriverPropertiesMSFT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV => {
            print_VkPhysicalDevicePerStageDescriptorSetFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID => {
            print_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID => {
            print_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID => {
            print_VkAndroidHardwareBufferFormatResolvePropertiesANDROID("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV => {
            print_VkLatencySleepModeInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV => {
            print_VkLatencySleepInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV => {
            print_VkSetLatencyMarkerInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV => {
            print_VkGetLatencyMarkerInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV => {
            print_VkLatencyTimingsFrameReportNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV => {
            print_VkOutOfBandQueueTypeInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV => {
            print_VkLatencySubmissionPresentIdNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV => {
            print_VkSwapchainLatencyCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV => {
            print_VkLatencySurfaceCapabilitiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV => {
            print_VkPhysicalDeviceCudaKernelLaunchFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV => {
            print_VkPhysicalDeviceCudaKernelLaunchPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM => {
            print_VkDeviceQueueShaderCoreControlCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM => {
            print_VkPhysicalDeviceSchedulingControlsFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM => {
            print_VkPhysicalDeviceSchedulingControlsPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG => {
            print_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM => {
            print_VkPhysicalDeviceRenderPassStripedFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM => {
            print_VkPhysicalDeviceRenderPassStripedPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM => {
            print_VkRenderPassStripeInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM => {
            print_VkRenderPassStripeBeginInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM => {
            print_VkRenderPassStripeSubmitInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM => {
            print_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES => {
            print_VkPhysicalDeviceShaderSubgroupRotateFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES => {
            print_VkPhysicalDeviceShaderExpectAssumeFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES => {
            print_VkPhysicalDeviceShaderFloatControls2Features("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES => {
            print_VkPhysicalDeviceDynamicRenderingLocalReadFeatures("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO => {
            print_VkRenderingAttachmentLocationInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO => {
            print_VkRenderingInputAttachmentIndexInfo("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderQuadControlFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV => {
            print_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT => {
            print_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT => {
            print_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT => {
            print_VkMemoryMapPlacedInfoEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderBfloat16FeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV => {
            print_VkPhysicalDeviceRawAccessChainsFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV => {
            print_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA => {
            print_VkPhysicalDeviceImageAlignmentControlFeaturesMESA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA => {
            print_VkPhysicalDeviceImageAlignmentControlPropertiesMESA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA => {
            print_VkImageAlignmentControlCreateInfoMESA("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR => {
            print_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV => {
            print_VkPhysicalDeviceCooperativeMatrix2FeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV => {
            print_VkPhysicalDeviceCooperativeMatrix2PropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV => {
            print_VkCooperativeMatrixFlexibleDimensionsPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI => {
            print_VkPhysicalDeviceHdrVividFeaturesHUAWEI("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT => {
            print_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX => {
            print_VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX => {
            print_VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR => {
            print_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV => {
            print_VkPhysicalDeviceCooperativeVectorFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
            print_VkCooperativeVectorPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
            print_VkPhysicalDeviceCooperativeVectorPropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV => {
            print_VkConvertCooperativeVectorMatrixInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM => {
            print_VkPhysicalDeviceTileShadingFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM => {
            print_VkPhysicalDeviceTileShadingPropertiesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM => {
            print_VkRenderPassTileShadingCreateInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM => {
            print_VkPerTileBeginInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM => {
            print_VkPerTileEndInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM => {
            print_VkDispatchTileInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE => {
            print_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE => {
            print_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE => {
            print_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV => {
            print_VkSetPresentConfigNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV => {
            print_VkPhysicalDevicePresentMeteringFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV => {
            print_VkExternalComputeQueueDeviceCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV => {
            print_VkExternalComputeQueueCreateInfoNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV => {
            print_VkExternalComputeQueueDataParamsNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV => {
            print_VkPhysicalDeviceExternalComputeQueuePropertiesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM => {
            print_VkPhysicalDeviceFormatPackFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM => {
            print_VkTensorDescriptionARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM => {
            print_VkTensorCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM => {
            print_VkTensorViewCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM => {
            print_VkTensorMemoryRequirementsInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM => {
            print_VkBindTensorMemoryInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM => {
            print_VkWriteDescriptorSetTensorARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM => {
            print_VkTensorFormatPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM => {
            print_VkPhysicalDeviceTensorPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM => {
            print_VkTensorMemoryBarrierARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM => {
            print_VkTensorDependencyInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM => {
            print_VkPhysicalDeviceTensorFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM => {
            print_VkDeviceTensorMemoryRequirementsARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM => {
            print_VkCopyTensorInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_COPY_ARM => {
            print_VkTensorCopyARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM => {
            print_VkMemoryDedicatedAllocateInfoTensorARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM => {
            print_VkPhysicalDeviceDescriptorBufferTensorPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM => {
            print_VkPhysicalDeviceDescriptorBufferTensorFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
            print_VkTensorCaptureDescriptorDataInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
            print_VkTensorViewCaptureDescriptorDataInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM => {
            print_VkDescriptorGetTensorInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM => {
            print_VkFrameBoundaryTensorsARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM => {
            print_VkPhysicalDeviceExternalTensorInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM => {
            print_VkExternalTensorPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM => {
            print_VkExternalMemoryTensorCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT => {
            print_VkPhysicalDeviceShaderFloat8FeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS => {
            print_VkSurfaceCreateInfoOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM => {
            print_VkPhysicalDeviceDataGraphFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM => {
            print_VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM => {
            print_VkDataGraphPipelineConstantARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM => {
            print_VkDataGraphPipelineResourceInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM => {
            print_VkDataGraphPipelineCompilerControlCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM => {
            print_VkDataGraphPipelineCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM => {
            print_VkDataGraphPipelineShaderModuleCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM => {
            print_VkDataGraphPipelineSessionCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM => {
            print_VkDataGraphPipelineSessionBindPointRequirementsInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM => {
            print_VkDataGraphPipelineSessionBindPointRequirementARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM => {
            print_VkDataGraphPipelineSessionMemoryRequirementsInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM => {
            print_VkBindDataGraphPipelineSessionMemoryInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM => {
            print_VkDataGraphPipelineInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM => {
            print_VkDataGraphPipelinePropertyQueryResultARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM => {
            print_VkDataGraphPipelineIdentifierCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM => {
            print_VkDataGraphPipelineDispatchInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM => {
            print_VkQueueFamilyDataGraphPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM => {
            print_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM => {
            print_VkQueueFamilyDataGraphProcessingEnginePropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM => {
            print_VkDataGraphProcessingEngineCreateInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC => {
            print_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM => {
            print_VkDataGraphPipelineBuiltinModelCreateInfoQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM => {
            print_VkPhysicalDeviceDataGraphModelFeaturesQCOM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR => {
            print_VkPhysicalDeviceShaderUntypedPointersFeaturesKHR("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS => {
            print_VkNativeBufferOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS => {
            print_VkSwapchainImageCreateInfoOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS => {
            print_VkPhysicalDevicePresentationPropertiesOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE => {
            print_VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE => {
            print_VkVideoEncodeRgbConversionCapabilitiesVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE => {
            print_VkVideoEncodeProfileRgbConversionInfoVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE => {
            print_VkVideoEncodeSessionRgbConversionCreateInfoVALVE("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT => {
            print_VkPhysicalDeviceShader64BitIndexingFeaturesEXT("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS => {
            print_VkNativeBufferUsageOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS => {
            print_VkNativeBufferPropertiesOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS => {
            print_VkNativeBufferFormatPropertiesOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS => {
            print_VkImportNativeBufferInfoOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS => {
            print_VkMemoryGetNativeBufferInfoOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS => {
            print_VkExternalFormatOHOS("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM => {
            print_VkPhysicalDevicePerformanceCountersByRegionFeaturesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM => {
            print_VkPhysicalDevicePerformanceCountersByRegionPropertiesARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM => {
            print_VkPerformanceCounterARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM => {
            print_VkPerformanceCounterDescriptionARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM => {
            print_VkRenderPassPerformanceCountersByRegionBeginInfoARM("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV => {
            print_VkComputeOccupancyPriorityParametersNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV => {
            print_VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV("", @ptrCast(base), 0);
            if (follow_pnext) {
                if (base.pNext) |pnext| {
                    base = pnext;
                    continue :blk base.sType;
                }
            }
        },
        else => {
            log.output("Unknown type: {t}", .{base.sType});
        },
    }
}
