// Copyright (c) 2025 Egor Lazarchuk
// SPDX-License-Identifier: MIT
//
// This file is auto generated by gen/vulkan_validation_gen.zig

const std = @import("std");
const vk = @import("volk");
const log = @import("log.zig");

const Allocator = std.mem.Allocator;
pub fn check_result(result: vk.VkResult) !void {
    switch (result) {
        vk.VK_SUCCESS => return,
        vk.VK_NOT_READY => {
            log.err(@src(), "Vulkan error: VK_NOT_READY (A fence or query has not yet completed)", .{});
            return error.VK_NOT_READY;
        },
        vk.VK_TIMEOUT => {
            log.err(@src(), "Vulkan error: VK_TIMEOUT (A wait operation has not completed in the specified time)", .{});
            return error.VK_TIMEOUT;
        },
        vk.VK_EVENT_SET => {
            log.err(@src(), "Vulkan error: VK_EVENT_SET (An event is signaled)", .{});
            return error.VK_EVENT_SET;
        },
        vk.VK_EVENT_RESET => {
            log.err(@src(), "Vulkan error: VK_EVENT_RESET (An event is unsignaled)", .{});
            return error.VK_EVENT_RESET;
        },
        vk.VK_INCOMPLETE => {
            log.err(@src(), "Vulkan error: VK_INCOMPLETE (A return array was too small for the result)", .{});
            return error.VK_INCOMPLETE;
        },
        vk.VK_ERROR_OUT_OF_HOST_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_HOST_MEMORY (A host memory allocation has failed)", .{});
            return error.VK_ERROR_OUT_OF_HOST_MEMORY;
        },
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DEVICE_MEMORY (A device memory allocation has failed)", .{});
            return error.VK_ERROR_OUT_OF_DEVICE_MEMORY;
        },
        vk.VK_ERROR_INITIALIZATION_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_INITIALIZATION_FAILED (Initialization of an object has failed)", .{});
            return error.VK_ERROR_INITIALIZATION_FAILED;
        },
        vk.VK_ERROR_DEVICE_LOST => {
            log.err(@src(), "Vulkan error: VK_ERROR_DEVICE_LOST (The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;)", .{});
            return error.VK_ERROR_DEVICE_LOST;
        },
        vk.VK_ERROR_MEMORY_MAP_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_MEMORY_MAP_FAILED (Mapping of a memory object has failed)", .{});
            return error.VK_ERROR_MEMORY_MAP_FAILED;
        },
        vk.VK_ERROR_LAYER_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_LAYER_NOT_PRESENT (Layer specified does not exist)", .{});
            return error.VK_ERROR_LAYER_NOT_PRESENT;
        },
        vk.VK_ERROR_EXTENSION_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_EXTENSION_NOT_PRESENT (Extension specified does not exist)", .{});
            return error.VK_ERROR_EXTENSION_NOT_PRESENT;
        },
        vk.VK_ERROR_FEATURE_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FEATURE_NOT_PRESENT (Requested feature is not available on this device)", .{});
            return error.VK_ERROR_FEATURE_NOT_PRESENT;
        },
        vk.VK_ERROR_INCOMPATIBLE_DRIVER => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DRIVER (Unable to find a Vulkan driver)", .{});
            return error.VK_ERROR_INCOMPATIBLE_DRIVER;
        },
        vk.VK_ERROR_TOO_MANY_OBJECTS => {
            log.err(@src(), "Vulkan error: VK_ERROR_TOO_MANY_OBJECTS (Too many objects of the type have already been created)", .{});
            return error.VK_ERROR_TOO_MANY_OBJECTS;
        },
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_FORMAT_NOT_SUPPORTED (Requested format is not supported on this device)", .{});
            return error.VK_ERROR_FORMAT_NOT_SUPPORTED;
        },
        vk.VK_ERROR_FRAGMENTED_POOL => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTED_POOL (A requested pool allocation has failed due to fragmentation of the pool's memory)", .{});
            return error.VK_ERROR_FRAGMENTED_POOL;
        },
        vk.VK_ERROR_UNKNOWN => {
            log.err(@src(), "Vulkan error: VK_ERROR_UNKNOWN (An unknown error has occurred, due to an implementation or application bug)", .{});
            return error.VK_ERROR_UNKNOWN;
        },
        vk.VK_ERROR_SURFACE_LOST_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_SURFACE_LOST_KHR (VK_KHR_surface)", .{});
            return error.VK_ERROR_SURFACE_LOST_KHR;
        },
        vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR (VK_KHR_surface)", .{});
            return error.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;
        },
        vk.VK_SUBOPTIMAL_KHR => {
            log.err(@src(), "Vulkan error: VK_SUBOPTIMAL_KHR (VK_KHR_swapchain)", .{});
            return error.VK_SUBOPTIMAL_KHR;
        },
        vk.VK_ERROR_OUT_OF_DATE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR (VK_KHR_swapchain)", .{});
            return error.VK_ERROR_OUT_OF_DATE_KHR;
        },
        vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR (VK_KHR_display_swapchain)", .{});
            return error.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR;
        },
        vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_OUT_OF_POOL_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY (VK_KHR_maintenance1)", .{});
            return error.VK_ERROR_OUT_OF_POOL_MEMORY;
        },
        vk.VK_ERROR_INVALID_EXTERNAL_HANDLE => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE (VK_KHR_external_memory)", .{});
            return error.VK_ERROR_INVALID_EXTERNAL_HANDLE;
        },
        vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT (VK_EXT_image_drm_format_modifier)", .{});
            return error.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT;
        },
        vk.VK_ERROR_FRAGMENTATION => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTATION (VK_EXT_descriptor_indexing)", .{});
            return error.VK_ERROR_FRAGMENTATION;
        },
        vk.VK_ERROR_NOT_PERMITTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_PERMITTED (VK_EXT_global_priority)", .{});
            return error.VK_ERROR_NOT_PERMITTED;
        },
        vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS (VK_EXT_buffer_device_address)", .{});
            return error.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
        },
        vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT (VK_EXT_full_screen_exclusive)", .{});
            return error.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT;
        },
        vk.VK_THREAD_IDLE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_IDLE_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_THREAD_IDLE_KHR;
        },
        vk.VK_THREAD_DONE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_DONE_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_THREAD_DONE_KHR;
        },
        vk.VK_OPERATION_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_DEFERRED_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_OPERATION_DEFERRED_KHR;
        },
        vk.VK_OPERATION_NOT_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_NOT_DEFERRED_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_OPERATION_NOT_DEFERRED_KHR;
        },
        vk.VK_PIPELINE_COMPILE_REQUIRED => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_COMPILE_REQUIRED (VK_EXT_pipeline_creation_cache_control)", .{});
            return error.VK_PIPELINE_COMPILE_REQUIRED;
        },
        vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR (VK_KHR_video_encode_queue)", .{});
            return error.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR;
        },
        vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_COMPRESSION_EXHAUSTED_EXT (VK_EXT_image_compression_control)", .{});
            return error.VK_ERROR_COMPRESSION_EXHAUSTED_EXT;
        },
        vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT => {
            log.err(@src(), "Vulkan error: VK_INCOMPATIBLE_SHADER_BINARY_EXT (VK_EXT_shader_object)", .{});
            return error.VK_INCOMPATIBLE_SHADER_BINARY_EXT;
        },
        vk.VK_PIPELINE_BINARY_MISSING_KHR => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_BINARY_MISSING_KHR (VK_KHR_pipeline_binary)", .{});
            return error.VK_PIPELINE_BINARY_MISSING_KHR;
        },
        vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_ENOUGH_SPACE_KHR (VK_KHR_pipeline_binary)", .{});
            return error.VK_ERROR_NOT_ENOUGH_SPACE_KHR;
        },
        else => {
            log.err(@src(), "Vulkan error: UNKNOWN {}", .{result});
            return error.UNKNOWN;
        },
    }
}
pub const Extensions = struct {
    instance: packed struct(u25) {
        VK_KHR_surface: bool = false,
        VK_KHR_display: bool = false,
        VK_EXT_debug_report: bool = false,
        VK_KHR_get_physical_device_properties2: bool = false,
        VK_EXT_validation_flags: bool = false,
        VK_KHR_device_group_creation: bool = false,
        VK_KHR_external_memory_capabilities: bool = false,
        VK_KHR_external_semaphore_capabilities: bool = false,
        VK_EXT_direct_mode_display: bool = false,
        VK_EXT_display_surface_counter: bool = false,
        VK_EXT_swapchain_colorspace: bool = false,
        VK_KHR_external_fence_capabilities: bool = false,
        VK_KHR_get_surface_capabilities2: bool = false,
        VK_KHR_get_display_properties2: bool = false,
        VK_EXT_debug_utils: bool = false,
        VK_EXT_metal_surface: bool = false,
        VK_KHR_surface_protected_capabilities: bool = false,
        VK_EXT_validation_features: bool = false,
        VK_EXT_headless_surface: bool = false,
        VK_EXT_surface_maintenance1: bool = false,
        VK_EXT_acquire_drm_display: bool = false,
        VK_EXT_directfb_surface: bool = false,
        VK_KHR_portability_enumeration: bool = false,
        VK_KHR_surface_maintenance1: bool = false,
        VK_EXT_layer_settings: bool = false,
    } = .{},
    device: packed struct(u257) {
        VK_KHR_swapchain: bool = false,
        VK_KHR_display_swapchain: bool = false,
        VK_EXT_depth_range_unrestricted: bool = false,
        VK_IMG_filter_cubic: bool = false,
        VK_EXT_debug_marker: bool = false,
        VK_KHR_video_queue: bool = false,
        VK_KHR_video_decode_queue: bool = false,
        VK_EXT_transform_feedback: bool = false,
        VK_KHR_video_encode_h264: bool = false,
        VK_KHR_video_encode_h265: bool = false,
        VK_KHR_video_decode_h264: bool = false,
        VK_KHR_dynamic_rendering: bool = false,
        VK_KHR_multiview: bool = false,
        VK_IMG_format_pvrtc: bool = false,
        VK_KHR_device_group: bool = false,
        VK_KHR_shader_draw_parameters: bool = false,
        VK_EXT_shader_subgroup_ballot: bool = false,
        VK_EXT_shader_subgroup_vote: bool = false,
        VK_EXT_texture_compression_astc_hdr: bool = false,
        VK_EXT_astc_decode_mode: bool = false,
        VK_EXT_pipeline_robustness: bool = false,
        VK_KHR_maintenance1: bool = false,
        VK_KHR_external_memory: bool = false,
        VK_KHR_external_memory_fd: bool = false,
        VK_KHR_external_semaphore: bool = false,
        VK_KHR_external_semaphore_fd: bool = false,
        VK_KHR_push_descriptor: bool = false,
        VK_EXT_conditional_rendering: bool = false,
        VK_KHR_shader_float16_int8: bool = false,
        VK_KHR_16bit_storage: bool = false,
        VK_KHR_incremental_present: bool = false,
        VK_KHR_descriptor_update_template: bool = false,
        VK_EXT_display_control: bool = false,
        VK_EXT_discard_rectangles: bool = false,
        VK_EXT_conservative_rasterization: bool = false,
        VK_EXT_depth_clip_enable: bool = false,
        VK_EXT_hdr_metadata: bool = false,
        VK_KHR_imageless_framebuffer: bool = false,
        VK_KHR_create_renderpass2: bool = false,
        VK_IMG_relaxed_line_rasterization: bool = false,
        VK_KHR_shared_presentable_image: bool = false,
        VK_KHR_external_fence: bool = false,
        VK_KHR_external_fence_fd: bool = false,
        VK_KHR_maintenance2: bool = false,
        VK_KHR_variable_pointers: bool = false,
        VK_EXT_external_memory_dma_buf: bool = false,
        VK_EXT_queue_family_foreign: bool = false,
        VK_KHR_dedicated_allocation: bool = false,
        VK_EXT_sampler_filter_minmax: bool = false,
        VK_KHR_storage_buffer_storage_class: bool = false,
        VK_EXT_inline_uniform_block: bool = false,
        VK_EXT_shader_stencil_export: bool = false,
        VK_KHR_shader_bfloat16: bool = false,
        VK_EXT_sample_locations: bool = false,
        VK_KHR_relaxed_block_layout: bool = false,
        VK_KHR_get_memory_requirements2: bool = false,
        VK_KHR_image_format_list: bool = false,
        VK_EXT_blend_operation_advanced: bool = false,
        VK_KHR_acceleration_structure: bool = false,
        VK_KHR_ray_tracing_pipeline: bool = false,
        VK_KHR_ray_query: bool = false,
        VK_EXT_post_depth_coverage: bool = false,
        VK_KHR_sampler_ycbcr_conversion: bool = false,
        VK_KHR_bind_memory2: bool = false,
        VK_EXT_image_drm_format_modifier: bool = false,
        VK_EXT_validation_cache: bool = false,
        VK_EXT_descriptor_indexing: bool = false,
        VK_EXT_shader_viewport_index_layer: bool = false,
        VK_KHR_maintenance3: bool = false,
        VK_KHR_draw_indirect_count: bool = false,
        VK_EXT_filter_cubic: bool = false,
        VK_QCOM_render_pass_shader_resolve: bool = false,
        VK_EXT_global_priority: bool = false,
        VK_KHR_shader_subgroup_extended_types: bool = false,
        VK_KHR_8bit_storage: bool = false,
        VK_EXT_external_memory_host: bool = false,
        VK_KHR_shader_atomic_int64: bool = false,
        VK_KHR_shader_clock: bool = false,
        VK_EXT_calibrated_timestamps: bool = false,
        VK_KHR_video_decode_h265: bool = false,
        VK_KHR_global_priority: bool = false,
        VK_EXT_vertex_attribute_divisor: bool = false,
        VK_EXT_pipeline_creation_feedback: bool = false,
        VK_KHR_driver_properties: bool = false,
        VK_KHR_shader_float_controls: bool = false,
        VK_KHR_depth_stencil_resolve: bool = false,
        VK_KHR_swapchain_mutable_format: bool = false,
        VK_KHR_timeline_semaphore: bool = false,
        VK_INTEL_shader_integer_functions2: bool = false,
        VK_INTEL_performance_query: bool = false,
        VK_KHR_vulkan_memory_model: bool = false,
        VK_EXT_pci_bus_info: bool = false,
        VK_KHR_shader_terminate_invocation: bool = false,
        VK_EXT_fragment_density_map: bool = false,
        VK_EXT_scalar_block_layout: bool = false,
        VK_EXT_subgroup_size_control: bool = false,
        VK_KHR_fragment_shading_rate: bool = false,
        VK_KHR_dynamic_rendering_local_read: bool = false,
        VK_EXT_shader_image_atomic_int64: bool = false,
        VK_KHR_shader_quad_control: bool = false,
        VK_KHR_spirv_1_4: bool = false,
        VK_EXT_memory_budget: bool = false,
        VK_EXT_memory_priority: bool = false,
        VK_KHR_separate_depth_stencil_layouts: bool = false,
        VK_EXT_buffer_device_address: bool = false,
        VK_EXT_tooling_info: bool = false,
        VK_EXT_separate_stencil_usage: bool = false,
        VK_KHR_present_wait: bool = false,
        VK_EXT_fragment_shader_interlock: bool = false,
        VK_EXT_ycbcr_image_arrays: bool = false,
        VK_KHR_uniform_buffer_standard_layout: bool = false,
        VK_EXT_provoking_vertex: bool = false,
        VK_EXT_full_screen_exclusive: bool = false,
        VK_KHR_buffer_device_address: bool = false,
        VK_EXT_line_rasterization: bool = false,
        VK_EXT_shader_atomic_float: bool = false,
        VK_EXT_host_query_reset: bool = false,
        VK_EXT_index_type_uint8: bool = false,
        VK_EXT_extended_dynamic_state: bool = false,
        VK_KHR_deferred_host_operations: bool = false,
        VK_KHR_pipeline_executable_properties: bool = false,
        VK_EXT_host_image_copy: bool = false,
        VK_KHR_map_memory2: bool = false,
        VK_EXT_map_memory_placed: bool = false,
        VK_EXT_shader_atomic_float2: bool = false,
        VK_EXT_swapchain_maintenance1: bool = false,
        VK_EXT_shader_demote_to_helper_invocation: bool = false,
        VK_KHR_shader_integer_dot_product: bool = false,
        VK_EXT_texel_buffer_alignment: bool = false,
        VK_QCOM_render_pass_transform: bool = false,
        VK_EXT_depth_bias_control: bool = false,
        VK_EXT_device_memory_report: bool = false,
        VK_EXT_robustness2: bool = false,
        VK_EXT_custom_border_color: bool = false,
        VK_KHR_pipeline_library: bool = false,
        VK_KHR_shader_non_semantic_info: bool = false,
        VK_KHR_present_id: bool = false,
        VK_EXT_private_data: bool = false,
        VK_EXT_pipeline_creation_cache_control: bool = false,
        VK_KHR_video_encode_queue: bool = false,
        VK_QCOM_render_pass_store_ops: bool = false,
        VK_QCOM_tile_shading: bool = false,
        VK_EXT_metal_objects: bool = false,
        VK_KHR_synchronization2: bool = false,
        VK_EXT_descriptor_buffer: bool = false,
        VK_EXT_graphics_pipeline_library: bool = false,
        VK_KHR_fragment_shader_barycentric: bool = false,
        VK_KHR_shader_subgroup_uniform_control_flow: bool = false,
        VK_KHR_zero_initialize_workgroup_memory: bool = false,
        VK_EXT_mesh_shader: bool = false,
        VK_EXT_ycbcr_2plane_444_formats: bool = false,
        VK_EXT_fragment_density_map2: bool = false,
        VK_QCOM_rotated_copy_commands: bool = false,
        VK_EXT_image_robustness: bool = false,
        VK_KHR_workgroup_memory_explicit_layout: bool = false,
        VK_KHR_copy_commands2: bool = false,
        VK_EXT_image_compression_control: bool = false,
        VK_EXT_attachment_feedback_loop_layout: bool = false,
        VK_EXT_4444_formats: bool = false,
        VK_EXT_device_fault: bool = false,
        VK_EXT_rgba10x6_formats: bool = false,
        VK_VALVE_mutable_descriptor_type: bool = false,
        VK_EXT_vertex_input_dynamic_state: bool = false,
        VK_EXT_physical_device_drm: bool = false,
        VK_EXT_device_address_binding_report: bool = false,
        VK_EXT_depth_clip_control: bool = false,
        VK_EXT_primitive_topology_list_restart: bool = false,
        VK_KHR_format_feature_flags2: bool = false,
        VK_EXT_present_mode_fifo_latest_ready: bool = false,
        VK_EXT_pipeline_properties: bool = false,
        VK_EXT_frame_boundary: bool = false,
        VK_EXT_multisampled_render_to_single_sampled: bool = false,
        VK_EXT_extended_dynamic_state2: bool = false,
        VK_EXT_color_write_enable: bool = false,
        VK_EXT_primitives_generated_query: bool = false,
        VK_KHR_ray_tracing_maintenance1: bool = false,
        VK_EXT_global_priority_query: bool = false,
        VK_EXT_image_view_min_lod: bool = false,
        VK_EXT_multi_draw: bool = false,
        VK_EXT_image_2d_view_of_3d: bool = false,
        VK_EXT_shader_tile_image: bool = false,
        VK_EXT_opacity_micromap: bool = false,
        VK_EXT_load_store_op_none: bool = false,
        VK_EXT_border_color_swizzle: bool = false,
        VK_EXT_pageable_device_local_memory: bool = false,
        VK_KHR_maintenance4: bool = false,
        VK_KHR_shader_subgroup_rotate: bool = false,
        VK_EXT_image_sliced_view_of_3d: bool = false,
        VK_VALVE_descriptor_set_host_mapping: bool = false,
        VK_EXT_depth_clamp_zero_one: bool = false,
        VK_EXT_non_seamless_cube_map: bool = false,
        VK_QCOM_fragment_density_map_offset: bool = false,
        VK_KHR_shader_maximal_reconvergence: bool = false,
        VK_EXT_image_compression_control_swapchain: bool = false,
        VK_QCOM_image_processing: bool = false,
        VK_EXT_nested_command_buffer: bool = false,
        VK_EXT_external_memory_acquire_unmodified: bool = false,
        VK_EXT_extended_dynamic_state3: bool = false,
        VK_EXT_subpass_merge_feedback: bool = false,
        VK_EXT_shader_module_identifier: bool = false,
        VK_EXT_rasterization_order_attachment_access: bool = false,
        VK_EXT_legacy_dithering: bool = false,
        VK_EXT_pipeline_protected_access: bool = false,
        VK_KHR_maintenance5: bool = false,
        VK_KHR_present_id2: bool = false,
        VK_KHR_present_wait2: bool = false,
        VK_KHR_ray_tracing_position_fetch: bool = false,
        VK_EXT_shader_object: bool = false,
        VK_KHR_pipeline_binary: bool = false,
        VK_QCOM_tile_properties: bool = false,
        VK_KHR_swapchain_maintenance1: bool = false,
        VK_QCOM_multiview_per_view_viewports: bool = false,
        VK_EXT_mutable_descriptor_type: bool = false,
        VK_EXT_legacy_vertex_attributes: bool = false,
        VK_EXT_pipeline_library_group_handles: bool = false,
        VK_EXT_dynamic_rendering_unused_attachments: bool = false,
        VK_KHR_cooperative_matrix: bool = false,
        VK_QCOM_multiview_per_view_render_areas: bool = false,
        VK_KHR_compute_shader_derivatives: bool = false,
        VK_KHR_video_decode_av1: bool = false,
        VK_KHR_video_encode_av1: bool = false,
        VK_KHR_video_decode_vp9: bool = false,
        VK_KHR_video_maintenance1: bool = false,
        VK_QCOM_image_processing2: bool = false,
        VK_QCOM_filter_cubic_weights: bool = false,
        VK_QCOM_ycbcr_degamma: bool = false,
        VK_QCOM_filter_cubic_clamp: bool = false,
        VK_EXT_attachment_feedback_loop_dynamic_state: bool = false,
        VK_KHR_vertex_attribute_divisor: bool = false,
        VK_KHR_load_store_op_none: bool = false,
        VK_KHR_unified_image_layouts: bool = false,
        VK_KHR_shader_float_controls2: bool = false,
        VK_KHR_index_type_uint8: bool = false,
        VK_KHR_line_rasterization: bool = false,
        VK_KHR_calibrated_timestamps: bool = false,
        VK_KHR_shader_expect_assume: bool = false,
        VK_KHR_maintenance6: bool = false,
        VK_QCOM_tile_memory_heap: bool = false,
        VK_KHR_video_encode_intra_refresh: bool = false,
        VK_KHR_video_encode_quantization_map: bool = false,
        VK_KHR_shader_relaxed_extended_instruction: bool = false,
        VK_KHR_maintenance7: bool = false,
        VK_EXT_shader_replicated_composites: bool = false,
        VK_EXT_shader_float8: bool = false,
        VK_EXT_device_generated_commands: bool = false,
        VK_KHR_maintenance8: bool = false,
        VK_EXT_depth_clamp_control: bool = false,
        VK_KHR_maintenance9: bool = false,
        VK_KHR_video_maintenance2: bool = false,
        VK_EXT_external_memory_metal: bool = false,
        VK_KHR_depth_clamp_zero_one: bool = false,
        VK_EXT_vertex_attribute_robustness: bool = false,
        VK_VALVE_fragment_density_map_layered: bool = false,
        VK_KHR_robustness2: bool = false,
        VK_EXT_fragment_density_map_offset: bool = false,
        VK_EXT_zero_initialize_device_memory: bool = false,
        VK_KHR_present_mode_fifo_latest_ready: bool = false,
    } = .{},

    const Self = @This();

    pub fn init(
        tmp_alloc: Allocator,
        api_version: u32,
        instance_extensions: []const [*c]const u8,
        device_extensions: []const [*c]const u8,
    ) !Self {
        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        var self: Self = .{};
        if (vk.VK_API_VERSION_1_1 <= api_version) {
            self.instance.VK_KHR_get_physical_device_properties2 = true;
            self.instance.VK_KHR_device_group_creation = true;
            self.instance.VK_KHR_external_memory_capabilities = true;
            self.instance.VK_KHR_external_semaphore_capabilities = true;
            self.instance.VK_KHR_external_fence_capabilities = true;
            self.device.VK_KHR_multiview = true;
            self.device.VK_KHR_device_group = true;
            self.device.VK_KHR_shader_draw_parameters = true;
            self.device.VK_KHR_maintenance1 = true;
            self.device.VK_KHR_external_memory = true;
            self.device.VK_KHR_external_semaphore = true;
            self.device.VK_KHR_16bit_storage = true;
            self.device.VK_KHR_descriptor_update_template = true;
            self.device.VK_KHR_external_fence = true;
            self.device.VK_KHR_maintenance2 = true;
            self.device.VK_KHR_variable_pointers = true;
            self.device.VK_KHR_dedicated_allocation = true;
            self.device.VK_KHR_storage_buffer_storage_class = true;
            self.device.VK_KHR_relaxed_block_layout = true;
            self.device.VK_KHR_get_memory_requirements2 = true;
            self.device.VK_KHR_sampler_ycbcr_conversion = true;
            self.device.VK_KHR_bind_memory2 = true;
            self.device.VK_KHR_maintenance3 = true;
        }
        if (vk.VK_API_VERSION_1_2 <= api_version) {
            self.device.VK_KHR_shader_float16_int8 = true;
            self.device.VK_KHR_imageless_framebuffer = true;
            self.device.VK_KHR_create_renderpass2 = true;
            self.device.VK_EXT_sampler_filter_minmax = true;
            self.device.VK_KHR_image_format_list = true;
            self.device.VK_EXT_descriptor_indexing = true;
            self.device.VK_EXT_shader_viewport_index_layer = true;
            self.device.VK_KHR_draw_indirect_count = true;
            self.device.VK_KHR_shader_subgroup_extended_types = true;
            self.device.VK_KHR_8bit_storage = true;
            self.device.VK_KHR_shader_atomic_int64 = true;
            self.device.VK_KHR_driver_properties = true;
            self.device.VK_KHR_shader_float_controls = true;
            self.device.VK_KHR_depth_stencil_resolve = true;
            self.device.VK_KHR_timeline_semaphore = true;
            self.device.VK_KHR_vulkan_memory_model = true;
            self.device.VK_EXT_scalar_block_layout = true;
            self.device.VK_KHR_spirv_1_4 = true;
            self.device.VK_KHR_separate_depth_stencil_layouts = true;
            self.device.VK_EXT_separate_stencil_usage = true;
            self.device.VK_KHR_uniform_buffer_standard_layout = true;
            self.device.VK_KHR_buffer_device_address = true;
            self.device.VK_EXT_host_query_reset = true;
        }
        if (vk.VK_API_VERSION_1_3 <= api_version) {
            self.device.VK_KHR_dynamic_rendering = true;
            self.device.VK_EXT_texture_compression_astc_hdr = true;
            self.device.VK_EXT_inline_uniform_block = true;
            self.device.VK_EXT_pipeline_creation_feedback = true;
            self.device.VK_KHR_shader_terminate_invocation = true;
            self.device.VK_EXT_subgroup_size_control = true;
            self.device.VK_EXT_tooling_info = true;
            self.device.VK_EXT_extended_dynamic_state = true;
            self.device.VK_EXT_shader_demote_to_helper_invocation = true;
            self.device.VK_KHR_shader_integer_dot_product = true;
            self.device.VK_EXT_texel_buffer_alignment = true;
            self.device.VK_KHR_shader_non_semantic_info = true;
            self.device.VK_EXT_private_data = true;
            self.device.VK_EXT_pipeline_creation_cache_control = true;
            self.device.VK_KHR_synchronization2 = true;
            self.device.VK_KHR_zero_initialize_workgroup_memory = true;
            self.device.VK_EXT_ycbcr_2plane_444_formats = true;
            self.device.VK_EXT_image_robustness = true;
            self.device.VK_KHR_copy_commands2 = true;
            self.device.VK_EXT_4444_formats = true;
            self.device.VK_KHR_format_feature_flags2 = true;
            self.device.VK_EXT_extended_dynamic_state2 = true;
            self.device.VK_KHR_maintenance4 = true;
        }
        if (vk.VK_API_VERSION_1_4 <= api_version) {
            self.device.VK_EXT_pipeline_robustness = true;
            self.device.VK_KHR_push_descriptor = true;
            self.device.VK_KHR_global_priority = true;
            self.device.VK_KHR_dynamic_rendering_local_read = true;
            self.device.VK_EXT_host_image_copy = true;
            self.device.VK_KHR_map_memory2 = true;
            self.device.VK_KHR_shader_subgroup_rotate = true;
            self.device.VK_EXT_pipeline_protected_access = true;
            self.device.VK_KHR_maintenance5 = true;
            self.device.VK_KHR_vertex_attribute_divisor = true;
            self.device.VK_KHR_load_store_op_none = true;
            self.device.VK_KHR_shader_float_controls2 = true;
            self.device.VK_KHR_index_type_uint8 = true;
            self.device.VK_KHR_line_rasterization = true;
            self.device.VK_KHR_shader_expect_assume = true;
            self.device.VK_KHR_maintenance6 = true;
        }
        // Instance extensions
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface")) {
                self.instance.VK_KHR_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_report")) {
                self.instance.VK_EXT_debug_report = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_physical_device_properties2")) {
                self.instance.VK_KHR_get_physical_device_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_flags")) {
                self.instance.VK_EXT_validation_flags = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group_creation")) {
                self.instance.VK_KHR_device_group_creation = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_memory_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_semaphore_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_direct_mode_display") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_direct_mode_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_surface_counter") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_display_surface_counter = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_colorspace") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_swapchain_colorspace = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_fence_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_surface_capabilities2") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_get_surface_capabilities2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_display_properties2") and (self.instance.VK_KHR_display)) {
                self.instance.VK_KHR_get_display_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_utils")) {
                self.instance.VK_EXT_debug_utils = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_metal_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_protected_capabilities") and (vk.VK_API_VERSION_1_1 <= api_version and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_protected_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_features")) {
                self.instance.VK_EXT_validation_features = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_headless_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_headless_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_surface_maintenance1") and (self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_EXT_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_acquire_drm_display") and (self.instance.VK_EXT_direct_mode_display)) {
                self.instance.VK_EXT_acquire_drm_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_directfb_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_directfb_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_portability_enumeration")) {
                self.instance.VK_KHR_portability_enumeration = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_maintenance1") and (self.instance.VK_KHR_surface or self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_layer_settings")) {
                self.instance.VK_EXT_layer_settings = true;
                break;
            }
        }
        // Device extensions
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain") and (self.instance.VK_KHR_surface)) {
                self.device.VK_KHR_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display_swapchain") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_display)) {
                self.device.VK_KHR_display_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_range_unrestricted")) {
                self.device.VK_EXT_depth_range_unrestricted = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_filter_cubic")) {
                self.device.VK_IMG_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_marker") and (self.instance.VK_EXT_debug_report)) {
                self.device.VK_EXT_debug_marker = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_queue") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_video_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_decode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_transform_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_transform_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h264") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h265") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h264") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_multiview") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_multiview = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_format_pvrtc")) {
                self.device.VK_IMG_format_pvrtc = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group") and (self.instance.VK_KHR_device_group_creation)) {
                self.device.VK_KHR_device_group = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_draw_parameters")) {
                self.device.VK_KHR_shader_draw_parameters = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_ballot")) {
                self.device.VK_EXT_shader_subgroup_ballot = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_vote")) {
                self.device.VK_EXT_shader_subgroup_vote = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texture_compression_astc_hdr") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texture_compression_astc_hdr = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_astc_decode_mode") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_astc_decode_mode = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance1")) {
                self.device.VK_KHR_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory") and (self.instance.VK_KHR_external_memory_capabilities or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_fd") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore") and (self.instance.VK_KHR_external_semaphore_capabilities)) {
                self.device.VK_KHR_external_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_fd") and (self.device.VK_KHR_external_semaphore or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_semaphore_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_push_descriptor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_push_descriptor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conditional_rendering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conditional_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float16_int8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float16_int8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_16bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_16bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_incremental_present") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_incremental_present = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_descriptor_update_template")) {
                self.device.VK_KHR_descriptor_update_template = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_control") and (self.instance.VK_EXT_display_surface_counter and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_display_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_discard_rectangles") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_discard_rectangles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conservative_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conservative_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_hdr_metadata") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_hdr_metadata = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_imageless_framebuffer") and ((((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_imageless_framebuffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_create_renderpass2") and ((self.device.VK_KHR_multiview and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_create_renderpass2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_relaxed_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_IMG_relaxed_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shared_presentable_image") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_surface_capabilities2 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_KHR_shared_presentable_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence") and (self.instance.VK_KHR_external_fence_capabilities)) {
                self.device.VK_KHR_external_fence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_fd") and (self.device.VK_KHR_external_fence or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_fence_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance2")) {
                self.device.VK_KHR_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_variable_pointers") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_variable_pointers = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_dma_buf") and (self.device.VK_KHR_external_memory_fd)) {
                self.device.VK_EXT_external_memory_dma_buf = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_queue_family_foreign") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_queue_family_foreign = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dedicated_allocation") and (self.device.VK_KHR_get_memory_requirements2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_dedicated_allocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sampler_filter_minmax") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sampler_filter_minmax = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_storage_buffer_storage_class")) {
                self.device.VK_KHR_storage_buffer_storage_class = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_inline_uniform_block") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance1) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_inline_uniform_block = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_stencil_export")) {
                self.device.VK_EXT_shader_stencil_export = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_bfloat16") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_bfloat16 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sample_locations") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sample_locations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_relaxed_block_layout")) {
                self.device.VK_KHR_relaxed_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_memory_requirements2")) {
                self.device.VK_KHR_get_memory_requirements2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_image_format_list")) {
                self.device.VK_KHR_image_format_list = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_blend_operation_advanced") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_blend_operation_advanced = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_acceleration_structure") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_EXT_descriptor_indexing and self.device.VK_KHR_buffer_device_address) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_deferred_host_operations)) {
                self.device.VK_KHR_acceleration_structure = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_pipeline") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_pipeline = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_query") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_post_depth_coverage")) {
                self.device.VK_EXT_post_depth_coverage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_sampler_ycbcr_conversion") and ((self.device.VK_KHR_maintenance1 and self.device.VK_KHR_bind_memory2 and self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_sampler_ycbcr_conversion = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_bind_memory2")) {
                self.device.VK_KHR_bind_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_drm_format_modifier") and ((((self.device.VK_KHR_bind_memory2 and self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_sampler_ycbcr_conversion) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_image_drm_format_modifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_cache")) {
                self.device.VK_EXT_validation_cache = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_indexing") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance3) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_descriptor_indexing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_viewport_index_layer")) {
                self.device.VK_EXT_shader_viewport_index_layer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_draw_indirect_count")) {
                self.device.VK_KHR_draw_indirect_count = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_filter_cubic")) {
                self.device.VK_EXT_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_shader_resolve")) {
                self.device.VK_QCOM_render_pass_shader_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority")) {
                self.device.VK_EXT_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_extended_types") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_extended_types = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_8bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_8bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_host") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_host = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_clock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_clock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h265") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_global_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_feedback")) {
                self.device.VK_EXT_pipeline_creation_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_driver_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_driver_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float_controls = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_stencil_resolve") and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_depth_stencil_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_mutable_format") and (self.device.VK_KHR_swapchain and (self.device.VK_KHR_maintenance2 or vk.VK_API_VERSION_1_1 <= api_version) and (self.device.VK_KHR_image_format_list or vk.VK_API_VERSION_1_2 <= api_version))) {
                self.device.VK_KHR_swapchain_mutable_format = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_timeline_semaphore") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_timeline_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_shader_integer_functions2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_INTEL_shader_integer_functions2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_performance_query")) {
                self.device.VK_INTEL_performance_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vulkan_memory_model") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vulkan_memory_model = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pci_bus_info") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pci_bus_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_terminate_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_terminate_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_density_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_scalar_block_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_scalar_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subgroup_size_control") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subgroup_size_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shading_rate") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_fragment_shading_rate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering_local_read") and (self.device.VK_KHR_dynamic_rendering or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering_local_read = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_image_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_image_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_quad_control") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_vulkan_memory_model) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_shader_maximal_reconvergence)) {
                self.device.VK_KHR_shader_quad_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_spirv_1_4") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_spirv_1_4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_budget") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_budget = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_separate_depth_stencil_layouts") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_separate_depth_stencil_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_buffer_device_address") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_tooling_info")) {
                self.device.VK_EXT_tooling_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_separate_stencil_usage")) {
                self.device.VK_EXT_separate_stencil_usage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait") and (self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id)) {
                self.device.VK_KHR_present_wait = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_shader_interlock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_shader_interlock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_image_arrays") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_image_arrays = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_uniform_buffer_standard_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_uniform_buffer_standard_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_provoking_vertex") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_provoking_vertex = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_full_screen_exclusive") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_full_screen_exclusive = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_buffer_device_address") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_device_group) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_atomic_float = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_query_reset") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_host_query_reset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_deferred_host_operations")) {
                self.device.VK_KHR_deferred_host_operations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_executable_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_pipeline_executable_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_image_copy") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_copy_commands2 and self.device.VK_KHR_format_feature_flags2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_host_image_copy = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_map_memory2")) {
                self.device.VK_KHR_map_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_map_memory_placed") and (self.device.VK_KHR_map_memory2 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_EXT_map_memory_placed = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float2") and (self.device.VK_EXT_shader_atomic_float)) {
                self.device.VK_EXT_shader_atomic_float2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_maintenance1") and (self.device.VK_KHR_swapchain and self.instance.VK_EXT_surface_maintenance1 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_demote_to_helper_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_demote_to_helper_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_integer_dot_product") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_integer_dot_product = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texel_buffer_alignment") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texel_buffer_alignment = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_transform")) {
                self.device.VK_QCOM_render_pass_transform = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_bias_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_bias_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_memory_report") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_memory_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_custom_border_color") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_custom_border_color = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_library")) {
                self.device.VK_KHR_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_non_semantic_info")) {
                self.device.VK_KHR_shader_non_semantic_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_present_id = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_private_data") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_private_data = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_cache_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_creation_cache_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_store_ops")) {
                self.device.VK_QCOM_render_pass_store_ops = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_shading") and (self.device.VK_QCOM_tile_properties or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_QCOM_tile_shading = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_objects")) {
                self.device.VK_EXT_metal_objects = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_synchronization2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_synchronization2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_buffer") and (((((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_buffer_device_address and self.device.VK_EXT_descriptor_indexing) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_descriptor_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_graphics_pipeline_library") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_graphics_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shader_barycentric") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_fragment_shader_barycentric = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_uniform_control_flow") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_uniform_control_flow = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_zero_initialize_workgroup_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_zero_initialize_workgroup_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mesh_shader") and (self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_mesh_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_2plane_444_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_2plane_444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map2") and (self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_EXT_fragment_density_map2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_rotated_copy_commands") and (self.device.VK_KHR_copy_commands2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_rotated_copy_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_workgroup_memory_explicit_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_workgroup_memory_explicit_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_copy_commands2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_copy_commands2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_compression_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_attachment_feedback_loop_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_4444_formats") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_4444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_fault") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_fault = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rgba10x6_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rgba10x6_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3)) {
                self.device.VK_VALVE_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_input_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_input_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_physical_device_drm") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_physical_device_drm = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_address_binding_report") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_EXT_debug_utils)) {
                self.device.VK_EXT_device_address_binding_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitive_topology_list_restart") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_primitive_topology_list_restart = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_format_feature_flags2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_format_feature_flags2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_frame_boundary")) {
                self.device.VK_EXT_frame_boundary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multisampled_render_to_single_sampled") and ((self.device.VK_KHR_create_renderpass2 and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_multisampled_render_to_single_sampled = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_color_write_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_color_write_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitives_generated_query") and (self.device.VK_EXT_transform_feedback)) {
                self.device.VK_EXT_primitives_generated_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_maintenance1") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority_query") and (self.device.VK_EXT_global_priority and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_global_priority_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_view_min_lod") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_view_min_lod = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multi_draw") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_multi_draw = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_2d_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_2d_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_tile_image") and (vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_tile_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_opacity_micromap") and (self.device.VK_KHR_acceleration_structure and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_EXT_opacity_micromap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_load_store_op_none")) {
                self.device.VK_EXT_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_border_color_swizzle") and (self.device.VK_EXT_custom_border_color)) {
                self.device.VK_EXT_border_color_swizzle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pageable_device_local_memory") and (self.device.VK_EXT_memory_priority)) {
                self.device.VK_EXT_pageable_device_local_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance4") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_rotate")) {
                self.device.VK_KHR_shader_subgroup_rotate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_sliced_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_sliced_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_descriptor_set_host_mapping") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_VALVE_descriptor_set_host_mapping = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_non_seamless_cube_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_non_seamless_cube_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_QCOM_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_maximal_reconvergence") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_maximal_reconvergence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control_swapchain") and (self.device.VK_EXT_image_compression_control)) {
                self.device.VK_EXT_image_compression_control_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing") and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_image_processing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_nested_command_buffer") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_nested_command_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_acquire_unmodified") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_acquire_unmodified = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subpass_merge_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subpass_merge_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_module_identifier") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_pipeline_creation_cache_control) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_module_identifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rasterization_order_attachment_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rasterization_order_attachment_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_dithering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_legacy_dithering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_protected_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_protected_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance5") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_maintenance5 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_id2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id2)) {
                self.device.VK_KHR_present_wait2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_position_fetch") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_position_fetch = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_object") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_object = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_binary") and (self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_KHR_pipeline_binary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_maintenance1") and (self.device.VK_KHR_swapchain or self.instance.VK_KHR_surface_maintenance1 or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_KHR_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_viewports") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_multiview_per_view_viewports = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_vertex_attributes") and (self.device.VK_EXT_vertex_input_dynamic_state)) {
                self.device.VK_EXT_legacy_vertex_attributes = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_library_group_handles") and (self.device.VK_KHR_ray_tracing_pipeline and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_pipeline_library_group_handles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_dynamic_rendering_unused_attachments") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_dynamic_rendering_unused_attachments = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_cooperative_matrix") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_cooperative_matrix = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_render_areas")) {
                self.device.VK_QCOM_multiview_per_view_render_areas = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_compute_shader_derivatives") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_compute_shader_derivatives = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_av1") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_av1") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_vp9") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_vp9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance1") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing2") and (self.device.VK_QCOM_image_processing)) {
                self.device.VK_QCOM_image_processing2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_weights") and (self.device.VK_EXT_filter_cubic)) {
                self.device.VK_QCOM_filter_cubic_weights = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_ycbcr_degamma")) {
                self.device.VK_QCOM_ycbcr_degamma = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_clamp") and ((self.device.VK_EXT_filter_cubic) and (vk.VK_API_VERSION_1_2 <= api_version or self.device.VK_EXT_sampler_filter_minmax))) {
                self.device.VK_QCOM_filter_cubic_clamp = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_dynamic_state") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_attachment_feedback_loop_layout)) {
                self.device.VK_EXT_attachment_feedback_loop_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_load_store_op_none")) {
                self.device.VK_KHR_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_unified_image_layouts")) {
                self.device.VK_KHR_unified_image_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls2") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_shader_float_controls2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_expect_assume") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_expect_assume = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance6") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance6 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_memory_heap") and ((self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_memory_heap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_intra_refresh") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_intra_refresh = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_quantization_map") and (self.device.VK_KHR_video_encode_queue and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_quantization_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_relaxed_extended_instruction")) {
                self.device.VK_KHR_shader_relaxed_extended_instruction = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance7") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance7 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_replicated_composites")) {
                self.device.VK_EXT_shader_replicated_composites = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_float8")) {
                self.device.VK_EXT_shader_float8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_generated_commands") and (((self.device.VK_KHR_buffer_device_address or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_maintenance5) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_device_generated_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance8") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance9") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance2") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_metal") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_metal = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_fragment_density_map_layered") and ((self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_VALVE_fragment_density_map_layered = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version) and (vk.VK_API_VERSION_1_3 <= api_version or self.device.VK_KHR_dynamic_rendering))) {
                self.device.VK_EXT_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_zero_initialize_device_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_zero_initialize_device_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        return self;
    }
};

pub fn validate_VkBaseOutStructure(extensions: *const Extensions, item: *const vk.VkBaseOutStructure, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBaseOutStructure: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBaseInStructure(extensions: *const Extensions, item: *const vk.VkBaseInStructure, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBaseInStructure: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOffset2D(extensions: *const Extensions, item: *const vk.VkOffset2D, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkOffset3D(extensions: *const Extensions, item: *const vk.VkOffset3D, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExtent2D(extensions: *const Extensions, item: *const vk.VkExtent2D, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExtent3D(extensions: *const Extensions, item: *const vk.VkExtent3D, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkViewport(extensions: *const Extensions, item: *const vk.VkViewport, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRect2D(extensions: *const Extensions, item: *const vk.VkRect2D, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClearRect(extensions: *const Extensions, item: *const vk.VkClearRect, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkComponentMapping(extensions: *const Extensions, item: *const vk.VkComponentMapping, validate_pnext: bool) bool {
    if (!validate_enum_VkComponentSwizzle(extensions, @ptrCast(&item.r)))
        return false;
    if (!validate_enum_VkComponentSwizzle(extensions, @ptrCast(&item.g)))
        return false;
    if (!validate_enum_VkComponentSwizzle(extensions, @ptrCast(&item.b)))
        return false;
    if (!validate_enum_VkComponentSwizzle(extensions, @ptrCast(&item.a)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkPhysicalDeviceType(extensions, @ptrCast(&item.deviceType)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExtensionProperties(extensions: *const Extensions, item: *const vk.VkExtensionProperties, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkLayerProperties(extensions: *const Extensions, item: *const vk.VkLayerProperties, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkApplicationInfo(extensions: *const Extensions, item: *const vk.VkApplicationInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT,
            => if (!validate_VkApplicationParametersEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkApplicationInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAllocationCallbacks(extensions: *const Extensions, item: *const vk.VkAllocationCallbacks, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceQueueCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDeviceQueueCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
            => if (!validate_VkDeviceQueueGlobalPriorityCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT,
            => if (!validate_VkApplicationParametersEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
            => if (!validate_VkDevicePrivateDataCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            => if (!validate_VkPhysicalDevicePrivateDataFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            => if (!validate_VkPhysicalDeviceVariablePointersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            => if (!validate_VkPhysicalDeviceMultiviewFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceGroupDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentIdFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentId2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentWaitFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentWait2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            => if (!validate_VkPhysicalDevice16BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            => if (!validate_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            => if (!validate_VkPhysicalDeviceProtectedMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            => if (!validate_VkPhysicalDeviceInlineUniformBlockFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            => if (!validate_VkPhysicalDeviceMaintenance4Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
            => if (!validate_VkPhysicalDeviceMaintenance5Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
            => if (!validate_VkPhysicalDeviceMaintenance6Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderDrawParametersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderFloat16Int8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            => if (!validate_VkPhysicalDeviceHostQueryResetFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
            => if (!validate_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            => if (!validate_VkDeviceDeviceMemoryReportCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            => if (!validate_VkPhysicalDeviceDescriptorIndexingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            => if (!validate_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            => if (!validate_VkPhysicalDevice8BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderAtomicInt64Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
            => if (!validate_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            => if (!validate_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            => if (!validate_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            => if (!validate_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            => if (!validate_VkPhysicalDeviceImagelessFramebufferFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            => if (!validate_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR,
            => if (!validate_VkPerformanceQueryReservationInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            => if (!validate_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderClockFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
            => if (!validate_VkPhysicalDeviceIndexTypeUint8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            => if (!validate_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            => if (!validate_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
            => if (!validate_VkPhysicalDeviceLineRasterizationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            => if (!validate_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan11Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan12Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan13Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan14Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO,
            => if (!validate_VkFaultCallbackInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            => if (!validate_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRobustness2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            => if (!validate_VkPhysicalDeviceImageRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            => if (!validate_VkPhysicalDevice4444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            => if (!validate_VkPhysicalDeviceSynchronization2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
            => if (!validate_VkPhysicalDeviceHostImageCopyFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO,
            => if (!validate_VkDeviceObjectReservationCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkanSC10Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
            => if (!validate_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            => if (!validate_VkPhysicalDeviceDynamicRenderingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
            => if (!validate_VkDevicePipelineBinaryInternalCacheControlKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            => if (!validate_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
            => if (!validate_VkPhysicalDevicePipelineRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFaultFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
            => if (!validate_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
            => if (!validate_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
            => if (!validate_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderFloatControls2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
            => if (!validate_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
            => if (!validate_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkInstanceCreateInfo(extensions: *const Extensions, item: *const vk.VkInstanceCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkInstanceCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
            => if (!validate_VkDebugReportCallbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
            => if (!validate_VkValidationFlagsEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
            => if (!validate_VkValidationFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
            => if (!validate_VkLayerSettingsCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            => if (!validate_VkDebugUtilsMessengerCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!validate_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG,
            => if (!validate_VkDirectDriverLoadingListLUNARG(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkInstanceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties, validate_pnext: bool) bool {
    if (!validate_bitmask_VkQueueFlagBits(extensions, @ptrCast(&item.queueFlags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkExportMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            => if (!validate_VkImportMemoryWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            => if (!validate_VkExportMemoryWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
            => if (!validate_VkImportMemoryZirconHandleInfoFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
            => if (!validate_VkImportMemoryFdInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
            => if (!validate_VkImportMemoryMetalHandleInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
            => if (!validate_VkMemoryAllocateFlagsInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
            => if (!validate_VkMemoryDedicatedAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
            => if (!validate_VkImportMemoryHostPointerInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            => if (!validate_VkImportAndroidHardwareBufferInfoANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
            => if (!validate_VkMemoryPriorityAllocateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
            => if (!validate_VkMemoryOpaqueCaptureAddressAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
            => if (!validate_VkImportMemoryBufferCollectionFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!validate_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
            => if (!validate_VkImportMetalBufferInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
            => if (!validate_VkImportScreenBufferInfoQNX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryRequirements(extensions: *const Extensions, item: *const vk.VkMemoryRequirements, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    if (!validate_bitmask_VkSparseImageFormatFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryType(extensions: *const Extensions, item: *const vk.VkMemoryType, validate_pnext: bool) bool {
    if (!validate_bitmask_VkMemoryPropertyFlagBits(extensions, @ptrCast(&item.propertyFlags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryHeap(extensions: *const Extensions, item: *const vk.VkMemoryHeap, validate_pnext: bool) bool {
    if (!validate_bitmask_VkMemoryHeapFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMappedMemoryRange(extensions: *const Extensions, item: *const vk.VkMappedMemoryRange, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMappedMemoryRange: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFormatProperties(extensions: *const Extensions, item: *const vk.VkFormatProperties, validate_pnext: bool) bool {
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.linearTilingFeatures)))
        return false;
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.optimalTilingFeatures)))
        return false;
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.bufferFeatures)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageFormatProperties(extensions: *const Extensions, item: *const vk.VkImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleCounts)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorBufferInfo(extensions: *const Extensions, item: *const vk.VkDescriptorBufferInfo, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorImageInfo(extensions: *const Extensions, item: *const vk.VkDescriptorImageInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkWriteDescriptorSet(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSet, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDescriptorType(extensions, @ptrCast(&item.descriptorType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
            => if (!validate_VkWriteDescriptorSetInlineUniformBlock(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
            => if (!validate_VkWriteDescriptorSetAccelerationStructureKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSet: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyDescriptorSet(extensions: *const Extensions, item: *const vk.VkCopyDescriptorSet, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyDescriptorSet: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferUsageFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2CreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferUsageFlags2CreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferUsageFlags2CreateInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2CreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkBufferCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkBufferUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_enum_VkSharingMode(extensions, @ptrCast(&item.sharingMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!validate_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
            => if (!validate_VkExternalMemoryBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
            => if (!validate_VkBufferOpaqueCaptureAddressCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
            => if (!validate_VkBufferDeviceAddressCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!validate_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!validate_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
            => if (!validate_VkBufferCollectionBufferCreateInfoFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferViewCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferViewCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!validate_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!validate_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferViewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSubresource(extensions: *const Extensions, item: *const vk.VkImageSubresource, validate_pnext: bool) bool {
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageSubresourceLayers(extensions: *const Extensions, item: *const vk.VkImageSubresourceLayers, validate_pnext: bool) bool {
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageSubresourceRange(extensions: *const Extensions, item: *const vk.VkImageSubresourceRange, validate_pnext: bool) bool {
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryBarrier(extensions: *const Extensions, item: *const vk.VkMemoryBarrier, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferMemoryBarrier(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!validate_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!validate_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageMemoryBarrier(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.oldLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.newLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
            => if (!validate_VkSampleLocationsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!validate_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!validate_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkImageType(extensions, @ptrCast(&item.imageType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!validate_enum_VkImageTiling(extensions, @ptrCast(&item.tiling)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_enum_VkSharingMode(extensions, @ptrCast(&item.sharingMode)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.initialLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            => if (!validate_VkExternalMemoryImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkImageSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            => if (!validate_VkImageFormatListCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            => if (!validate_VkImageDrmFormatModifierListCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            => if (!validate_VkImageDrmFormatModifierExplicitCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            => if (!validate_VkImageStencilUsageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!validate_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!validate_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
            => if (!validate_VkBufferCollectionImageCreateInfoFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            => if (!validate_VkImageCompressionControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!validate_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
            => if (!validate_VkImportMetalTextureInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
            => if (!validate_VkImportMetalIOSurfaceInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            => if (!validate_VkExternalFormatQNX(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
            => if (!validate_VkImageAlignmentControlCreateInfoMESA(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubresourceLayout(extensions: *const Extensions, item: *const vk.VkSubresourceLayout, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageViewCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageViewCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkImageViewType(extensions, @ptrCast(&item.viewType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
            => if (!validate_VkImageViewUsageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
            => if (!validate_VkImageViewSlicedCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
            => if (!validate_VkSamplerYcbcrConversionInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            => if (!validate_VkImageViewASTCDecodeModeEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!validate_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            => if (!validate_VkImageViewMinLodCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!validate_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCopy(extensions: *const Extensions, item: *const vk.VkBufferCopy, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseMemoryBind, validate_pnext: bool) bool {
    if (!validate_bitmask_VkSparseMemoryBindFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBind, validate_pnext: bool) bool {
    if (!validate_bitmask_VkSparseMemoryBindFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseBufferMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseBufferMemoryBindInfo, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageOpaqueMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageOpaqueMemoryBindInfo, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBindInfo, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindSparseInfo(extensions: *const Extensions, item: *const vk.VkBindSparseInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
            => if (!validate_VkDeviceGroupBindSparseInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
            => if (!validate_VkTimelineSemaphoreSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!validate_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindSparseInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCopy(extensions: *const Extensions, item: *const vk.VkImageCopy, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageBlit(extensions: *const Extensions, item: *const vk.VkImageBlit, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferImageCopy(extensions: *const Extensions, item: *const vk.VkBufferImageCopy, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageResolve(extensions: *const Extensions, item: *const vk.VkImageResolve, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkShaderModuleCreateInfo(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
            => if (!validate_VkValidationFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            => if (!validate_VkShaderModuleValidationCacheCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutBinding(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBinding, validate_pnext: bool) bool {
    if (!validate_enum_VkDescriptorType(extensions, @ptrCast(&item.descriptorType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorSetLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDescriptorSetLayoutCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            => if (!validate_VkDescriptorSetLayoutBindingFlagsCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
            => if (!validate_VkMutableDescriptorTypeCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorPoolSize(extensions: *const Extensions, item: *const vk.VkDescriptorPoolSize, validate_pnext: bool) bool {
    if (!validate_enum_VkDescriptorType(extensions, @ptrCast(&item.type)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDescriptorPoolCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            => if (!validate_VkDescriptorPoolInlineUniformBlockCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
            => if (!validate_VkMutableDescriptorTypeCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetAllocateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
            => if (!validate_VkDescriptorSetVariableDescriptorCountAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSpecializationMapEntry(extensions: *const Extensions, item: *const vk.VkSpecializationMapEntry, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSpecializationInfo(extensions: *const Extensions, item: *const vk.VkSpecializationInfo, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineShaderStageCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineShaderStageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stage)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            => if (!validate_VkShaderModuleCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            => if (!validate_VkShaderModuleValidationCacheCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            => if (!validate_VkDebugUtilsObjectNameInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
            => if (!validate_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!validate_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkComputePipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkComputePipelineCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
            => if (!validate_VkPipelineCreateFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            => if (!validate_VkPipelineBinaryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            => if (!validate_VkPipelineCreationFeedbackCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
            => if (!validate_VkSubpassShadingPipelineCreateInfoHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!validate_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkComputePipelineCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreateFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2CreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreateFlags2CreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreateFlags2CreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2CreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVertexInputBindingDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription, validate_pnext: bool) bool {
    if (!validate_enum_VkVertexInputRate(extensions, @ptrCast(&item.inputRate)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVertexInputAttributeDescription(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription, validate_pnext: bool) bool {
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineVertexInputStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
            => if (!validate_VkPipelineVertexInputDivisorStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineVertexInputStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineInputAssemblyStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineInputAssemblyStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPrimitiveTopology(extensions, @ptrCast(&item.topology)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineInputAssemblyStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineTessellationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
            => if (!validate_VkPipelineTessellationDomainOriginStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineTessellationStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineViewportStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineViewportStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
            => if (!validate_VkPipelineViewportDepthClipControlCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
            => if (!validate_VkPipelineViewportDepthClampControlCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPolygonMode(extensions, @ptrCast(&item.polygonMode)))
        return false;
    if (!validate_bitmask_VkCullModeFlagBits(extensions, @ptrCast(&item.cullMode)))
        return false;
    if (!validate_enum_VkFrontFace(extensions, @ptrCast(&item.frontFace)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
            => if (!validate_VkPipelineRasterizationConservativeStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
            => if (!validate_VkPipelineRasterizationStateStreamCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
            => if (!validate_VkPipelineRasterizationDepthClipStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationLineStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
            => if (!validate_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
            => if (!validate_VkDepthBiasRepresentationInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineMultisampleStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineMultisampleStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.rasterizationSamples)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
            => if (!validate_VkPipelineSampleLocationsStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineMultisampleStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineColorBlendAttachmentState(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAttachmentState, validate_pnext: bool) bool {
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.srcColorBlendFactor)))
        return false;
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.dstColorBlendFactor)))
        return false;
    if (!validate_enum_VkBlendOp(extensions, @ptrCast(&item.colorBlendOp)))
        return false;
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.srcAlphaBlendFactor)))
        return false;
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.dstAlphaBlendFactor)))
        return false;
    if (!validate_enum_VkBlendOp(extensions, @ptrCast(&item.alphaBlendOp)))
        return false;
    if (!validate_bitmask_VkColorComponentFlagBits(extensions, @ptrCast(&item.colorWriteMask)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineColorBlendStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineColorBlendStateCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkLogicOp(extensions, @ptrCast(&item.logicOp)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
            => if (!validate_VkPipelineColorBlendAdvancedStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
            => if (!validate_VkPipelineColorWriteCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorBlendStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineDynamicStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDynamicStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.dynamicStateCount) |i| {
        if (!validate_enum_VkDynamicState(extensions, @ptrCast(&item.pDynamicStates[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDynamicStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkStencilOpState(extensions: *const Extensions, item: *const vk.VkStencilOpState, validate_pnext: bool) bool {
    if (!validate_enum_VkStencilOp(extensions, @ptrCast(&item.failOp)))
        return false;
    if (!validate_enum_VkStencilOp(extensions, @ptrCast(&item.passOp)))
        return false;
    if (!validate_enum_VkStencilOp(extensions, @ptrCast(&item.depthFailOp)))
        return false;
    if (!validate_enum_VkCompareOp(extensions, @ptrCast(&item.compareOp)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineDepthStencilStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineDepthStencilStateCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkCompareOp(extensions, @ptrCast(&item.depthCompareOp)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDepthStencilStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGraphicsPipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
            => if (!validate_VkPipelineCreateFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            => if (!validate_VkPipelineBinaryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
            => if (!validate_VkPipelineDiscardRectangleStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            => if (!validate_VkPipelineCreationFeedbackCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
            => if (!validate_VkPipelineLibraryCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
            => if (!validate_VkPipelineFragmentShadingRateStateCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
            => if (!validate_VkPipelineRenderingCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
            => if (!validate_VkGraphicsPipelineLibraryCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!validate_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
            => if (!validate_VkRenderingAttachmentLocationInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
            => if (!validate_VkRenderingInputAttachmentIndexInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE,
            => if (!validate_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCacheCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineCacheCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCacheCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCacheHeaderVersionOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionOne, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCacheStageValidationIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheStageValidationIndexEntry, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCacheSafetyCriticalIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheSafetyCriticalIndexEntry, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCacheHeaderVersionSafetyCriticalOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionSafetyCriticalOne, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPushConstantRange(extensions: *const Extensions, item: *const vk.VkPushConstantRange, validate_pnext: bool) bool {
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineBinaryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryHandlesInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryHandlesInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryHandlesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineBinaryKeysAndDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeysAndDataKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineBinaryKeyKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeyKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryKeyKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkReleaseCapturedPipelineDataInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseCapturedPipelineDataInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkReleaseCapturedPipelineDataInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryDataInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryDataInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineLayoutCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineLayoutCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSamplerCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkFilter(extensions, @ptrCast(&item.magFilter)))
        return false;
    if (!validate_enum_VkFilter(extensions, @ptrCast(&item.minFilter)))
        return false;
    if (!validate_enum_VkSamplerMipmapMode(extensions, @ptrCast(&item.mipmapMode)))
        return false;
    if (!validate_enum_VkSamplerAddressMode(extensions, @ptrCast(&item.addressModeU)))
        return false;
    if (!validate_enum_VkSamplerAddressMode(extensions, @ptrCast(&item.addressModeV)))
        return false;
    if (!validate_enum_VkSamplerAddressMode(extensions, @ptrCast(&item.addressModeW)))
        return false;
    if (!validate_enum_VkCompareOp(extensions, @ptrCast(&item.compareOp)))
        return false;
    if (!validate_enum_VkBorderColor(extensions, @ptrCast(&item.borderColor)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
            => if (!validate_VkSamplerYcbcrConversionInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
            => if (!validate_VkSamplerReductionModeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            => if (!validate_VkSamplerCustomBorderColorCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            => if (!validate_VkSamplerBorderColorComponentMappingCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!validate_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkCommandPoolCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO,
            => if (!validate_VkCommandPoolMemoryReservationCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferAllocateInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferAllocateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkCommandBufferLevel(extensions, @ptrCast(&item.level)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkQueryControlFlagBits(extensions, @ptrCast(&item.queryFlags)))
        return false;
    if (!validate_bitmask_VkQueryPipelineStatisticFlagBits(extensions, @ptrCast(&item.pipelineStatistics)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
            => if (!validate_VkCommandBufferInheritanceConditionalRenderingInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
            => if (!validate_VkCommandBufferInheritanceRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
            => if (!validate_VkRenderingAttachmentLocationInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
            => if (!validate_VkRenderingInputAttachmentIndexInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferBeginInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkCommandBufferUsageFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
            => if (!validate_VkDeviceGroupCommandBufferBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassBeginInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkDeviceGroupRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            => if (!validate_VkRenderPassSampleLocationsBeginInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            => if (!validate_VkRenderPassAttachmentBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkClearDepthStencilValue(extensions: *const Extensions, item: *const vk.VkClearDepthStencilValue, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClearAttachment(extensions: *const Extensions, item: *const vk.VkClearAttachment, validate_pnext: bool) bool {
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentDescription(extensions: *const Extensions, item: *const vk.VkAttachmentDescription, validate_pnext: bool) bool {
    if (!validate_bitmask_VkAttachmentDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!validate_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.loadOp)))
        return false;
    if (!validate_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.storeOp)))
        return false;
    if (!validate_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.stencilLoadOp)))
        return false;
    if (!validate_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.stencilStoreOp)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.initialLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.finalLayout)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentReference(extensions: *const Extensions, item: *const vk.VkAttachmentReference, validate_pnext: bool) bool {
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.layout)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassDescription(extensions: *const Extensions, item: *const vk.VkSubpassDescription, validate_pnext: bool) bool {
    if (!validate_bitmask_VkSubpassDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkPipelineBindPoint(extensions, @ptrCast(&item.pipelineBindPoint)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassDependency(extensions: *const Extensions, item: *const vk.VkSubpassDependency, validate_pnext: bool) bool {
    if (!validate_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.srcStageMask)))
        return false;
    if (!validate_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.dstStageMask)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!validate_bitmask_VkDependencyFlagBits(extensions, @ptrCast(&item.dependencyFlags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkRenderPassCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
            => if (!validate_VkRenderPassMultiviewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
            => if (!validate_VkRenderPassInputAttachmentAspectCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            => if (!validate_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
            => if (!validate_VkRenderPassCreationControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            => if (!validate_VkRenderPassCreationFeedbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkEventCreateInfo(extensions: *const Extensions, item: *const vk.VkEventCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkEventCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!validate_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            => if (!validate_VkImportMetalSharedEventInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkEventCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkFenceCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFenceCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
            => if (!validate_VkExportFenceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            => if (!validate_VkExportFenceWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSparseProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseProperties, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceLimits(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLimits, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkExportSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            => if (!validate_VkExportSemaphoreWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
            => if (!validate_VkSemaphoreTypeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!validate_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            => if (!validate_VkImportMetalSharedEventInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkQueryPoolCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkQueryType(extensions, @ptrCast(&item.queryType)))
        return false;
    if (!validate_bitmask_VkQueryPipelineStatisticFlagBits(extensions, @ptrCast(&item.pipelineStatistics)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            => if (!validate_VkQueryPoolPerformanceCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            => if (!validate_VkQueryPoolPerformanceQueryCreateInfoINTEL(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            => if (!validate_VkVideoDecodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeVP9ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
            => if (!validate_VkVideoEncodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
            => if (!validate_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
            => if (!validate_VkVideoEncodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
            => if (!validate_VkVideoEncodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFramebufferCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFramebufferCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
            => if (!validate_VkFramebufferAttachmentsCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrawIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndirectCommand, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDrawIndexedIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndexedIndirectCommand, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDispatchIndirectCommand(extensions: *const Extensions, item: *const vk.VkDispatchIndirectCommand, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMultiDrawInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMultiDrawIndexedInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawIndexedInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubmitInfo(extensions: *const Extensions, item: *const vk.VkSubmitInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.waitSemaphoreCount) |i| {
        if (!validate_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.pWaitDstStageMask[i]))) 
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            => if (!validate_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
            => if (!validate_VkD3D12FenceSubmitInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
            => if (!validate_VkDeviceGroupSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
            => if (!validate_VkProtectedSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
            => if (!validate_VkTimelineSemaphoreSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            => if (!validate_VkPerformanceQuerySubmitInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!validate_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.supportedTransforms)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayPlanePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlanePropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayModeParametersKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeParametersKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayModePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayModePropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayModeCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayModeCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions, @ptrCast(&item.supportedAlpha)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplaySurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.transform)))
        return false;
    if (!validate_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions, @ptrCast(&item.alphaMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplaySurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayPresentInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.supportedTransforms)))
        return false;
    if (!validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.currentTransform)))
        return false;
    if (!validate_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, @ptrCast(&item.supportedCompositeAlpha)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.supportedUsageFlags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAndroidSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAndroidSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkViSurfaceCreateInfoNN(extensions: *const Extensions, item: *const vk.VkViSurfaceCreateInfoNN, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkViSurfaceCreateInfoNN: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWaylandSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWaylandSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWin32SurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32SurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWin32SurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkXlibSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXlibSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkXlibSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkXcbSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXcbSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkXcbSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDirectFBSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDirectFBSurfaceCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectFBSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImagePipeSurfaceCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImagePipeSurfaceCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImagePipeSurfaceCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkScreenSurfaceCreateInfoQNX(extensions: *const Extensions, item: *const vk.VkScreenSurfaceCreateInfoQNX, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenSurfaceCreateInfoQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceFormatKHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormatKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_enum_VkColorSpaceKHR(extensions, @ptrCast(&item.colorSpace)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSwapchainCreateFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.imageFormat)))
        return false;
    if (!validate_enum_VkColorSpaceKHR(extensions, @ptrCast(&item.imageColorSpace)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.imageUsage)))
        return false;
    if (!validate_enum_VkSharingMode(extensions, @ptrCast(&item.imageSharingMode)))
        return false;
    if (!validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.preTransform)))
        return false;
    if (!validate_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, @ptrCast(&item.compositeAlpha)))
        return false;
    if (!validate_enum_VkPresentModeKHR(extensions, @ptrCast(&item.presentMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            => if (!validate_VkSwapchainCounterCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkDeviceGroupSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            => if (!validate_VkImageFormatListCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            => if (!validate_VkSurfaceFullScreenExclusiveInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            => if (!validate_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            => if (!validate_VkImageCompressionControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainPresentModesCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainPresentScalingCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkPresentInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.swapchainCount) |i| {
        if (!validate_enum_VkResult(extensions, @ptrCast(&item.pResults[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
            => if (!validate_VkDisplayPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
            => if (!validate_VkPresentRegionsKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
            => if (!validate_VkDeviceGroupPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PRESENT_ID_KHR,
            => if (!validate_VkPresentIdKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR,
            => if (!validate_VkPresentId2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!validate_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
            => if (!validate_VkSwapchainPresentFenceInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
            => if (!validate_VkSwapchainPresentModeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugReportCallbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugReportCallbackCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDebugReportFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugReportCallbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkValidationFlagsEXT(extensions: *const Extensions, item: *const vk.VkValidationFlagsEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.disabledValidationCheckCount) |i| {
        if (!validate_enum_VkValidationCheckEXT(extensions, @ptrCast(&item.pDisabledValidationChecks[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationFlagsEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkValidationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkValidationFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.enabledValidationFeatureCount) |i| {
        if (!validate_enum_VkValidationFeatureEnableEXT(extensions, @ptrCast(&item.pEnabledValidationFeatures[i])))
            return false;
    }
    for (0..item.disabledValidationFeatureCount) |i| {
        if (!validate_enum_VkValidationFeatureDisableEXT(extensions, @ptrCast(&item.pDisabledValidationFeatures[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLayerSettingsCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingsCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLayerSettingsCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLayerSettingEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkLayerSettingTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkApplicationParametersEXT(extensions: *const Extensions, item: *const vk.VkApplicationParametersEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkApplicationParametersEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugMarkerObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectNameInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDebugReportObjectTypeEXT(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerObjectNameInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugMarkerObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectTagInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDebugReportObjectTypeEXT(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerObjectTagInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugMarkerMarkerInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerMarkerInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerMarkerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDevicePrivateDataCreateInfo(extensions: *const Extensions, item: *const vk.VkDevicePrivateDataCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDevicePrivateDataCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDevicePrivateDataCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDevicePrivateDataCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPrivateDataSlotCreateInfo(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPrivateDataSlotCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPrivateDataSlotCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePrivateDataFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrivateDataFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrivateDataFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePrivateDataFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrivateDataFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMultiDrawPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiDrawPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFeatures2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            => if (!validate_VkPhysicalDevicePrivateDataFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            => if (!validate_VkPhysicalDeviceVariablePointersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            => if (!validate_VkPhysicalDeviceMultiviewFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentIdFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentId2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentWaitFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentWait2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            => if (!validate_VkPhysicalDevice16BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            => if (!validate_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            => if (!validate_VkPhysicalDeviceProtectedMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            => if (!validate_VkPhysicalDeviceInlineUniformBlockFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            => if (!validate_VkPhysicalDeviceMaintenance4Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
            => if (!validate_VkPhysicalDeviceMaintenance5Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
            => if (!validate_VkPhysicalDeviceMaintenance6Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderDrawParametersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderFloat16Int8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            => if (!validate_VkPhysicalDeviceHostQueryResetFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
            => if (!validate_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            => if (!validate_VkPhysicalDeviceDescriptorIndexingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            => if (!validate_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            => if (!validate_VkPhysicalDevice8BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderAtomicInt64Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
            => if (!validate_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            => if (!validate_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            => if (!validate_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            => if (!validate_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            => if (!validate_VkPhysicalDeviceImagelessFramebufferFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            => if (!validate_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            => if (!validate_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderClockFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
            => if (!validate_VkPhysicalDeviceIndexTypeUint8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            => if (!validate_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            => if (!validate_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
            => if (!validate_VkPhysicalDeviceLineRasterizationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            => if (!validate_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan11Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan12Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan13Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkan14Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            => if (!validate_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRobustness2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            => if (!validate_VkPhysicalDeviceImageRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            => if (!validate_VkPhysicalDevice4444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            => if (!validate_VkPhysicalDeviceSynchronization2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
            => if (!validate_VkPhysicalDeviceHostImageCopyFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES,
            => if (!validate_VkPhysicalDeviceVulkanSC10Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
            => if (!validate_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            => if (!validate_VkPhysicalDeviceDynamicRenderingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            => if (!validate_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
            => if (!validate_VkPhysicalDevicePipelineRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFaultFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
            => if (!validate_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
            => if (!validate_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
            => if (!validate_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
            => if (!validate_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
            => if (!validate_VkPhysicalDeviceShaderFloatControls2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
            => if (!validate_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
            => if (!validate_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
            => if (!validate_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
            => if (!validate_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
            => if (!validate_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFeatures2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFeatures2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceMultiDrawPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
            => if (!validate_VkPhysicalDevicePushDescriptorProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            => if (!validate_VkPhysicalDeviceDriverProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
            => if (!validate_VkPhysicalDeviceIDProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            => if (!validate_VkPhysicalDeviceMultiviewProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceDiscardRectanglePropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            => if (!validate_VkPhysicalDeviceSubgroupProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            => if (!validate_VkPhysicalDevicePointClippingProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            => if (!validate_VkPhysicalDeviceProtectedMemoryProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            => if (!validate_VkPhysicalDeviceSamplerFilterMinmaxProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceSampleLocationsPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            => if (!validate_VkPhysicalDeviceInlineUniformBlockProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            => if (!validate_VkPhysicalDeviceMaintenance3Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
            => if (!validate_VkPhysicalDeviceMaintenance4Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
            => if (!validate_VkPhysicalDeviceMaintenance5Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
            => if (!validate_VkPhysicalDeviceMaintenance6Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance7PropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
            => if (!validate_VkPhysicalDeviceLayeredApiPropertiesListKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceMaintenance9PropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            => if (!validate_VkPhysicalDeviceFloatControlsProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            => if (!validate_VkPhysicalDeviceDescriptorIndexingProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            => if (!validate_VkPhysicalDeviceTimelineSemaphoreProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
            => if (!validate_VkPhysicalDeviceVertexAttributeDivisorProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDevicePCIBusInfoPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            => if (!validate_VkPhysicalDeviceDepthStencilResolveProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceTransformFeedbackPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceMeshShaderPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceAccelerationStructurePropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDevicePerformanceQueryPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            => if (!validate_VkPhysicalDeviceTexelBufferAlignmentProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            => if (!validate_VkPhysicalDeviceSubgroupSizeControlProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            => if (!validate_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
            => if (!validate_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
            => if (!validate_VkPhysicalDeviceLineRasterizationProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            => if (!validate_VkPhysicalDeviceVulkan11Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            => if (!validate_VkPhysicalDeviceVulkan12Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
            => if (!validate_VkPhysicalDeviceVulkan13Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES,
            => if (!validate_VkPhysicalDeviceVulkan14Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceCustomBorderColorPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceRobustness2PropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDevicePortabilitySubsetPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
            => if (!validate_VkPhysicalDeviceHostImageCopyProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES,
            => if (!validate_VkPhysicalDeviceVulkanSC10Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceProvokingVertexPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceDescriptorBufferPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            => if (!validate_VkPhysicalDeviceShaderIntegerDotProductProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceDrmPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDevicePipelineBinaryPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceOpacityMicromapPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
            => if (!validate_VkPhysicalDevicePipelineRobustnessProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceShaderObjectPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceShaderTileImagePropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
            => if (!validate_VkPhysicalDeviceLayeredDriverPropertiesMSFT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID,
            => if (!validate_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
            => if (!validate_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE,
            => if (!validate_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProperties2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkFormatProperties2(extensions: *const Extensions, item: *const vk.VkFormatProperties2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            => if (!validate_VkDrmFormatModifierPropertiesListEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT,
            => if (!validate_VkSubpassResolvePerformanceQueryEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
            => if (!validate_VkFormatProperties3(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT,
            => if (!validate_VkDrmFormatModifierPropertiesList2EXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkFormatProperties2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkImageFormatProperties2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            => if (!validate_VkExternalImageFormatProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            => if (!validate_VkSamplerYcbcrConversionImageFormatProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            => if (!validate_VkAndroidHardwareBufferUsageANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            => if (!validate_VkFilterCubicImageViewImageFormatPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
            => if (!validate_VkHostImageCopyDevicePerformanceQuery(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            => if (!validate_VkImageCompressionPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkImageFormatProperties2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageFormatInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_enum_VkImageType(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_enum_VkImageTiling(extensions, @ptrCast(&item.tiling)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            => if (!validate_VkPhysicalDeviceExternalImageFormatInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            => if (!validate_VkImageFormatListCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            => if (!validate_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            => if (!validate_VkImageStencilUsageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            => if (!validate_VkPhysicalDeviceImageViewImageFormatInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!validate_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            => if (!validate_VkImageCompressionControlEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageFormatInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageFormatInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageFormatInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkQueueFamilyProperties2(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR,
            => if (!validate_VkQueueFamilyOwnershipTransferPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
            => if (!validate_VkQueueFamilyGlobalPriorityProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR,
            => if (!validate_VkQueueFamilyVideoPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
            => if (!validate_VkQueueFamilyQueryResultStatusPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyProperties2KHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
            => if (!validate_VkPhysicalDeviceMemoryBudgetPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryProperties2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSparseImageFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSparseImageFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSparseImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_enum_VkImageType(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_enum_VkImageTiling(extensions, @ptrCast(&item.tiling)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSparseImageFormatInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSparseImageFormatInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePushDescriptorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePushDescriptorProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePushDescriptorProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePushDescriptorPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePushDescriptorPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkConformanceVersion(extensions: *const Extensions, item: *const vk.VkConformanceVersion, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkConformanceVersionKHR(extensions: *const Extensions, item: *const vk.VkConformanceVersionKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDriverProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDriverProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDriverId(extensions, @ptrCast(&item.driverID)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDriverProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDriverPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDriverPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPresentRegionsKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionsKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentRegionsKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentRegionKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRectLayerKHR(extensions: *const Extensions, item: *const vk.VkRectLayerKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVariablePointersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointersFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVariablePointersFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVariablePointersFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointersFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVariablePointerFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointerFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVariablePointerFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointerFeatures, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalMemoryProperties(extensions: *const Extensions, item: *const vk.VkExternalMemoryProperties, validate_pnext: bool) bool {
    if (!validate_bitmask_VkExternalMemoryFeatureFlagBits(extensions, @ptrCast(&item.externalMemoryFeatures)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.exportFromImportedHandleTypes)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.compatibleHandleTypes)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalMemoryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceExternalImageFormatInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalImageFormatInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalImageFormatInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalImageFormatInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalImageFormatInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalImageFormatProperties(extensions: *const Extensions, item: *const vk.VkExternalImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalImageFormatProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalImageFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalImageFormatPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceExternalBufferInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalBufferInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkBufferCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkBufferUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!validate_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalBufferInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalBufferInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalBufferInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalBufferProperties(extensions: *const Extensions, item: *const vk.VkExternalBufferProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalBufferProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalBufferPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalBufferPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceIDProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIDProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceIDProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceIDPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIDPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalMemoryImageCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryImageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryImageCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalMemoryBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryBufferCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryBufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryBufferCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryBufferCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExportMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMemoryAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportMemoryWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryZirconHandlePropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryZirconHandlePropertiesFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryZirconHandlePropertiesFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryGetZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryWin32HandlePropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryWin32HandlePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryWin32HandlePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryFdPropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryFdPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryFdPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32KeyedMutexAcquireReleaseInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWin32KeyedMutexAcquireReleaseInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryMetalHandleInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryMetalHandleInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryMetalHandlePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryMetalHandlePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMetalHandlePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryGetMetalHandleInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetMetalHandleInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalSemaphoreInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSemaphoreInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
            => if (!validate_VkSemaphoreTypeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalSemaphoreInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalSemaphoreInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSemaphoreInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.exportFromImportedHandleTypes)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.compatibleHandleTypes)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreFeatureFlagBits(extensions, @ptrCast(&item.externalSemaphoreFeatures)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalSemaphoreProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalSemaphorePropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalSemaphorePropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExportSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkExportSemaphoreCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportSemaphoreCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportSemaphoreCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportSemaphoreCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSemaphoreImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportSemaphoreWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportSemaphoreWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkD3D12FenceSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkD3D12FenceSubmitInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkD3D12FenceSubmitInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportSemaphoreFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSemaphoreImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportSemaphoreZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportSemaphoreZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSemaphoreImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkSemaphoreGetZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalFenceInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFenceInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFenceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalFenceInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFenceInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalFenceProperties(extensions: *const Extensions, item: *const vk.VkExternalFenceProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.exportFromImportedHandleTypes)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.compatibleHandleTypes)))
        return false;
    if (!validate_bitmask_VkExternalFenceFeatureFlagBits(extensions, @ptrCast(&item.externalFenceFeatures)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFenceProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalFencePropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalFencePropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExportFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkExportFenceCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportFenceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportFenceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportFenceCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFenceImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportFenceWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportFenceWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportFenceWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFenceGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportFenceFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFenceImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportFenceFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFenceGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassMultiviewCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassMultiviewCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassMultiviewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassMultiviewCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassMultiviewCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSurfaceCapabilities2EXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2EXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.supportedTransforms)))
        return false;
    if (!validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.currentTransform)))
        return false;
    if (!validate_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, @ptrCast(&item.supportedCompositeAlpha)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.supportedUsageFlags)))
        return false;
    if (!validate_bitmask_VkSurfaceCounterFlagBitsEXT(extensions, @ptrCast(&item.supportedSurfaceCounters)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilities2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPowerInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDisplayPowerStateEXT(extensions, @ptrCast(&item.powerState)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPowerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDeviceEventTypeEXT(extensions, @ptrCast(&item.deviceEvent)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDisplayEventTypeEXT(extensions, @ptrCast(&item.displayEvent)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainCounterCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainCounterCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSurfaceCounterFlagBitsEXT(extensions, @ptrCast(&item.surfaceCounters)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainCounterCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGroupProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGroupProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGroupPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGroupPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryAllocateFlagsInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagsInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkMemoryAllocateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryAllocateFlagsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryAllocateFlagsInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagsInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindBufferMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
            => if (!validate_VkBindBufferMemoryDeviceGroupInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
            => if (!validate_VkBindMemoryStatus(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindBufferMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindBufferMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindBufferMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryDeviceGroupInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindBufferMemoryDeviceGroupInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindBufferMemoryDeviceGroupInfoKHR(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryDeviceGroupInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindImageMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
            => if (!validate_VkBindImageMemoryDeviceGroupInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
            => if (!validate_VkBindImageMemorySwapchainInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
            => if (!validate_VkBindImagePlaneMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
            => if (!validate_VkBindMemoryStatus(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImageMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemoryInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindImageMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryDeviceGroupInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemoryDeviceGroupInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImageMemoryDeviceGroupInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemoryDeviceGroupInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceGroupRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupRenderPassBeginInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupRenderPassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupRenderPassBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupRenderPassBeginInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceGroupCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupCommandBufferBeginInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupCommandBufferBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupCommandBufferBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupCommandBufferBeginInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceGroupSubmitInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupSubmitInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupSubmitInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceGroupBindSparseInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupBindSparseInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupBindSparseInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupBindSparseInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupBindSparseInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceGroupPresentCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, @ptrCast(&item.modes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupPresentCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageSwapchainCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImageMemorySwapchainInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemorySwapchainInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemorySwapchainInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAcquireNextImageInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireNextImageInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAcquireNextImageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupDeviceCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupDeviceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupDeviceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupDeviceCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceGroupSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupSwapchainCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, @ptrCast(&item.modes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorUpdateTemplateEntry(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateEntry, validate_pnext: bool) bool {
    if (!validate_enum_VkDescriptorType(extensions, @ptrCast(&item.descriptorType)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorUpdateTemplateEntryKHR(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateEntryKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorUpdateTemplateCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDescriptorUpdateTemplateType(extensions, @ptrCast(&item.templateType)))
        return false;
    if (!validate_enum_VkPipelineBindPoint(extensions, @ptrCast(&item.pipelineBindPoint)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorUpdateTemplateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorUpdateTemplateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkXYColorEXT(extensions: *const Extensions, item: *const vk.VkXYColorEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePresentIdFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentIdFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentIdFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentIdKHR(extensions: *const Extensions, item: *const vk.VkPresentIdKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentIdKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentId2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentId2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentId2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentId2KHR(extensions: *const Extensions, item: *const vk.VkPresentId2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentId2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentWait2InfoKHR(extensions: *const Extensions, item: *const vk.VkPresentWait2InfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentWait2InfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentWaitFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentWaitFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentWait2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentWait2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHdrMetadataEXT(extensions: *const Extensions, item: *const vk.VkHdrMetadataEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkHdrVividDynamicMetadataHUAWEI(extensions: *const Extensions, item: *const vk.VkHdrVividDynamicMetadataHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHdrVividDynamicMetadataHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkIOSSurfaceCreateInfoMVK, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIOSSurfaceCreateInfoMVK: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMacOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkMacOSSurfaceCreateInfoMVK, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMacOSSurfaceCreateInfoMVK: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMetalSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMetalSurfaceCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMetalSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDiscardRectanglePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDiscardRectanglePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineDiscardRectangleStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDiscardRectangleModeEXT(extensions, @ptrCast(&item.discardRectangleMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDiscardRectangleStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkInputAttachmentAspectReference(extensions: *const Extensions, item: *const vk.VkInputAttachmentAspectReference, validate_pnext: bool) bool {
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkInputAttachmentAspectReferenceKHR(extensions: *const Extensions, item: *const vk.VkInputAttachmentAspectReferenceKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassInputAttachmentAspectCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassInputAttachmentAspectCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassInputAttachmentAspectCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassInputAttachmentAspectCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassInputAttachmentAspectCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSurfaceInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSurfaceInfo2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            => if (!validate_VkSurfaceFullScreenExclusiveInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            => if (!validate_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
            => if (!validate_VkSurfacePresentModeKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSurfaceInfo2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            => if (!validate_VkSharedPresentSurfaceCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
            => if (!validate_VkSurfaceProtectedCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            => if (!validate_VkSurfaceCapabilitiesFullScreenExclusiveEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR,
            => if (!validate_VkSurfaceCapabilitiesPresentId2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR,
            => if (!validate_VkSurfaceCapabilitiesPresentWait2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR,
            => if (!validate_VkSurfacePresentScalingCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
            => if (!validate_VkSurfacePresentModeCompatibilityKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilities2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceFormat2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormat2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            => if (!validate_VkImageCompressionPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFormat2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayProperties2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneProperties2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayModeProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayModeProperties2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayModeProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneInfo2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneInfo2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneInfo2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilities2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneCapabilities2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSharedPresentSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSharedPresentSurfaceCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.sharedPresentSupportedUsageFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSharedPresentSurfaceCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice16BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice16BitStorageFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice16BitStorageFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice16BitStorageFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevice16BitStorageFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedStages)))
        return false;
    if (!validate_bitmask_VkSubgroupFeatureFlagBits(extensions, @ptrCast(&item.supportedOperations)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkBufferMemoryRequirementsInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkBufferMemoryRequirementsInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceBufferMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceBufferMemoryRequirements, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceBufferMemoryRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceBufferMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkDeviceBufferMemoryRequirementsKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageMemoryRequirementsInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
            => if (!validate_VkImagePlaneMemoryRequirementsInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkImageMemoryRequirementsInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageSparseMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageSparseMemoryRequirementsInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSparseMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSparseMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkImageSparseMemoryRequirementsInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceImageMemoryRequirements, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.planeAspect)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceImageMemoryRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceImageMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkDeviceImageMemoryRequirementsKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkMemoryRequirements2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
            => if (!validate_VkMemoryDedicatedRequirements(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryRequirements2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryRequirements2KHR(extensions: *const Extensions, item: *const vk.VkMemoryRequirements2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSparseImageMemoryRequirements2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSparseImageMemoryRequirements2KHR(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePointClippingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePointClippingProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPointClippingBehavior(extensions, @ptrCast(&item.pointClippingBehavior)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePointClippingProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePointClippingPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePointClippingPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryDedicatedRequirements(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedRequirements, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryDedicatedRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryDedicatedRequirementsKHR(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedRequirementsKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryDedicatedAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryDedicatedAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryDedicatedAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageViewUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewUsageCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewUsageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewSlicedCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewSlicedCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewSlicedCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewUsageCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageViewUsageCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineTessellationDomainOriginStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkTessellationDomainOrigin(extensions, @ptrCast(&item.domainOrigin)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineTessellationDomainOriginStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineTessellationDomainOriginStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSamplerYcbcrConversionInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerYcbcrConversionInfoKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSamplerYcbcrConversionCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.ycbcrModel)))
        return false;
    if (!validate_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.ycbcrRange)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.xChromaOffset)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.yChromaOffset)))
        return false;
    if (!validate_enum_VkFilter(extensions, @ptrCast(&item.chromaFilter)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            => if (!validate_VkExternalFormatQNX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerYcbcrConversionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindImagePlaneMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImagePlaneMemoryInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.planeAspect)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImagePlaneMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImagePlaneMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImagePlaneMemoryInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImagePlaneMemoryRequirementsInfo(extensions: *const Extensions, item: *const vk.VkImagePlaneMemoryRequirementsInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.planeAspect)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImagePlaneMemoryRequirementsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImagePlaneMemoryRequirementsInfoKHR(extensions: *const Extensions, item: *const vk.VkImagePlaneMemoryRequirementsInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSamplerYcbcrConversionFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSamplerYcbcrConversionImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionImageFormatProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerYcbcrConversionImageFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionImageFormatPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkConditionalRenderingBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingBeginInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkConditionalRenderingFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkConditionalRenderingBeginInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkProtectedSubmitInfo(extensions: *const Extensions, item: *const vk.VkProtectedSubmitInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkProtectedSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProtectedMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProtectedMemoryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProtectedMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProtectedMemoryProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceQueueInfo2(extensions: *const Extensions, item: *const vk.VkDeviceQueueInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDeviceQueueCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSamplerFilterMinmaxProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSamplerFilterMinmaxProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSampleLocationEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSampleLocationsInfoEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationsInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleLocationsPerPixel)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSampleLocationsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkAttachmentSampleLocationsEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkSubpassSampleLocationsEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassSampleLocationsBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSampleLocationsBeginInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassSampleLocationsBeginInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineSampleLocationsStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineSampleLocationsStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSampleLocationsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleLocationSampleCounts)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSampleLocationsPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMultisamplePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMultisamplePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultisamplePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerReductionModeCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerReductionModeCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkSamplerReductionMode(extensions, @ptrCast(&item.reductionMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerReductionModeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerReductionModeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerReductionModeCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiDrawFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineColorBlendAdvancedStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkBlendOverlapEXT(extensions, @ptrCast(&item.blendOverlap)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorBlendAdvancedStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInlineUniformBlockFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInlineUniformBlockFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceInlineUniformBlockProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInlineUniformBlockProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkWriteDescriptorSetInlineUniformBlock(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetInlineUniformBlock, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetInlineUniformBlock: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteDescriptorSetInlineUniformBlockEXT(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetInlineUniformBlockEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorPoolInlineUniformBlockCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorPoolInlineUniformBlockCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageFormatListCreateInfo(extensions: *const Extensions, item: *const vk.VkImageFormatListCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.viewFormatCount) |i| {
        if (!validate_enum_VkFormat(extensions, @ptrCast(&item.pViewFormats[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatListCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageFormatListCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageFormatListCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationCacheCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShaderModuleValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleValidationCacheCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleValidationCacheCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance3Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance3Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance3Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance3PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance3PropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance4Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance4Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance4FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance4Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance4Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance4PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4PropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance5Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance5Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance5FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance5Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance5Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance5PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5PropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance6Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance6Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance6FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance6Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance6Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance6PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6PropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance7FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance7PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance7PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredApiPropertiesListKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiPropertiesListKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredApiPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPhysicalDeviceLayeredApiKHR(extensions, @ptrCast(&item.layeredAPI)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiVulkanPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance8FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance9FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance9PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDefaultVertexAttributeValueKHR(extensions, @ptrCast(&item.defaultVertexAttributeValue)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance9PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyOwnershipTransferPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyOwnershipTransferPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAreaInfo(extensions: *const Extensions, item: *const vk.VkRenderingAreaInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.colorAttachmentCount) |i| {
        if (!validate_enum_VkFormat(extensions, @ptrCast(&item.pColorAttachmentFormats[i])))
            return false;
    }
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.depthAttachmentFormat)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.stencilAttachmentFormat)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAreaInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAreaInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAreaInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorSetLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutSupport, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
            => if (!validate_VkDescriptorSetVariableDescriptorCountLayoutSupport(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutSupport: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutSupportKHR(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutSupportKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderDrawParametersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderDrawParametersFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderDrawParameterFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDrawParameterFeatures, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloat16Int8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat16Int8Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloat16Int8Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat16Int8FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceFloat16Int8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloat16Int8FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceFloatControlsProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloatControlsProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.denormBehaviorIndependence)))
        return false;
    if (!validate_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.roundingModeIndependence)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFloatControlsProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFloatControlsPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloatControlsPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceHostQueryResetFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostQueryResetFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostQueryResetFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHostQueryResetFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostQueryResetFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkNativeBufferUsage2ANDROID(extensions: *const Extensions, item: *const vk.VkNativeBufferUsage2ANDROID, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkNativeBufferANDROID(extensions: *const Extensions, item: *const vk.VkNativeBufferANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkNativeBufferANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainImageCreateInfoANDROID(extensions: *const Extensions, item: *const vk.VkSwapchainImageCreateInfoANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSwapchainImageUsageFlagBitsANDROID(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainImageCreateInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentationPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentationPropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentationPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceQueueGlobalPriorityCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkQueueGlobalPriority(extensions, @ptrCast(&item.globalPriority)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueGlobalPriorityCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceQueueGlobalPriorityCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceQueueGlobalPriorityCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGlobalPriorityQueryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkQueueFamilyGlobalPriorityProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.priorityCount) |i| {
        if (!validate_enum_VkQueueGlobalPriority(extensions, @ptrCast(&item.priorities[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyGlobalPriorityProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyGlobalPriorityPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkQueueFamilyGlobalPriorityPropertiesEXT(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDebugUtilsObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectNameInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsObjectNameInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectTagInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsObjectTagInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsLabelEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsLabelEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsLabelEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsMessengerCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDebugUtilsMessageSeverityFlagBitsEXT(extensions, @ptrCast(&item.messageSeverity)))
        return false;
    if (!validate_bitmask_VkDebugUtilsMessageTypeFlagBitsEXT(extensions, @ptrCast(&item.messageType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsMessengerCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsMessengerCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCallbackDataEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT,
            => if (!validate_VkDeviceAddressBindingCallbackDataEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsMessengerCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceDeviceMemoryReportCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceDeviceMemoryReportCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceMemoryReportCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportCallbackDataEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDeviceMemoryReportEventTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceMemoryReportCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryHostPointerInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryHostPointerInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryHostPointerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryHostPointerPropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryHostPointerPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryHostPointerPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemoryHostPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceConservativeRasterizationPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCalibratedTimestampInfoKHR(extensions: *const Extensions, item: *const vk.VkCalibratedTimestampInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkTimeDomainKHR(extensions, @ptrCast(&item.timeDomain)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCalibratedTimestampInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCalibratedTimestampInfoEXT(extensions: *const Extensions, item: *const vk.VkCalibratedTimestampInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineRasterizationConservativeStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkConservativeRasterizationModeEXT(extensions, @ptrCast(&item.conservativeRasterizationMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationConservativeStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorIndexingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorIndexingFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorIndexingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorIndexingProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorSetLayoutBindingFlagsCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.bindingCount) |i| {
        if (!validate_bitmask_VkDescriptorBindingFlagBits(extensions, @ptrCast(&item.pBindingFlags[i]))) 
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutBindingFlagsCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorSetVariableDescriptorCountAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetVariableDescriptorCountAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorSetVariableDescriptorCountLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetVariableDescriptorCountLayoutSupport: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentDescription2(extensions: *const Extensions, item: *const vk.VkAttachmentDescription2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkAttachmentDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!validate_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.loadOp)))
        return false;
    if (!validate_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.storeOp)))
        return false;
    if (!validate_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.stencilLoadOp)))
        return false;
    if (!validate_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.stencilStoreOp)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.initialLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.finalLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
            => if (!validate_VkAttachmentDescriptionStencilLayout(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentDescription2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentDescription2KHR(extensions: *const Extensions, item: *const vk.VkAttachmentDescription2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentReference2(extensions: *const Extensions, item: *const vk.VkAttachmentReference2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.layout)))
        return false;
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
            => if (!validate_VkAttachmentReferenceStencilLayout(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentReference2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentReference2KHR(extensions: *const Extensions, item: *const vk.VkAttachmentReference2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassDescription2(extensions: *const Extensions, item: *const vk.VkSubpassDescription2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSubpassDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkPipelineBindPoint(extensions, @ptrCast(&item.pipelineBindPoint)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
            => if (!validate_VkSubpassDescriptionDepthStencilResolve(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            => if (!validate_VkFragmentShadingRateAttachmentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            => if (!validate_VkMultisampledRenderToSingleSampledInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
            => if (!validate_VkRenderPassCreationControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
            => if (!validate_VkRenderPassSubpassFeedbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDescription2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassDescription2KHR(extensions: *const Extensions, item: *const vk.VkSubpassDescription2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassDependency2(extensions: *const Extensions, item: *const vk.VkSubpassDependency2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.srcStageMask)))
        return false;
    if (!validate_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.dstStageMask)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!validate_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!validate_bitmask_VkDependencyFlagBits(extensions, @ptrCast(&item.dependencyFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
            => if (!validate_VkMemoryBarrier2(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!validate_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDependency2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassDependency2KHR(extensions: *const Extensions, item: *const vk.VkSubpassDependency2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassCreateInfo2(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkRenderPassCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            => if (!validate_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
            => if (!validate_VkRenderPassCreationControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            => if (!validate_VkRenderPassCreationFeedbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassCreateInfo2KHR(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassBeginInfo(extensions: *const Extensions, item: *const vk.VkSubpassBeginInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkSubpassContents(extensions, @ptrCast(&item.contents)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkSubpassBeginInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassEndInfo(extensions: *const Extensions, item: *const vk.VkSubpassEndInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
            => if (!validate_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassEndInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassEndInfoKHR(extensions: *const Extensions, item: *const vk.VkSubpassEndInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTimelineSemaphoreFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceTimelineSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTimelineSemaphoreProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTimelineSemaphorePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphorePropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSemaphoreTypeCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreTypeCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkSemaphoreType(extensions, @ptrCast(&item.semaphoreType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreTypeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreTypeCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreTypeCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkTimelineSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkTimelineSemaphoreSubmitInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTimelineSemaphoreSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTimelineSemaphoreSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkTimelineSemaphoreSubmitInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSemaphoreWaitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSemaphoreWaitFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreWaitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreWaitInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSemaphoreSignalInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSignalInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSignalInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreSignalInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreSignalInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVertexInputBindingDivisorDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescription, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVertexInputBindingDivisorDescriptionKHR(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescriptionKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVertexInputBindingDivisorDescriptionEXT(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescriptionEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineVertexInputDivisorStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineVertexInputDivisorStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineVertexInputDivisorStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineVertexInputDivisorStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePCIBusInfoPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePCIBusInfoPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkImportAndroidHardwareBufferInfoANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportAndroidHardwareBufferInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferUsageANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferUsageANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferUsageANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferPropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            => if (!validate_VkAndroidHardwareBufferFormatPropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
            => if (!validate_VkAndroidHardwareBufferFormatProperties2ANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID,
            => if (!validate_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkMemoryGetAndroidHardwareBufferInfoANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetAndroidHardwareBufferInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferFormatPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatPropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.formatFeatures)))
        return false;
    if (!validate_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!validate_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceConditionalRenderingInfoEXT(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceConditionalRenderingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice8BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice8BitStorageFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice8BitStorageFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice8BitStorageFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevice8BitStorageFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceConditionalRenderingFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanMemoryModelFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicInt64Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicInt64Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicInt64Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDepthStencilResolveProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthStencilResolveProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedDepthResolveModes)))
        return false;
    if (!validate_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedStencilResolveModes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthStencilResolveProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthStencilResolvePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthStencilResolvePropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassDescriptionDepthStencilResolve(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionDepthStencilResolve, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.depthResolveMode)))
        return false;
    if (!validate_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.stencilResolveMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDescriptionDepthStencilResolve: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassDescriptionDepthStencilResolveKHR(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionDepthStencilResolveKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageViewASTCDecodeModeEXT(extensions: *const Extensions, item: *const vk.VkImageViewASTCDecodeModeEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.decodeMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewASTCDecodeModeEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceASTCDecodeFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTransformFeedbackFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTransformFeedbackPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTransformFeedbackPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationStateStreamCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateStreamCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMeshShaderPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrawMeshTasksIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawMeshTasksIndirectCommandEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRayTracingShaderGroupCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkRayTracingShaderGroupTypeKHR(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingShaderGroupCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRayTracingPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPipelineCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
            => if (!validate_VkPipelineCreateFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            => if (!validate_VkPipelineBinaryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            => if (!validate_VkPipelineCreationFeedbackCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!validate_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteDescriptorSetAccelerationStructureKHR(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetAccelerationStructureKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetAccelerationStructureKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAccelerationStructureFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPipelineFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayQueryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAccelerationStructurePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAccelerationStructurePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPipelinePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkStridedDeviceAddressRegionKHR(extensions: *const Extensions, item: *const vk.VkStridedDeviceAddressRegionKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkTraceRaysIndirectCommandKHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommandKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkTraceRaysIndirectCommand2KHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommand2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrmFormatModifierPropertiesListEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesListEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDrmFormatModifierPropertiesListEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.drmFormatModifierTilingFeatures)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkSharingMode(extensions, @ptrCast(&item.sharingMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageDrmFormatModifierInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageDrmFormatModifierListCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierListCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierListCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageDrmFormatModifierExplicitCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierExplicitCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageStencilUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageStencilUsageCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.stencilUsage)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageStencilUsageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageStencilUsageCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageStencilUsageCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassFragmentDensityMapCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassFragmentDensityMapOffsetEndInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceScalarBlockLayoutFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSurfaceProtectedCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceProtectedCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceProtectedCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceUniformBufferStandardLayoutFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClipEnableFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationDepthClipStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationDepthClipStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryBudgetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryBudgetPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryPriorityFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryPriorityAllocateInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryPriorityAllocateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryPriorityAllocateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBufferDeviceAddressFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBufferDeviceAddressFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBufferAddressFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferAddressFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferDeviceAddressInfo(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferDeviceAddressInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferDeviceAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferDeviceAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferOpaqueCaptureAddressCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferOpaqueCaptureAddressCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferOpaqueCaptureAddressCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferOpaqueCaptureAddressCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferOpaqueCaptureAddressCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferDeviceAddressCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferDeviceAddressCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageViewImageFormatInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageViewType(extensions, @ptrCast(&item.imageViewType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageViewImageFormatInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFilterCubicImageViewImageFormatPropertiesEXT(extensions: *const Extensions, item: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFilterCubicImageViewImageFormatPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImagelessFramebufferFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImagelessFramebufferFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImagelessFramebufferFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkFramebufferAttachmentsCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentsCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferAttachmentsCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFramebufferAttachmentsCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentsCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkFramebufferAttachmentImageInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentImageInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    for (0..item.viewFormatCount) |i| {
        if (!validate_enum_VkFormat(extensions, @ptrCast(&item.pViewFormats[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferAttachmentImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFramebufferAttachmentImageInfoKHR(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentImageInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassAttachmentBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassAttachmentBeginInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassAttachmentBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassAttachmentBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassAttachmentBeginInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTextureCompressionASTCHDRFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreationFeedback(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedback, validate_pnext: bool) bool {
    if (!validate_bitmask_VkPipelineCreationFeedbackFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCreationFeedbackEXT(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCreationFeedbackCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreationFeedbackCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreationFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSurfaceFullScreenExclusiveInfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFullScreenExclusiveEXT(extensions, @ptrCast(&item.fullScreenExclusive)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFullScreenExclusiveInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveWin32InfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFullScreenExclusiveWin32InfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesFullScreenExclusiveEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesFullScreenExclusiveEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceQueryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePerformanceQueryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceQueryPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceCounterKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPerformanceCounterUnitKHR(extensions, @ptrCast(&item.unit)))
        return false;
    if (!validate_enum_VkPerformanceCounterScopeKHR(extensions, @ptrCast(&item.scope)))
        return false;
    if (!validate_enum_VkPerformanceCounterStorageKHR(extensions, @ptrCast(&item.storage)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceCounterDescriptionKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPerformanceCounterDescriptionFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterDescriptionKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolPerformanceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolPerformanceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAcquireProfilingLockInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkAcquireProfilingLockFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAcquireProfilingLockInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceQuerySubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQuerySubmitInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceQuerySubmitInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceQueryReservationInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQueryReservationInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceQueryReservationInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHeadlessSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkHeadlessSurfaceCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHeadlessSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceValueINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkPerformanceValueTypeINTEL(extensions, @ptrCast(&item.type)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkInitializePerformanceApiInfoINTEL(extensions: *const Extensions, item: *const vk.VkInitializePerformanceApiInfoINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkInitializePerformanceApiInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolPerformanceQueryCreateInfoINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkQueryPoolSamplingModeINTEL(extensions, @ptrCast(&item.performanceCountersSampling)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolPerformanceQueryCreateInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolCreateInfoINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateInfoINTEL, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPerformanceMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceMarkerInfoINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceMarkerInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceStreamMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceStreamMarkerInfoINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceStreamMarkerInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceOverrideInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideInfoINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPerformanceOverrideTypeINTEL(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceOverrideInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceConfigurationAcquireInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationAcquireInfoINTEL, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPerformanceConfigurationTypeINTEL(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceConfigurationAcquireInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderClockFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderClockFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceIndexTypeUint8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceIndexTypeUint8Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceIndexTypeUint8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentReferenceStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentReferenceStencilLayout, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.stencilLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentReferenceStencilLayout: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentReferenceStencilLayoutKHR(extensions: *const Extensions, item: *const vk.VkAttachmentReferenceStencilLayoutKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentDescriptionStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionStencilLayout, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.stencilInitialLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.stencilFinalLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentDescriptionStencilLayout: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentDescriptionStencilLayoutKHR(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionStencilLayoutKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineExecutablePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutablePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stages)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutablePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineExecutableInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineExecutableStatisticKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPipelineExecutableStatisticFormatKHR(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableStatisticKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineExecutableInternalRepresentationKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInternalRepresentationKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableInternalRepresentationKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTexelBufferAlignmentProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTexelBufferAlignmentProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupSizeControlFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupSizeControlProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.requiredSubgroupSizeStages)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupSizeControlProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkShaderRequiredSubgroupSizeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderRequiredSubgroupSizeCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassShadingPipelineCreateInfoHUAWEI(extensions: *const Extensions, item: *const vk.VkSubpassShadingPipelineCreateInfoHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassShadingPipelineCreateInfoHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryOpaqueCaptureAddressAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryOpaqueCaptureAddressAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryOpaqueCaptureAddressAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceMemoryOpaqueCaptureAddressInfo(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceMemoryOpaqueCaptureAddressInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceMemoryOpaqueCaptureAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLineRasterizationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLineRasterizationProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineRasterizationLineStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkLineRasterizationMode(extensions, @ptrCast(&item.lineRasterizationMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationLineStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationLineStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineRasterizationLineStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineCreationCacheControlFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan11Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan11Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan11Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.subgroupSupportedStages)))
        return false;
    if (!validate_bitmask_VkSubgroupFeatureFlagBits(extensions, @ptrCast(&item.subgroupSupportedOperations)))
        return false;
    if (!validate_enum_VkPointClippingBehavior(extensions, @ptrCast(&item.pointClippingBehavior)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan11Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan12Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan12Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan12Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDriverId(extensions, @ptrCast(&item.driverID)))
        return false;
    if (!validate_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.denormBehaviorIndependence)))
        return false;
    if (!validate_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.roundingModeIndependence)))
        return false;
    if (!validate_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedDepthResolveModes)))
        return false;
    if (!validate_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedStencilResolveModes)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.framebufferIntegerColorSampleCounts)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan12Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan13Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan13Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan13Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.requiredSubgroupSizeStages)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan13Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan14Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan14Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan14Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessStorageBuffers)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessUniformBuffers)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessVertexInputs)))
        return false;
    if (!validate_enum_VkPipelineRobustnessImageBehavior(extensions, @ptrCast(&item.defaultRobustnessImages)))
        return false;
    for (0..item.copySrcLayoutCount) |i| {
        if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.pCopySrcLayouts[i])))
            return false;
    }
    for (0..item.copyDstLayoutCount) |i| {
        if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.pCopyDstLayouts[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan14Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFaultData(extensions: *const Extensions, item: *const vk.VkFaultData, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFaultLevel(extensions, @ptrCast(&item.faultLevel)))
        return false;
    if (!validate_enum_VkFaultType(extensions, @ptrCast(&item.faultType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFaultData: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFaultCallbackInfo(extensions: *const Extensions, item: *const vk.VkFaultCallbackInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFaultCallbackInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceToolProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceToolProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkToolPurposeFlagBits(extensions, @ptrCast(&item.purposes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceToolProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceToolPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceToolPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSamplerCustomBorderColorCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCustomBorderColorCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCustomBorderColorCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCustomBorderColorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCustomBorderColorPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCustomBorderColorFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerBorderColorComponentMappingCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerBorderColorComponentMappingCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryTrianglesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.vertexFormat)))
        return false;
    if (!validate_enum_VkIndexType(extensions, @ptrCast(&item.indexType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT,
            => if (!validate_VkAccelerationStructureTrianglesOpacityMicromapEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryTrianglesDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryAabbsDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryAabbsDataKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryAabbsDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryInstancesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryInstancesDataKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryInstancesDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkGeometryTypeKHR(extensions, @ptrCast(&item.geometryType)))
        return false;
    if (!validate_bitmask_VkGeometryFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureBuildGeometryInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildGeometryInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkAccelerationStructureTypeKHR(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkBuildAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureBuildGeometryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureBuildRangeInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildRangeInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkAccelerationStructureCreateFlagBitsKHR(extensions, @ptrCast(&item.createFlags)))
        return false;
    if (!validate_enum_VkAccelerationStructureTypeKHR(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!validate_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAabbPositionsKHR(extensions: *const Extensions, item: *const vk.VkAabbPositionsKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkTransformMatrixKHR(extensions: *const Extensions, item: *const vk.VkTransformMatrixKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureInstanceKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureInstanceKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureDeviceAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureDeviceAddressInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureDeviceAddressInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureVersionInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureVersionInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureVersionInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkCopyAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyAccelerationStructureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyAccelerationStructureToMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkCopyAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyAccelerationStructureToMemoryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMemoryToAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkCopyAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToAccelerationStructureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRayTracingPipelineInterfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineInterfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineLibraryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineLibraryCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineLibraryCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRefreshObjectKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!validate_bitmask_VkRefreshObjectFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRefreshObjectListKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectListKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRefreshObjectListKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState3PropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkColorBlendEquationEXT(extensions: *const Extensions, item: *const vk.VkColorBlendEquationEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.srcColorBlendFactor)))
        return false;
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.dstColorBlendFactor)))
        return false;
    if (!validate_enum_VkBlendOp(extensions, @ptrCast(&item.colorBlendOp)))
        return false;
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.srcAlphaBlendFactor)))
        return false;
    if (!validate_enum_VkBlendFactor(extensions, @ptrCast(&item.dstAlphaBlendFactor)))
        return false;
    if (!validate_enum_VkBlendOp(extensions, @ptrCast(&item.alphaBlendOp)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkColorBlendAdvancedEXT(extensions: *const Extensions, item: *const vk.VkColorBlendAdvancedEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkBlendOp(extensions, @ptrCast(&item.advancedBlendOp)))
        return false;
    if (!validate_enum_VkBlendOverlapEXT(extensions, @ptrCast(&item.blendOverlap)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRobustness2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRobustness2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRobustness2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2FeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceRobustness2PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRobustness2PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRobustness2PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2PropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceImageRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageRobustnessFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageRobustnessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageRobustnessFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePortabilitySubsetFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePortabilitySubsetPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePortabilitySubsetPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice4444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice4444FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCopy2(extensions: *const Extensions, item: *const vk.VkBufferCopy2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCopy2KHR(extensions: *const Extensions, item: *const vk.VkBufferCopy2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageCopy2(extensions: *const Extensions, item: *const vk.VkImageCopy2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCopy2KHR(extensions: *const Extensions, item: *const vk.VkImageCopy2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageBlit2(extensions: *const Extensions, item: *const vk.VkImageBlit2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageBlit2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageBlit2KHR(extensions: *const Extensions, item: *const vk.VkImageBlit2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferImageCopy2(extensions: *const Extensions, item: *const vk.VkBufferImageCopy2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferImageCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferImageCopy2KHR(extensions: *const Extensions, item: *const vk.VkBufferImageCopy2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageResolve2(extensions: *const Extensions, item: *const vk.VkImageResolve2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageResolve2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageResolve2KHR(extensions: *const Extensions, item: *const vk.VkImageResolve2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyBufferInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyBufferInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyBufferInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyImageInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBlitImageInfo2(extensions: *const Extensions, item: *const vk.VkBlitImageInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!validate_enum_VkFilter(extensions, @ptrCast(&item.filter)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBlitImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBlitImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkBlitImageInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyBufferToImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferToImageInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyBufferToImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyBufferToImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyBufferToImageInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyImageToBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageToBufferInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToBufferInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageToBufferInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyImageToBufferInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkResolveImageInfo2(extensions: *const Extensions, item: *const vk.VkResolveImageInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkResolveImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkResolveImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkResolveImageInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateAttachmentInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFragmentShadingRateAttachmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineFragmentShadingRateStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFragmentShadingRateCombinerOpKHR(extensions, @ptrCast(&item.combinerOps)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineFragmentShadingRateStateCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.maxFragmentShadingRateRasterizationSamples)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRatePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRateKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleCounts)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTerminateInvocationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureBuildSizesInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildSizesInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureBuildSizesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMutableDescriptorTypeListEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeListEXT, validate_pnext: bool) bool {
    for (0..item.descriptorTypeCount) |i| {
        if (!validate_enum_VkDescriptorType(extensions, @ptrCast(&item.pDescriptorTypes[i])))
            return false;
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMutableDescriptorTypeListVALVE(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeListVALVE, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMutableDescriptorTypeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMutableDescriptorTypeCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMutableDescriptorTypeCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeCreateInfoVALVE, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClipControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions, @ptrCast(&item.supportedIndirectCommandsInputModes)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedIndirectCommandsShaderStages)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedIndirectCommandsShaderStagesPipelineBinding)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedIndirectCommandsShaderStagesShaderBinding)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsPipelineInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsPipelineInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsShaderInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsShaderInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsMemoryRequirementsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
            => if (!validate_VkGeneratedCommandsPipelineInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
            => if (!validate_VkGeneratedCommandsShaderInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsMemoryRequirementsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetPipelineInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetPipelineInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetShaderLayoutInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetShaderLayoutInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetShaderInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkIndirectExecutionSetInfoTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.shaderStages)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
            => if (!validate_VkGeneratedCommandsPipelineInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
            => if (!validate_VkGeneratedCommandsShaderInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteIndirectExecutionSetPipelineEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetPipelineEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteIndirectExecutionSetPipelineEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteIndirectExecutionSetShaderEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetShaderEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteIndirectExecutionSetShaderEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectCommandsLayoutCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkIndirectCommandsLayoutUsageFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.shaderStages)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!validate_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectCommandsLayoutTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutTokenEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkIndirectCommandsTokenTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutTokenEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrawIndirectCountIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawIndirectCountIndirectCommandEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsVertexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsVertexBufferTokenEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindVertexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindVertexBufferIndirectCommandEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsIndexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsIndexBufferTokenEXT, validate_pnext: bool) bool {
    if (!validate_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions, @ptrCast(&item.mode)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindIndexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindIndexBufferIndirectCommandEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkIndexType(extensions, @ptrCast(&item.indexType)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsPushConstantTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsPushConstantTokenEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsExecutionSetTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsExecutionSetTokenEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkIndirectExecutionSetInfoTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.shaderStages)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineViewportDepthClipControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportDepthClipControlCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClampControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineViewportDepthClampControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDepthClampModeEXT(extensions, @ptrCast(&item.depthClampMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportDepthClampControlCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVertexInputBindingDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription2EXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkVertexInputRate(extensions, @ptrCast(&item.inputRate)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVertexInputBindingDescription2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVertexInputAttributeDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription2EXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVertexInputAttributeDescription2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceColorWriteEnableFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineColorWriteCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorWriteCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorWriteCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkMemoryBarrier2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkMemoryBarrier2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.oldLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.newLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
            => if (!validate_VkSampleLocationsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!validate_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!validate_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!validate_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!validate_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryBarrierAccessFlags3KHR(extensions: *const Extensions, item: *const vk.VkMemoryBarrierAccessFlags3KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrierAccessFlags3KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDependencyInfo(extensions: *const Extensions, item: *const vk.VkDependencyInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDependencyFlagBits(extensions, @ptrCast(&item.dependencyFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDependencyInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDependencyInfoKHR(extensions: *const Extensions, item: *const vk.VkDependencyInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSubmitInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreSubmitInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCommandBufferSubmitInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferSubmitInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkCommandBufferSubmitInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubmitInfo2(extensions: *const Extensions, item: *const vk.VkSubmitInfo2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSubmitFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            => if (!validate_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            => if (!validate_VkPerformanceQuerySubmitInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!validate_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubmitInfo2KHR(extensions: *const Extensions, item: *const vk.VkSubmitInfo2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSynchronization2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSynchronization2Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSynchronization2Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSynchronization2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSynchronization2FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHostImageCopyFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostImageCopyFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHostImageCopyFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceHostImageCopyProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.copySrcLayoutCount) |i| {
        if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.pCopySrcLayouts[i])))
            return false;
    }
    for (0..item.copyDstLayoutCount) |i| {
        if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.pCopyDstLayouts[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostImageCopyProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHostImageCopyPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryToImageCopy(extensions: *const Extensions, item: *const vk.VkMemoryToImageCopy, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryToImageCopy: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryToImageCopyEXT(extensions: *const Extensions, item: *const vk.VkMemoryToImageCopyEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageToMemoryCopy(extensions: *const Extensions, item: *const vk.VkImageToMemoryCopy, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageToMemoryCopy: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageToMemoryCopyEXT(extensions: *const Extensions, item: *const vk.VkImageToMemoryCopyEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyMemoryToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkHostImageCopyFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMemoryToImageInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyImageToMemoryInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToMemoryInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkHostImageCopyFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageToMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyImageToMemoryInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyImageToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToImageInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkHostImageCopyFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageToImageInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyImageToImageInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkHostImageLayoutTransitionInfo(extensions: *const Extensions, item: *const vk.VkHostImageLayoutTransitionInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.oldLayout)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.newLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHostImageLayoutTransitionInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHostImageLayoutTransitionInfoEXT(extensions: *const Extensions, item: *const vk.VkHostImageLayoutTransitionInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubresourceHostMemcpySize(extensions: *const Extensions, item: *const vk.VkSubresourceHostMemcpySize, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubresourceHostMemcpySize: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubresourceHostMemcpySizeEXT(extensions: *const Extensions, item: *const vk.VkSubresourceHostMemcpySizeEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkHostImageCopyDevicePerformanceQuery(extensions: *const Extensions, item: *const vk.VkHostImageCopyDevicePerformanceQuery, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHostImageCopyDevicePerformanceQuery: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHostImageCopyDevicePerformanceQueryEXT(extensions: *const Extensions, item: *const vk.VkHostImageCopyDevicePerformanceQueryEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVulkanSC10Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Properties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanSC10Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelinePoolSize(extensions: *const Extensions, item: *const vk.VkPipelinePoolSize, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelinePoolSize: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceObjectReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceObjectReservationCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceObjectReservationCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandPoolMemoryReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryReservationCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolMemoryReservationCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandPoolMemoryConsumption(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryConsumption, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolMemoryConsumption: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkanSC10Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanSC10Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyDitheringFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesPresentId2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentId2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesPresentId2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesPresentWait2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentWait2KHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesPresentWait2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassResolvePerformanceQueryEXT(extensions: *const Extensions, item: *const vk.VkSubpassResolvePerformanceQueryEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassResolvePerformanceQueryEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMultisampledRenderToSingleSampledInfoEXT(extensions: *const Extensions, item: *const vk.VkMultisampledRenderToSingleSampledInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.rasterizationSamples)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultisampledRenderToSingleSampledInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineProtectedAccessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkQueueFamilyVideoPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyVideoPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions, @ptrCast(&item.videoCodecOperations)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyVideoPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyQueryResultStatusPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyQueryResultStatusPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoProfileListInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileListInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoProfileListInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoFormatInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoFormatInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.imageUsage)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!validate_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoFormatInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.imageCreateFlags)))
        return false;
    if (!validate_enum_VkImageType(extensions, @ptrCast(&item.imageType)))
        return false;
    if (!validate_enum_VkImageTiling(extensions, @ptrCast(&item.imageTiling)))
        return false;
    if (!validate_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.imageUsageFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR,
            => if (!validate_VkVideoFormatQuantizationMapPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR,
            => if (!validate_VkVideoFormatH265QuantizationMapPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR,
            => if (!validate_VkVideoFormatAV1QuantizationMapPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatQuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatQuantizationMapPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatQuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatH265QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatH265QuantizationMapPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions, @ptrCast(&item.compatibleCtbSizes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatH265QuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatAV1QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatAV1QuantizationMapPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions, @ptrCast(&item.compatibleSuperblockSizes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatAV1QuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions, @ptrCast(&item.videoCodecOperation)))
        return false;
    if (!validate_bitmask_VkVideoChromaSubsamplingFlagBitsKHR(extensions, @ptrCast(&item.chromaSubsampling)))
        return false;
    if (!validate_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions, @ptrCast(&item.lumaBitDepth)))
        return false;
    if (!validate_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions, @ptrCast(&item.chromaBitDepth)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            => if (!validate_VkVideoDecodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeVP9ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
            => if (!validate_VkVideoDecodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
            => if (!validate_VkVideoEncodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
            => if (!validate_VkVideoEncodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
            => if (!validate_VkVideoEncodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoCapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeQuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
            => if (!validate_VkVideoDecodeCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR,
            => if (!validate_VkVideoDecodeH264CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR,
            => if (!validate_VkVideoDecodeH265CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR,
            => if (!validate_VkVideoDecodeVP9CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR,
            => if (!validate_VkVideoDecodeAV1CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeH264CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeH265CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeAV1CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR,
            => if (!validate_VkVideoEncodeIntraRefreshCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionMemoryRequirementsKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionMemoryRequirementsKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindVideoSessionMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindVideoSessionMemoryInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindVideoSessionMemoryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoPictureResourceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoPictureResourceInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoPictureResourceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoReferenceSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
            => if (!validate_VkVideoDecodeH264DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR,
            => if (!validate_VkVideoDecodeH265DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,
            => if (!validate_VkVideoDecodeAV1DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
            => if (!validate_VkVideoEncodeH264DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR,
            => if (!validate_VkVideoEncodeH265DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR,
            => if (!validate_VkVideoReferenceIntraRefreshInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoReferenceSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoDecodeCapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoDecodeUsageFlagBitsKHR(extensions, @ptrCast(&item.videoUsageHints)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeUsageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
            => if (!validate_VkVideoInlineQueryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR,
            => if (!validate_VkVideoDecodeH264InlineSessionParametersInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR,
            => if (!validate_VkVideoDecodeH264PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR,
            => if (!validate_VkVideoDecodeH265InlineSessionParametersInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR,
            => if (!validate_VkVideoDecodeH265PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR,
            => if (!validate_VkVideoDecodeVP9PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR,
            => if (!validate_VkVideoDecodeAV1InlineSessionParametersInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR,
            => if (!validate_VkVideoDecodeAV1PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoMaintenance2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoInlineQueryInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoInlineQueryInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoInlineQueryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoDecodeH264PictureLayoutFlagBitsKHR(extensions, @ptrCast(&item.pictureLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264InlineSessionParametersInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265InlineSessionParametersInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoDecodeVP9FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeVP9ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeVP9CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeVP9PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1InlineSessionParametersInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoSessionCreateFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.pictureFormat)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.referencePictureFormat)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeH264SessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeH265SessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1SessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoSessionParametersCreateFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoDecodeH264SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoDecodeH265SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoDecodeAV1SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            => if (!validate_VkVideoEncodeQualityLevelInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeH264SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeH265SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionParametersUpdateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersUpdateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!validate_VkVideoDecodeH264SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!validate_VkVideoDecodeH265SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!validate_VkVideoEncodeH264SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!validate_VkVideoEncodeH265SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersUpdateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeSessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersGetInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR,
            => if (!validate_VkVideoEncodeH264SessionParametersGetInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR,
            => if (!validate_VkVideoEncodeH265SessionParametersGetInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeSessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            => if (!validate_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            => if (!validate_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoBeginCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoBeginCodingInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeRateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeH264RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR,
            => if (!validate_VkVideoEncodeH264GopRemainingFrameInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeH265RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR,
            => if (!validate_VkVideoEncodeH265GopRemainingFrameInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1GopRemainingFrameInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoBeginCodingInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEndCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEndCodingInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEndCodingInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoCodingControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoCodingControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            => if (!validate_VkVideoEncodeQualityLevelInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeRateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeH264RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeH265RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoCodingControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeUsageFlagBitsKHR(extensions, @ptrCast(&item.videoUsageHints)))
        return false;
    if (!validate_bitmask_VkVideoEncodeContentFlagBitsKHR(extensions, @ptrCast(&item.videoContentHints)))
        return false;
    if (!validate_enum_VkVideoEncodeTuningModeKHR(extensions, @ptrCast(&item.tuningMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeUsageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
            => if (!validate_VkVideoInlineQueryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
            => if (!validate_VkVideoEncodeQuantizationMapInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
            => if (!validate_VkVideoEncodeH264PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR,
            => if (!validate_VkVideoEncodeH265PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR,
            => if (!validate_VkVideoEncodeIntraRefreshInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQuantizationMapInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions, @ptrCast(&item.encodeFeedbackFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolVideoEncodeFeedbackCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQualityLevelInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!validate_VkVideoEncodeH264QualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!validate_VkVideoEncodeH265QualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!validate_VkVideoEncodeAV1QualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeRateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, @ptrCast(&item.rateControlMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeRateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!validate_VkVideoEncodeH264RateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!validate_VkVideoEncodeH265RateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!validate_VkVideoEncodeAV1RateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeCapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, @ptrCast(&item.rateControlModes)))
        return false;
    if (!validate_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions, @ptrCast(&item.supportedEncodeFeedbackFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH264CapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH264StdFlagBitsKHR(extensions, @ptrCast(&item.stdSyntaxFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersGetInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersFeedbackInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264NaluSliceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264NaluSliceInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264NaluSliceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QpKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH264FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264FrameSizeKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH264GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264GopRemainingFrameInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH265CapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions, @ptrCast(&item.ctbSizes)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(extensions, @ptrCast(&item.transformBlockSizes)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH265StdFlagBitsKHR(extensions, @ptrCast(&item.stdSyntaxFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersGetInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersFeedbackInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265NaluSliceSegmentInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265NaluSliceSegmentInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265NaluSliceSegmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QpKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH265FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265FrameSizeKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH265GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265GopRemainingFrameInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeAV1CapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions, @ptrCast(&item.superblockSizes)))
        return false;
    if (!validate_bitmask_VkVideoEncodeAV1StdFlagBitsKHR(extensions, @ptrCast(&item.stdSyntaxFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeAV1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkVideoEncodeAV1PredictionModeKHR(extensions, @ptrCast(&item.predictionMode)))
        return false;
    if (!validate_enum_VkVideoEncodeAV1RateControlGroupKHR(extensions, @ptrCast(&item.rateControlGroup)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1QIndexKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QIndexKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeAV1FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1FrameSizeKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeAV1GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1GopRemainingFrameInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProvokingVertexFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProvokingVertexPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProvokingVertexPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkProvokingVertexModeEXT(extensions, @ptrCast(&item.provokingVertexMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeIntraRefreshCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions, @ptrCast(&item.intraRefreshModes)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeIntraRefreshCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions, @ptrCast(&item.intraRefreshMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionIntraRefreshCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeIntraRefreshInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoReferenceIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceIntraRefreshInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoReferenceIntraRefreshInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorAddressInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorAddressInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorBufferBindingInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkBufferUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!validate_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT,
            => if (!validate_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorBufferBindingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorGetInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorGetInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDescriptorType(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorGetInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpaqueCaptureDescriptorDataCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerDotProductFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerDotProductProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerDotProductProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDrmPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDrmPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDrmPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryBufferCollectionFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryBufferCollectionFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryBufferCollectionFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionImageCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionImageCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionImageCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionBufferCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionBufferCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionBufferCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionPropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionPropertiesFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.formatFeatures)))
        return false;
    if (!validate_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!validate_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionPropertiesFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.requiredFormatFeatures)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSysmemColorSpaceFUCHSIA(extensions: *const Extensions, item: *const vk.VkSysmemColorSpaceFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSysmemColorSpaceFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageFormatConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.requiredFormatFeatures)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageConstraintsInfoFlagBitsFUCHSIA(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFormatProperties3(extensions: *const Extensions, item: *const vk.VkFormatProperties3, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFormatProperties3: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFormatProperties3KHR(extensions: *const Extensions, item: *const vk.VkFormatProperties3KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDrmFormatModifierPropertiesList2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesList2EXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDrmFormatModifierPropertiesList2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrmFormatModifierProperties2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierProperties2EXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAndroidHardwareBufferFormatProperties2ANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatProperties2ANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!validate_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatProperties2ANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRenderingCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRenderingCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.colorAttachmentCount) |i| {
        if (!validate_enum_VkFormat(extensions, @ptrCast(&item.pColorAttachmentFormats[i])))
            return false;
    }
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.depthAttachmentFormat)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.stencilAttachmentFormat)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRenderingCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRenderingCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineRenderingCreateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderingInfo(extensions: *const Extensions, item: *const vk.VkRenderingInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkRenderingFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkDeviceGroupRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            => if (!validate_VkMultisampledRenderToSingleSampledInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            => if (!validate_VkRenderingFragmentShadingRateAttachmentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            => if (!validate_VkRenderingFragmentDensityMapAttachmentInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderingEndInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderingEndInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
            => if (!validate_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingEndInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAttachmentInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    if (!validate_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.resolveMode)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.resolveImageLayout)))
        return false;
    if (!validate_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.loadOp)))
        return false;
    if (!validate_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.storeOp)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT,
            => if (!validate_VkAttachmentFeedbackLoopInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderingFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingFragmentShadingRateAttachmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingFragmentDensityMapAttachmentInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingFragmentDensityMapAttachmentInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCommandBufferInheritanceRenderingInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderingInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkRenderingFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    for (0..item.colorAttachmentCount) |i| {
        if (!validate_enum_VkFormat(extensions, @ptrCast(&item.pColorAttachmentFormats[i])))
            return false;
    }
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.depthAttachmentFormat)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.stencilAttachmentFormat)))
        return false;
    if (!validate_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.rasterizationSamples)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceRenderingInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceRenderingInfoKHR(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderingInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewMinLodFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageViewMinLodFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewMinLodCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewMinLodCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewMinLodCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineBinaryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDevicePipelineBinaryInternalCacheControlKHR(extensions: *const Extensions, item: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDevicePipelineBinaryInternalCacheControlKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineBinaryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineBinaryPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGraphicsPipelineLibraryCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkGraphicsPipelineLibraryFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineLibraryCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetBindingReferenceVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetBindingReferenceVALVE, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetBindingReferenceVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutHostMappingInfoVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutHostMappingInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNestedCommandBufferFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNestedCommandBufferPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageModuleIdentifierCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShaderModuleIdentifierEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleIdentifierEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleIdentifierEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCompressionControlEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionControlEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageCompressionFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    for (0..item.compressionControlPlaneCount) |i| {
        if (!validate_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions, @ptrCast(&item.pFixedRateFlags[i]))) 
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCompressionControlEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageCompressionControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCompressionPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageCompressionFlagBitsEXT(extensions, @ptrCast(&item.imageCompressionFlags)))
        return false;
    if (!validate_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions, @ptrCast(&item.imageCompressionFixedRateFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCompressionPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSubresource2(extensions: *const Extensions, item: *const vk.VkImageSubresource2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSubresource2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSubresource2KHR(extensions: *const Extensions, item: *const vk.VkImageSubresource2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageSubresource2EXT(extensions: *const Extensions, item: *const vk.VkImageSubresource2EXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubresourceLayout2(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
            => if (!validate_VkSubresourceHostMemcpySize(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            => if (!validate_VkImageCompressionPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubresourceLayout2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubresourceLayout2KHR(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2KHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubresourceLayout2EXT(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2EXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassCreationControlEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationControlEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreationControlEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassCreationFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassCreationFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreationFeedbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassSubpassFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkSubpassMergeStatusEXT(extensions, @ptrCast(&item.subpassMergeStatus)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassSubpassFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassSubpassFeedbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapBuildInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkMicromapTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_bitmask_VkBuildMicromapFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkBuildMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapBuildInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkMicromapCreateFlagBitsEXT(extensions, @ptrCast(&item.createFlags)))
        return false;
    if (!validate_enum_VkMicromapTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapVersionInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapVersionInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapVersionInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkCopyMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMicromapInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMicromapToMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapToMemoryInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkCopyMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMicromapToMemoryInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMemoryToMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMemoryToMicromapInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkCopyMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToMicromapInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapBuildSizesInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildSizesInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapBuildSizesInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapUsageEXT(extensions: *const Extensions, item: *const vk.VkMicromapUsageEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMicromapTriangleEXT(extensions: *const Extensions, item: *const vk.VkMicromapTriangleEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpacityMicromapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceOpacityMicromapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpacityMicromapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureTrianglesOpacityMicromapEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkIndexType(extensions, @ptrCast(&item.indexType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureTrianglesOpacityMicromapEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelinePropertiesIdentifierEXT(extensions: *const Extensions, item: *const vk.VkPipelinePropertiesIdentifierEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelinePropertiesIdentifierEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelinePropertiesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryAcquireUnmodifiedEXT(extensions: *const Extensions, item: *const vk.VkExternalMemoryAcquireUnmodifiedEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryAcquireUnmodifiedEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalObjectCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkExportMetalObjectTypeFlagBitsEXT(extensions, @ptrCast(&item.exportObjectType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalObjectCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalObjectsInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectsInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT,
            => if (!validate_VkExportMetalDeviceInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
            => if (!validate_VkExportMetalCommandQueueInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT,
            => if (!validate_VkExportMetalBufferInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT,
            => if (!validate_VkExportMetalTextureInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT,
            => if (!validate_VkExportMetalIOSurfaceInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT,
            => if (!validate_VkExportMetalSharedEventInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalObjectsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalDeviceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalDeviceInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalDeviceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalCommandQueueInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalCommandQueueInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalCommandQueueInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalBufferInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalBufferInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalBufferInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalBufferInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalTextureInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.plane)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalTextureInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalTextureInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.plane)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalTextureInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalIOSurfaceInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalIOSurfaceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalIOSurfaceInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalIOSurfaceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalSharedEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalSharedEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalSharedEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalSharedEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineRobustnessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineRobustnessCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessCreateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.storageBuffers)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.uniformBuffers)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.vertexInputs)))
        return false;
    if (!validate_enum_VkPipelineRobustnessImageBehavior(extensions, @ptrCast(&item.images)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRobustnessCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRobustnessCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePipelineRobustnessProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessProperties, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessStorageBuffers)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessUniformBuffers)))
        return false;
    if (!validate_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessVertexInputs)))
        return false;
    if (!validate_enum_VkPipelineRobustnessImageBehavior(extensions, @ptrCast(&item.defaultRobustnessImages)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineRobustnessProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineRobustnessPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessPropertiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentFeedbackLoopInfoEXT(extensions: *const Extensions, item: *const vk.VkAttachmentFeedbackLoopInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentFeedbackLoopInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAddressBindingReportFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceAddressBindingCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingCallbackDataEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkDeviceAddressBindingFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_enum_VkDeviceAddressBindingTypeEXT(extensions, @ptrCast(&item.bindingType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceAddressBindingCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFaultFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFaultFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFaultFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceFaultAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkDeviceFaultAddressTypeEXT(extensions, @ptrCast(&item.addressType)))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceFaultVendorInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceFaultCountsEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultCountsEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceFaultCountsEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceFaultInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceFaultInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionOneEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDepthBiasInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
            => if (!validate_VkDepthBiasRepresentationInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDepthBiasInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDepthBiasRepresentationInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDepthBiasRepresentationEXT(extensions, @ptrCast(&item.depthBiasRepresentation)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDepthBiasRepresentationInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFrameBoundaryEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkFrameBoundaryFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFrameBoundaryEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFrameBoundaryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfacePresentModeKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkPresentModeKHR(extensions, @ptrCast(&item.presentMode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentModeKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfacePresentModeEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSurfacePresentScalingCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentScalingCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPresentScalingFlagBitsKHR(extensions, @ptrCast(&item.supportedPresentScaling)))
        return false;
    if (!validate_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.supportedPresentGravityX)))
        return false;
    if (!validate_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.supportedPresentGravityY)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentScalingCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfacePresentScalingCapabilitiesEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentScalingCapabilitiesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSurfacePresentModeCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeCompatibilityKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.presentModeCount) |i| {
        if (!validate_enum_VkPresentModeKHR(extensions, @ptrCast(&item.pPresentModes[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentModeCompatibilityKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfacePresentModeCompatibilityEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeCompatibilityEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSwapchainPresentFenceInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentFenceInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentFenceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentFenceInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentFenceInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSwapchainPresentModesCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModesCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentModesCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentModesCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModesCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSwapchainPresentModeInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModeInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.swapchainCount) |i| {
        if (!validate_enum_VkPresentModeKHR(extensions, @ptrCast(&item.pPresentModes[i])))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentModeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentModeInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModeInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSwapchainPresentScalingCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentScalingCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkPresentScalingFlagBitsKHR(extensions, @ptrCast(&item.scalingBehavior)))
        return false;
    if (!validate_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.presentGravityX)))
        return false;
    if (!validate_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.presentGravityY)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentScalingCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentScalingCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentScalingCreateInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkReleaseSwapchainImagesInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseSwapchainImagesInfoKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkReleaseSwapchainImagesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkReleaseSwapchainImagesInfoEXT(extensions: *const Extensions, item: *const vk.VkReleaseSwapchainImagesInfoEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthBiasControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDirectDriverLoadingInfoLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingInfoLUNARG, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectDriverLoadingInfoLUNARG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDirectDriverLoadingListLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingListLUNARG, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkDirectDriverLoadingModeLUNARG(extensions, @ptrCast(&item.mode)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectDriverLoadingListLUNARG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceImageSubresourceInfo(extensions: *const Extensions, item: *const vk.VkDeviceImageSubresourceInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceImageSubresourceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceImageSubresourceInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceImageSubresourceInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryMapInfo(extensions: *const Extensions, item: *const vk.VkMemoryMapInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkMemoryMapFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
            => if (!validate_VkMemoryMapPlacedInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMapInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryMapInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryMapInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryUnmapInfo(extensions: *const Extensions, item: *const vk.VkMemoryUnmapInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkMemoryUnmapFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryUnmapInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryUnmapInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryUnmapInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderObjectFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderObjectPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderObjectPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShaderCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderCreateFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stage)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.nextStage)))
        return false;
    if (!validate_enum_VkShaderCodeTypeEXT(extensions, @ptrCast(&item.codeType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
            => if (!validate_VkValidationFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTileImageFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderTileImagePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTileImagePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportScreenBufferInfoQNX(extensions: *const Extensions, item: *const vk.VkImportScreenBufferInfoQNX, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportScreenBufferInfoQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkScreenBufferPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferPropertiesQNX, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX,
            => if (!validate_VkScreenBufferFormatPropertiesQNX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenBufferPropertiesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkScreenBufferFormatPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferFormatPropertiesQNX, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!validate_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.formatFeatures)))
        return false;
    if (!validate_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!validate_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenBufferFormatPropertiesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalFormatQNX(extensions: *const Extensions, item: *const vk.VkExternalFormatQNX, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFormatQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.AType)))
        return false;
    if (!validate_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.BType)))
        return false;
    if (!validate_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.CType)))
        return false;
    if (!validate_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.ResultType)))
        return false;
    if (!validate_enum_VkScopeKHR(extensions, @ptrCast(&item.scope)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCooperativeMatrixPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.cooperativeMatrixSupportedStages)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindMemoryStatus(extensions: *const Extensions, item: *const vk.VkBindMemoryStatus, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkResult(extensions, @ptrCast(&item.pResult)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindMemoryStatus: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindMemoryStatusKHR(extensions: *const Extensions, item: *const vk.VkBindMemoryStatusKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindDescriptorSetsInfo(extensions: *const Extensions, item: *const vk.VkBindDescriptorSetsInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!validate_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorSetsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindDescriptorSetsInfoKHR(extensions: *const Extensions, item: *const vk.VkBindDescriptorSetsInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPushConstantsInfo(extensions: *const Extensions, item: *const vk.VkPushConstantsInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!validate_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushConstantsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPushConstantsInfoKHR(extensions: *const Extensions, item: *const vk.VkPushConstantsInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPushDescriptorSetInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!validate_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPushDescriptorSetInfoKHR(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPushDescriptorSetWithTemplateInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetWithTemplateInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!validate_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetWithTemplateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPushDescriptorSetWithTemplateInfoKHR(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetWithTemplateInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSetDescriptorBufferOffsetsInfoEXT(extensions: *const Extensions, item: *const vk.VkSetDescriptorBufferOffsetsInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!validate_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSetDescriptorBufferOffsetsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(extensions: *const Extensions, item: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!validate_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorBufferEmbeddedSamplersInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredDriverPropertiesMSFT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkLayeredDriverUnderlyingApiMSFT(extensions, @ptrCast(&item.underlyingAPI)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredDriverPropertiesMSFT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFormatResolveFeaturesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.externalFormatResolveChromaOffsetX)))
        return false;
    if (!validate_enum_VkChromaLocation(extensions, @ptrCast(&item.externalFormatResolveChromaOffsetY)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFormatResolvePropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatResolvePropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_enum_VkFormat(extensions, @ptrCast(&item.colorAttachmentFormat)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatResolvePropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupRotateFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderExpectAssumeFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderExpectAssumeFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloatControls2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloatControls2Features, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloatControls2Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloatControls2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloatControls2FeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingLocalReadFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderingAttachmentLocationInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentLocationInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentLocationInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAttachmentLocationInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentLocationInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderingInputAttachmentIndexInfo(extensions: *const Extensions, item: *const vk.VkRenderingInputAttachmentIndexInfo, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingInputAttachmentIndexInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingInputAttachmentIndexInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingInputAttachmentIndexInfoKHR, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderQuadControlFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMapMemoryPlacedFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMapMemoryPlacedPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryMapPlacedInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryMapPlacedInfoEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMapPlacedInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderBfloat16FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageAlignmentControlFeaturesMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageAlignmentControlPropertiesMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageAlignmentControlCreateInfoMESA(extensions: *const Extensions, item: *const vk.VkImageAlignmentControlCreateInfoMESA, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageAlignmentControlCreateInfoMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDepthClampRangeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampRangeEXT, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHdrVividFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHdrVividFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClampZeroOneFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineFragmentDensityMapLayeredCreateInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloat8FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOHSurfaceCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkOHSurfaceCreateInfoOHOS, validate_pnext: bool) bool {
    if (!validate_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOHSurfaceCreateInfoOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkSurfaceCreateInfoOHOS, validate_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = validate_pnext;
    return true;
}

pub fn validate_enum_VkImageLayout(extensions: *const Extensions, item: *const vk.VkImageLayout) bool {
    const min = @min(
        vk.VK_IMAGE_LAYOUT_UNDEFINED,
        vk.VK_IMAGE_LAYOUT_GENERAL,
        vk.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_PREINITIALIZED,
    );
    const max = @max(
        vk.VK_IMAGE_LAYOUT_UNDEFINED,
        vk.VK_IMAGE_LAYOUT_GENERAL,
        vk.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_PREINITIALIZED,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == vk.VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == vk.VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkAttachmentLoadOp(extensions: *const Extensions, item: *const vk.VkAttachmentLoadOp) bool {
    const min = @min(
        vk.VK_ATTACHMENT_LOAD_OP_LOAD,
        vk.VK_ATTACHMENT_LOAD_OP_CLEAR,
        vk.VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    );
    const max = @max(
        vk.VK_ATTACHMENT_LOAD_OP_LOAD,
        vk.VK_ATTACHMENT_LOAD_OP_CLEAR,
        vk.VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_load_store_op_none and item.* == vk.VK_ATTACHMENT_LOAD_OP_NONE_EXT)
        return true;
    if (extensions.device.VK_KHR_load_store_op_none and item.* == vk.VK_ATTACHMENT_LOAD_OP_NONE_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkAttachmentStoreOp(extensions: *const Extensions, item: *const vk.VkAttachmentStoreOp) bool {
    const min = @min(
        vk.VK_ATTACHMENT_STORE_OP_STORE,
        vk.VK_ATTACHMENT_STORE_OP_DONT_CARE,
    );
    const max = @max(
        vk.VK_ATTACHMENT_STORE_OP_STORE,
        vk.VK_ATTACHMENT_STORE_OP_DONT_CARE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_KHR)
        return true;
    if (extensions.device.VK_QCOM_render_pass_store_ops and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_QCOM)
        return true;
    if (extensions.device.VK_EXT_load_store_op_none and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_EXT)
        return true;
    if (extensions.device.VK_KHR_load_store_op_none and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkImageType(extensions: *const Extensions, item: *const vk.VkImageType) bool {
    const min = @min(
        vk.VK_IMAGE_TYPE_1D,
        vk.VK_IMAGE_TYPE_2D,
        vk.VK_IMAGE_TYPE_3D,
    );
    const max = @max(
        vk.VK_IMAGE_TYPE_1D,
        vk.VK_IMAGE_TYPE_2D,
        vk.VK_IMAGE_TYPE_3D,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkImageTiling(extensions: *const Extensions, item: *const vk.VkImageTiling) bool {
    const min = @min(
        vk.VK_IMAGE_TILING_OPTIMAL,
        vk.VK_IMAGE_TILING_LINEAR,
    );
    const max = @max(
        vk.VK_IMAGE_TILING_OPTIMAL,
        vk.VK_IMAGE_TILING_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkImageViewType(extensions: *const Extensions, item: *const vk.VkImageViewType) bool {
    const min = @min(
        vk.VK_IMAGE_VIEW_TYPE_1D,
        vk.VK_IMAGE_VIEW_TYPE_2D,
        vk.VK_IMAGE_VIEW_TYPE_3D,
        vk.VK_IMAGE_VIEW_TYPE_CUBE,
        vk.VK_IMAGE_VIEW_TYPE_1D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_2D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    );
    const max = @max(
        vk.VK_IMAGE_VIEW_TYPE_1D,
        vk.VK_IMAGE_VIEW_TYPE_2D,
        vk.VK_IMAGE_VIEW_TYPE_3D,
        vk.VK_IMAGE_VIEW_TYPE_CUBE,
        vk.VK_IMAGE_VIEW_TYPE_1D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_2D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkCommandBufferLevel(extensions: *const Extensions, item: *const vk.VkCommandBufferLevel) bool {
    const min = @min(
        vk.VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        vk.VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    );
    const max = @max(
        vk.VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        vk.VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkComponentSwizzle(extensions: *const Extensions, item: *const vk.VkComponentSwizzle) bool {
    const min = @min(
        vk.VK_COMPONENT_SWIZZLE_IDENTITY,
        vk.VK_COMPONENT_SWIZZLE_ZERO,
        vk.VK_COMPONENT_SWIZZLE_ONE,
        vk.VK_COMPONENT_SWIZZLE_R,
        vk.VK_COMPONENT_SWIZZLE_G,
        vk.VK_COMPONENT_SWIZZLE_B,
        vk.VK_COMPONENT_SWIZZLE_A,
    );
    const max = @max(
        vk.VK_COMPONENT_SWIZZLE_IDENTITY,
        vk.VK_COMPONENT_SWIZZLE_ZERO,
        vk.VK_COMPONENT_SWIZZLE_ONE,
        vk.VK_COMPONENT_SWIZZLE_R,
        vk.VK_COMPONENT_SWIZZLE_G,
        vk.VK_COMPONENT_SWIZZLE_B,
        vk.VK_COMPONENT_SWIZZLE_A,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDescriptorType(extensions: *const Extensions, item: *const vk.VkDescriptorType) bool {
    const min = @min(
        vk.VK_DESCRIPTOR_TYPE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    );
    const max = @max(
        vk.VK_DESCRIPTOR_TYPE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_DESCRIPTOR_TYPE_MUTABLE_VALVE)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_DESCRIPTOR_TYPE_MUTABLE_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkQueryType(extensions: *const Extensions, item: *const vk.VkQueryType) bool {
    const min = @min(
        vk.VK_QUERY_TYPE_OCCLUSION,
        vk.VK_QUERY_TYPE_PIPELINE_STATISTICS,
        vk.VK_QUERY_TYPE_TIMESTAMP,
    );
    const max = @max(
        vk.VK_QUERY_TYPE_OCCLUSION,
        vk.VK_QUERY_TYPE_PIPELINE_STATISTICS,
        vk.VK_QUERY_TYPE_TIMESTAMP,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == vk.VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkBorderColor(extensions: *const Extensions, item: *const vk.VkBorderColor) bool {
    const min = @min(
        vk.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_INT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
        vk.VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    );
    const max = @max(
        vk.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_INT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
        vk.VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_BORDER_COLOR_FLOAT_CUSTOM_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_BORDER_COLOR_INT_CUSTOM_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkPipelineBindPoint(extensions: *const Extensions, item: *const vk.VkPipelineBindPoint) bool {
    const min = @min(
        vk.VK_PIPELINE_BIND_POINT_GRAPHICS,
        vk.VK_PIPELINE_BIND_POINT_COMPUTE,
    );
    const max = @max(
        vk.VK_PIPELINE_BIND_POINT_GRAPHICS,
        vk.VK_PIPELINE_BIND_POINT_COMPUTE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkPipelineCacheHeaderVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersion) bool {
    const min = vk.VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
    const max = vk.VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkPipelineCacheCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance8)
        valid_bits |= vk.VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPrimitiveTopology(extensions: *const Extensions, item: *const vk.VkPrimitiveTopology) bool {
    const min = @min(
        vk.VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    );
    const max = @max(
        vk.VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkSharingMode(extensions: *const Extensions, item: *const vk.VkSharingMode) bool {
    const min = @min(
        vk.VK_SHARING_MODE_EXCLUSIVE,
        vk.VK_SHARING_MODE_CONCURRENT,
    );
    const max = @max(
        vk.VK_SHARING_MODE_EXCLUSIVE,
        vk.VK_SHARING_MODE_CONCURRENT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkIndexType(extensions: *const Extensions, item: *const vk.VkIndexType) bool {
    const min = @min(
        vk.VK_INDEX_TYPE_UINT16,
        vk.VK_INDEX_TYPE_UINT32,
    );
    const max = @max(
        vk.VK_INDEX_TYPE_UINT16,
        vk.VK_INDEX_TYPE_UINT32,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_INDEX_TYPE_NONE_KHR)
        return true;
    if (extensions.device.VK_EXT_index_type_uint8 and item.* == vk.VK_INDEX_TYPE_UINT8_EXT)
        return true;
    if (extensions.device.VK_KHR_index_type_uint8 and item.* == vk.VK_INDEX_TYPE_UINT8_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkFilter(extensions: *const Extensions, item: *const vk.VkFilter) bool {
    const min = @min(
        vk.VK_FILTER_NEAREST,
        vk.VK_FILTER_LINEAR,
    );
    const max = @max(
        vk.VK_FILTER_NEAREST,
        vk.VK_FILTER_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_IMG_filter_cubic and item.* == vk.VK_FILTER_CUBIC_IMG)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_FILTER_CUBIC_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkSamplerMipmapMode(extensions: *const Extensions, item: *const vk.VkSamplerMipmapMode) bool {
    const min = @min(
        vk.VK_SAMPLER_MIPMAP_MODE_NEAREST,
        vk.VK_SAMPLER_MIPMAP_MODE_LINEAR,
    );
    const max = @max(
        vk.VK_SAMPLER_MIPMAP_MODE_NEAREST,
        vk.VK_SAMPLER_MIPMAP_MODE_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkSamplerAddressMode(extensions: *const Extensions, item: *const vk.VkSamplerAddressMode) bool {
    const min = @min(
        vk.VK_SAMPLER_ADDRESS_MODE_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    );
    const max = @max(
        vk.VK_SAMPLER_ADDRESS_MODE_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkCompareOp(extensions: *const Extensions, item: *const vk.VkCompareOp) bool {
    const min = @min(
        vk.VK_COMPARE_OP_NEVER,
        vk.VK_COMPARE_OP_LESS,
        vk.VK_COMPARE_OP_EQUAL,
        vk.VK_COMPARE_OP_LESS_OR_EQUAL,
        vk.VK_COMPARE_OP_GREATER,
        vk.VK_COMPARE_OP_NOT_EQUAL,
        vk.VK_COMPARE_OP_GREATER_OR_EQUAL,
        vk.VK_COMPARE_OP_ALWAYS,
    );
    const max = @max(
        vk.VK_COMPARE_OP_NEVER,
        vk.VK_COMPARE_OP_LESS,
        vk.VK_COMPARE_OP_EQUAL,
        vk.VK_COMPARE_OP_LESS_OR_EQUAL,
        vk.VK_COMPARE_OP_GREATER,
        vk.VK_COMPARE_OP_NOT_EQUAL,
        vk.VK_COMPARE_OP_GREATER_OR_EQUAL,
        vk.VK_COMPARE_OP_ALWAYS,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPolygonMode(extensions: *const Extensions, item: *const vk.VkPolygonMode) bool {
    const min = @min(
        vk.VK_POLYGON_MODE_FILL,
        vk.VK_POLYGON_MODE_LINE,
        vk.VK_POLYGON_MODE_POINT,
    );
    const max = @max(
        vk.VK_POLYGON_MODE_FILL,
        vk.VK_POLYGON_MODE_LINE,
        vk.VK_POLYGON_MODE_POINT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkFrontFace(extensions: *const Extensions, item: *const vk.VkFrontFace) bool {
    const min = @min(
        vk.VK_FRONT_FACE_COUNTER_CLOCKWISE,
        vk.VK_FRONT_FACE_CLOCKWISE,
    );
    const max = @max(
        vk.VK_FRONT_FACE_COUNTER_CLOCKWISE,
        vk.VK_FRONT_FACE_CLOCKWISE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkBlendFactor(extensions: *const Extensions, item: *const vk.VkBlendFactor) bool {
    const min = @min(
        vk.VK_BLEND_FACTOR_ZERO,
        vk.VK_BLEND_FACTOR_ONE,
        vk.VK_BLEND_FACTOR_SRC_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
        vk.VK_BLEND_FACTOR_DST_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
        vk.VK_BLEND_FACTOR_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_DST_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
        vk.VK_BLEND_FACTOR_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
        vk.VK_BLEND_FACTOR_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_SRC1_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    );
    const max = @max(
        vk.VK_BLEND_FACTOR_ZERO,
        vk.VK_BLEND_FACTOR_ONE,
        vk.VK_BLEND_FACTOR_SRC_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
        vk.VK_BLEND_FACTOR_DST_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
        vk.VK_BLEND_FACTOR_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_DST_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
        vk.VK_BLEND_FACTOR_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
        vk.VK_BLEND_FACTOR_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_SRC1_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkBlendOp(extensions: *const Extensions, item: *const vk.VkBlendOp) bool {
    const min = @min(
        vk.VK_BLEND_OP_ADD,
        vk.VK_BLEND_OP_SUBTRACT,
        vk.VK_BLEND_OP_REVERSE_SUBTRACT,
        vk.VK_BLEND_OP_MIN,
        vk.VK_BLEND_OP_MAX,
    );
    const max = @max(
        vk.VK_BLEND_OP_ADD,
        vk.VK_BLEND_OP_SUBTRACT,
        vk.VK_BLEND_OP_REVERSE_SUBTRACT,
        vk.VK_BLEND_OP_MIN,
        vk.VK_BLEND_OP_MAX,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_ZERO_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_XOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MULTIPLY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SCREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_OVERLAY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DARKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LIGHTEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_COLORDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_COLORBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HARDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SOFTLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DIFFERENCE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_EXCLUSION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_RGB_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_VIVIDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PINLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HARDMIX_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_HUE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_SATURATION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_COLOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_LUMINOSITY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_DARKER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MINUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MINUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_CONTRAST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_OVG_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_RED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_GREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_BLUE_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkStencilOp(extensions: *const Extensions, item: *const vk.VkStencilOp) bool {
    const min = @min(
        vk.VK_STENCIL_OP_KEEP,
        vk.VK_STENCIL_OP_ZERO,
        vk.VK_STENCIL_OP_REPLACE,
        vk.VK_STENCIL_OP_INCREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_DECREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_INVERT,
        vk.VK_STENCIL_OP_INCREMENT_AND_WRAP,
        vk.VK_STENCIL_OP_DECREMENT_AND_WRAP,
    );
    const max = @max(
        vk.VK_STENCIL_OP_KEEP,
        vk.VK_STENCIL_OP_ZERO,
        vk.VK_STENCIL_OP_REPLACE,
        vk.VK_STENCIL_OP_INCREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_DECREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_INVERT,
        vk.VK_STENCIL_OP_INCREMENT_AND_WRAP,
        vk.VK_STENCIL_OP_DECREMENT_AND_WRAP,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkLogicOp(extensions: *const Extensions, item: *const vk.VkLogicOp) bool {
    const min = @min(
        vk.VK_LOGIC_OP_CLEAR,
        vk.VK_LOGIC_OP_AND,
        vk.VK_LOGIC_OP_AND_REVERSE,
        vk.VK_LOGIC_OP_COPY,
        vk.VK_LOGIC_OP_AND_INVERTED,
        vk.VK_LOGIC_OP_NO_OP,
        vk.VK_LOGIC_OP_XOR,
        vk.VK_LOGIC_OP_OR,
        vk.VK_LOGIC_OP_NOR,
        vk.VK_LOGIC_OP_EQUIVALENT,
        vk.VK_LOGIC_OP_INVERT,
        vk.VK_LOGIC_OP_OR_REVERSE,
        vk.VK_LOGIC_OP_COPY_INVERTED,
        vk.VK_LOGIC_OP_OR_INVERTED,
        vk.VK_LOGIC_OP_NAND,
        vk.VK_LOGIC_OP_SET,
    );
    const max = @max(
        vk.VK_LOGIC_OP_CLEAR,
        vk.VK_LOGIC_OP_AND,
        vk.VK_LOGIC_OP_AND_REVERSE,
        vk.VK_LOGIC_OP_COPY,
        vk.VK_LOGIC_OP_AND_INVERTED,
        vk.VK_LOGIC_OP_NO_OP,
        vk.VK_LOGIC_OP_XOR,
        vk.VK_LOGIC_OP_OR,
        vk.VK_LOGIC_OP_NOR,
        vk.VK_LOGIC_OP_EQUIVALENT,
        vk.VK_LOGIC_OP_INVERT,
        vk.VK_LOGIC_OP_OR_REVERSE,
        vk.VK_LOGIC_OP_COPY_INVERTED,
        vk.VK_LOGIC_OP_OR_INVERTED,
        vk.VK_LOGIC_OP_NAND,
        vk.VK_LOGIC_OP_SET,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkInternalAllocationType(extensions: *const Extensions, item: *const vk.VkInternalAllocationType) bool {
    const min = vk.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
    const max = vk.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkSystemAllocationScope(extensions: *const Extensions, item: *const vk.VkSystemAllocationScope) bool {
    const min = @min(
        vk.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    );
    const max = @max(
        vk.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPhysicalDeviceType(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceType) bool {
    const min = @min(
        vk.VK_PHYSICAL_DEVICE_TYPE_OTHER,
        vk.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_CPU,
    );
    const max = @max(
        vk.VK_PHYSICAL_DEVICE_TYPE_OTHER,
        vk.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_CPU,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkVertexInputRate(extensions: *const Extensions, item: *const vk.VkVertexInputRate) bool {
    const min = @min(
        vk.VK_VERTEX_INPUT_RATE_VERTEX,
        vk.VK_VERTEX_INPUT_RATE_INSTANCE,
    );
    const max = @max(
        vk.VK_VERTEX_INPUT_RATE_VERTEX,
        vk.VK_VERTEX_INPUT_RATE_INSTANCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkFormat(extensions: *const Extensions, item: *const vk.VkFormat) bool {
    const min = @min(
        vk.VK_FORMAT_UNDEFINED,
        vk.VK_FORMAT_R4G4_UNORM_PACK8,
        vk.VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        vk.VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        vk.VK_FORMAT_R5G6B5_UNORM_PACK16,
        vk.VK_FORMAT_B5G6R5_UNORM_PACK16,
        vk.VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        vk.VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        vk.VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        vk.VK_FORMAT_R8_UNORM,
        vk.VK_FORMAT_R8_SNORM,
        vk.VK_FORMAT_R8_USCALED,
        vk.VK_FORMAT_R8_SSCALED,
        vk.VK_FORMAT_R8_UINT,
        vk.VK_FORMAT_R8_SINT,
        vk.VK_FORMAT_R8_SRGB,
        vk.VK_FORMAT_R8G8_UNORM,
        vk.VK_FORMAT_R8G8_SNORM,
        vk.VK_FORMAT_R8G8_USCALED,
        vk.VK_FORMAT_R8G8_SSCALED,
        vk.VK_FORMAT_R8G8_UINT,
        vk.VK_FORMAT_R8G8_SINT,
        vk.VK_FORMAT_R8G8_SRGB,
        vk.VK_FORMAT_R8G8B8_UNORM,
        vk.VK_FORMAT_R8G8B8_SNORM,
        vk.VK_FORMAT_R8G8B8_USCALED,
        vk.VK_FORMAT_R8G8B8_SSCALED,
        vk.VK_FORMAT_R8G8B8_UINT,
        vk.VK_FORMAT_R8G8B8_SINT,
        vk.VK_FORMAT_R8G8B8_SRGB,
        vk.VK_FORMAT_B8G8R8_UNORM,
        vk.VK_FORMAT_B8G8R8_SNORM,
        vk.VK_FORMAT_B8G8R8_USCALED,
        vk.VK_FORMAT_B8G8R8_SSCALED,
        vk.VK_FORMAT_B8G8R8_UINT,
        vk.VK_FORMAT_B8G8R8_SINT,
        vk.VK_FORMAT_B8G8R8_SRGB,
        vk.VK_FORMAT_R8G8B8A8_UNORM,
        vk.VK_FORMAT_R8G8B8A8_SNORM,
        vk.VK_FORMAT_R8G8B8A8_USCALED,
        vk.VK_FORMAT_R8G8B8A8_SSCALED,
        vk.VK_FORMAT_R8G8B8A8_UINT,
        vk.VK_FORMAT_R8G8B8A8_SINT,
        vk.VK_FORMAT_R8G8B8A8_SRGB,
        vk.VK_FORMAT_B8G8R8A8_UNORM,
        vk.VK_FORMAT_B8G8R8A8_SNORM,
        vk.VK_FORMAT_B8G8R8A8_USCALED,
        vk.VK_FORMAT_B8G8R8A8_SSCALED,
        vk.VK_FORMAT_B8G8R8A8_UINT,
        vk.VK_FORMAT_B8G8R8A8_SINT,
        vk.VK_FORMAT_B8G8R8A8_SRGB,
        vk.VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_UINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UINT_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SINT_PACK32,
        vk.VK_FORMAT_R16_UNORM,
        vk.VK_FORMAT_R16_SNORM,
        vk.VK_FORMAT_R16_USCALED,
        vk.VK_FORMAT_R16_SSCALED,
        vk.VK_FORMAT_R16_UINT,
        vk.VK_FORMAT_R16_SINT,
        vk.VK_FORMAT_R16_SFLOAT,
        vk.VK_FORMAT_R16G16_UNORM,
        vk.VK_FORMAT_R16G16_SNORM,
        vk.VK_FORMAT_R16G16_USCALED,
        vk.VK_FORMAT_R16G16_SSCALED,
        vk.VK_FORMAT_R16G16_UINT,
        vk.VK_FORMAT_R16G16_SINT,
        vk.VK_FORMAT_R16G16_SFLOAT,
        vk.VK_FORMAT_R16G16B16_UNORM,
        vk.VK_FORMAT_R16G16B16_SNORM,
        vk.VK_FORMAT_R16G16B16_USCALED,
        vk.VK_FORMAT_R16G16B16_SSCALED,
        vk.VK_FORMAT_R16G16B16_UINT,
        vk.VK_FORMAT_R16G16B16_SINT,
        vk.VK_FORMAT_R16G16B16_SFLOAT,
        vk.VK_FORMAT_R16G16B16A16_UNORM,
        vk.VK_FORMAT_R16G16B16A16_SNORM,
        vk.VK_FORMAT_R16G16B16A16_USCALED,
        vk.VK_FORMAT_R16G16B16A16_SSCALED,
        vk.VK_FORMAT_R16G16B16A16_UINT,
        vk.VK_FORMAT_R16G16B16A16_SINT,
        vk.VK_FORMAT_R16G16B16A16_SFLOAT,
        vk.VK_FORMAT_R32_UINT,
        vk.VK_FORMAT_R32_SINT,
        vk.VK_FORMAT_R32_SFLOAT,
        vk.VK_FORMAT_R32G32_UINT,
        vk.VK_FORMAT_R32G32_SINT,
        vk.VK_FORMAT_R32G32_SFLOAT,
        vk.VK_FORMAT_R32G32B32_UINT,
        vk.VK_FORMAT_R32G32B32_SINT,
        vk.VK_FORMAT_R32G32B32_SFLOAT,
        vk.VK_FORMAT_R32G32B32A32_UINT,
        vk.VK_FORMAT_R32G32B32A32_SINT,
        vk.VK_FORMAT_R32G32B32A32_SFLOAT,
        vk.VK_FORMAT_R64_UINT,
        vk.VK_FORMAT_R64_SINT,
        vk.VK_FORMAT_R64_SFLOAT,
        vk.VK_FORMAT_R64G64_UINT,
        vk.VK_FORMAT_R64G64_SINT,
        vk.VK_FORMAT_R64G64_SFLOAT,
        vk.VK_FORMAT_R64G64B64_UINT,
        vk.VK_FORMAT_R64G64B64_SINT,
        vk.VK_FORMAT_R64G64B64_SFLOAT,
        vk.VK_FORMAT_R64G64B64A64_UINT,
        vk.VK_FORMAT_R64G64B64A64_SINT,
        vk.VK_FORMAT_R64G64B64A64_SFLOAT,
        vk.VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        vk.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
        vk.VK_FORMAT_D16_UNORM,
        vk.VK_FORMAT_X8_D24_UNORM_PACK32,
        vk.VK_FORMAT_D32_SFLOAT,
        vk.VK_FORMAT_S8_UINT,
        vk.VK_FORMAT_D16_UNORM_S8_UINT,
        vk.VK_FORMAT_D24_UNORM_S8_UINT,
        vk.VK_FORMAT_D32_SFLOAT_S8_UINT,
        vk.VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
        vk.VK_FORMAT_BC2_UNORM_BLOCK,
        vk.VK_FORMAT_BC2_SRGB_BLOCK,
        vk.VK_FORMAT_BC3_UNORM_BLOCK,
        vk.VK_FORMAT_BC3_SRGB_BLOCK,
        vk.VK_FORMAT_BC4_UNORM_BLOCK,
        vk.VK_FORMAT_BC4_SNORM_BLOCK,
        vk.VK_FORMAT_BC5_UNORM_BLOCK,
        vk.VK_FORMAT_BC5_SNORM_BLOCK,
        vk.VK_FORMAT_BC6H_UFLOAT_BLOCK,
        vk.VK_FORMAT_BC6H_SFLOAT_BLOCK,
        vk.VK_FORMAT_BC7_UNORM_BLOCK,
        vk.VK_FORMAT_BC7_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
        vk.VK_FORMAT_EAC_R11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11_SNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    );
    const max = @max(
        vk.VK_FORMAT_UNDEFINED,
        vk.VK_FORMAT_R4G4_UNORM_PACK8,
        vk.VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        vk.VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        vk.VK_FORMAT_R5G6B5_UNORM_PACK16,
        vk.VK_FORMAT_B5G6R5_UNORM_PACK16,
        vk.VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        vk.VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        vk.VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        vk.VK_FORMAT_R8_UNORM,
        vk.VK_FORMAT_R8_SNORM,
        vk.VK_FORMAT_R8_USCALED,
        vk.VK_FORMAT_R8_SSCALED,
        vk.VK_FORMAT_R8_UINT,
        vk.VK_FORMAT_R8_SINT,
        vk.VK_FORMAT_R8_SRGB,
        vk.VK_FORMAT_R8G8_UNORM,
        vk.VK_FORMAT_R8G8_SNORM,
        vk.VK_FORMAT_R8G8_USCALED,
        vk.VK_FORMAT_R8G8_SSCALED,
        vk.VK_FORMAT_R8G8_UINT,
        vk.VK_FORMAT_R8G8_SINT,
        vk.VK_FORMAT_R8G8_SRGB,
        vk.VK_FORMAT_R8G8B8_UNORM,
        vk.VK_FORMAT_R8G8B8_SNORM,
        vk.VK_FORMAT_R8G8B8_USCALED,
        vk.VK_FORMAT_R8G8B8_SSCALED,
        vk.VK_FORMAT_R8G8B8_UINT,
        vk.VK_FORMAT_R8G8B8_SINT,
        vk.VK_FORMAT_R8G8B8_SRGB,
        vk.VK_FORMAT_B8G8R8_UNORM,
        vk.VK_FORMAT_B8G8R8_SNORM,
        vk.VK_FORMAT_B8G8R8_USCALED,
        vk.VK_FORMAT_B8G8R8_SSCALED,
        vk.VK_FORMAT_B8G8R8_UINT,
        vk.VK_FORMAT_B8G8R8_SINT,
        vk.VK_FORMAT_B8G8R8_SRGB,
        vk.VK_FORMAT_R8G8B8A8_UNORM,
        vk.VK_FORMAT_R8G8B8A8_SNORM,
        vk.VK_FORMAT_R8G8B8A8_USCALED,
        vk.VK_FORMAT_R8G8B8A8_SSCALED,
        vk.VK_FORMAT_R8G8B8A8_UINT,
        vk.VK_FORMAT_R8G8B8A8_SINT,
        vk.VK_FORMAT_R8G8B8A8_SRGB,
        vk.VK_FORMAT_B8G8R8A8_UNORM,
        vk.VK_FORMAT_B8G8R8A8_SNORM,
        vk.VK_FORMAT_B8G8R8A8_USCALED,
        vk.VK_FORMAT_B8G8R8A8_SSCALED,
        vk.VK_FORMAT_B8G8R8A8_UINT,
        vk.VK_FORMAT_B8G8R8A8_SINT,
        vk.VK_FORMAT_B8G8R8A8_SRGB,
        vk.VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_UINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UINT_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SINT_PACK32,
        vk.VK_FORMAT_R16_UNORM,
        vk.VK_FORMAT_R16_SNORM,
        vk.VK_FORMAT_R16_USCALED,
        vk.VK_FORMAT_R16_SSCALED,
        vk.VK_FORMAT_R16_UINT,
        vk.VK_FORMAT_R16_SINT,
        vk.VK_FORMAT_R16_SFLOAT,
        vk.VK_FORMAT_R16G16_UNORM,
        vk.VK_FORMAT_R16G16_SNORM,
        vk.VK_FORMAT_R16G16_USCALED,
        vk.VK_FORMAT_R16G16_SSCALED,
        vk.VK_FORMAT_R16G16_UINT,
        vk.VK_FORMAT_R16G16_SINT,
        vk.VK_FORMAT_R16G16_SFLOAT,
        vk.VK_FORMAT_R16G16B16_UNORM,
        vk.VK_FORMAT_R16G16B16_SNORM,
        vk.VK_FORMAT_R16G16B16_USCALED,
        vk.VK_FORMAT_R16G16B16_SSCALED,
        vk.VK_FORMAT_R16G16B16_UINT,
        vk.VK_FORMAT_R16G16B16_SINT,
        vk.VK_FORMAT_R16G16B16_SFLOAT,
        vk.VK_FORMAT_R16G16B16A16_UNORM,
        vk.VK_FORMAT_R16G16B16A16_SNORM,
        vk.VK_FORMAT_R16G16B16A16_USCALED,
        vk.VK_FORMAT_R16G16B16A16_SSCALED,
        vk.VK_FORMAT_R16G16B16A16_UINT,
        vk.VK_FORMAT_R16G16B16A16_SINT,
        vk.VK_FORMAT_R16G16B16A16_SFLOAT,
        vk.VK_FORMAT_R32_UINT,
        vk.VK_FORMAT_R32_SINT,
        vk.VK_FORMAT_R32_SFLOAT,
        vk.VK_FORMAT_R32G32_UINT,
        vk.VK_FORMAT_R32G32_SINT,
        vk.VK_FORMAT_R32G32_SFLOAT,
        vk.VK_FORMAT_R32G32B32_UINT,
        vk.VK_FORMAT_R32G32B32_SINT,
        vk.VK_FORMAT_R32G32B32_SFLOAT,
        vk.VK_FORMAT_R32G32B32A32_UINT,
        vk.VK_FORMAT_R32G32B32A32_SINT,
        vk.VK_FORMAT_R32G32B32A32_SFLOAT,
        vk.VK_FORMAT_R64_UINT,
        vk.VK_FORMAT_R64_SINT,
        vk.VK_FORMAT_R64_SFLOAT,
        vk.VK_FORMAT_R64G64_UINT,
        vk.VK_FORMAT_R64G64_SINT,
        vk.VK_FORMAT_R64G64_SFLOAT,
        vk.VK_FORMAT_R64G64B64_UINT,
        vk.VK_FORMAT_R64G64B64_SINT,
        vk.VK_FORMAT_R64G64B64_SFLOAT,
        vk.VK_FORMAT_R64G64B64A64_UINT,
        vk.VK_FORMAT_R64G64B64A64_SINT,
        vk.VK_FORMAT_R64G64B64A64_SFLOAT,
        vk.VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        vk.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
        vk.VK_FORMAT_D16_UNORM,
        vk.VK_FORMAT_X8_D24_UNORM_PACK32,
        vk.VK_FORMAT_D32_SFLOAT,
        vk.VK_FORMAT_S8_UINT,
        vk.VK_FORMAT_D16_UNORM_S8_UINT,
        vk.VK_FORMAT_D24_UNORM_S8_UINT,
        vk.VK_FORMAT_D32_SFLOAT_S8_UINT,
        vk.VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
        vk.VK_FORMAT_BC2_UNORM_BLOCK,
        vk.VK_FORMAT_BC2_SRGB_BLOCK,
        vk.VK_FORMAT_BC3_UNORM_BLOCK,
        vk.VK_FORMAT_BC3_SRGB_BLOCK,
        vk.VK_FORMAT_BC4_UNORM_BLOCK,
        vk.VK_FORMAT_BC4_SNORM_BLOCK,
        vk.VK_FORMAT_BC5_UNORM_BLOCK,
        vk.VK_FORMAT_BC5_SNORM_BLOCK,
        vk.VK_FORMAT_BC6H_UFLOAT_BLOCK,
        vk.VK_FORMAT_BC6H_SFLOAT_BLOCK,
        vk.VK_FORMAT_BC7_UNORM_BLOCK,
        vk.VK_FORMAT_BC7_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
        vk.VK_FORMAT_EAC_R11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11_SNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8B8G8R8_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B8G8R8G8_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16B16G16R16_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B16G16R16G16_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_FORMAT_A8_UNORM_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkStructureType(extensions: *const Extensions, item: *const vk.VkStructureType) bool {
    const min = @min(
        vk.VK_STRUCTURE_TYPE_APPLICATION_INFO,
        vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SUBMIT_INFO,
        vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
        vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    );
    const max = @max(
        vk.VK_STRUCTURE_TYPE_APPLICATION_INFO,
        vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SUBMIT_INFO,
        vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
        vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_EXT_validation_flags and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT)
        return true;
    if (extensions.instance.VK_KHR_device_group_creation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_device_group_creation and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_EXT_display_surface_counter and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_metal_surface and item.* == vk.VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_protected_capabilities and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
        return true;
    if (extensions.instance.VK_EXT_validation_features and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT)
        return true;
    if (extensions.instance.VK_EXT_headless_surface and item.* == vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT)
        return true;
    if (extensions.instance.VK_EXT_directfb_surface and item.* == vk.VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR)
        return true;
    if (extensions.instance.VK_EXT_layer_settings and item.* == vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_push_descriptor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_float16_int8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float16_int8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_16bit_storage and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_incremental_present and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_hdr_metadata and item.* == vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR)
        return true;
    if (extensions.device.VK_IMG_relaxed_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_variable_pointers and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_variable_pointers and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dedicated_allocation and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_dedicated_allocation and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR)
        return true;
    if (extensions.device.VK_KHR_image_format_list and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_bind_memory2 and item.* == vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_bind_memory2 and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance3 and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_extended_types and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_8bit_storage and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_atomic_int64 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_clock and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_feedback and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_depth_stencil_resolve and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_depth_stencil_resolve and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR)
        return true;
    if (extensions.device.VK_INTEL_shader_integer_functions2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL)
        return true;
    if (extensions.device.VK_KHR_vulkan_memory_model and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_pci_bus_info and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_terminate_invocation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_scalar_block_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_image_atomic_int64 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_quad_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_memory_budget and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_tooling_info and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_separate_stencil_usage and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_present_wait and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_shader_interlock and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_image_arrays and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_uniform_buffer_standard_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_query_reset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_index_type_uint8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT)
        return true;
    if (extensions.device.VK_KHR_map_memory2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_map_memory2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_demote_to_helper_invocation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_integer_dot_product and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_integer_dot_product and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_texel_buffer_alignment and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_texel_buffer_alignment and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_EXT_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_ID_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_uniform_control_flow and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_zero_initialize_workgroup_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_QCOM_rotated_copy_commands and item.* == vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_image_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_workgroup_memory_explicit_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_rgba10x6_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_physical_device_drm and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitive_topology_list_restart and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_format_feature_flags2 and item.* == vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR)
        return true;
    if (extensions.device.VK_EXT_present_mode_fifo_latest_ready and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_global_priority_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority_query and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_2d_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pageable_device_local_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_rotate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_zero_one and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_non_seamless_cube_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_shader_maximal_reconvergence and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control_swapchain and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_acquire_unmodified and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_dithering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_protected_access and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_viewports and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_library_group_handles and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_dynamic_rendering_unused_attachments and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_index_type_uint8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_calibrated_timestamps and item.* == vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_expect_assume and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_relaxed_extended_instruction and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_replicated_composites and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_depth_clamp_zero_one and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkSubpassContents(extensions: *const Extensions, item: *const vk.VkSubpassContents) bool {
    const min = @min(
        vk.VK_SUBPASS_CONTENTS_INLINE,
        vk.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    );
    const max = @max(
        vk.VK_SUBPASS_CONTENTS_INLINE,
        vk.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkResult(extensions: *const Extensions, item: *const vk.VkResult) bool {
    const min = @min(
        vk.VK_SUCCESS,
        vk.VK_NOT_READY,
        vk.VK_TIMEOUT,
        vk.VK_EVENT_SET,
        vk.VK_EVENT_RESET,
        vk.VK_INCOMPLETE,
        vk.VK_ERROR_OUT_OF_HOST_MEMORY,
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY,
        vk.VK_ERROR_INITIALIZATION_FAILED,
        vk.VK_ERROR_DEVICE_LOST,
        vk.VK_ERROR_MEMORY_MAP_FAILED,
        vk.VK_ERROR_LAYER_NOT_PRESENT,
        vk.VK_ERROR_EXTENSION_NOT_PRESENT,
        vk.VK_ERROR_FEATURE_NOT_PRESENT,
        vk.VK_ERROR_INCOMPATIBLE_DRIVER,
        vk.VK_ERROR_TOO_MANY_OBJECTS,
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED,
        vk.VK_ERROR_FRAGMENTED_POOL,
        vk.VK_ERROR_UNKNOWN,
    );
    const max = @max(
        vk.VK_SUCCESS,
        vk.VK_NOT_READY,
        vk.VK_TIMEOUT,
        vk.VK_EVENT_SET,
        vk.VK_EVENT_RESET,
        vk.VK_INCOMPLETE,
        vk.VK_ERROR_OUT_OF_HOST_MEMORY,
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY,
        vk.VK_ERROR_INITIALIZATION_FAILED,
        vk.VK_ERROR_DEVICE_LOST,
        vk.VK_ERROR_MEMORY_MAP_FAILED,
        vk.VK_ERROR_LAYER_NOT_PRESENT,
        vk.VK_ERROR_EXTENSION_NOT_PRESENT,
        vk.VK_ERROR_FEATURE_NOT_PRESENT,
        vk.VK_ERROR_INCOMPATIBLE_DRIVER,
        vk.VK_ERROR_TOO_MANY_OBJECTS,
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED,
        vk.VK_ERROR_FRAGMENTED_POOL,
        vk.VK_ERROR_UNKNOWN,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_ERROR_SURFACE_LOST_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_SUBOPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_ERROR_OUT_OF_DATE_KHR)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance1 and item.* == vk.VK_ERROR_OUT_OF_POOL_MEMORY_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_ERROR_FRAGMENTATION_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_ERROR_NOT_PERMITTED_EXT)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_ERROR_NOT_PERMITTED_KHR)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_ERROR_INVALID_DEVICE_ADDRESS_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_THREAD_IDLE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_THREAD_DONE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OPERATION_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OPERATION_NOT_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_PIPELINE_COMPILE_REQUIRED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_PIPELINE_BINARY_MISSING_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkDynamicState(extensions: *const Extensions, item: *const vk.VkDynamicState) bool {
    const min = @min(
        vk.VK_DYNAMIC_STATE_VIEWPORT,
        vk.VK_DYNAMIC_STATE_SCISSOR,
        vk.VK_DYNAMIC_STATE_LINE_WIDTH,
        vk.VK_DYNAMIC_STATE_DEPTH_BIAS,
        vk.VK_DYNAMIC_STATE_BLEND_CONSTANTS,
        vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS,
        vk.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    );
    const max = @max(
        vk.VK_DYNAMIC_STATE_VIEWPORT,
        vk.VK_DYNAMIC_STATE_SCISSOR,
        vk.VK_DYNAMIC_STATE_LINE_WIDTH,
        vk.VK_DYNAMIC_STATE_DEPTH_BIAS,
        vk.VK_DYNAMIC_STATE_BLEND_CONSTANTS,
        vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS,
        vk.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_CULL_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_FRONT_FACE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_STENCIL_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VERTEX_INPUT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_LOGIC_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_POLYGON_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_KHR)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkDescriptorUpdateTemplateType(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateType) bool {
    const min = vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    const max = vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_push_descriptor and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkObjectType(extensions: *const Extensions, item: *const vk.VkObjectType) bool {
    const min = @min(
        vk.VK_OBJECT_TYPE_UNKNOWN,
        vk.VK_OBJECT_TYPE_INSTANCE,
        vk.VK_OBJECT_TYPE_PHYSICAL_DEVICE,
        vk.VK_OBJECT_TYPE_DEVICE,
        vk.VK_OBJECT_TYPE_QUEUE,
        vk.VK_OBJECT_TYPE_SEMAPHORE,
        vk.VK_OBJECT_TYPE_COMMAND_BUFFER,
        vk.VK_OBJECT_TYPE_FENCE,
        vk.VK_OBJECT_TYPE_DEVICE_MEMORY,
        vk.VK_OBJECT_TYPE_BUFFER,
        vk.VK_OBJECT_TYPE_IMAGE,
        vk.VK_OBJECT_TYPE_EVENT,
        vk.VK_OBJECT_TYPE_QUERY_POOL,
        vk.VK_OBJECT_TYPE_BUFFER_VIEW,
        vk.VK_OBJECT_TYPE_IMAGE_VIEW,
        vk.VK_OBJECT_TYPE_SHADER_MODULE,
        vk.VK_OBJECT_TYPE_PIPELINE_CACHE,
        vk.VK_OBJECT_TYPE_PIPELINE_LAYOUT,
        vk.VK_OBJECT_TYPE_RENDER_PASS,
        vk.VK_OBJECT_TYPE_PIPELINE,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
        vk.VK_OBJECT_TYPE_SAMPLER,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_POOL,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET,
        vk.VK_OBJECT_TYPE_FRAMEBUFFER,
        vk.VK_OBJECT_TYPE_COMMAND_POOL,
    );
    const max = @max(
        vk.VK_OBJECT_TYPE_UNKNOWN,
        vk.VK_OBJECT_TYPE_INSTANCE,
        vk.VK_OBJECT_TYPE_PHYSICAL_DEVICE,
        vk.VK_OBJECT_TYPE_DEVICE,
        vk.VK_OBJECT_TYPE_QUEUE,
        vk.VK_OBJECT_TYPE_SEMAPHORE,
        vk.VK_OBJECT_TYPE_COMMAND_BUFFER,
        vk.VK_OBJECT_TYPE_FENCE,
        vk.VK_OBJECT_TYPE_DEVICE_MEMORY,
        vk.VK_OBJECT_TYPE_BUFFER,
        vk.VK_OBJECT_TYPE_IMAGE,
        vk.VK_OBJECT_TYPE_EVENT,
        vk.VK_OBJECT_TYPE_QUERY_POOL,
        vk.VK_OBJECT_TYPE_BUFFER_VIEW,
        vk.VK_OBJECT_TYPE_IMAGE_VIEW,
        vk.VK_OBJECT_TYPE_SHADER_MODULE,
        vk.VK_OBJECT_TYPE_PIPELINE_CACHE,
        vk.VK_OBJECT_TYPE_PIPELINE_LAYOUT,
        vk.VK_OBJECT_TYPE_RENDER_PASS,
        vk.VK_OBJECT_TYPE_PIPELINE,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
        vk.VK_OBJECT_TYPE_SAMPLER,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_POOL,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET,
        vk.VK_OBJECT_TYPE_FRAMEBUFFER,
        vk.VK_OBJECT_TYPE_COMMAND_POOL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_OBJECT_TYPE_SURFACE_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_OBJECT_TYPE_DISPLAY_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_OBJECT_TYPE_DISPLAY_MODE_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_OBJECT_TYPE_SWAPCHAIN_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_OBJECT_TYPE_VIDEO_SESSION_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_OBJECT_TYPE_VALIDATION_CACHE_EXT)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_OBJECT_TYPE_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_OBJECT_TYPE_SHADER_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_OBJECT_TYPE_PIPELINE_BINARY_KHR)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkRayTracingInvocationReorderModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingInvocationReorderModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkRayTracingLssIndexingModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssIndexingModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkRayTracingLssPrimitiveEndCapsModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssPrimitiveEndCapsModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDirectDriverLoadingModeLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingModeLUNARG) bool {
    const min = @min(
        vk.VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
        vk.VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
    );
    const max = @max(
        vk.VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
        vk.VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkAntiLagModeAMD(extensions: *const Extensions, item: *const vk.VkAntiLagModeAMD) bool {
    const min = @min(
        vk.VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
        vk.VK_ANTI_LAG_MODE_ON_AMD,
        vk.VK_ANTI_LAG_MODE_OFF_AMD,
    );
    const max = @max(
        vk.VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
        vk.VK_ANTI_LAG_MODE_ON_AMD,
        vk.VK_ANTI_LAG_MODE_OFF_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkAntiLagStageAMD(extensions: *const Extensions, item: *const vk.VkAntiLagStageAMD) bool {
    const min = @min(
        vk.VK_ANTI_LAG_STAGE_INPUT_AMD,
        vk.VK_ANTI_LAG_STAGE_PRESENT_AMD,
    );
    const max = @max(
        vk.VK_ANTI_LAG_STAGE_INPUT_AMD,
        vk.VK_ANTI_LAG_STAGE_PRESENT_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkQueueFlagBits(extensions: *const Extensions, item: *const vk.VkQueueFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUEUE_GRAPHICS_BIT |
        vk.VK_QUEUE_COMPUTE_BIT |
        vk.VK_QUEUE_TRANSFER_BIT |
        vk.VK_QUEUE_SPARSE_BINDING_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_QUEUE_VIDEO_DECODE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_QUEUE_VIDEO_ENCODE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkCullModeFlagBits(extensions: *const Extensions, item: *const vk.VkCullModeFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CULL_MODE_NONE |
        vk.VK_CULL_MODE_FRONT_BIT |
        vk.VK_CULL_MODE_BACK_BIT |
        vk.VK_CULL_MODE_FRONT_AND_BACK;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkRenderPassCreateFlagBits(extensions: *const Extensions, item: *const vk.VkRenderPassCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_QCOM_render_pass_transform)
        valid_bits |= vk.VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDeviceQueueCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkMemoryPropertyFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryPropertyFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_CACHED_BIT |
        vk.VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkMemoryHeapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryHeapFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_MEMORY_HEAP_DEVICE_LOCAL_BIT;
    if (extensions.instance.VK_KHR_device_group_creation)
        valid_bits |= vk.VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkAccessFlagBits(extensions: *const Extensions, item: *const vk.VkAccessFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_ACCESS_INDIRECT_COMMAND_READ_BIT |
        vk.VK_ACCESS_INDEX_READ_BIT |
        vk.VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT |
        vk.VK_ACCESS_UNIFORM_READ_BIT |
        vk.VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_SHADER_READ_BIT |
        vk.VK_ACCESS_SHADER_WRITE_BIT |
        vk.VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_TRANSFER_READ_BIT |
        vk.VK_ACCESS_TRANSFER_WRITE_BIT |
        vk.VK_ACCESS_HOST_READ_BIT |
        vk.VK_ACCESS_HOST_WRITE_BIT |
        vk.VK_ACCESS_MEMORY_READ_BIT |
        vk.VK_ACCESS_MEMORY_WRITE_BIT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT;
    if (extensions.device.VK_EXT_blend_operation_advanced)
        valid_bits |= vk.VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_NONE_KHR;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkBufferUsageFlagBits(extensions: *const Extensions, item: *const vk.VkBufferUsageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUFFER_USAGE_TRANSFER_SRC_BIT |
        vk.VK_BUFFER_USAGE_TRANSFER_DST_BIT |
        vk.VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_INDEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR;
    if (extensions.device.VK_EXT_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkBufferUsageFlagBits2(extensions: *const Extensions, item: *const vk.VkBufferUsageFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT |
        vk.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT |
        vk.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkBufferCreateFlagBits(extensions: *const Extensions, item: *const vk.VkBufferCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUFFER_CREATE_SPARSE_BINDING_BIT |
        vk.VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT |
        vk.VK_BUFFER_CREATE_SPARSE_ALIASED_BIT;
    if (extensions.device.VK_EXT_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkShaderStageFlagBits(extensions: *const Extensions, item: *const vk.VkShaderStageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SHADER_STAGE_VERTEX_BIT |
        vk.VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT |
        vk.VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT |
        vk.VK_SHADER_STAGE_GEOMETRY_BIT |
        vk.VK_SHADER_STAGE_FRAGMENT_BIT |
        vk.VK_SHADER_STAGE_COMPUTE_BIT |
        vk.VK_SHADER_STAGE_ALL_GRAPHICS |
        vk.VK_SHADER_STAGE_ALL;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_RAYGEN_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_MISS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_CALLABLE_BIT_KHR;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_SHADER_STAGE_TASK_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_SHADER_STAGE_MESH_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageUsageFlagBits(extensions: *const Extensions, item: *const vk.VkImageUsageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_USAGE_TRANSFER_SRC_BIT |
        vk.VK_IMAGE_USAGE_TRANSFER_DST_BIT |
        vk.VK_IMAGE_USAGE_SAMPLED_BIT |
        vk.VK_IMAGE_USAGE_STORAGE_BIT |
        vk.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageCreateFlagBits(extensions: *const Extensions, item: *const vk.VkImageCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_CREATE_SPARSE_BINDING_BIT |
        vk.VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT |
        vk.VK_IMAGE_CREATE_SPARSE_ALIASED_BIT |
        vk.VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT |
        vk.VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance2)
        valid_bits |= vk.VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance2)
        valid_bits |= vk.VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR;
    if (extensions.device.VK_EXT_sample_locations)
        valid_bits |= vk.VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_CREATE_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_bind_memory2)
        valid_bits |= vk.VK_IMAGE_CREATE_ALIAS_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled)
        valid_bits |= vk.VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_image_2d_view_of_3d)
        valid_bits |= vk.VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT;
    if (extensions.device.VK_QCOM_fragment_density_map_offset)
        valid_bits |= vk.VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map_offset)
        valid_bits |= vk.VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageViewCreateFlagBits(extensions: *const Extensions, item: *const vk.VkImageViewCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map2)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSamplerCreateFlagBits(extensions: *const Extensions, item: *const vk.VkSamplerCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_non_seamless_cube_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT |
        vk.VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT |
        vk.VK_PIPELINE_CREATE_DERIVATIVE_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_DISPATCH_BASE_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_executable_properties)
        valid_bits |= vk.VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_executable_properties)
        valid_bits |= vk.VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_LIBRARY_BIT_KHR;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_protected_access)
        valid_bits |= vk.VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_protected_access)
        valid_bits |= vk.VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineCreateFlagBits2(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT |
        vk.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT |
        vk.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT |
        vk.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT |
        vk.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT |
        vk.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT |
        vk.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT |
        vk.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT |
        vk.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM;
    if (extensions.device.VK_KHR_pipeline_binary)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineShaderStageCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_subgroup_size_control)
        valid_bits |= vk.VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    if (extensions.device.VK_EXT_subgroup_size_control)
        valid_bits |= vk.VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkColorComponentFlagBits(extensions: *const Extensions, item: *const vk.VkColorComponentFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COLOR_COMPONENT_R_BIT |
        vk.VK_COLOR_COMPONENT_G_BIT |
        vk.VK_COLOR_COMPONENT_B_BIT |
        vk.VK_COLOR_COMPONENT_A_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkFenceCreateFlagBits(extensions: *const Extensions, item: *const vk.VkFenceCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_FENCE_CREATE_SIGNALED_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSemaphoreCreateFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkFormatFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT |
        vk.VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_BLIT_SRC_BIT |
        vk.VK_FORMAT_FEATURE_BLIT_DST_BIT |
        vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT;
    if (extensions.device.VK_IMG_filter_cubic)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_EXT_sampler_filter_minmax)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_EXT_filter_cubic)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkQueryControlFlagBits(extensions: *const Extensions, item: *const vk.VkQueryControlFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_QUERY_CONTROL_PRECISE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkQueryResultFlagBits(extensions: *const Extensions, item: *const vk.VkQueryResultFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUERY_RESULT_64_BIT |
        vk.VK_QUERY_RESULT_WAIT_BIT |
        vk.VK_QUERY_RESULT_WITH_AVAILABILITY_BIT |
        vk.VK_QUERY_RESULT_PARTIAL_BIT;
    if (extensions.device.VK_KHR_video_queue)
        valid_bits |= vk.VK_QUERY_RESULT_WITH_STATUS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkCommandBufferUsageFlagBits(extensions: *const Extensions, item: *const vk.VkCommandBufferUsageFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT |
        vk.VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT |
        vk.VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkQueryPipelineStatisticFlagBits(extensions: *const Extensions, item: *const vk.VkQueryPipelineStatisticFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkMemoryMapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryMapFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_map_memory_placed)
        valid_bits |= vk.VK_MEMORY_MAP_PLACED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageAspectFlagBits(extensions: *const Extensions, item: *const vk.VkImageAspectFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_ASPECT_COLOR_BIT |
        vk.VK_IMAGE_ASPECT_DEPTH_BIT |
        vk.VK_IMAGE_ASPECT_STENCIL_BIT |
        vk.VK_IMAGE_ASPECT_METADATA_BIT;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_0_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_1_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_2_BIT_KHR;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance4)
        valid_bits |= vk.VK_IMAGE_ASPECT_NONE_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSparseImageFormatFlagBits(extensions: *const Extensions, item: *const vk.VkSparseImageFormatFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT |
        vk.VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT |
        vk.VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSparseMemoryBindFlagBits(extensions: *const Extensions, item: *const vk.VkSparseMemoryBindFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SPARSE_MEMORY_BIND_METADATA_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineStageFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineStageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT |
        vk.VK_PIPELINE_STAGE_VERTEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_VERTEX_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
        vk.VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_HOST_BIT |
        vk.VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT |
        vk.VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_NONE_KHR;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkCommandPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_POOL_CREATE_TRANSIENT_BIT |
        vk.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkCommandPoolResetFlagBits(extensions: *const Extensions, item: *const vk.VkCommandPoolResetFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkCommandBufferResetFlagBits(extensions: *const Extensions, item: *const vk.VkCommandBufferResetFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSampleCountFlagBits(extensions: *const Extensions, item: *const vk.VkSampleCountFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SAMPLE_COUNT_1_BIT |
        vk.VK_SAMPLE_COUNT_2_BIT |
        vk.VK_SAMPLE_COUNT_4_BIT |
        vk.VK_SAMPLE_COUNT_8_BIT |
        vk.VK_SAMPLE_COUNT_16_BIT |
        vk.VK_SAMPLE_COUNT_32_BIT |
        vk.VK_SAMPLE_COUNT_64_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkAttachmentDescriptionFlagBits(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkStencilFaceFlagBits(extensions: *const Extensions, item: *const vk.VkStencilFaceFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_STENCIL_FACE_FRONT_BIT |
        vk.VK_STENCIL_FACE_BACK_BIT |
        vk.VK_STENCIL_FACE_FRONT_AND_BACK;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDescriptorPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT;
    if (extensions.device.VK_VALVE_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE;
    if (extensions.device.VK_EXT_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDependencyFlagBits(extensions: *const Extensions, item: *const vk.VkDependencyFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DEPENDENCY_BY_REGION_BIT;
    if (extensions.device.VK_KHR_multiview)
        valid_bits |= vk.VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance8)
        valid_bits |= vk.VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance9)
        valid_bits |= vk.VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkSemaphoreType(extensions: *const Extensions, item: *const vk.VkSemaphoreType) bool {
    const min = @min(
        vk.VK_SEMAPHORE_TYPE_BINARY,
        vk.VK_SEMAPHORE_TYPE_TIMELINE,
    );
    const max = @max(
        vk.VK_SEMAPHORE_TYPE_BINARY,
        vk.VK_SEMAPHORE_TYPE_TIMELINE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_SEMAPHORE_TYPE_BINARY_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_SEMAPHORE_TYPE_TIMELINE_KHR)
        return true;
    return false;
}

pub fn validate_bitmask_VkSemaphoreWaitFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SEMAPHORE_WAIT_ANY_BIT;
    if (extensions.device.VK_KHR_timeline_semaphore)
        valid_bits |= vk.VK_SEMAPHORE_WAIT_ANY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPresentModeKHR(extensions: *const Extensions, item: *const vk.VkPresentModeKHR) bool {
    const min = @min(
        vk.VK_PRESENT_MODE_IMMEDIATE_KHR,
        vk.VK_PRESENT_MODE_MAILBOX_KHR,
        vk.VK_PRESENT_MODE_FIFO_KHR,
        vk.VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    );
    const max = @max(
        vk.VK_PRESENT_MODE_IMMEDIATE_KHR,
        vk.VK_PRESENT_MODE_MAILBOX_KHR,
        vk.VK_PRESENT_MODE_FIFO_KHR,
        vk.VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR)
        return true;
    if (extensions.device.VK_EXT_present_mode_fifo_latest_ready and item.* == vk.VK_PRESENT_MODE_FIFO_LATEST_READY_EXT)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == vk.VK_PRESENT_MODE_FIFO_LATEST_READY_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkColorSpaceKHR(extensions: *const Extensions, item: *const vk.VkColorSpaceKHR) bool {
    const min = vk.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    const max = vk.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT709_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT709_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT2020_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_HDR10_ST2084_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DOLBYVISION_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_HDR10_HLG_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_PASS_THROUGH_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT)
        return true;
    return false;
}

pub fn validate_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneAlphaFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkCompositeAlphaFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkCompositeAlphaFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSurfaceTransformFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkSurfaceTransformFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkDisplaySurfaceStereoTypeNV(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceStereoTypeNV) bool {
    const min = @min(
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
    );
    const max = @max(
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkSwapchainImageUsageFlagBitsANDROID(extensions: *const Extensions, item: *const vk.VkSwapchainImageUsageFlagBitsANDROID) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkTimeDomainKHR(extensions: *const Extensions, item: *const vk.VkTimeDomainKHR) bool {
    const min = @min(
        vk.VK_TIME_DOMAIN_DEVICE_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
        vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
    );
    const max = @max(
        vk.VK_TIME_DOMAIN_DEVICE_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
        vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_DEVICE_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT)
        return true;
    return false;
}

pub fn validate_bitmask_VkDebugReportFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugReportFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEBUG_REPORT_INFORMATION_BIT_EXT |
        vk.VK_DEBUG_REPORT_WARNING_BIT_EXT |
        vk.VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |
        vk.VK_DEBUG_REPORT_ERROR_BIT_EXT |
        vk.VK_DEBUG_REPORT_DEBUG_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkDebugReportObjectTypeEXT(extensions: *const Extensions, item: *const vk.VkDebugReportObjectTypeEXT) bool {
    const min = @min(
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    );
    const max = @max(
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkDeviceMemoryReportEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportEventTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkRasterizationOrderAMD(extensions: *const Extensions, item: *const vk.VkRasterizationOrderAMD) bool {
    const min = @min(
        vk.VK_RASTERIZATION_ORDER_STRICT_AMD,
        vk.VK_RASTERIZATION_ORDER_RELAXED_AMD,
    );
    const max = @max(
        vk.VK_RASTERIZATION_ORDER_STRICT_AMD,
        vk.VK_RASTERIZATION_ORDER_RELAXED_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkExternalMemoryFeatureFlagBitsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkClusterAccelerationStructureIndexFormatFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureIndexFormatFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkClusterAccelerationStructureTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureTypeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkClusterAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpTypeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkClusterAccelerationStructureOpModeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpModeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkClusterAccelerationStructureClusterFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureClusterFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkClusterAccelerationStructureGeometryFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGeometryFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkClusterAccelerationStructureAddressResolutionFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureAddressResolutionFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkValidationCheckEXT(extensions: *const Extensions, item: *const vk.VkValidationCheckEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_CHECK_ALL_EXT,
        vk.VK_VALIDATION_CHECK_SHADERS_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_CHECK_ALL_EXT,
        vk.VK_VALIDATION_CHECK_SHADERS_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkValidationFeatureEnableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureEnableEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkValidationFeatureDisableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureDisableEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkLayerSettingTypeEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingTypeEXT) bool {
    const min = @min(
        vk.VK_LAYER_SETTING_TYPE_BOOL32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_STRING_EXT,
    );
    const max = @max(
        vk.VK_LAYER_SETTING_TYPE_BOOL32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_STRING_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkSubgroupFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkSubgroupFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SUBGROUP_FEATURE_BASIC_BIT |
        vk.VK_SUBGROUP_FEATURE_VOTE_BIT |
        vk.VK_SUBGROUP_FEATURE_ARITHMETIC_BIT |
        vk.VK_SUBGROUP_FEATURE_BALLOT_BIT |
        vk.VK_SUBGROUP_FEATURE_SHUFFLE_BIT |
        vk.VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT |
        vk.VK_SUBGROUP_FEATURE_CLUSTERED_BIT |
        vk.VK_SUBGROUP_FEATURE_QUAD_BIT;
    if (extensions.device.VK_KHR_shader_subgroup_rotate)
        valid_bits |= vk.VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR;
    if (extensions.device.VK_KHR_shader_subgroup_rotate)
        valid_bits |= vk.VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkIndirectCommandsLayoutUsageFlagBitsNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkIndirectStateFlagBitsNV(extensions: *const Extensions, item: *const vk.VkIndirectStateFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkIndirectCommandsTokenTypeNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeNV) bool {
    const min = @min(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    );
    const max = @max(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV)
        return true;
    return false;
}

pub fn validate_bitmask_VkPrivateDataSlotCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDescriptorSetLayoutCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_push_descriptor)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT;
    if (extensions.device.VK_VALVE_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE;
    if (extensions.device.VK_EXT_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR;
    if (extensions.device.VK_EXT_external_memory_dma_buf)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_host)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_host)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkExternalMemoryFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT |
        vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkExternalSemaphoreFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSemaphoreImportFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreImportFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
    if (extensions.device.VK_KHR_external_semaphore)
        valid_bits |= vk.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkExternalFenceHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalFenceHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkExternalFenceFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalFenceFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkFenceImportFlagBits(extensions: *const Extensions, item: *const vk.VkFenceImportFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_FENCE_IMPORT_TEMPORARY_BIT;
    if (extensions.device.VK_KHR_external_fence)
        valid_bits |= vk.VK_FENCE_IMPORT_TEMPORARY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSurfaceCounterFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCounterFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SURFACE_COUNTER_VBLANK_BIT_EXT |
        vk.VK_SURFACE_COUNTER_VBLANK_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkDisplayPowerStateEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerStateEXT) bool {
    const min = @min(
        vk.VK_DISPLAY_POWER_STATE_OFF_EXT,
        vk.VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
        vk.VK_DISPLAY_POWER_STATE_ON_EXT,
    );
    const max = @max(
        vk.VK_DISPLAY_POWER_STATE_OFF_EXT,
        vk.VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
        vk.VK_DISPLAY_POWER_STATE_ON_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDeviceEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventTypeEXT) bool {
    const min = vk.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
    const max = vk.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDisplayEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventTypeEXT) bool {
    const min = vk.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
    const max = vk.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkPeerMemoryFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkPeerMemoryFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT |
        vk.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT |
        vk.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT |
        vk.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkMemoryAllocateFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_zero_initialize_device_memory)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSwapchainCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_swapchain)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain_mutable_format)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR;
    if (extensions.device.VK_EXT_swapchain_maintenance1)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT;
    if (extensions.device.VK_KHR_present_id2)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR;
    if (extensions.device.VK_KHR_present_wait2)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain_maintenance1)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkViewportCoordinateSwizzleNV(extensions: *const Extensions, item: *const vk.VkViewportCoordinateSwizzleNV) bool {
    const min = @min(
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    );
    const max = @max(
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDiscardRectangleModeEXT(extensions: *const Extensions, item: *const vk.VkDiscardRectangleModeEXT) bool {
    const min = @min(
        vk.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
        vk.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    );
    const max = @max(
        vk.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
        vk.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkSubpassDescriptionFlagBits(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_QCOM_render_pass_shader_resolve)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM;
    if (extensions.device.VK_QCOM_render_pass_shader_resolve)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPointClippingBehavior(extensions: *const Extensions, item: *const vk.VkPointClippingBehavior) bool {
    const min = @min(
        vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
        vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    );
    const max = @max(
        vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
        vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkSamplerReductionMode(extensions: *const Extensions, item: *const vk.VkSamplerReductionMode) bool {
    const min = @min(
        vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
        vk.VK_SAMPLER_REDUCTION_MODE_MIN,
        vk.VK_SAMPLER_REDUCTION_MODE_MAX,
    );
    const max = @max(
        vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
        vk.VK_SAMPLER_REDUCTION_MODE_MIN,
        vk.VK_SAMPLER_REDUCTION_MODE_MAX,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_MIN_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_MAX_EXT)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM)
        return true;
    return false;
}

pub fn validate_enum_VkTessellationDomainOrigin(extensions: *const Extensions, item: *const vk.VkTessellationDomainOrigin) bool {
    const min = @min(
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    );
    const max = @max(
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkSamplerYcbcrModelConversion(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrModelConversion) bool {
    const min = @min(
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    );
    const max = @max(
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkSamplerYcbcrRange(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrRange) bool {
    const min = @min(
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    );
    const max = @max(
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkChromaLocation(extensions: *const Extensions, item: *const vk.VkChromaLocation) bool {
    const min = @min(
        vk.VK_CHROMA_LOCATION_COSITED_EVEN,
        vk.VK_CHROMA_LOCATION_MIDPOINT,
    );
    const max = @max(
        vk.VK_CHROMA_LOCATION_COSITED_EVEN,
        vk.VK_CHROMA_LOCATION_MIDPOINT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_CHROMA_LOCATION_COSITED_EVEN_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_CHROMA_LOCATION_MIDPOINT_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkBlendOverlapEXT(extensions: *const Extensions, item: *const vk.VkBlendOverlapEXT) bool {
    const min = @min(
        vk.VK_BLEND_OVERLAP_UNCORRELATED_EXT,
        vk.VK_BLEND_OVERLAP_DISJOINT_EXT,
        vk.VK_BLEND_OVERLAP_CONJOINT_EXT,
    );
    const max = @max(
        vk.VK_BLEND_OVERLAP_UNCORRELATED_EXT,
        vk.VK_BLEND_OVERLAP_DISJOINT_EXT,
        vk.VK_BLEND_OVERLAP_CONJOINT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkCoverageModulationModeNV(extensions: *const Extensions, item: *const vk.VkCoverageModulationModeNV) bool {
    const min = @min(
        vk.VK_COVERAGE_MODULATION_MODE_NONE_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGB_NV,
        vk.VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    );
    const max = @max(
        vk.VK_COVERAGE_MODULATION_MODE_NONE_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGB_NV,
        vk.VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkCoverageReductionModeNV(extensions: *const Extensions, item: *const vk.VkCoverageReductionModeNV) bool {
    const min = @min(
        vk.VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
        vk.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
    );
    const max = @max(
        vk.VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
        vk.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkValidationCacheHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheHeaderVersionEXT) bool {
    const min = vk.VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
    const max = vk.VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkShaderInfoTypeAMD(extensions: *const Extensions, item: *const vk.VkShaderInfoTypeAMD) bool {
    const min = @min(
        vk.VK_SHADER_INFO_TYPE_STATISTICS_AMD,
        vk.VK_SHADER_INFO_TYPE_BINARY_AMD,
        vk.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    );
    const max = @max(
        vk.VK_SHADER_INFO_TYPE_STATISTICS_AMD,
        vk.VK_SHADER_INFO_TYPE_BINARY_AMD,
        vk.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkQueueGlobalPriority(extensions: *const Extensions, item: *const vk.VkQueueGlobalPriority) bool {
    const min = @min(
        vk.VK_QUEUE_GLOBAL_PRIORITY_LOW,
        vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
        vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH,
        vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    );
    const max = @max(
        vk.VK_QUEUE_GLOBAL_PRIORITY_LOW,
        vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
        vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH,
        vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR)
        return true;
    return false;
}

pub fn validate_bitmask_VkDebugUtilsMessageSeverityFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageSeverityFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDebugUtilsMessageTypeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageTypeFlagBitsEXT) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    if (extensions.device.VK_EXT_device_address_binding_report)
        valid_bits |= vk.VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkConservativeRasterizationModeEXT(extensions: *const Extensions, item: *const vk.VkConservativeRasterizationModeEXT) bool {
    const min = @min(
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    );
    const max = @max(
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkDescriptorBindingFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorBindingFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT |
        vk.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT |
        vk.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT |
        vk.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkVendorId(extensions: *const Extensions, item: *const vk.VkVendorId) bool {
    const min = @min(
        vk.VK_VENDOR_ID_KHRONOS,
        vk.VK_VENDOR_ID_VIV,
        vk.VK_VENDOR_ID_VSI,
        vk.VK_VENDOR_ID_KAZAN,
        vk.VK_VENDOR_ID_CODEPLAY,
        vk.VK_VENDOR_ID_MESA,
        vk.VK_VENDOR_ID_POCL,
        vk.VK_VENDOR_ID_MOBILEYE,
    );
    const max = @max(
        vk.VK_VENDOR_ID_KHRONOS,
        vk.VK_VENDOR_ID_VIV,
        vk.VK_VENDOR_ID_VSI,
        vk.VK_VENDOR_ID_KAZAN,
        vk.VK_VENDOR_ID_CODEPLAY,
        vk.VK_VENDOR_ID_MESA,
        vk.VK_VENDOR_ID_POCL,
        vk.VK_VENDOR_ID_MOBILEYE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDriverId(extensions: *const Extensions, item: *const vk.VkDriverId) bool {
    const min = @min(
        vk.VK_DRIVER_ID_AMD_PROPRIETARY,
        vk.VK_DRIVER_ID_AMD_OPEN_SOURCE,
        vk.VK_DRIVER_ID_MESA_RADV,
        vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY,
        vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
        vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
        vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
        vk.VK_DRIVER_ID_ARM_PROPRIETARY,
        vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
        vk.VK_DRIVER_ID_GGP_PROPRIETARY,
        vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_LLVMPIPE,
        vk.VK_DRIVER_ID_MOLTENVK,
        vk.VK_DRIVER_ID_COREAVI_PROPRIETARY,
        vk.VK_DRIVER_ID_JUICE_PROPRIETARY,
        vk.VK_DRIVER_ID_VERISILICON_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_TURNIP,
        vk.VK_DRIVER_ID_MESA_V3DV,
        vk.VK_DRIVER_ID_MESA_PANVK,
        vk.VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_VENUS,
        vk.VK_DRIVER_ID_MESA_DOZEN,
        vk.VK_DRIVER_ID_MESA_NVK,
        vk.VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_MESA_HONEYKRISP,
        vk.VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
    );
    const max = @max(
        vk.VK_DRIVER_ID_AMD_PROPRIETARY,
        vk.VK_DRIVER_ID_AMD_OPEN_SOURCE,
        vk.VK_DRIVER_ID_MESA_RADV,
        vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY,
        vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
        vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
        vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
        vk.VK_DRIVER_ID_ARM_PROPRIETARY,
        vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
        vk.VK_DRIVER_ID_GGP_PROPRIETARY,
        vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_LLVMPIPE,
        vk.VK_DRIVER_ID_MOLTENVK,
        vk.VK_DRIVER_ID_COREAVI_PROPRIETARY,
        vk.VK_DRIVER_ID_JUICE_PROPRIETARY,
        vk.VK_DRIVER_ID_VERISILICON_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_TURNIP,
        vk.VK_DRIVER_ID_MESA_V3DV,
        vk.VK_DRIVER_ID_MESA_PANVK,
        vk.VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_VENUS,
        vk.VK_DRIVER_ID_MESA_DOZEN,
        vk.VK_DRIVER_ID_MESA_NVK,
        vk.VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_MESA_HONEYKRISP,
        vk.VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_AMD_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_MESA_RADV_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_ARM_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_GGP_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR)
        return true;
    return false;
}

pub fn validate_bitmask_VkConditionalRenderingFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkResolveModeFlagBits(extensions: *const Extensions, item: *const vk.VkResolveModeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_RESOLVE_MODE_NONE |
        vk.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT |
        vk.VK_RESOLVE_MODE_AVERAGE_BIT |
        vk.VK_RESOLVE_MODE_MIN_BIT |
        vk.VK_RESOLVE_MODE_MAX_BIT;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_NONE_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_AVERAGE_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_MIN_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_MAX_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkShadingRatePaletteEntryNV(extensions: *const Extensions, item: *const vk.VkShadingRatePaletteEntryNV) bool {
    const min = @min(
        vk.VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    );
    const max = @max(
        vk.VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkCoarseSampleOrderTypeNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleOrderTypeNV) bool {
    const min = @min(
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    );
    const max = @max(
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkGeometryInstanceFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkGeometryInstanceFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkGeometryFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkGeometryFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_GEOMETRY_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkAccelerationStructureCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkCopyAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureModeKHR) bool {
    const min = @min(
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    );
    const max = @max(
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkBuildAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureModeKHR) bool {
    const min = @min(
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
    );
    const max = @max(
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkAccelerationStructureTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTypeKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkGeometryTypeKHR(extensions: *const Extensions, item: *const vk.VkGeometryTypeKHR) bool {
    const min = @min(
        vk.VK_GEOMETRY_TYPE_TRIANGLES_KHR,
        vk.VK_GEOMETRY_TYPE_AABBS_KHR,
        vk.VK_GEOMETRY_TYPE_INSTANCES_KHR,
    );
    const max = @max(
        vk.VK_GEOMETRY_TYPE_TRIANGLES_KHR,
        vk.VK_GEOMETRY_TYPE_AABBS_KHR,
        vk.VK_GEOMETRY_TYPE_INSTANCES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkAccelerationStructureMemoryRequirementsTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMemoryRequirementsTypeNV) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkAccelerationStructureBuildTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildTypeKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkRayTracingShaderGroupTypeKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupTypeKHR) bool {
    const min = @min(
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
    );
    const max = @max(
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkAccelerationStructureCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCompatibilityKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkShaderGroupShaderKHR(extensions: *const Extensions, item: *const vk.VkShaderGroupShaderKHR) bool {
    const min = @min(
        vk.VK_SHADER_GROUP_SHADER_GENERAL_KHR,
        vk.VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
    );
    const max = @max(
        vk.VK_SHADER_GROUP_SHADER_GENERAL_KHR,
        vk.VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkMemoryOverallocationBehaviorAMD(extensions: *const Extensions, item: *const vk.VkMemoryOverallocationBehaviorAMD) bool {
    const min = @min(
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    );
    const max = @max(
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkFramebufferCreateFlagBits(extensions: *const Extensions, item: *const vk.VkFramebufferCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_imageless_framebuffer)
        valid_bits |= vk.VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkQueryPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_maintenance9)
        valid_bits |= vk.VK_QUERY_POOL_CREATE_RESET_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDeviceDiagnosticsConfigFlagBitsNV(extensions: *const Extensions, item: *const vk.VkDeviceDiagnosticsConfigFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineCreationFeedbackFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT |
        vk.VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT |
        vk.VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkFullScreenExclusiveEXT) bool {
    const min = @min(
        vk.VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
    );
    const max = @max(
        vk.VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPerformanceCounterScopeKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterScopeKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_QUERY_SCOPE_RENDER_PASS_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_QUERY_SCOPE_RENDER_PASS_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkMemoryDecompressionMethodFlagBitsNV(extensions: *const Extensions, item: *const vk.VkMemoryDecompressionMethodFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPerformanceCounterUnitKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterUnitKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPerformanceCounterStorageKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterStorageKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkPerformanceCounterDescriptionFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkAcquireProfilingLockFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkShaderCorePropertiesFlagBitsAMD(extensions: *const Extensions, item: *const vk.VkShaderCorePropertiesFlagBitsAMD) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkRefreshObjectFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPerformanceConfigurationTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationTypeINTEL) bool {
    const min = vk.VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
    const max = vk.VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkQueryPoolSamplingModeINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolSamplingModeINTEL) bool {
    const min = vk.VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
    const max = vk.VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPerformanceOverrideTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPerformanceParameterTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceParameterTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
        vk.VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
        vk.VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPerformanceValueTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkShaderFloatControlsIndependence(extensions: *const Extensions, item: *const vk.VkShaderFloatControlsIndependence) bool {
    const min = @min(
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
    );
    const max = @max(
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR)
        return true;
    return false;
}

pub fn validate_enum_VkPipelineExecutableStatisticFormatKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticFormatKHR) bool {
    const min = @min(
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
    );
    const max = @max(
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkLineRasterizationMode(extensions: *const Extensions, item: *const vk.VkLineRasterizationMode) bool {
    const min = @min(
        vk.VK_LINE_RASTERIZATION_MODE_DEFAULT,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
        vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
    );
    const max = @max(
        vk.VK_LINE_RASTERIZATION_MODE_DEFAULT,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
        vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR)
        return true;
    return false;
}

pub fn validate_bitmask_VkShaderModuleCreateFlagBits(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineCompilerControlFlagBitsAMD(extensions: *const Extensions, item: *const vk.VkPipelineCompilerControlFlagBitsAMD) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkFaultLevel(extensions: *const Extensions, item: *const vk.VkFaultLevel) bool {
    const min = @min(
        vk.VK_FAULT_LEVEL_UNASSIGNED,
        vk.VK_FAULT_LEVEL_CRITICAL,
        vk.VK_FAULT_LEVEL_RECOVERABLE,
        vk.VK_FAULT_LEVEL_WARNING,
    );
    const max = @max(
        vk.VK_FAULT_LEVEL_UNASSIGNED,
        vk.VK_FAULT_LEVEL_CRITICAL,
        vk.VK_FAULT_LEVEL_RECOVERABLE,
        vk.VK_FAULT_LEVEL_WARNING,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkFaultType(extensions: *const Extensions, item: *const vk.VkFaultType) bool {
    const min = @min(
        vk.VK_FAULT_TYPE_INVALID,
        vk.VK_FAULT_TYPE_UNASSIGNED,
        vk.VK_FAULT_TYPE_IMPLEMENTATION,
        vk.VK_FAULT_TYPE_SYSTEM,
        vk.VK_FAULT_TYPE_PHYSICAL_DEVICE,
        vk.VK_FAULT_TYPE_COMMAND_BUFFER_FULL,
        vk.VK_FAULT_TYPE_INVALID_API_USAGE,
    );
    const max = @max(
        vk.VK_FAULT_TYPE_INVALID,
        vk.VK_FAULT_TYPE_UNASSIGNED,
        vk.VK_FAULT_TYPE_IMPLEMENTATION,
        vk.VK_FAULT_TYPE_SYSTEM,
        vk.VK_FAULT_TYPE_PHYSICAL_DEVICE,
        vk.VK_FAULT_TYPE_COMMAND_BUFFER_FULL,
        vk.VK_FAULT_TYPE_INVALID_API_USAGE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkFaultQueryBehavior(extensions: *const Extensions, item: *const vk.VkFaultQueryBehavior) bool {
    const min = vk.VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS;
    const max = vk.VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkToolPurposeFlagBits(extensions: *const Extensions, item: *const vk.VkToolPurposeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_TOOL_PURPOSE_VALIDATION_BIT |
        vk.VK_TOOL_PURPOSE_PROFILING_BIT |
        vk.VK_TOOL_PURPOSE_TRACING_BIT |
        vk.VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT |
        vk.VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_VALIDATION_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_PROFILING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_TRACING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPipelineMatchControl(extensions: *const Extensions, item: *const vk.VkPipelineMatchControl) bool {
    const min = vk.VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH;
    const max = vk.VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkFragmentShadingRateCombinerOpKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateCombinerOpKHR) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkFragmentShadingRateNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateNV) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkFragmentShadingRateTypeNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateTypeNV) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkSubpassMergeStatusEXT(extensions: *const Extensions, item: *const vk.VkSubpassMergeStatusEXT) bool {
    const min = @min(
        vk.VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
    );
    const max = @max(
        vk.VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkAccessFlagBits2(extensions: *const Extensions, item: *const vk.VkAccessFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_ACCESS_2_NONE |
        vk.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT |
        vk.VK_ACCESS_2_INDEX_READ_BIT |
        vk.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT |
        vk.VK_ACCESS_2_UNIFORM_READ_BIT |
        vk.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_SHADER_READ_BIT |
        vk.VK_ACCESS_2_SHADER_WRITE_BIT |
        vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_2_TRANSFER_READ_BIT |
        vk.VK_ACCESS_2_TRANSFER_WRITE_BIT |
        vk.VK_ACCESS_2_HOST_READ_BIT |
        vk.VK_ACCESS_2_HOST_WRITE_BIT |
        vk.VK_ACCESS_2_MEMORY_READ_BIT |
        vk.VK_ACCESS_2_MEMORY_WRITE_BIT |
        vk.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT |
        vk.VK_ACCESS_2_SHADER_STORAGE_READ_BIT |
        vk.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_NONE_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INDEX_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_UNIFORM_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFER_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_HOST_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_HOST_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_MEMORY_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_MEMORY_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1)
        valid_bits |= vk.VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_ACCESS_2_MICROMAP_READ_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineStageFlagBits2(extensions: *const Extensions, item: *const vk.VkPipelineStageFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_PIPELINE_STAGE_2_NONE |
        vk.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_2_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_2_HOST_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT |
        vk.VK_PIPELINE_STAGE_2_COPY_BIT |
        vk.VK_PIPELINE_STAGE_2_RESOLVE_BIT |
        vk.VK_PIPELINE_STAGE_2_BLIT_BIT |
        vk.VK_PIPELINE_STAGE_2_CLEAR_BIT |
        vk.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_NONE_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_HOST_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COPY_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_BLIT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkSubmitFlagBits(extensions: *const Extensions, item: *const vk.VkSubmitFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SUBMIT_PROTECTED_BIT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_SUBMIT_PROTECTED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkEventCreateFlagBits(extensions: *const Extensions, item: *const vk.VkEventCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineLayoutCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkSciSyncClientTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncClientTypeNV) bool {
    const min = @min(
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV,
    );
    const max = @max(
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkSciSyncPrimitiveTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncPrimitiveTypeNV) bool {
    const min = @min(
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV,
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV,
    );
    const max = @max(
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV,
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkProvokingVertexModeEXT(extensions: *const Extensions, item: *const vk.VkProvokingVertexModeEXT) bool {
    const min = @min(
        vk.VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
        vk.VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
    );
    const max = @max(
        vk.VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
        vk.VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPipelineCacheValidationVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheValidationVersion) bool {
    const min = vk.VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE;
    const max = vk.VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkAccelerationStructureMotionInstanceTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInstanceTypeNV) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkPipelineColorBlendStateCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPipelineDepthStencilStateCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkGraphicsPipelineLibraryFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkDeviceAddressBindingFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkDeviceAddressBindingTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkFrameBoundaryFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPresentScalingFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPresentScalingFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR |
        vk.VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT |
        vk.VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR |
        vk.VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT |
        vk.VK_PRESENT_SCALING_STRETCH_BIT_KHR |
        vk.VK_PRESENT_SCALING_STRETCH_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPresentGravityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPresentGravityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PRESENT_GRAVITY_MIN_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_MIN_BIT_EXT |
        vk.VK_PRESENT_GRAVITY_MAX_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_MAX_BIT_EXT |
        vk.VK_PRESENT_GRAVITY_CENTERED_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_CENTERED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkPhysicalDeviceSchedulingControlsFlagBitsARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodecOperationFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_CODEC_OPERATION_NONE_KHR;
    if (extensions.device.VK_KHR_video_encode_h264)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_h265)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_h264)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_h265)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_av1)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_av1)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_vp9)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoChromaSubsamplingFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoChromaSubsamplingFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoComponentBitDepthFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR |
        vk.VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoSessionCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_maintenance2)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoSessionParametersCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoDecodeH264PictureLayoutFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureLayoutFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoCodingControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkQueryResultStatusKHR(extensions: *const Extensions, item: *const vk.VkQueryResultStatusKHR) bool {
    const min = @min(
        vk.VK_QUERY_RESULT_STATUS_ERROR_KHR,
        vk.VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
        vk.VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
    );
    const max = @max(
        vk.VK_QUERY_RESULT_STATUS_ERROR_KHR,
        vk.VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
        vk.VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR)
        return true;
    return false;
}

pub fn validate_bitmask_VkVideoDecodeUsageFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_USAGE_DEFAULT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoDecodeCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR |
        vk.VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeUsageFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeContentFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeContentFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkVideoEncodeTuningModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeTuningModeKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkVideoEncodeCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFeedbackFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH264CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH264StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkHostImageCopyFlagBits(extensions: *const Extensions, item: *const vk.VkHostImageCopyFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_HOST_IMAGE_COPY_MEMCPY_BIT |
        vk.VK_HOST_IMAGE_COPY_MEMCPY;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_HOST_IMAGE_COPY_MEMCPY_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPartitionedAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureOpTypeNV) bool {
    const min = @min(
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
    );
    const max = @max(
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkPartitionedAccelerationStructureInstanceFlagBitsNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureInstanceFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageFormatConstraintsFlagBitsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsFlagBitsFUCHSIA) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageConstraintsInfoFlagBitsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFlagBitsFUCHSIA) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkFormatFeatureFlagBits2(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT |
        vk.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT |
        vk.VK_FORMAT_FEATURE_2_BLIT_DST_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT |
        vk.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT |
        vk.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT |
        vk.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT |
        vk.VK_FORMAT_FEATURE_2_DISJOINT_BIT |
        vk.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkRenderingFlagBits(extensions: *const Extensions, item: *const vk.VkRenderingFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT |
        vk.VK_RENDERING_SUSPENDING_BIT |
        vk.VK_RENDERING_RESUMING_BIT;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_SUSPENDING_BIT_KHR;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_RESUMING_BIT_KHR;
    if (extensions.device.VK_EXT_nested_command_buffer)
        valid_bits |= vk.VK_RENDERING_CONTENTS_INLINE_BIT_EXT;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance7)
        valid_bits |= vk.VK_RENDERING_CONTENTS_INLINE_BIT_KHR;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH265CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH265StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CtbSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeAV1CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeAV1StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkVideoEncodeAV1PredictionModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PredictionModeKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkVideoEncodeAV1RateControlGroupKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlGroupKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkExportMetalObjectTypeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectTypeFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkInstanceCreateFlagBits(extensions: *const Extensions, item: *const vk.VkInstanceCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.instance.VK_KHR_portability_enumeration)
        valid_bits |= vk.VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageCompressionFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_COMPRESSION_DEFAULT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT |
        vk.VK_IMAGE_COMPRESSION_DISABLED_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFixedRateFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPipelineRobustnessBufferBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessBufferBehavior) bool {
    const min = @min(
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
    );
    const max = @max(
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkPipelineRobustnessImageBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessImageBehavior) bool {
    const min = @min(
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
    );
    const max = @max(
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT)
        return true;
    return false;
}

pub fn validate_bitmask_VkOpticalFlowGridSizeFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowGridSizeFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkOpticalFlowUsageFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowUsageFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV |
        vk.VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_COST_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkOpticalFlowPerformanceLevelNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowPerformanceLevelNV) bool {
    const min = @min(
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
    );
    const max = @max(
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkOpticalFlowSessionBindingPointNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionBindingPointNV) bool {
    const min = @min(
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
    );
    const max = @max(
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkOpticalFlowSessionCreateFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreateFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkOpticalFlowExecuteFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowExecuteFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkMicromapTypeEXT(extensions: *const Extensions, item: *const vk.VkMicromapTypeEXT) bool {
    const min = vk.VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT;
    const max = vk.VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkBuildMicromapFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT |
        vk.VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT |
        vk.VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkMicromapCreateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkCopyMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapModeEXT) bool {
    const min = @min(
        vk.VK_COPY_MICROMAP_MODE_CLONE_EXT,
        vk.VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_COMPACT_EXT,
    );
    const max = @max(
        vk.VK_COPY_MICROMAP_MODE_CLONE_EXT,
        vk.VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_COMPACT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkBuildMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapModeEXT) bool {
    const min = vk.VK_BUILD_MICROMAP_MODE_BUILD_EXT;
    const max = vk.VK_BUILD_MICROMAP_MODE_BUILD_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkOpacityMicromapFormatEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapFormatEXT) bool {
    const min = @min(
        vk.VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
        vk.VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
    );
    const max = @max(
        vk.VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
        vk.VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkOpacityMicromapSpecialIndexEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapSpecialIndexEXT) bool {
    const min = @min(
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
    );
    const max = @max(
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDepthBiasRepresentationEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationEXT) bool {
    const min = @min(
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
    );
    const max = @max(
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDeviceFaultAddressTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDeviceFaultVendorBinaryHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionEXT) bool {
    const min = vk.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT;
    const max = vk.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkIndirectCommandsLayoutUsageFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkIndirectExecutionSetInfoTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetInfoTypeEXT) bool {
    const min = @min(
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
    );
    const max = @max(
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsInputModeFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT |
        vk.VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkIndirectCommandsTokenTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeEXT) bool {
    const min = @min(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    );
    const max = @max(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkDisplacementMicromapFormatNV(extensions: *const Extensions, item: *const vk.VkDisplacementMicromapFormatNV) bool {
    const min = @min(
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV,
    );
    const max = @max(
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkShaderCreateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateFlagBitsEXT) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SHADER_CREATE_LINK_STAGE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkShaderCodeTypeEXT(extensions: *const Extensions, item: *const vk.VkShaderCodeTypeEXT) bool {
    const min = @min(
        vk.VK_SHADER_CODE_TYPE_BINARY_EXT,
        vk.VK_SHADER_CODE_TYPE_SPIRV_EXT,
    );
    const max = @max(
        vk.VK_SHADER_CODE_TYPE_BINARY_EXT,
        vk.VK_SHADER_CODE_TYPE_SPIRV_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkScopeKHR(extensions: *const Extensions, item: *const vk.VkScopeKHR) bool {
    const min = @min(
        vk.VK_SCOPE_DEVICE_KHR,
        vk.VK_SCOPE_WORKGROUP_KHR,
        vk.VK_SCOPE_SUBGROUP_KHR,
        vk.VK_SCOPE_QUEUE_FAMILY_KHR,
    );
    const max = @max(
        vk.VK_SCOPE_DEVICE_KHR,
        vk.VK_SCOPE_WORKGROUP_KHR,
        vk.VK_SCOPE_SUBGROUP_KHR,
        vk.VK_SCOPE_QUEUE_FAMILY_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkComponentTypeKHR(extensions: *const Extensions, item: *const vk.VkComponentTypeKHR) bool {
    const min = @min(
        vk.VK_COMPONENT_TYPE_FLOAT16_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT32_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT64_KHR,
        vk.VK_COMPONENT_TYPE_SINT8_KHR,
        vk.VK_COMPONENT_TYPE_SINT16_KHR,
        vk.VK_COMPONENT_TYPE_SINT32_KHR,
        vk.VK_COMPONENT_TYPE_SINT64_KHR,
        vk.VK_COMPONENT_TYPE_UINT8_KHR,
        vk.VK_COMPONENT_TYPE_UINT16_KHR,
        vk.VK_COMPONENT_TYPE_UINT32_KHR,
        vk.VK_COMPONENT_TYPE_UINT64_KHR,
    );
    const max = @max(
        vk.VK_COMPONENT_TYPE_FLOAT16_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT32_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT64_KHR,
        vk.VK_COMPONENT_TYPE_SINT8_KHR,
        vk.VK_COMPONENT_TYPE_SINT16_KHR,
        vk.VK_COMPONENT_TYPE_SINT32_KHR,
        vk.VK_COMPONENT_TYPE_SINT64_KHR,
        vk.VK_COMPONENT_TYPE_UINT8_KHR,
        vk.VK_COMPONENT_TYPE_UINT16_KHR,
        vk.VK_COMPONENT_TYPE_UINT32_KHR,
        vk.VK_COMPONENT_TYPE_UINT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == vk.VK_COMPONENT_TYPE_BFLOAT16_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT)
        return true;
    return false;
}

pub fn validate_enum_VkCubicFilterWeightsQCOM(extensions: *const Extensions, item: *const vk.VkCubicFilterWeightsQCOM) bool {
    const min = @min(
        vk.VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
    );
    const max = @max(
        vk.VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkBlockMatchWindowCompareModeQCOM(extensions: *const Extensions, item: *const vk.VkBlockMatchWindowCompareModeQCOM) bool {
    const min = @min(
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
    );
    const max = @max(
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPhysicalDeviceLayeredApiKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiKHR) bool {
    const min = @min(
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
    );
    const max = @max(
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkLayeredDriverUnderlyingApiMSFT(extensions: *const Extensions, item: *const vk.VkLayeredDriverUnderlyingApiMSFT) bool {
    const min = @min(
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
    );
    const max = @max(
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkLatencyMarkerNV(extensions: *const Extensions, item: *const vk.VkLatencyMarkerNV) bool {
    const min = @min(
        vk.VK_LATENCY_MARKER_SIMULATION_START_NV,
        vk.VK_LATENCY_MARKER_SIMULATION_END_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_PRESENT_END_NV,
        vk.VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
        vk.VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
    );
    const max = @max(
        vk.VK_LATENCY_MARKER_SIMULATION_START_NV,
        vk.VK_LATENCY_MARKER_SIMULATION_END_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_PRESENT_END_NV,
        vk.VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
        vk.VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkOutOfBandQueueTypeNV(extensions: *const Extensions, item: *const vk.VkOutOfBandQueueTypeNV) bool {
    const min = @min(
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
    );
    const max = @max(
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkMemoryUnmapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryUnmapFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_map_memory_placed)
        valid_bits |= vk.VK_MEMORY_UNMAP_RESERVE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkWaylandSurfaceCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkDepthClampModeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampModeEXT) bool {
    const min = @min(
        vk.VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
        vk.VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
    );
    const max = @max(
        vk.VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
        vk.VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkAccessFlagBits3KHR(extensions: *const Extensions, item: *const vk.VkAccessFlagBits3KHR) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_ACCESS_3_NONE_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkTileShadingRenderPassFlagBitsQCOM(extensions: *const Extensions, item: *const vk.VkTileShadingRenderPassFlagBitsQCOM) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM |
        vk.VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkCooperativeVectorMatrixLayoutNV(extensions: *const Extensions, item: *const vk.VkCooperativeVectorMatrixLayoutNV) bool {
    const min = @min(
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
    );
    const max = @max(
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkTensorCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM |
        vk.VK_TENSOR_CREATE_PROTECTED_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_bitmask_VkTensorUsageFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorUsageFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_TENSOR_USAGE_SHADER_BIT_ARM |
        vk.VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM |
        vk.VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM |
        vk.VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkTensorTilingARM(extensions: *const Extensions, item: *const vk.VkTensorTilingARM) bool {
    const min = @min(
        vk.VK_TENSOR_TILING_OPTIMAL_ARM,
        vk.VK_TENSOR_TILING_LINEAR_ARM,
    );
    const max = @max(
        vk.VK_TENSOR_TILING_OPTIMAL_ARM,
        vk.VK_TENSOR_TILING_LINEAR_ARM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkTensorViewCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorViewCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkDefaultVertexAttributeValueKHR(extensions: *const Extensions, item: *const vk.VkDefaultVertexAttributeValueKHR) bool {
    const min = @min(
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR,
    );
    const max = @max(
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkDataGraphPipelineSessionCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkDataGraphPipelineSessionBindPointARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointARM) bool {
    const min = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM;
    const max = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDataGraphPipelineSessionBindPointTypeARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointTypeARM) bool {
    const min = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM;
    const max = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkDataGraphPipelinePropertyARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelinePropertyARM) bool {
    const min = @min(
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM,
    );
    const max = @max(
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_bitmask_VkDataGraphPipelineDispatchFlagBitsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineDispatchFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn validate_enum_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphProcessingEngineTypeARM) bool {
    const min = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM;
    const max = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_enum_VkPhysicalDeviceDataGraphOperationTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphOperationTypeARM) bool {
    const min = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM;
    const max = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn validate_spirv_extension(api_version: u32, extensions: *const Extensions, extension_name: []const u8) bool {
    if (std.mem.eql(u8, extension_name, "VK_KHR_variable_pointers"))
        return extensions.device.VK_KHR_variable_pointers and vk.VK_API_VERSION_1_1 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_draw_parameters"))
        return extensions.device.VK_KHR_shader_draw_parameters and vk.VK_API_VERSION_1_1 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_8bit_storage"))
        return extensions.device.VK_KHR_8bit_storage and vk.VK_API_VERSION_1_2 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_16bit_storage"))
        return extensions.device.VK_KHR_16bit_storage and vk.VK_API_VERSION_1_1 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_clock"))
        return extensions.device.VK_KHR_shader_clock;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_float_controls"))
        return extensions.device.VK_KHR_shader_float_controls and vk.VK_API_VERSION_1_2 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_storage_buffer_storage_class"))
        return extensions.device.VK_KHR_storage_buffer_storage_class and vk.VK_API_VERSION_1_1 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_EXT_post_depth_coverage"))
        return extensions.device.VK_EXT_post_depth_coverage;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_stencil_export"))
        return extensions.device.VK_EXT_shader_stencil_export;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_subgroup_ballot"))
        return extensions.device.VK_EXT_shader_subgroup_ballot;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_subgroup_vote"))
        return extensions.device.VK_EXT_shader_subgroup_vote;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_viewport_index_layer"))
        return extensions.device.VK_EXT_shader_viewport_index_layer and vk.VK_API_VERSION_1_2 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_EXT_descriptor_indexing"))
        return extensions.device.VK_EXT_descriptor_indexing and vk.VK_API_VERSION_1_2 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_vulkan_memory_model"))
        return extensions.device.VK_KHR_vulkan_memory_model and vk.VK_API_VERSION_1_2 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_ray_tracing_pipeline"))
        return extensions.device.VK_KHR_ray_tracing_pipeline;
    if (std.mem.eql(u8, extension_name, "VK_KHR_ray_query"))
        return extensions.device.VK_KHR_ray_query;
    if (std.mem.eql(u8, extension_name, "VK_KHR_ray_tracing_maintenance1"))
        return extensions.device.VK_KHR_ray_tracing_maintenance1;
    if (std.mem.eql(u8, extension_name, "VK_EXT_fragment_density_map"))
        return extensions.device.VK_EXT_fragment_density_map;
    if (std.mem.eql(u8, extension_name, "VK_KHR_buffer_device_address"))
        return extensions.device.VK_KHR_buffer_device_address and vk.VK_API_VERSION_1_2 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_EXT_buffer_device_address"))
        return extensions.device.VK_EXT_buffer_device_address;
    if (std.mem.eql(u8, extension_name, "VK_EXT_fragment_shader_interlock"))
        return extensions.device.VK_EXT_fragment_shader_interlock;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_demote_to_helper_invocation"))
        return extensions.device.VK_EXT_shader_demote_to_helper_invocation and vk.VK_API_VERSION_1_3 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_fragment_shading_rate"))
        return extensions.device.VK_KHR_fragment_shading_rate;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_non_semantic_info"))
        return extensions.device.VK_KHR_shader_non_semantic_info and vk.VK_API_VERSION_1_3 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_image_atomic_int64"))
        return extensions.device.VK_EXT_shader_image_atomic_int64;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_terminate_invocation"))
        return extensions.device.VK_KHR_shader_terminate_invocation and vk.VK_API_VERSION_1_3 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_multiview"))
        return extensions.device.VK_KHR_multiview and vk.VK_API_VERSION_1_1 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_workgroup_memory_explicit_layout"))
        return extensions.device.VK_KHR_workgroup_memory_explicit_layout;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_atomic_float"))
        return extensions.device.VK_EXT_shader_atomic_float;
    if (std.mem.eql(u8, extension_name, "VK_KHR_fragment_shader_barycentric"))
        return extensions.device.VK_KHR_fragment_shader_barycentric;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_subgroup_uniform_control_flow"))
        return extensions.device.VK_KHR_shader_subgroup_uniform_control_flow;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_atomic_float2"))
        return extensions.device.VK_EXT_shader_atomic_float2;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_atomic_float2"))
        return extensions.device.VK_EXT_shader_atomic_float2;
    if (std.mem.eql(u8, extension_name, "VK_EXT_conservative_rasterization"))
        return extensions.device.VK_EXT_conservative_rasterization;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_integer_dot_product"))
        return extensions.device.VK_KHR_shader_integer_dot_product and vk.VK_API_VERSION_1_3 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_INTEL_shader_integer_functions2"))
        return extensions.device.VK_INTEL_shader_integer_functions2;
    if (std.mem.eql(u8, extension_name, "VK_KHR_device_group"))
        return extensions.device.VK_KHR_device_group and vk.VK_API_VERSION_1_1 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_QCOM_image_processing"))
        return extensions.device.VK_QCOM_image_processing;
    if (std.mem.eql(u8, extension_name, "VK_QCOM_image_processing2"))
        return extensions.device.VK_QCOM_image_processing2;
    if (std.mem.eql(u8, extension_name, "VK_EXT_mesh_shader"))
        return extensions.device.VK_EXT_mesh_shader;
    if (std.mem.eql(u8, extension_name, "VK_KHR_ray_tracing_position_fetch"))
        return extensions.device.VK_KHR_ray_tracing_position_fetch;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_tile_image"))
        return extensions.device.VK_EXT_shader_tile_image;
    if (std.mem.eql(u8, extension_name, "VK_EXT_opacity_micromap"))
        return extensions.device.VK_EXT_opacity_micromap;
    if (std.mem.eql(u8, extension_name, "VK_KHR_cooperative_matrix"))
        return extensions.device.VK_KHR_cooperative_matrix;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_maximal_reconvergence"))
        return extensions.device.VK_KHR_shader_maximal_reconvergence;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_subgroup_rotate"))
        return extensions.device.VK_KHR_shader_subgroup_rotate and vk.VK_API_VERSION_1_4 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_expect_assume"))
        return extensions.device.VK_KHR_shader_expect_assume and vk.VK_API_VERSION_1_4 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_float_controls2"))
        return extensions.device.VK_KHR_shader_float_controls2 and vk.VK_API_VERSION_1_4 <= api_version;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_quad_control"))
        return extensions.device.VK_KHR_shader_quad_control;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_bfloat16"))
        return extensions.device.VK_KHR_shader_bfloat16;
    if (std.mem.eql(u8, extension_name, "VK_KHR_compute_shader_derivatives"))
        return extensions.device.VK_KHR_compute_shader_derivatives;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_replicated_composites"))
        return extensions.device.VK_EXT_shader_replicated_composites;
    if (std.mem.eql(u8, extension_name, "VK_KHR_shader_relaxed_extended_instruction"))
        return extensions.device.VK_KHR_shader_relaxed_extended_instruction;
    if (std.mem.eql(u8, extension_name, "VK_QCOM_tile_shading"))
        return extensions.device.VK_QCOM_tile_shading;
    if (std.mem.eql(u8, extension_name, "VK_EXT_shader_float8"))
        return extensions.device.VK_EXT_shader_float8;
}
