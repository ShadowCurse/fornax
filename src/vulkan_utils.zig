// Copyright (c) 2025 Egor Lazarchuk
// SPDX-License-Identifier: MIT
//
// This file is auto generated by gen/vulkan_utils_gen.zig

const std = @import("std");
const vk = @import("volk");
const log = @import("log.zig");

const Allocator = std.mem.Allocator;
pub fn print_struct(@"struct": anytype) void {
    print_struct_inner("", @"struct", 0);
}

fn print_offset_output(offset: u32, comptime format: []const u8, args: anytype) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output(format, args);
}

fn print_offset_struct(offset: u32, field_name: []const u8, @"struct": anytype) void {
    for (0..offset) |_| log.output("    ", .{});
    print_struct_inner(
        field_name,
        @"struct",
        offset,
    );
}

fn print_offset_slice(
    offset: u32,
    field_name: []const u8,
    type_name: []const u8,
    comptime T: type,
    elements: []const T,
) void {
    print_offset_output(offset, "{s}: []{s} = [\n", .{ field_name, type_name });
    defer print_offset_output(offset, "]\n", .{});
    for (elements) |*binding| {
        for (0..offset + 1) |_| log.output("    ", .{});
        print_struct_inner(&.{}, binding, offset + 1);
    }
}

fn print_struct_inner(name: []const u8, @"struct": anytype, base_offset: u32) void {
    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    const type_name = @typeName(t)["cimport.struct_".len..];
    log.output("{s}: {s} = .{{\n", .{ name, type_name });
    const fields = @typeInfo(t).@"struct".fields;
    const fields_base_offset = base_offset + 1;
    inline for (fields) |field| {
        switch (field.type) {
            i16, i32, u32, u64, usize, vk.VkStructureType => {
                print_offset_output(fields_base_offset, "{s}: {s} = {d},\n", .{
                    field.name,
                    @typeName(field.type),
                    @field(@"struct", field.name),
                });
            },
            f32, f64 => {
                print_offset_output(
                    fields_base_offset,
                    "{s}: {d},\n",
                    .{ field.name, @field(@"struct", field.name) },
                );
            },
            vk.VkOffset2D,
            vk.VkExtent2D,
            vk.VkOffset3D,
            vk.VkExtent3D,
            vk.VkPhysicalDeviceFeatures,
            => print_offset_struct(
                fields_base_offset,
                field.name,
                &@field(@"struct", field.name),
            ),
            ?*anyopaque,
            ?*const anyopaque,
            vk.VkBuffer,
            vk.VkImage,
            vk.VkInstance,
            vk.VkPhysicalDevice,
            vk.VkDevice,
            vk.VkQueue,
            vk.VkSemaphore,
            vk.VkCommandBuffer,
            vk.VkFence,
            vk.VkDeviceMemory,
            vk.VkEvent,
            vk.VkQueryPool,
            vk.VkBufferView,
            vk.VkImageView,
            vk.VkShaderModule,
            vk.VkPipelineCache,
            vk.VkPipelineLayout,
            vk.VkPipeline,
            vk.VkRenderPass,
            vk.VkDescriptorSetLayout,
            vk.VkSampler,
            vk.VkDescriptorSet,
            vk.VkDescriptorPool,
            vk.VkFramebuffer,
            vk.VkCommandPool,
            => print_offset_output(
                fields_base_offset,
                "{s}: {?},\n",
                .{ field.name, @field(@"struct", field.name) },
            ),
            [*c]const u8 => print_offset_output(
                fields_base_offset,
                "{s}: {s},\n",
                .{ field.name, @field(@"struct", field.name) },
            ),
            [*c]const u32 => {
                if (@hasField(t, "codeSize")) {
                    const len = @field(@"struct", "codeSize") / @sizeOf(u32);
                    print_offset_output(
                        fields_base_offset,
                        "{s}: {d} instructions,\n",
                        .{ field.name, len },
                    );
                }
            },
            [*c]const vk.VkDescriptorSetLayoutBinding => {
                const len = @field(@"struct", "bindingCount");
                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkDescriptorSetLayoutBinding,
                    elements,
                );
            },
            [*c]const vk.VkDescriptorSetLayout => {
                const len = if (@hasField(t, "descriptorSetCount"))
                    @field(@"struct", "descriptorSetCount")
                else if (@hasField(t, "setLayoutCount"))
                    @field(@"struct", "setLayoutCount");
                var elements: []const *anyopaque = undefined;
                elements.ptr = @ptrCast(@field(@"struct", field.name));
                elements.len = len;
                print_offset_output(
                    fields_base_offset,
                    "{s}: {any},\n",
                    .{ field.name, elements },
                );
            },
            [*c]const vk.VkPushConstantRange => {
                const len = @field(@"struct", "pushConstantRangeCount");
                var elements: []const vk.VkPushConstantRange = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkPushConstantRange,
                    elements,
                );
            },
            [*c]const vk.VkAttachmentDescription => {
                const len = @field(@"struct", "attachmentCount");
                var elements: []const vk.VkAttachmentDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkAttachmentDescription,
                    elements,
                );
            },
            [*c]const vk.VkSubpassDescription => {
                const len = @field(@"struct", "subpassCount");
                var elements: []const vk.VkSubpassDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSubpassDescription,
                    elements,
                );
            },
            [*c]const vk.VkAttachmentReference => {
                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
                    @field(@"struct", "inputAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
                    @field(@"struct", "colorAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
                    if (@field(@"struct", field.name) != null)
                        break :blk @field(@"struct", "colorAttachmentCount")
                    else
                        break :blk 0;
                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
                    @intFromBool(@field(@"struct", field.name) != null)
                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
                    @field(@"struct", "preserveAttachmentCount")
                else
                    @panic("Cannot find length for the VkAttachmentReference array");

                if (len != 0) {
                    var elements: []const vk.VkAttachmentReference = undefined;
                    elements.ptr = @field(@"struct", field.name);
                    elements.len = len;
                    print_offset_slice(
                        fields_base_offset,
                        field.name,
                        type_name,
                        vk.VkAttachmentReference,
                        elements,
                    );
                }
            },
            [*c]const vk.VkSubpassDependency => {
                const len = @field(@"struct", "dependencyCount");
                var elements: []const vk.VkSubpassDependency = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSubpassDependency,
                    elements,
                );
            },
            [*c]const vk.VkPipelineShaderStageCreateInfo => {
                const len = @field(@"struct", "stageCount");
                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkPipelineShaderStageCreateInfo,
                    elements,
                );
            },
            [*c]const vk.VkSpecializationMapEntry => {
                const len = @field(@"struct", "mapEntryCount");
                var elements: []const vk.VkSpecializationMapEntry = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSpecializationMapEntry,
                    elements,
                );
            },
            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
            [*c]const vk.VkPipelineTessellationStateCreateInfo,
            [*c]const vk.VkPipelineViewportStateCreateInfo,
            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
            [*c]const vk.VkPipelineDynamicStateCreateInfo,
            [*c]const vk.VkSpecializationInfo,
            [*c]const vk.VkViewport,
            [*c]const vk.VkRect2D,
            => {
                const element_type = @typeInfo(field.type).pointer.child;
                const element: ?*const element_type = @field(@"struct", field.name);
                if (element) |e|
                    print_offset_struct(fields_base_offset, field.name, e)
                else
                    print_offset_output(
                        fields_base_offset,
                        "{s}: {?},\n",
                        .{ field.name, element },
                    );
            },
            else => log.warn(
                @src(),
                "Cannot format field {s} of type {s}",
                .{ field.name, @typeName(field.type) },
            ),
        }
    }
    for (0..base_offset) |_|
        log.output("    ", .{});
    log.output("}},\n", .{});
}

pub fn print_chain(chain: anytype) void {
    var current: ?*const anyopaque = chain;
    while (current) |c| {
        const base_struct: *const vk.VkBaseInStructure = @ptrCast(@alignCast(c));
        switch (base_struct.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_INFO => {
                const nn: *const vk.VkApplicationInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO => {
                const nn: *const vk.VkInstanceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO => {
                const nn: *const vk.VkSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE => {
                const nn: *const vk.VkMappedMemoryRange = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO => {
                const nn: *const vk.VkBindSparseInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO => {
                const nn: *const vk.VkFenceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO => {
                const nn: *const vk.VkEventCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO => {
                const nn: *const vk.VkQueryPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkBufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO => {
                const nn: *const vk.VkBufferViewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkImageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO => {
                const nn: *const vk.VkImageViewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO => {
                const nn: *const vk.VkShaderModuleCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO => {
                const nn: *const vk.VkPipelineCacheCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineInputAssemblyStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineViewportStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineMultisampleStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDepthStencilStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineColorBlendStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDynamicStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkGraphicsPipelineCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkComputePipelineCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkPipelineLayoutCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO => {
                const nn: *const vk.VkSamplerCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET => {
                const nn: *const vk.VkWriteDescriptorSet = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET => {
                const nn: *const vk.VkCopyDescriptorSet = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO => {
                const nn: *const vk.VkFramebufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO => {
                const nn: *const vk.VkRenderPassCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO => {
                const nn: *const vk.VkCommandPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO => {
                const nn: *const vk.VkCommandBufferAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER => {
                const nn: *const vk.VkBufferMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER => {
                const nn: *const vk.VkImageMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER => {
                const nn: *const vk.VkMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO => {
                const nn: *const vk.VkBindBufferMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO => {
                const nn: *const vk.VkBindImageMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice16BitStorageFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS => {
                const nn: *const vk.VkMemoryDedicatedRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO => {
                const nn: *const vk.VkMemoryAllocateFlagsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupRenderPassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO => {
                const nn: *const vk.VkDeviceGroupSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO => {
                const nn: *const vk.VkDeviceGroupBindSparseInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindBufferMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindImageMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceGroupProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceGroupDeviceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkBufferMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageSparseMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkMemoryRequirements2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkSparseImageMemoryRequirements2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 => {
                const nn: *const vk.VkPhysicalDeviceFeatures2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkImageFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceImageFormatInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 => {
                const nn: *const vk.VkQueueFamilyProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceMemoryProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkSparseImageFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceSparseImageFormatInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePointClippingProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO => {
                const nn: *const vk.VkRenderPassInputAttachmentAspectCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageViewUsageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO => {
                const nn: *const vk.VkRenderPassMultiviewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVariablePointersFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO => {
                const nn: *const vk.VkProtectedSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 => {
                const nn: *const vk.VkDeviceQueueInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO => {
                const nn: *const vk.VkBindImagePlaneMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO => {
                const nn: *const vk.VkImagePlaneMemoryRequirementsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkSamplerYcbcrConversionImageFormatProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO => {
                const nn: *const vk.VkDescriptorUpdateTemplateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalImageFormatInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkExternalImageFormatProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalBufferInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES => {
                const nn: *const vk.VkExternalBufferProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceIDProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryBufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryImageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkExportMemoryAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalFenceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES => {
                const nn: *const vk.VkExternalFenceProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO => {
                const nn: *const vk.VkExportFenceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkExportSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalSemaphoreInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkExternalSemaphoreProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance3Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetLayoutSupport = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO => {
                const nn: *const vk.VkImageFormatListCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 => {
                const nn: *const vk.VkAttachmentDescription2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 => {
                const nn: *const vk.VkAttachmentReference2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 => {
                const nn: *const vk.VkSubpassDescription2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 => {
                const nn: *const vk.VkSubpassDependency2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 => {
                const nn: *const vk.VkRenderPassCreateInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO => {
                const nn: *const vk.VkSubpassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO => {
                const nn: *const vk.VkSubpassEndInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice8BitStorageFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDriverProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicInt64Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat16Int8Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceFloatControlsProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDepthStencilResolveProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE => {
                const nn: *const vk.VkSubpassDescriptionDepthStencilResolve = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageStencilUsageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO => {
                const nn: *const vk.VkSamplerReductionModeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentsCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassAttachmentBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentReferenceStencilLayout = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentDescriptionStencilLayout = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostQueryResetFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreTypeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkTimelineSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO => {
                const nn: *const vk.VkSemaphoreWaitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO => {
                const nn: *const vk.VkSemaphoreSignalInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO => {
                const nn: *const vk.VkBufferDeviceAddressInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO => {
                const nn: *const vk.VkBufferOpaqueCaptureAddressCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO => {
                const nn: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreationFeedbackCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceToolProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePrivateDataFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO => {
                const nn: *const vk.VkDevicePrivateDataCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO => {
                const nn: *const vk.VkPrivateDataSlotCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkBufferMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkImageMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO => {
                const nn: *const vk.VkDependencyInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2 => {
                const nn: *const vk.VkSubmitInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO => {
                const nn: *const vk.VkCommandBufferSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSynchronization2Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImageRobustnessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyBufferInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyBufferToImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyImageToBufferInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 => {
                const nn: *const vk.VkBlitImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 => {
                const nn: *const vk.VkResolveImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2 => {
                const nn: *const vk.VkBufferCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2 => {
                const nn: *const vk.VkImageCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2 => {
                const nn: *const vk.VkImageBlit2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 => {
                const nn: *const vk.VkBufferImageCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 => {
                const nn: *const vk.VkImageResolve2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK => {
                const nn: *const vk.VkWriteDescriptorSetInlineUniformBlock = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INFO => {
                const nn: *const vk.VkRenderingInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO => {
                const nn: *const vk.VkRenderingAttachmentInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO => {
                const nn: *const vk.VkPipelineRenderingCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceRenderingInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 => {
                const nn: *const vk.VkFormatProperties3 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceBufferMemoryRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceImageMemoryRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueGlobalPriorityCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES => {
                const nn: *const vk.VkQueueFamilyGlobalPriorityProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloatControls2Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationLineStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputDivisorStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceIndexTypeUint8Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO => {
                const nn: *const vk.VkMemoryMapInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO => {
                const nn: *const vk.VkMemoryUnmapInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO => {
                const nn: *const vk.VkRenderingAreaInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO => {
                const nn: *const vk.VkDeviceImageSubresourceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 => {
                const nn: *const vk.VkSubresourceLayout2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 => {
                const nn: *const vk.VkImageSubresource2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreateFlags2CreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkBufferUsageFlags2CreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePushDescriptorProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO => {
                const nn: *const vk.VkRenderingAttachmentLocationInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO => {
                const nn: *const vk.VkRenderingInputAttachmentIndexInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS => {
                const nn: *const vk.VkBindMemoryStatus = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO => {
                const nn: *const vk.VkBindDescriptorSetsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO => {
                const nn: *const vk.VkPushConstantsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO => {
                const nn: *const vk.VkPushDescriptorSetInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO => {
                const nn: *const vk.VkPushDescriptorSetWithTemplateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO => {
                const nn: *const vk.VkPipelineRobustnessCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY => {
                const nn: *const vk.VkMemoryToImageCopy = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY => {
                const nn: *const vk.VkImageToMemoryCopy = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO => {
                const nn: *const vk.VkCopyImageToMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyMemoryToImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO => {
                const nn: *const vk.VkHostImageLayoutTransitionInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyImageToImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE => {
                const nn: *const vk.VkSubresourceHostMemcpySize = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY => {
                const nn: *const vk.VkHostImageCopyDevicePerformanceQuery = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR => {
                const nn: *const vk.VkPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR => {
                const nn: *const vk.VkDeviceGroupPresentCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkImageSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR => {
                const nn: *const vk.VkBindImageMemorySwapchainInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR => {
                const nn: *const vk.VkAcquireNextImageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplayModeCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplaySurfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDisplayPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugReportCallbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD => {
                const nn: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectNameInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectTagInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerMarkerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR => {
                const nn: *const vk.VkVideoProfileInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR => {
                const nn: *const vk.VkVideoPictureResourceInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR => {
                const nn: *const vk.VkVideoSessionMemoryRequirementsKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR => {
                const nn: *const vk.VkBindVideoSessionMemoryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersUpdateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoBeginCodingInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoEndCodingInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoCodingControlInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceSlotInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyVideoPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR => {
                const nn: *const vk.VkVideoProfileListInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoFormatInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoDecodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeUsageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationImageCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationBufferCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuFunctionCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX => {
                const nn: *const vk.VkCuLaunchInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleTexturingModeCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX => {
                const nn: *const vk.VkImageViewHandleInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX => {
                const nn: *const vk.VkImageViewAddressPropertiesNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD => {
                const nn: *const vk.VkTextureLODGatherFormatPropertiesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalMemoryImageCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkExportMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT => {
                const nn: *const vk.VkValidationFlagsEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT => {
                const nn: *const vk.VkImageViewASTCDecodeModeEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR => {
                const nn: *const vk.VkImportMemoryFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR => {
                const nn: *const vk.VkMemoryFdPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR => {
                const nn: *const vk.VkMemoryGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR => {
                const nn: *const vk.VkImportSemaphoreFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkSemaphoreGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT => {
                const nn: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT => {
                const nn: *const vk.VkConditionalRenderingBeginInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR => {
                const nn: *const vk.VkPresentRegionsKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportWScalingStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT => {
                const nn: *const vk.VkSurfaceCapabilities2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT => {
                const nn: *const vk.VkDisplayPowerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT => {
                const nn: *const vk.VkDeviceEventInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT => {
                const nn: *const vk.VkDisplayEventInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT => {
                const nn: *const vk.VkSwapchainCounterCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX => {
                const nn: *const vk.VkMultiviewPerViewAttributesInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT => {
                const nn: *const vk.VkHdrMetadataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG => {
                const nn: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR => {
                const nn: *const vk.VkSharedPresentSurfaceCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR => {
                const nn: *const vk.VkImportFenceFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkFenceGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolPerformanceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR => {
                const nn: *const vk.VkPerformanceQuerySubmitInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR => {
                const nn: *const vk.VkAcquireProfilingLockInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR => {
                const nn: *const vk.VkPerformanceCounterKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR => {
                const nn: *const vk.VkPerformanceCounterDescriptionKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR => {
                const nn: *const vk.VkPhysicalDeviceSurfaceInfo2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilities2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR => {
                const nn: *const vk.VkSurfaceFormat2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayModeProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR => {
                const nn: *const vk.VkDisplayPlaneInfo2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneCapabilities2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectNameInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectTagInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT => {
                const nn: *const vk.VkDebugUtilsLabelEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD => {
                const nn: *const vk.VkAttachmentSampleCountInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT => {
                const nn: *const vk.VkSampleLocationsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT => {
                const nn: *const vk.VkRenderPassSampleLocationsBeginInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT => {
                const nn: *const vk.VkMultisamplePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageToColorStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildGeometryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureDeviceAddressInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryAabbsDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryInstancesDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureVersionInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildSizesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageModulationStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesListEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierListCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesList2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderModuleValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_NV => {
                const nn: *const vk.VkGeometryNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV => {
                const nn: *const vk.VkGeometryTrianglesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV => {
                const nn: *const vk.VkGeometryAABBNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV => {
                const nn: *const vk.VkBindAccelerationStructureMemoryInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT => {
                const nn: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT => {
                const nn: *const vk.VkImportMemoryHostPointerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT => {
                const nn: *const vk.VkMemoryHostPointerPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD => {
                const nn: *const vk.VkPipelineCompilerControlCreateInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD => {
                const nn: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV => {
                const nn: *const vk.VkCheckpointDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointProperties2NV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV => {
                const nn: *const vk.VkCheckpointData2NV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL => {
                const nn: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL => {
                const nn: *const vk.VkInitializePerformanceApiInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceMarkerInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceStreamMarkerInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceOverrideInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceConfigurationAcquireInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT => {
                const nn: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT => {
                const nn: *const vk.VkMemoryPriorityAllocateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfaceProtectedCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT => {
                const nn: *const vk.VkBufferDeviceAddressCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT => {
                const nn: *const vk.VkValidationFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageReductionStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV => {
                const nn: *const vk.VkFramebufferMixedSamplesCombinationNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT => {
                const nn: *const vk.VkHeadlessSurfaceCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR => {
                const nn: *const vk.VkPipelineInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR => {
                const nn: *const vk.VkPipelineExecutablePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR => {
                const nn: *const vk.VkPipelineExecutableInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR => {
                const nn: *const vk.VkPipelineExecutableStatisticKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR => {
                const nn: *const vk.VkPipelineExecutableInternalRepresentationKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT => {
                const nn: *const vk.VkMemoryMapPlacedInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV => {
                const nn: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTransformBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT => {
                const nn: *const vk.VkDepthBiasInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT => {
                const nn: *const vk.VkDepthBiasRepresentationInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT => {
                const nn: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceMemoryReportCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerCustomBorderColorCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineLibraryCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentBarrierNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainPresentBarrierCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlLayerInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeUsageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersGetInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV => {
                const nn: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTileShadingCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkPerTileBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM => {
                const nn: *const vk.VkPerTileEndInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM => {
                const nn: *const vk.VkDispatchTileInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV => {
                const nn: *const vk.VkQueryLowLatencySupportNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT => {
                const nn: *const vk.VkDescriptorAddressInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT => {
                const nn: *const vk.VkDescriptorGetInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkBufferCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageViewCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkSamplerCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT => {
                const nn: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT => {
                const nn: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMotionInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCopyCommandTransformInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT => {
                const nn: *const vk.VkImageCompressionControlEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT => {
                const nn: *const vk.VkImageCompressionPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFaultFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT => {
                const nn: *const vk.VkDeviceFaultCountsEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT => {
                const nn: *const vk.VkDeviceFaultInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputBindingDescription2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputAttributeDescription2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDrmPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceAddressBindingCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkMemoryGetRemoteAddressInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT => {
                const nn: *const vk.VkPipelinePropertiesIdentifierEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT => {
                const nn: *const vk.VkFrameBoundaryEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT => {
                const nn: *const vk.VkSubpassResolvePerformanceQueryEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT => {
                const nn: *const vk.VkMultisampledRenderToSingleSampledInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorWriteCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT => {
                const nn: *const vk.VkMicromapVersionInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapToMemoryInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMemoryToMicromapInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkMicromapCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildSizesInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT => {
                const nn: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageViewSlicedCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE => {
                const nn: *const vk.VkDescriptorSetBindingReferenceVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE => {
                const nn: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeBeginInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeSubmitInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV => {
                const nn: *const vk.VkComputePipelineIndirectBufferInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkPipelineIndirectDeviceAddressInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometrySpheresDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM => {
                const nn: *const vk.VkImageViewSampleWeightCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT => {
                const nn: *const vk.VkExternalMemoryAcquireUnmodifiedEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT => {
                const nn: *const vk.VkRenderPassCreationControlEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingInfoLUNARG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingListLUNARG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorViewCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindTensorMemoryInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM => {
                const nn: *const vk.VkWriteDescriptorSetTensorARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM => {
                const nn: *const vk.VkTensorFormatPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM => {
                const nn: *const vk.VkTensorDescriptionARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkTensorMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM => {
                const nn: *const vk.VkTensorMemoryBarrierARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM => {
                const nn: *const vk.VkDeviceTensorMemoryRequirementsARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM => {
                const nn: *const vk.VkCopyTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_COPY_ARM => {
                const nn: *const vk.VkTensorCopyARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM => {
                const nn: *const vk.VkTensorDependencyInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfoTensorARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceExternalTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkExternalTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkExternalMemoryTensorCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM => {
                const nn: *const vk.VkDescriptorGetTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorViewCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM => {
                const nn: *const vk.VkFrameBoundaryTensorsARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT => {
                const nn: *const vk.VkShaderModuleIdentifierEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowExecuteInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD => {
                const nn: *const vk.VkAntiLagDataAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD => {
                const nn: *const vk.VkAntiLagPresentationInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentWait2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR => {
                const nn: *const vk.VkPresentWait2InfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR => {
                const nn: *const vk.VkPipelineBinaryKeyKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR => {
                const nn: *const vk.VkReleaseCapturedPipelineDataInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryDataInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR => {
                const nn: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryHandlesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM => {
                const nn: *const vk.VkTilePropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC => {
                const nn: *const vk.VkAmigoProfilingSubmitInfoSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR => {
                const nn: *const vk.VkSurfacePresentModeKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfacePresentScalingCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR => {
                const nn: *const vk.VkSurfacePresentModeCompatibilityKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentFenceInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModesCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentScalingCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR => {
                const nn: *const vk.VkReleaseSwapchainImagesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV => {
                const nn: *const vk.VkConvertCooperativeVectorMatrixInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT => {
                const nn: *const vk.VkMutableDescriptorTypeCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT => {
                const nn: *const vk.VkLayerSettingsCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV => {
                const nn: *const vk.VkLatencySleepModeInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV => {
                const nn: *const vk.VkLatencySleepInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkSetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkGetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV => {
                const nn: *const vk.VkLatencyTimingsFrameReportNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV => {
                const nn: *const vk.VkOutOfBandQueueTypeInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainLatencyCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV => {
                const nn: *const vk.VkLatencySurfaceCapabilitiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineResourceInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDataGraphFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM => {
                const nn: *const vk.VkDataGraphPipelinePropertyQueryResultARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineDispatchInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphProcessingEngineCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR => {
                const nn: *const vk.VkVideoInlineQueryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerCubicWeightsCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM => {
                const nn: *const vk.VkBlitImageCubicWeightsInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT => {
                const nn: *const vk.VkAttachmentFeedbackLoopInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT => {
                const nn: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR => {
                const nn: *const vk.VkCalibratedTimestampInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT => {
                const nn: *const vk.VkSetDescriptorBufferOffsetsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT => {
                const nn: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM => {
                const nn: *const vk.VkTileMemoryRequirementsQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM => {
                const nn: *const vk.VkTileMemoryBindInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM => {
                const nn: *const vk.VkTileMemorySizeInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV => {
                const nn: *const vk.VkDisplaySurfaceStereoCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV => {
                const nn: *const vk.VkDisplayModeStereoPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatQuantizationMapPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueDeviceCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV => {
                const nn: *const vk.VkExternalComputeQueueDataParamsNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureInputInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureCommandsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureInstancesInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkBuildPartitionedAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureFlagsNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetPipelineEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetShaderEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetPipelineInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsPipelineInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsShaderInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR => {
                const nn: *const vk.VkMemoryBarrierAccessFlags3KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA => {
                const nn: *const vk.VkImageAlignmentControlCreateInfoMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceFormatPackFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE => {
                const nn: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT => {
                const nn: *const vk.VkRenderingEndInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            else => {
                log.warn(@src(), "Unknown struct sType: {d}", .{base_struct.sType});
                current = base_struct.pNext;
            },
        }
    }
}
pub fn size_of_VkBaseOutStructure(item: *const vk.VkBaseOutStructure, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBaseOutStructure);
}
pub fn size_of_VkBaseInStructure(item: *const vk.VkBaseInStructure, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBaseInStructure);
}
pub fn size_of_VkOffset2D(item: *const vk.VkOffset2D, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkOffset2D);
}
pub fn size_of_VkOffset3D(item: *const vk.VkOffset3D, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkOffset3D);
}
pub fn size_of_VkExtent2D(item: *const vk.VkExtent2D, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExtent2D);
}
pub fn size_of_VkExtent3D(item: *const vk.VkExtent3D, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExtent3D);
}
pub fn size_of_VkViewport(item: *const vk.VkViewport, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkViewport);
}
pub fn size_of_VkRect2D(item: *const vk.VkRect2D, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRect2D);
}
pub fn size_of_VkClearRect(item: *const vk.VkClearRect, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkClearRect);
}
pub fn size_of_VkComponentMapping(item: *const vk.VkComponentMapping, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkComponentMapping);
}
pub fn size_of_VkPhysicalDeviceProperties(item: *const vk.VkPhysicalDeviceProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceProperties);
}
pub fn size_of_VkExtensionProperties(item: *const vk.VkExtensionProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExtensionProperties);
}
pub fn size_of_VkLayerProperties(item: *const vk.VkLayerProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkLayerProperties);
}
pub fn size_of_VkApplicationInfo(item: *const vk.VkApplicationInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pApplicationName)) |i|
        size += @sizeOf(i);
    for (std.mem.span(item.pEngineName)) |i|
        size += @sizeOf(i);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT,
                => size += size_of_VkApplicationParametersEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkApplicationInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkApplicationInfo);
}
pub fn size_of_VkAllocationCallbacks(item: *const vk.VkAllocationCallbacks, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pUserData) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkAllocationCallbacks);
}
pub fn size_of_VkDeviceQueueCreateInfo(item: *const vk.VkDeviceQueueCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.queueCount) |_|
        size += @sizeOf(f32);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
                => size += size_of_VkDeviceQueueGlobalPriorityCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkDeviceQueueCreateInfo);
}
pub fn size_of_VkDeviceCreateInfo(item: *const vk.VkDeviceCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.queueCreateInfoCount) |i|
        size += size_of_VkDeviceQueueCreateInfo(@ptrCast(&item.pQueueCreateInfos[i]), false);
    for (0..item.enabledLayerCount) |_|
        size += @sizeOf(u8);
    for (0..item.enabledExtensionCount) |_|
        size += @sizeOf(u8);
    if (item.pEnabledFeatures) |ptr| size += size_of_VkPhysicalDeviceFeatures(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT,
                => size += size_of_VkApplicationParametersEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
                => size += size_of_VkDevicePrivateDataCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
                => size += size_of_VkPhysicalDevicePrivateDataFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
                => size += size_of_VkPhysicalDeviceFeatures2(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
                => size += size_of_VkPhysicalDeviceVariablePointersFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
                => size += size_of_VkPhysicalDeviceMultiviewFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
                => size += size_of_VkDeviceGroupDeviceCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentIdFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentId2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentWaitFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentWait2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
                => size += size_of_VkPhysicalDevice16BitStorageFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
                => size += size_of_VkPhysicalDeviceSamplerYcbcrConversionFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
                => size += size_of_VkPhysicalDeviceProtectedMemoryFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMultiDrawFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
                => size += size_of_VkPhysicalDeviceInlineUniformBlockFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
                => size += size_of_VkPhysicalDeviceMaintenance4Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
                => size += size_of_VkPhysicalDeviceMaintenance5Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
                => size += size_of_VkPhysicalDeviceMaintenance6Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance7FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance8FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance9FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderDrawParametersFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderFloat16Int8Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
                => size += size_of_VkPhysicalDeviceHostQueryResetFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
                => size += size_of_VkPhysicalDeviceGlobalPriorityQueryFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
                => size += size_of_VkDeviceDeviceMemoryReportCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
                => size += size_of_VkPhysicalDeviceDescriptorIndexingFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
                => size += size_of_VkPhysicalDeviceTimelineSemaphoreFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
                => size += size_of_VkPhysicalDevice8BitStorageFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceConditionalRenderingFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkanMemoryModelFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderAtomicInt64Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
                => size += size_of_VkPhysicalDeviceVertexAttributeDivisorFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceASTCDecodeFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceTransformFeedbackFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMeshShaderFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceAccelerationStructureFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayQueryFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
                => size += size_of_VkPhysicalDeviceScalarBlockLayoutFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
                => size += size_of_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthClipEnableFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMemoryPriorityFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
                => size += size_of_VkPhysicalDeviceBufferDeviceAddressFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
                => size += size_of_VkPhysicalDeviceImagelessFramebufferFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
                => size += size_of_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePerformanceQueryFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR,
                => size += size_of_VkPerformanceQueryReservationInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
                => size += size_of_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderClockFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
                => size += size_of_VkPhysicalDeviceIndexTypeUint8Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
                => size += size_of_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
                => size += size_of_VkPhysicalDeviceSubgroupSizeControlFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
                => size += size_of_VkPhysicalDeviceLineRasterizationFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
                => size += size_of_VkPhysicalDevicePipelineCreationCacheControlFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan11Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan12Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan13Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan14Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO,
                => size += size_of_VkFaultCallbackInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceCustomBorderColorFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
                => size += size_of_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRobustness2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
                => size += size_of_VkPhysicalDeviceImageRobustnessFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePortabilitySubsetFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
                => size += size_of_VkPhysicalDevice4444FormatsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderTerminateInvocationFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthClipControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthClampControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceColorWriteEnableFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
                => size += size_of_VkPhysicalDeviceSynchronization2Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
                => size += size_of_VkPhysicalDeviceHostImageCopyFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO,
                => size += size_of_VkDeviceObjectReservationCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkanSC10Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceLegacyDitheringFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
                => size += size_of_VkPhysicalDevicePipelineProtectedAccessFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceProvokingVertexFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDescriptorBufferFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderIntegerDotProductFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
                => size += size_of_VkPhysicalDeviceDynamicRenderingFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageViewMinLodFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePipelineBinaryFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
                => size += size_of_VkDevicePipelineBinaryInternalCacheControlKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
                => size += size_of_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageCompressionControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceOpacityMicromapFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePipelinePropertiesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
                => size += size_of_VkPhysicalDevicePipelineRobustnessFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceAddressBindingReportFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFaultFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFrameBoundaryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthBiasControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderObjectFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderTileImageFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
                => size += size_of_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
                => size += size_of_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
                => size += size_of_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderSubgroupRotateFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderExpectAssumeFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderFloatControls2Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
                => size += size_of_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderQuadControlFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderBfloat16FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
                => size += size_of_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceHdrVividFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderFloat8FeaturesEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDeviceCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkDeviceCreateInfo);
}
pub fn size_of_VkInstanceCreateInfo(item: *const vk.VkInstanceCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pApplicationInfo) |ptr| size += size_of_VkApplicationInfo(@ptrCast(ptr), false);
    for (0..item.enabledLayerCount) |_|
        size += @sizeOf(u8);
    for (0..item.enabledExtensionCount) |_|
        size += @sizeOf(u8);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
                => size += size_of_VkDebugReportCallbackCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
                => size += size_of_VkValidationFlagsEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
                => size += size_of_VkValidationFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
                => size += size_of_VkLayerSettingsCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
                => size += size_of_VkDebugUtilsMessengerCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                => size += size_of_VkExportMetalObjectCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG,
                => size += size_of_VkDirectDriverLoadingListLUNARG(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkInstanceCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkInstanceCreateInfo);
}
pub fn size_of_VkQueueFamilyProperties(item: *const vk.VkQueueFamilyProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyProperties);
}
pub fn size_of_VkPhysicalDeviceMemoryProperties(item: *const vk.VkPhysicalDeviceMemoryProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMemoryProperties);
}
pub fn size_of_VkMemoryAllocateInfo(item: *const vk.VkMemoryAllocateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
                => size += size_of_VkExportMemoryAllocateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
                => size += size_of_VkImportMemoryWin32HandleInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
                => size += size_of_VkExportMemoryWin32HandleInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
                => size += size_of_VkImportMemoryZirconHandleInfoFUCHSIA(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
                => size += size_of_VkImportMemoryFdInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
                => size += size_of_VkImportMemoryMetalHandleInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
                => size += size_of_VkMemoryAllocateFlagsInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
                => size += size_of_VkMemoryDedicatedAllocateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
                => size += size_of_VkImportMemoryHostPointerInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
                => size += size_of_VkImportAndroidHardwareBufferInfoANDROID(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
                => size += size_of_VkMemoryPriorityAllocateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
                => size += size_of_VkMemoryOpaqueCaptureAddressAllocateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
                => size += size_of_VkImportMemoryBufferCollectionFUCHSIA(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                => size += size_of_VkExportMetalObjectCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
                => size += size_of_VkImportMetalBufferInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
                => size += size_of_VkImportScreenBufferInfoQNX(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkMemoryAllocateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkMemoryAllocateInfo);
}
pub fn size_of_VkMemoryRequirements(item: *const vk.VkMemoryRequirements, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryRequirements);
}
pub fn size_of_VkSparseImageFormatProperties(item: *const vk.VkSparseImageFormatProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseImageFormatProperties);
}
pub fn size_of_VkSparseImageMemoryRequirements(item: *const vk.VkSparseImageMemoryRequirements, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseImageMemoryRequirements);
}
pub fn size_of_VkMemoryType(item: *const vk.VkMemoryType, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryType);
}
pub fn size_of_VkMemoryHeap(item: *const vk.VkMemoryHeap, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryHeap);
}
pub fn size_of_VkMappedMemoryRange(item: *const vk.VkMappedMemoryRange, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMappedMemoryRange);
}
pub fn size_of_VkFormatProperties(item: *const vk.VkFormatProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFormatProperties);
}
pub fn size_of_VkImageFormatProperties(item: *const vk.VkImageFormatProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageFormatProperties);
}
pub fn size_of_VkDescriptorBufferInfo(item: *const vk.VkDescriptorBufferInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorBufferInfo);
}
pub fn size_of_VkDescriptorImageInfo(item: *const vk.VkDescriptorImageInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorImageInfo);
}
pub fn size_of_VkWriteDescriptorSet(item: *const vk.VkWriteDescriptorSet, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorCount) |i|
        size += size_of_VkDescriptorImageInfo(@ptrCast(&item.pImageInfo[i]), false);
    for (0..item.descriptorCount) |i|
        size += size_of_VkDescriptorBufferInfo(@ptrCast(&item.pBufferInfo[i]), false);
    for (0..item.descriptorCount) |_|
        size += @sizeOf(vk.VkBufferView);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
                => size += size_of_VkWriteDescriptorSetInlineUniformBlock(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
                => size += size_of_VkWriteDescriptorSetAccelerationStructureKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSet: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkWriteDescriptorSet);
}
pub fn size_of_VkCopyDescriptorSet(item: *const vk.VkCopyDescriptorSet, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyDescriptorSet);
}
pub fn size_of_VkBufferUsageFlags2CreateInfo(item: *const vk.VkBufferUsageFlags2CreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferUsageFlags2CreateInfo);
}
pub fn size_of_VkBufferUsageFlags2CreateInfoKHR(item: *const vk.VkBufferUsageFlags2CreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferUsageFlags2CreateInfoKHR);
}
pub fn size_of_VkBufferCreateInfo(item: *const vk.VkBufferCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.queueFamilyIndexCount) |_|
        size += @sizeOf(u32);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                => size += size_of_VkBufferUsageFlags2CreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
                => size += size_of_VkExternalMemoryBufferCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
                => size += size_of_VkBufferOpaqueCaptureAddressCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
                => size += size_of_VkBufferDeviceAddressCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
                => size += size_of_VkVideoProfileListInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                => size += size_of_VkOpaqueCaptureDescriptorDataCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
                => size += size_of_VkBufferCollectionBufferCreateInfoFUCHSIA(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBufferCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkBufferCreateInfo);
}
pub fn size_of_VkBufferViewCreateInfo(item: *const vk.VkBufferViewCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                => size += size_of_VkBufferUsageFlags2CreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                => size += size_of_VkExportMetalObjectCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBufferViewCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkBufferViewCreateInfo);
}
pub fn size_of_VkImageSubresource(item: *const vk.VkImageSubresource, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSubresource);
}
pub fn size_of_VkImageSubresourceLayers(item: *const vk.VkImageSubresourceLayers, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSubresourceLayers);
}
pub fn size_of_VkImageSubresourceRange(item: *const vk.VkImageSubresourceRange, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSubresourceRange);
}
pub fn size_of_VkMemoryBarrier(item: *const vk.VkMemoryBarrier, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryBarrier);
}
pub fn size_of_VkBufferMemoryBarrier(item: *const vk.VkBufferMemoryBarrier, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
                => size += size_of_VkMemoryBarrierAccessFlags3KHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                => size += size_of_VkExternalMemoryAcquireUnmodifiedEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkBufferMemoryBarrier);
}
pub fn size_of_VkImageMemoryBarrier(item: *const vk.VkImageMemoryBarrier, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
                => size += size_of_VkSampleLocationsInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
                => size += size_of_VkMemoryBarrierAccessFlags3KHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                => size += size_of_VkExternalMemoryAcquireUnmodifiedEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkImageMemoryBarrier);
}
pub fn size_of_VkImageCreateInfo(item: *const vk.VkImageCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.queueFamilyIndexCount) |_|
        size += @sizeOf(u32);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                => size += size_of_VkExternalMemoryImageCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                => size += size_of_VkImageSwapchainCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                => size += size_of_VkImageFormatListCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                => size += size_of_VkImageDrmFormatModifierListCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                => size += size_of_VkImageDrmFormatModifierExplicitCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                => size += size_of_VkImageStencilUsageCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
                => size += size_of_VkVideoProfileListInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                => size += size_of_VkOpaqueCaptureDescriptorDataCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                => size += size_of_VkBufferCollectionImageCreateInfoFUCHSIA(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                => size += size_of_VkImageCompressionControlEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                => size += size_of_VkExportMetalObjectCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                => size += size_of_VkImportMetalTextureInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                => size += size_of_VkImportMetalIOSurfaceInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                => size += size_of_VkExternalFormatQNX(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                => size += size_of_VkImageAlignmentControlCreateInfoMESA(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkImageCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkImageCreateInfo);
}
pub fn size_of_VkSubresourceLayout(item: *const vk.VkSubresourceLayout, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubresourceLayout);
}
pub fn size_of_VkImageViewCreateInfo(item: *const vk.VkImageViewCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
                => size += size_of_VkImageViewUsageCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
                => size += size_of_VkImageViewSlicedCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
                => size += size_of_VkSamplerYcbcrConversionInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
                => size += size_of_VkImageViewASTCDecodeModeEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                => size += size_of_VkOpaqueCaptureDescriptorDataCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
                => size += size_of_VkImageViewMinLodCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                => size += size_of_VkExportMetalObjectCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkImageViewCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkImageViewCreateInfo);
}
pub fn size_of_VkBufferCopy(item: *const vk.VkBufferCopy, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCopy);
}
pub fn size_of_VkSparseMemoryBind(item: *const vk.VkSparseMemoryBind, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseMemoryBind);
}
pub fn size_of_VkSparseImageMemoryBind(item: *const vk.VkSparseImageMemoryBind, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseImageMemoryBind);
}
pub fn size_of_VkSparseBufferMemoryBindInfo(item: *const vk.VkSparseBufferMemoryBindInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.bindCount) |i|
        size += size_of_VkSparseMemoryBind(@ptrCast(&item.pBinds[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSparseBufferMemoryBindInfo);
}
pub fn size_of_VkSparseImageOpaqueMemoryBindInfo(item: *const vk.VkSparseImageOpaqueMemoryBindInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.bindCount) |i|
        size += size_of_VkSparseMemoryBind(@ptrCast(&item.pBinds[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSparseImageOpaqueMemoryBindInfo);
}
pub fn size_of_VkSparseImageMemoryBindInfo(item: *const vk.VkSparseImageMemoryBindInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.bindCount) |i|
        size += size_of_VkSparseImageMemoryBind(@ptrCast(&item.pBinds[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSparseImageMemoryBindInfo);
}
pub fn size_of_VkBindSparseInfo(item: *const vk.VkBindSparseInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.waitSemaphoreCount) |_|
        size += @sizeOf(vk.VkSemaphore);
    for (0..item.bufferBindCount) |i|
        size += size_of_VkSparseBufferMemoryBindInfo(@ptrCast(&item.pBufferBinds[i]), false);
    for (0..item.imageOpaqueBindCount) |i|
        size += size_of_VkSparseImageOpaqueMemoryBindInfo(@ptrCast(&item.pImageOpaqueBinds[i]), false);
    for (0..item.imageBindCount) |i|
        size += size_of_VkSparseImageMemoryBindInfo(@ptrCast(&item.pImageBinds[i]), false);
    for (0..item.signalSemaphoreCount) |_|
        size += @sizeOf(vk.VkSemaphore);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
                => size += size_of_VkDeviceGroupBindSparseInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
                => size += size_of_VkTimelineSemaphoreSubmitInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                => size += size_of_VkFrameBoundaryEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBindSparseInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkBindSparseInfo);
}
pub fn size_of_VkImageCopy(item: *const vk.VkImageCopy, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageCopy);
}
pub fn size_of_VkImageBlit(item: *const vk.VkImageBlit, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageBlit);
}
pub fn size_of_VkBufferImageCopy(item: *const vk.VkBufferImageCopy, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferImageCopy);
}
pub fn size_of_VkImageResolve(item: *const vk.VkImageResolve, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageResolve);
}
pub fn size_of_VkShaderModuleCreateInfo(item: *const vk.VkShaderModuleCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
                => size += size_of_VkValidationFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
                => size += size_of_VkShaderModuleValidationCacheCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkShaderModuleCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkShaderModuleCreateInfo);
}
pub fn size_of_VkDescriptorSetLayoutBinding(item: *const vk.VkDescriptorSetLayoutBinding, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorCount) |_|
        size += @sizeOf(vk.VkSampler);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDescriptorSetLayoutBinding);
}
pub fn size_of_VkDescriptorSetLayoutCreateInfo(item: *const vk.VkDescriptorSetLayoutCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.bindingCount) |i|
        size += size_of_VkDescriptorSetLayoutBinding(@ptrCast(&item.pBindings[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
                => size += size_of_VkDescriptorSetLayoutBindingFlagsCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
                => size += size_of_VkMutableDescriptorTypeCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkDescriptorSetLayoutCreateInfo);
}
pub fn size_of_VkDescriptorPoolSize(item: *const vk.VkDescriptorPoolSize, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorPoolSize);
}
pub fn size_of_VkDescriptorPoolCreateInfo(item: *const vk.VkDescriptorPoolCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.poolSizeCount) |i|
        size += size_of_VkDescriptorPoolSize(@ptrCast(&item.pPoolSizes[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
                => size += size_of_VkDescriptorPoolInlineUniformBlockCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
                => size += size_of_VkMutableDescriptorTypeCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDescriptorPoolCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkDescriptorPoolCreateInfo);
}
pub fn size_of_VkDescriptorSetAllocateInfo(item: *const vk.VkDescriptorSetAllocateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorSetCount) |_|
        size += @sizeOf(vk.VkDescriptorSetLayout);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
                => size += size_of_VkDescriptorSetVariableDescriptorCountAllocateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetAllocateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkDescriptorSetAllocateInfo);
}
pub fn size_of_VkSpecializationMapEntry(item: *const vk.VkSpecializationMapEntry, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSpecializationMapEntry);
}
pub fn size_of_VkSpecializationInfo(item: *const vk.VkSpecializationInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.mapEntryCount) |i|
        size += size_of_VkSpecializationMapEntry(@ptrCast(&item.pMapEntries[i]), false);
    for (0..item.dataSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSpecializationInfo);
}
pub fn size_of_VkPipelineShaderStageCreateInfo(item: *const vk.VkPipelineShaderStageCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pName)) |i|
        size += @sizeOf(i);
    for (std.mem.span(item.pName)) |i|
        size += @sizeOf(i);
    if (item.pSpecializationInfo) |ptr| size += size_of_VkSpecializationInfo(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                => size += size_of_VkShaderModuleCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
                => size += size_of_VkShaderModuleValidationCacheCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                => size += size_of_VkDebugUtilsObjectNameInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                => size += size_of_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                => size += size_of_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                => size += size_of_VkPipelineRobustnessCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPipelineShaderStageCreateInfo);
}
pub fn size_of_VkComputePipelineCreateInfo(item: *const vk.VkComputePipelineCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
                => size += size_of_VkPipelineCreateFlags2CreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
                => size += size_of_VkPipelineBinaryInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
                => size += size_of_VkPipelineCreationFeedbackCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
                => size += size_of_VkSubpassShadingPipelineCreateInfoHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                => size += size_of_VkPipelineRobustnessCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkComputePipelineCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkComputePipelineCreateInfo);
}
pub fn size_of_VkPipelineCreateFlags2CreateInfo(item: *const vk.VkPipelineCreateFlags2CreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCreateFlags2CreateInfo);
}
pub fn size_of_VkPipelineCreateFlags2CreateInfoKHR(item: *const vk.VkPipelineCreateFlags2CreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCreateFlags2CreateInfoKHR);
}
pub fn size_of_VkVertexInputBindingDescription(item: *const vk.VkVertexInputBindingDescription, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVertexInputBindingDescription);
}
pub fn size_of_VkVertexInputAttributeDescription(item: *const vk.VkVertexInputAttributeDescription, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVertexInputAttributeDescription);
}
pub fn size_of_VkPipelineVertexInputStateCreateInfo(item: *const vk.VkPipelineVertexInputStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.vertexBindingDescriptionCount) |i|
        size += size_of_VkVertexInputBindingDescription(@ptrCast(&item.pVertexBindingDescriptions[i]), false);
    for (0..item.vertexAttributeDescriptionCount) |i|
        size += size_of_VkVertexInputAttributeDescription(@ptrCast(&item.pVertexAttributeDescriptions[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
                => size += size_of_VkPipelineVertexInputDivisorStateCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPipelineVertexInputStateCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPipelineVertexInputStateCreateInfo);
}
pub fn size_of_VkPipelineInputAssemblyStateCreateInfo(item: *const vk.VkPipelineInputAssemblyStateCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineInputAssemblyStateCreateInfo);
}
pub fn size_of_VkPipelineTessellationStateCreateInfo(item: *const vk.VkPipelineTessellationStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
                => size += size_of_VkPipelineTessellationDomainOriginStateCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPipelineTessellationStateCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPipelineTessellationStateCreateInfo);
}
pub fn size_of_VkPipelineViewportStateCreateInfo(item: *const vk.VkPipelineViewportStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.viewportCount) |i|
        size += size_of_VkViewport(@ptrCast(&item.pViewports[i]), false);
    for (0..item.scissorCount) |i|
        size += size_of_VkRect2D(@ptrCast(&item.pScissors[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
                => size += size_of_VkPipelineViewportDepthClipControlCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
                => size += size_of_VkPipelineViewportDepthClampControlCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportStateCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPipelineViewportStateCreateInfo);
}
pub fn size_of_VkPipelineRasterizationStateCreateInfo(item: *const vk.VkPipelineRasterizationStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
                => size += size_of_VkPipelineRasterizationConservativeStateCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
                => size += size_of_VkPipelineRasterizationStateStreamCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
                => size += size_of_VkPipelineRasterizationDepthClipStateCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
                => size += size_of_VkPipelineRasterizationLineStateCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
                => size += size_of_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
                => size += size_of_VkDepthBiasRepresentationInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPipelineRasterizationStateCreateInfo);
}
pub fn size_of_VkPipelineMultisampleStateCreateInfo(item: *const vk.VkPipelineMultisampleStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
                => size += size_of_VkPipelineSampleLocationsStateCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPipelineMultisampleStateCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPipelineMultisampleStateCreateInfo);
}
pub fn size_of_VkPipelineColorBlendAttachmentState(item: *const vk.VkPipelineColorBlendAttachmentState, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineColorBlendAttachmentState);
}
pub fn size_of_VkPipelineColorBlendStateCreateInfo(item: *const vk.VkPipelineColorBlendStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentCount) |i|
        size += size_of_VkPipelineColorBlendAttachmentState(@ptrCast(&item.pAttachments[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
                => size += size_of_VkPipelineColorBlendAdvancedStateCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
                => size += size_of_VkPipelineColorWriteCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPipelineColorBlendStateCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPipelineColorBlendStateCreateInfo);
}
pub fn size_of_VkPipelineDynamicStateCreateInfo(item: *const vk.VkPipelineDynamicStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.dynamicStateCount) |_|
        size += @sizeOf(vk.VkDynamicState);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineDynamicStateCreateInfo);
}
pub fn size_of_VkStencilOpState(item: *const vk.VkStencilOpState, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkStencilOpState);
}
pub fn size_of_VkPipelineDepthStencilStateCreateInfo(item: *const vk.VkPipelineDepthStencilStateCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineDepthStencilStateCreateInfo);
}
pub fn size_of_VkGraphicsPipelineCreateInfo(item: *const vk.VkGraphicsPipelineCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.stageCount) |i|
        size += size_of_VkPipelineShaderStageCreateInfo(@ptrCast(&item.pStages[i]), false);
    for (0..item.stageCount) |i|
        size += size_of_VkPipelineShaderStageCreateInfo(@ptrCast(&item.pStages[i]), false);
    if (item.pVertexInputState) |ptr| size += size_of_VkPipelineVertexInputStateCreateInfo(@ptrCast(ptr), false);
    if (item.pInputAssemblyState) |ptr| size += size_of_VkPipelineInputAssemblyStateCreateInfo(@ptrCast(ptr), false);
    if (item.pTessellationState) |ptr| size += size_of_VkPipelineTessellationStateCreateInfo(@ptrCast(ptr), false);
    if (item.pViewportState) |ptr| size += size_of_VkPipelineViewportStateCreateInfo(@ptrCast(ptr), false);
    if (item.pRasterizationState) |ptr| size += size_of_VkPipelineRasterizationStateCreateInfo(@ptrCast(ptr), false);
    if (item.pMultisampleState) |ptr| size += size_of_VkPipelineMultisampleStateCreateInfo(@ptrCast(ptr), false);
    if (item.pDepthStencilState) |ptr| size += size_of_VkPipelineDepthStencilStateCreateInfo(@ptrCast(ptr), false);
    if (item.pColorBlendState) |ptr| size += size_of_VkPipelineColorBlendStateCreateInfo(@ptrCast(ptr), false);
    if (item.pDynamicState) |ptr| size += size_of_VkPipelineDynamicStateCreateInfo(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
                => size += size_of_VkPipelineCreateFlags2CreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
                => size += size_of_VkPipelineBinaryInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
                => size += size_of_VkPipelineDiscardRectangleStateCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
                => size += size_of_VkPipelineCreationFeedbackCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
                => size += size_of_VkPipelineLibraryCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
                => size += size_of_VkPipelineFragmentShadingRateStateCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
                => size += size_of_VkPipelineRenderingCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
                => size += size_of_VkGraphicsPipelineLibraryCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                => size += size_of_VkPipelineRobustnessCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
                => size += size_of_VkRenderingAttachmentLocationInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
                => size += size_of_VkRenderingInputAttachmentIndexInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE,
                => size += size_of_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkGraphicsPipelineCreateInfo);
}
pub fn size_of_VkPipelineCacheCreateInfo(item: *const vk.VkPipelineCacheCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.initialDataSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineCacheCreateInfo);
}
pub fn size_of_VkPipelineCacheHeaderVersionOne(item: *const vk.VkPipelineCacheHeaderVersionOne, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCacheHeaderVersionOne);
}
pub fn size_of_VkPipelineCacheStageValidationIndexEntry(item: *const vk.VkPipelineCacheStageValidationIndexEntry, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCacheStageValidationIndexEntry);
}
pub fn size_of_VkPipelineCacheSafetyCriticalIndexEntry(item: *const vk.VkPipelineCacheSafetyCriticalIndexEntry, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCacheSafetyCriticalIndexEntry);
}
pub fn size_of_VkPipelineCacheHeaderVersionSafetyCriticalOne(item: *const vk.VkPipelineCacheHeaderVersionSafetyCriticalOne, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCacheHeaderVersionSafetyCriticalOne);
}
pub fn size_of_VkPushConstantRange(item: *const vk.VkPushConstantRange, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPushConstantRange);
}
pub fn size_of_VkPipelineBinaryCreateInfoKHR(item: *const vk.VkPipelineBinaryCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pKeysAndDataInfo) |ptr| size += size_of_VkPipelineBinaryKeysAndDataKHR(@ptrCast(ptr), false);
    if (item.pPipelineCreateInfo) |ptr| size += size_of_VkPipelineCreateInfoKHR(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineBinaryCreateInfoKHR);
}
pub fn size_of_VkPipelineBinaryHandlesInfoKHR(item: *const vk.VkPipelineBinaryHandlesInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.pipelineBinaryCount) |_|
        size += @sizeOf(vk.VkPipelineBinaryKHR);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineBinaryHandlesInfoKHR);
}
pub fn size_of_VkPipelineBinaryDataKHR(item: *const vk.VkPipelineBinaryDataKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.dataSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineBinaryDataKHR);
}
pub fn size_of_VkPipelineBinaryKeysAndDataKHR(item: *const vk.VkPipelineBinaryKeysAndDataKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.binaryCount) |i|
        size += size_of_VkPipelineBinaryKeyKHR(@ptrCast(&item.pPipelineBinaryKeys[i]), false);
    for (0..item.binaryCount) |i|
        size += size_of_VkPipelineBinaryDataKHR(@ptrCast(&item.pPipelineBinaryData[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineBinaryKeysAndDataKHR);
}
pub fn size_of_VkPipelineBinaryKeyKHR(item: *const vk.VkPipelineBinaryKeyKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineBinaryKeyKHR);
}
pub fn size_of_VkPipelineBinaryInfoKHR(item: *const vk.VkPipelineBinaryInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.binaryCount) |_|
        size += @sizeOf(vk.VkPipelineBinaryKHR);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineBinaryInfoKHR);
}
pub fn size_of_VkReleaseCapturedPipelineDataInfoKHR(item: *const vk.VkReleaseCapturedPipelineDataInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkReleaseCapturedPipelineDataInfoKHR);
}
pub fn size_of_VkPipelineBinaryDataInfoKHR(item: *const vk.VkPipelineBinaryDataInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineBinaryDataInfoKHR);
}
pub fn size_of_VkPipelineCreateInfoKHR(item: *const vk.VkPipelineCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCreateInfoKHR);
}
pub fn size_of_VkPipelineLayoutCreateInfo(item: *const vk.VkPipelineLayoutCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.setLayoutCount) |_|
        size += @sizeOf(vk.VkDescriptorSetLayout);
    for (0..item.pushConstantRangeCount) |i|
        size += size_of_VkPushConstantRange(@ptrCast(&item.pPushConstantRanges[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineLayoutCreateInfo);
}
pub fn size_of_VkSamplerCreateInfo(item: *const vk.VkSamplerCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
                => size += size_of_VkSamplerYcbcrConversionInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
                => size += size_of_VkSamplerReductionModeCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
                => size += size_of_VkSamplerCustomBorderColorCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
                => size += size_of_VkSamplerBorderColorComponentMappingCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                => size += size_of_VkOpaqueCaptureDescriptorDataCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSamplerCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSamplerCreateInfo);
}
pub fn size_of_VkCommandPoolCreateInfo(item: *const vk.VkCommandPoolCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO,
                => size += size_of_VkCommandPoolMemoryReservationCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkCommandPoolCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkCommandPoolCreateInfo);
}
pub fn size_of_VkCommandBufferAllocateInfo(item: *const vk.VkCommandBufferAllocateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCommandBufferAllocateInfo);
}
pub fn size_of_VkCommandBufferInheritanceInfo(item: *const vk.VkCommandBufferInheritanceInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
                => size += size_of_VkCommandBufferInheritanceConditionalRenderingInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
                => size += size_of_VkCommandBufferInheritanceRenderingInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
                => size += size_of_VkRenderingAttachmentLocationInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
                => size += size_of_VkRenderingInputAttachmentIndexInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkCommandBufferInheritanceInfo);
}
pub fn size_of_VkCommandBufferBeginInfo(item: *const vk.VkCommandBufferBeginInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pInheritanceInfo) |ptr| size += size_of_VkCommandBufferInheritanceInfo(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
                => size += size_of_VkDeviceGroupCommandBufferBeginInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkCommandBufferBeginInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkCommandBufferBeginInfo);
}
pub fn size_of_VkRenderPassBeginInfo(item: *const vk.VkRenderPassBeginInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.clearValueCount) |_|
        size += @sizeOf(vk.VkClearValue);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
                => size += size_of_VkDeviceGroupRenderPassBeginInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
                => size += size_of_VkRenderPassSampleLocationsBeginInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
                => size += size_of_VkRenderPassAttachmentBeginInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkRenderPassBeginInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkRenderPassBeginInfo);
}
pub fn size_of_VkClearDepthStencilValue(item: *const vk.VkClearDepthStencilValue, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkClearDepthStencilValue);
}
pub fn size_of_VkClearAttachment(item: *const vk.VkClearAttachment, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkClearAttachment);
}
pub fn size_of_VkAttachmentDescription(item: *const vk.VkAttachmentDescription, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentDescription);
}
pub fn size_of_VkAttachmentReference(item: *const vk.VkAttachmentReference, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentReference);
}
pub fn size_of_VkSubpassDescription(item: *const vk.VkSubpassDescription, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.inputAttachmentCount) |i|
        size += size_of_VkAttachmentReference(@ptrCast(&item.pInputAttachments[i]), false);
    for (0..item.colorAttachmentCount) |i|
        size += size_of_VkAttachmentReference(@ptrCast(&item.pColorAttachments[i]), false);
    for (0..item.colorAttachmentCount) |i|
        size += size_of_VkAttachmentReference(@ptrCast(&item.pResolveAttachments[i]), false);
    if (item.pDepthStencilAttachment) |ptr| size += size_of_VkAttachmentReference(@ptrCast(ptr), false);
    for (0..item.preserveAttachmentCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSubpassDescription);
}
pub fn size_of_VkSubpassDependency(item: *const vk.VkSubpassDependency, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassDependency);
}
pub fn size_of_VkRenderPassCreateInfo(item: *const vk.VkRenderPassCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentCount) |i|
        size += size_of_VkAttachmentDescription(@ptrCast(&item.pAttachments[i]), false);
    for (0..item.subpassCount) |i|
        size += size_of_VkSubpassDescription(@ptrCast(&item.pSubpasses[i]), false);
    for (0..item.dependencyCount) |i|
        size += size_of_VkSubpassDependency(@ptrCast(&item.pDependencies[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
                => size += size_of_VkRenderPassMultiviewCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
                => size += size_of_VkRenderPassInputAttachmentAspectCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
                => size += size_of_VkRenderPassFragmentDensityMapCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
                => size += size_of_VkRenderPassCreationControlEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
                => size += size_of_VkRenderPassCreationFeedbackCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkRenderPassCreateInfo);
}
pub fn size_of_VkEventCreateInfo(item: *const vk.VkEventCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                => size += size_of_VkExportMetalObjectCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
                => size += size_of_VkImportMetalSharedEventInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkEventCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkEventCreateInfo);
}
pub fn size_of_VkFenceCreateInfo(item: *const vk.VkFenceCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
                => size += size_of_VkExportFenceCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
                => size += size_of_VkExportFenceWin32HandleInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkFenceCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkFenceCreateInfo);
}
pub fn size_of_VkPhysicalDeviceFeatures(item: *const vk.VkPhysicalDeviceFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFeatures);
}
pub fn size_of_VkPhysicalDeviceSparseProperties(item: *const vk.VkPhysicalDeviceSparseProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSparseProperties);
}
pub fn size_of_VkPhysicalDeviceLimits(item: *const vk.VkPhysicalDeviceLimits, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLimits);
}
pub fn size_of_VkSemaphoreCreateInfo(item: *const vk.VkSemaphoreCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
                => size += size_of_VkExportSemaphoreCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
                => size += size_of_VkExportSemaphoreWin32HandleInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
                => size += size_of_VkSemaphoreTypeCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                => size += size_of_VkExportMetalObjectCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
                => size += size_of_VkImportMetalSharedEventInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSemaphoreCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSemaphoreCreateInfo);
}
pub fn size_of_VkQueryPoolCreateInfo(item: *const vk.VkQueryPoolCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
                => size += size_of_VkQueryPoolPerformanceCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
                => size += size_of_VkQueryPoolPerformanceQueryCreateInfoINTEL(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
                => size += size_of_VkVideoProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
                => size += size_of_VkVideoDecodeUsageInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeH264ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeH265ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeVP9ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeAV1ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
                => size += size_of_VkVideoEncodeUsageInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
                => size += size_of_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
                => size += size_of_VkVideoEncodeH264ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
                => size += size_of_VkVideoEncodeH265ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1ProfileInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkQueryPoolCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkQueryPoolCreateInfo);
}
pub fn size_of_VkFramebufferCreateInfo(item: *const vk.VkFramebufferCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentCount) |_|
        size += @sizeOf(vk.VkImageView);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
                => size += size_of_VkFramebufferAttachmentsCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkFramebufferCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkFramebufferCreateInfo);
}
pub fn size_of_VkDrawIndirectCommand(item: *const vk.VkDrawIndirectCommand, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDrawIndirectCommand);
}
pub fn size_of_VkDrawIndexedIndirectCommand(item: *const vk.VkDrawIndexedIndirectCommand, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDrawIndexedIndirectCommand);
}
pub fn size_of_VkDispatchIndirectCommand(item: *const vk.VkDispatchIndirectCommand, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDispatchIndirectCommand);
}
pub fn size_of_VkMultiDrawInfoEXT(item: *const vk.VkMultiDrawInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMultiDrawInfoEXT);
}
pub fn size_of_VkMultiDrawIndexedInfoEXT(item: *const vk.VkMultiDrawIndexedInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMultiDrawIndexedInfoEXT);
}
pub fn size_of_VkSubmitInfo(item: *const vk.VkSubmitInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.waitSemaphoreCount) |_|
        size += @sizeOf(vk.VkSemaphore);
    for (0..item.waitSemaphoreCount) |_|
        size += @sizeOf(vk.VkPipelineStageFlags);
    for (0..item.commandBufferCount) |_|
        size += @sizeOf(vk.VkCommandBuffer);
    for (0..item.signalSemaphoreCount) |_|
        size += @sizeOf(vk.VkSemaphore);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
                => size += size_of_VkWin32KeyedMutexAcquireReleaseInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
                => size += size_of_VkD3D12FenceSubmitInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
                => size += size_of_VkDeviceGroupSubmitInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
                => size += size_of_VkProtectedSubmitInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
                => size += size_of_VkTimelineSemaphoreSubmitInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
                => size += size_of_VkPerformanceQuerySubmitInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                => size += size_of_VkFrameBoundaryEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkSubmitInfo);
}
pub fn size_of_VkDisplayPropertiesKHR(item: *const vk.VkDisplayPropertiesKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.displayName)) |i|
        size += @sizeOf(i);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDisplayPropertiesKHR);
}
pub fn size_of_VkDisplayPlanePropertiesKHR(item: *const vk.VkDisplayPlanePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayPlanePropertiesKHR);
}
pub fn size_of_VkDisplayModeParametersKHR(item: *const vk.VkDisplayModeParametersKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayModeParametersKHR);
}
pub fn size_of_VkDisplayModePropertiesKHR(item: *const vk.VkDisplayModePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayModePropertiesKHR);
}
pub fn size_of_VkDisplayModeCreateInfoKHR(item: *const vk.VkDisplayModeCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayModeCreateInfoKHR);
}
pub fn size_of_VkDisplayPlaneCapabilitiesKHR(item: *const vk.VkDisplayPlaneCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayPlaneCapabilitiesKHR);
}
pub fn size_of_VkDisplaySurfaceCreateInfoKHR(item: *const vk.VkDisplaySurfaceCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplaySurfaceCreateInfoKHR);
}
pub fn size_of_VkDisplayPresentInfoKHR(item: *const vk.VkDisplayPresentInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayPresentInfoKHR);
}
pub fn size_of_VkSurfaceCapabilitiesKHR(item: *const vk.VkSurfaceCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceCapabilitiesKHR);
}
pub fn size_of_VkAndroidSurfaceCreateInfoKHR(item: *const vk.VkAndroidSurfaceCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.window) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkAndroidSurfaceCreateInfoKHR);
}
pub fn size_of_VkViSurfaceCreateInfoNN(item: *const vk.VkViSurfaceCreateInfoNN, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.window) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkViSurfaceCreateInfoNN);
}
pub fn size_of_VkWaylandSurfaceCreateInfoKHR(item: *const vk.VkWaylandSurfaceCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.display) |ptr| size += @sizeOf(ptr.*);
    if (item.surface) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkWaylandSurfaceCreateInfoKHR);
}
pub fn size_of_VkWin32SurfaceCreateInfoKHR(item: *const vk.VkWin32SurfaceCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkWin32SurfaceCreateInfoKHR);
}
pub fn size_of_VkXlibSurfaceCreateInfoKHR(item: *const vk.VkXlibSurfaceCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.dpy) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkXlibSurfaceCreateInfoKHR);
}
pub fn size_of_VkXcbSurfaceCreateInfoKHR(item: *const vk.VkXcbSurfaceCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.connection) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkXcbSurfaceCreateInfoKHR);
}
pub fn size_of_VkDirectFBSurfaceCreateInfoEXT(item: *const vk.VkDirectFBSurfaceCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.dfb) |ptr| size += @sizeOf(ptr.*);
    if (item.surface) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDirectFBSurfaceCreateInfoEXT);
}
pub fn size_of_VkImagePipeSurfaceCreateInfoFUCHSIA(item: *const vk.VkImagePipeSurfaceCreateInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImagePipeSurfaceCreateInfoFUCHSIA);
}
pub fn size_of_VkScreenSurfaceCreateInfoQNX(item: *const vk.VkScreenSurfaceCreateInfoQNX, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.context) |ptr| size += @sizeOf(ptr.*);
    if (item.window) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkScreenSurfaceCreateInfoQNX);
}
pub fn size_of_VkSurfaceFormatKHR(item: *const vk.VkSurfaceFormatKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceFormatKHR);
}
pub fn size_of_VkSwapchainCreateInfoKHR(item: *const vk.VkSwapchainCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.queueFamilyIndexCount) |_|
        size += @sizeOf(u32);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
                => size += size_of_VkSwapchainCounterCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
                => size += size_of_VkDeviceGroupSwapchainCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                => size += size_of_VkImageFormatListCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
                => size += size_of_VkSurfaceFullScreenExclusiveInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
                => size += size_of_VkSurfaceFullScreenExclusiveWin32InfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                => size += size_of_VkImageCompressionControlEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
                => size += size_of_VkSwapchainPresentModesCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR,
                => size += size_of_VkSwapchainPresentScalingCreateInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSwapchainCreateInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkSwapchainCreateInfoKHR);
}
pub fn size_of_VkPresentInfoKHR(item: *const vk.VkPresentInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.waitSemaphoreCount) |_|
        size += @sizeOf(vk.VkSemaphore);
    for (0..item.swapchainCount) |_|
        size += @sizeOf(vk.VkSwapchainKHR);
    for (0..item.swapchainCount) |_|
        size += @sizeOf(u32);
    for (0..item.swapchainCount) |_|
        size += @sizeOf(vk.VkResult);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
                => size += size_of_VkDisplayPresentInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
                => size += size_of_VkPresentRegionsKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
                => size += size_of_VkDeviceGroupPresentInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PRESENT_ID_KHR,
                => size += size_of_VkPresentIdKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR,
                => size += size_of_VkPresentId2KHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                => size += size_of_VkFrameBoundaryEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
                => size += size_of_VkSwapchainPresentFenceInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
                => size += size_of_VkSwapchainPresentModeInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPresentInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPresentInfoKHR);
}
pub fn size_of_VkDebugReportCallbackCreateInfoEXT(item: *const vk.VkDebugReportCallbackCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pUserData) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugReportCallbackCreateInfoEXT);
}
pub fn size_of_VkValidationFlagsEXT(item: *const vk.VkValidationFlagsEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.disabledValidationCheckCount) |_|
        size += @sizeOf(vk.VkValidationCheckEXT);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkValidationFlagsEXT);
}
pub fn size_of_VkValidationFeaturesEXT(item: *const vk.VkValidationFeaturesEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.enabledValidationFeatureCount) |_|
        size += @sizeOf(vk.VkValidationFeatureEnableEXT);
    for (0..item.disabledValidationFeatureCount) |_|
        size += @sizeOf(vk.VkValidationFeatureDisableEXT);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkValidationFeaturesEXT);
}
pub fn size_of_VkLayerSettingsCreateInfoEXT(item: *const vk.VkLayerSettingsCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.settingCount) |i|
        size += size_of_VkLayerSettingEXT(@ptrCast(&item.pSettings[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkLayerSettingsCreateInfoEXT);
}
pub fn size_of_VkLayerSettingEXT(item: *const vk.VkLayerSettingEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pLayerName)) |i|
        size += @sizeOf(i);
    for (std.mem.span(item.pSettingName)) |i|
        size += @sizeOf(i);
    for (0..item.valueCount) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkLayerSettingEXT);
}
pub fn size_of_VkApplicationParametersEXT(item: *const vk.VkApplicationParametersEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkApplicationParametersEXT);
}
pub fn size_of_VkDebugMarkerObjectNameInfoEXT(item: *const vk.VkDebugMarkerObjectNameInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pObjectName)) |i|
        size += @sizeOf(i);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugMarkerObjectNameInfoEXT);
}
pub fn size_of_VkDebugMarkerObjectTagInfoEXT(item: *const vk.VkDebugMarkerObjectTagInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.tagSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugMarkerObjectTagInfoEXT);
}
pub fn size_of_VkDebugMarkerMarkerInfoEXT(item: *const vk.VkDebugMarkerMarkerInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pMarkerName)) |i|
        size += @sizeOf(i);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugMarkerMarkerInfoEXT);
}
pub fn size_of_VkDevicePrivateDataCreateInfo(item: *const vk.VkDevicePrivateDataCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDevicePrivateDataCreateInfo);
}
pub fn size_of_VkDevicePrivateDataCreateInfoEXT(item: *const vk.VkDevicePrivateDataCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDevicePrivateDataCreateInfoEXT);
}
pub fn size_of_VkPrivateDataSlotCreateInfo(item: *const vk.VkPrivateDataSlotCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPrivateDataSlotCreateInfo);
}
pub fn size_of_VkPrivateDataSlotCreateInfoEXT(item: *const vk.VkPrivateDataSlotCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPrivateDataSlotCreateInfoEXT);
}
pub fn size_of_VkPhysicalDevicePrivateDataFeatures(item: *const vk.VkPhysicalDevicePrivateDataFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePrivateDataFeatures);
}
pub fn size_of_VkPhysicalDevicePrivateDataFeaturesEXT(item: *const vk.VkPhysicalDevicePrivateDataFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePrivateDataFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceMultiDrawPropertiesEXT(item: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMultiDrawPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceFeatures2(item: *const vk.VkPhysicalDeviceFeatures2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
                => size += size_of_VkPhysicalDevicePrivateDataFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
                => size += size_of_VkPhysicalDeviceVariablePointersFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
                => size += size_of_VkPhysicalDeviceMultiviewFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentIdFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentId2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentWaitFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentWait2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
                => size += size_of_VkPhysicalDevice16BitStorageFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
                => size += size_of_VkPhysicalDeviceSamplerYcbcrConversionFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
                => size += size_of_VkPhysicalDeviceProtectedMemoryFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMultiDrawFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
                => size += size_of_VkPhysicalDeviceInlineUniformBlockFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
                => size += size_of_VkPhysicalDeviceMaintenance4Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
                => size += size_of_VkPhysicalDeviceMaintenance5Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
                => size += size_of_VkPhysicalDeviceMaintenance6Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance7FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance8FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance9FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderDrawParametersFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderFloat16Int8Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
                => size += size_of_VkPhysicalDeviceHostQueryResetFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
                => size += size_of_VkPhysicalDeviceGlobalPriorityQueryFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
                => size += size_of_VkPhysicalDeviceDescriptorIndexingFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
                => size += size_of_VkPhysicalDeviceTimelineSemaphoreFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
                => size += size_of_VkPhysicalDevice8BitStorageFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceConditionalRenderingFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkanMemoryModelFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderAtomicInt64Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
                => size += size_of_VkPhysicalDeviceVertexAttributeDivisorFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceASTCDecodeFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceTransformFeedbackFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMeshShaderFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceAccelerationStructureFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayQueryFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
                => size += size_of_VkPhysicalDeviceScalarBlockLayoutFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
                => size += size_of_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthClipEnableFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMemoryPriorityFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
                => size += size_of_VkPhysicalDeviceBufferDeviceAddressFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
                => size += size_of_VkPhysicalDeviceImagelessFramebufferFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
                => size += size_of_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePerformanceQueryFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
                => size += size_of_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderClockFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
                => size += size_of_VkPhysicalDeviceIndexTypeUint8Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
                => size += size_of_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
                => size += size_of_VkPhysicalDeviceSubgroupSizeControlFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
                => size += size_of_VkPhysicalDeviceLineRasterizationFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
                => size += size_of_VkPhysicalDevicePipelineCreationCacheControlFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan11Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan12Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan13Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkan14Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceCustomBorderColorFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
                => size += size_of_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRobustness2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
                => size += size_of_VkPhysicalDeviceImageRobustnessFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePortabilitySubsetFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
                => size += size_of_VkPhysicalDevice4444FormatsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderTerminateInvocationFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthClipControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthClampControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceColorWriteEnableFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
                => size += size_of_VkPhysicalDeviceSynchronization2Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
                => size += size_of_VkPhysicalDeviceHostImageCopyFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES,
                => size += size_of_VkPhysicalDeviceVulkanSC10Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceLegacyDitheringFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
                => size += size_of_VkPhysicalDevicePipelineProtectedAccessFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceProvokingVertexFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDescriptorBufferFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderIntegerDotProductFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
                => size += size_of_VkPhysicalDeviceDynamicRenderingFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageViewMinLodFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePipelineBinaryFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
                => size += size_of_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageCompressionControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceOpacityMicromapFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePipelinePropertiesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
                => size += size_of_VkPhysicalDevicePipelineRobustnessFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceAddressBindingReportFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFaultFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
                => size += size_of_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceFrameBoundaryFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceDepthBiasControlFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderObjectFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderTileImageFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
                => size += size_of_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
                => size += size_of_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
                => size += size_of_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderSubgroupRotateFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderExpectAssumeFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
                => size += size_of_VkPhysicalDeviceShaderFloatControls2Features(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
                => size += size_of_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderQuadControlFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceShaderBfloat16FeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
                => size += size_of_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
                => size += size_of_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceHdrVividFeaturesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
                => size += size_of_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
                => size += size_of_VkPhysicalDeviceShaderFloat8FeaturesEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFeatures2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceFeatures2);
}
pub fn size_of_VkPhysicalDeviceFeatures2KHR(item: *const vk.VkPhysicalDeviceFeatures2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFeatures2KHR);
}
pub fn size_of_VkPhysicalDeviceProperties2(item: *const vk.VkPhysicalDeviceProperties2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceMultiDrawPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
                => size += size_of_VkPhysicalDevicePushDescriptorProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
                => size += size_of_VkPhysicalDeviceDriverProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
                => size += size_of_VkPhysicalDeviceIDProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
                => size += size_of_VkPhysicalDeviceMultiviewProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceDiscardRectanglePropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
                => size += size_of_VkPhysicalDeviceSubgroupProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
                => size += size_of_VkPhysicalDevicePointClippingProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
                => size += size_of_VkPhysicalDeviceProtectedMemoryProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
                => size += size_of_VkPhysicalDeviceSamplerFilterMinmaxProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceSampleLocationsPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
                => size += size_of_VkPhysicalDeviceInlineUniformBlockProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
                => size += size_of_VkPhysicalDeviceMaintenance3Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
                => size += size_of_VkPhysicalDeviceMaintenance4Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
                => size += size_of_VkPhysicalDeviceMaintenance5Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
                => size += size_of_VkPhysicalDeviceMaintenance6Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance7PropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
                => size += size_of_VkPhysicalDeviceLayeredApiPropertiesListKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceMaintenance9PropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
                => size += size_of_VkPhysicalDeviceFloatControlsProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
                => size += size_of_VkPhysicalDeviceDescriptorIndexingProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
                => size += size_of_VkPhysicalDeviceTimelineSemaphoreProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
                => size += size_of_VkPhysicalDeviceVertexAttributeDivisorProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDevicePCIBusInfoPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
                => size += size_of_VkPhysicalDeviceDepthStencilResolveProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceTransformFeedbackPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceMeshShaderPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceAccelerationStructurePropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDevicePerformanceQueryPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
                => size += size_of_VkPhysicalDeviceTexelBufferAlignmentProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
                => size += size_of_VkPhysicalDeviceSubgroupSizeControlProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
                => size += size_of_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
                => size += size_of_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
                => size += size_of_VkPhysicalDeviceLineRasterizationProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
                => size += size_of_VkPhysicalDeviceVulkan11Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
                => size += size_of_VkPhysicalDeviceVulkan12Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
                => size += size_of_VkPhysicalDeviceVulkan13Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES,
                => size += size_of_VkPhysicalDeviceVulkan14Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceCustomBorderColorPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceRobustness2PropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDevicePortabilitySubsetPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
                => size += size_of_VkPhysicalDeviceHostImageCopyProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES,
                => size += size_of_VkPhysicalDeviceVulkanSC10Properties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceProvokingVertexPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceDescriptorBufferPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
                => size += size_of_VkPhysicalDeviceShaderIntegerDotProductProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceDrmPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDevicePipelineBinaryPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceOpacityMicromapPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
                => size += size_of_VkPhysicalDevicePipelineRobustnessProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceShaderObjectPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceShaderTileImagePropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
                => size += size_of_VkPhysicalDeviceLayeredDriverPropertiesMSFT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID,
                => size += size_of_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
                => size += size_of_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE,
                => size += size_of_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProperties2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceProperties2);
}
pub fn size_of_VkPhysicalDeviceProperties2KHR(item: *const vk.VkPhysicalDeviceProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceProperties2KHR);
}
pub fn size_of_VkFormatProperties2(item: *const vk.VkFormatProperties2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
                => size += size_of_VkDrmFormatModifierPropertiesListEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT,
                => size += size_of_VkSubpassResolvePerformanceQueryEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
                => size += size_of_VkFormatProperties3(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT,
                => size += size_of_VkDrmFormatModifierPropertiesList2EXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkFormatProperties2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkFormatProperties2);
}
pub fn size_of_VkFormatProperties2KHR(item: *const vk.VkFormatProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFormatProperties2KHR);
}
pub fn size_of_VkImageFormatProperties2(item: *const vk.VkImageFormatProperties2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
                => size += size_of_VkExternalImageFormatProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
                => size += size_of_VkSamplerYcbcrConversionImageFormatProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
                => size += size_of_VkAndroidHardwareBufferUsageANDROID(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
                => size += size_of_VkFilterCubicImageViewImageFormatPropertiesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
                => size += size_of_VkHostImageCopyDevicePerformanceQuery(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
                => size += size_of_VkImageCompressionPropertiesEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkImageFormatProperties2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkImageFormatProperties2);
}
pub fn size_of_VkImageFormatProperties2KHR(item: *const vk.VkImageFormatProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageFormatProperties2KHR);
}
pub fn size_of_VkPhysicalDeviceImageFormatInfo2(item: *const vk.VkPhysicalDeviceImageFormatInfo2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
                => size += size_of_VkPhysicalDeviceExternalImageFormatInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                => size += size_of_VkImageFormatListCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
                => size += size_of_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                => size += size_of_VkImageStencilUsageCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
                => size += size_of_VkPhysicalDeviceImageViewImageFormatInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
                => size += size_of_VkVideoProfileListInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                => size += size_of_VkImageCompressionControlEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageFormatInfo2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceImageFormatInfo2);
}
pub fn size_of_VkPhysicalDeviceImageFormatInfo2KHR(item: *const vk.VkPhysicalDeviceImageFormatInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageFormatInfo2KHR);
}
pub fn size_of_VkQueueFamilyProperties2(item: *const vk.VkQueueFamilyProperties2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR,
                => size += size_of_VkQueueFamilyOwnershipTransferPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
                => size += size_of_VkQueueFamilyGlobalPriorityProperties(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR,
                => size += size_of_VkQueueFamilyVideoPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
                => size += size_of_VkQueueFamilyQueryResultStatusPropertiesKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyProperties2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkQueueFamilyProperties2);
}
pub fn size_of_VkQueueFamilyProperties2KHR(item: *const vk.VkQueueFamilyProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyProperties2KHR);
}
pub fn size_of_VkPhysicalDeviceMemoryProperties2(item: *const vk.VkPhysicalDeviceMemoryProperties2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
                => size += size_of_VkPhysicalDeviceMemoryBudgetPropertiesEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryProperties2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceMemoryProperties2);
}
pub fn size_of_VkPhysicalDeviceMemoryProperties2KHR(item: *const vk.VkPhysicalDeviceMemoryProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMemoryProperties2KHR);
}
pub fn size_of_VkSparseImageFormatProperties2(item: *const vk.VkSparseImageFormatProperties2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseImageFormatProperties2);
}
pub fn size_of_VkSparseImageFormatProperties2KHR(item: *const vk.VkSparseImageFormatProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseImageFormatProperties2KHR);
}
pub fn size_of_VkPhysicalDeviceSparseImageFormatInfo2(item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSparseImageFormatInfo2);
}
pub fn size_of_VkPhysicalDeviceSparseImageFormatInfo2KHR(item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSparseImageFormatInfo2KHR);
}
pub fn size_of_VkPhysicalDevicePushDescriptorProperties(item: *const vk.VkPhysicalDevicePushDescriptorProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePushDescriptorProperties);
}
pub fn size_of_VkPhysicalDevicePushDescriptorPropertiesKHR(item: *const vk.VkPhysicalDevicePushDescriptorPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePushDescriptorPropertiesKHR);
}
pub fn size_of_VkConformanceVersion(item: *const vk.VkConformanceVersion, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkConformanceVersion);
}
pub fn size_of_VkConformanceVersionKHR(item: *const vk.VkConformanceVersionKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkConformanceVersionKHR);
}
pub fn size_of_VkPhysicalDeviceDriverProperties(item: *const vk.VkPhysicalDeviceDriverProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDriverProperties);
}
pub fn size_of_VkPhysicalDeviceDriverPropertiesKHR(item: *const vk.VkPhysicalDeviceDriverPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDriverPropertiesKHR);
}
pub fn size_of_VkPresentRegionsKHR(item: *const vk.VkPresentRegionsKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.swapchainCount) |i|
        size += size_of_VkPresentRegionKHR(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPresentRegionsKHR);
}
pub fn size_of_VkPresentRegionKHR(item: *const vk.VkPresentRegionKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.rectangleCount) |i|
        size += size_of_VkRectLayerKHR(@ptrCast(&item.pRectangles[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPresentRegionKHR);
}
pub fn size_of_VkRectLayerKHR(item: *const vk.VkRectLayerKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRectLayerKHR);
}
pub fn size_of_VkPhysicalDeviceVariablePointersFeatures(item: *const vk.VkPhysicalDeviceVariablePointersFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVariablePointersFeatures);
}
pub fn size_of_VkPhysicalDeviceVariablePointersFeaturesKHR(item: *const vk.VkPhysicalDeviceVariablePointersFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVariablePointersFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceVariablePointerFeaturesKHR(item: *const vk.VkPhysicalDeviceVariablePointerFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVariablePointerFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceVariablePointerFeatures(item: *const vk.VkPhysicalDeviceVariablePointerFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVariablePointerFeatures);
}
pub fn size_of_VkExternalMemoryProperties(item: *const vk.VkExternalMemoryProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalMemoryProperties);
}
pub fn size_of_VkExternalMemoryPropertiesKHR(item: *const vk.VkExternalMemoryPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalMemoryPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceExternalImageFormatInfo(item: *const vk.VkPhysicalDeviceExternalImageFormatInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalImageFormatInfo);
}
pub fn size_of_VkPhysicalDeviceExternalImageFormatInfoKHR(item: *const vk.VkPhysicalDeviceExternalImageFormatInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalImageFormatInfoKHR);
}
pub fn size_of_VkExternalImageFormatProperties(item: *const vk.VkExternalImageFormatProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalImageFormatProperties);
}
pub fn size_of_VkExternalImageFormatPropertiesKHR(item: *const vk.VkExternalImageFormatPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalImageFormatPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceExternalBufferInfo(item: *const vk.VkPhysicalDeviceExternalBufferInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                => size += size_of_VkBufferUsageFlags2CreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalBufferInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceExternalBufferInfo);
}
pub fn size_of_VkPhysicalDeviceExternalBufferInfoKHR(item: *const vk.VkPhysicalDeviceExternalBufferInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalBufferInfoKHR);
}
pub fn size_of_VkExternalBufferProperties(item: *const vk.VkExternalBufferProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalBufferProperties);
}
pub fn size_of_VkExternalBufferPropertiesKHR(item: *const vk.VkExternalBufferPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalBufferPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceIDProperties(item: *const vk.VkPhysicalDeviceIDProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceIDProperties);
}
pub fn size_of_VkPhysicalDeviceIDPropertiesKHR(item: *const vk.VkPhysicalDeviceIDPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceIDPropertiesKHR);
}
pub fn size_of_VkExternalMemoryImageCreateInfo(item: *const vk.VkExternalMemoryImageCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalMemoryImageCreateInfo);
}
pub fn size_of_VkExternalMemoryImageCreateInfoKHR(item: *const vk.VkExternalMemoryImageCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalMemoryImageCreateInfoKHR);
}
pub fn size_of_VkExternalMemoryBufferCreateInfo(item: *const vk.VkExternalMemoryBufferCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalMemoryBufferCreateInfo);
}
pub fn size_of_VkExternalMemoryBufferCreateInfoKHR(item: *const vk.VkExternalMemoryBufferCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalMemoryBufferCreateInfoKHR);
}
pub fn size_of_VkExportMemoryAllocateInfo(item: *const vk.VkExportMemoryAllocateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMemoryAllocateInfo);
}
pub fn size_of_VkExportMemoryAllocateInfoKHR(item: *const vk.VkExportMemoryAllocateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMemoryAllocateInfoKHR);
}
pub fn size_of_VkImportMemoryWin32HandleInfoKHR(item: *const vk.VkImportMemoryWin32HandleInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMemoryWin32HandleInfoKHR);
}
pub fn size_of_VkExportMemoryWin32HandleInfoKHR(item: *const vk.VkExportMemoryWin32HandleInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pAttributes) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkExportMemoryWin32HandleInfoKHR);
}
pub fn size_of_VkImportMemoryZirconHandleInfoFUCHSIA(item: *const vk.VkImportMemoryZirconHandleInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMemoryZirconHandleInfoFUCHSIA);
}
pub fn size_of_VkMemoryZirconHandlePropertiesFUCHSIA(item: *const vk.VkMemoryZirconHandlePropertiesFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryZirconHandlePropertiesFUCHSIA);
}
pub fn size_of_VkMemoryGetZirconHandleInfoFUCHSIA(item: *const vk.VkMemoryGetZirconHandleInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryGetZirconHandleInfoFUCHSIA);
}
pub fn size_of_VkMemoryWin32HandlePropertiesKHR(item: *const vk.VkMemoryWin32HandlePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryWin32HandlePropertiesKHR);
}
pub fn size_of_VkMemoryGetWin32HandleInfoKHR(item: *const vk.VkMemoryGetWin32HandleInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryGetWin32HandleInfoKHR);
}
pub fn size_of_VkImportMemoryFdInfoKHR(item: *const vk.VkImportMemoryFdInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMemoryFdInfoKHR);
}
pub fn size_of_VkMemoryFdPropertiesKHR(item: *const vk.VkMemoryFdPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryFdPropertiesKHR);
}
pub fn size_of_VkMemoryGetFdInfoKHR(item: *const vk.VkMemoryGetFdInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryGetFdInfoKHR);
}
pub fn size_of_VkWin32KeyedMutexAcquireReleaseInfoKHR(item: *const vk.VkWin32KeyedMutexAcquireReleaseInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.acquireCount) |_|
        size += @sizeOf(vk.VkDeviceMemory);
    for (0..item.acquireCount) |_|
        size += @sizeOf(u64);
    for (0..item.acquireCount) |_|
        size += @sizeOf(u32);
    for (0..item.releaseCount) |_|
        size += @sizeOf(vk.VkDeviceMemory);
    for (0..item.releaseCount) |_|
        size += @sizeOf(u64);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkWin32KeyedMutexAcquireReleaseInfoKHR);
}
pub fn size_of_VkImportMemoryMetalHandleInfoEXT(item: *const vk.VkImportMemoryMetalHandleInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.handle) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImportMemoryMetalHandleInfoEXT);
}
pub fn size_of_VkMemoryMetalHandlePropertiesEXT(item: *const vk.VkMemoryMetalHandlePropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryMetalHandlePropertiesEXT);
}
pub fn size_of_VkMemoryGetMetalHandleInfoEXT(item: *const vk.VkMemoryGetMetalHandleInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryGetMetalHandleInfoEXT);
}
pub fn size_of_VkPhysicalDeviceExternalSemaphoreInfo(item: *const vk.VkPhysicalDeviceExternalSemaphoreInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
                => size += size_of_VkSemaphoreTypeCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalSemaphoreInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceExternalSemaphoreInfo);
}
pub fn size_of_VkPhysicalDeviceExternalSemaphoreInfoKHR(item: *const vk.VkPhysicalDeviceExternalSemaphoreInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalSemaphoreInfoKHR);
}
pub fn size_of_VkExternalSemaphoreProperties(item: *const vk.VkExternalSemaphoreProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalSemaphoreProperties);
}
pub fn size_of_VkExternalSemaphorePropertiesKHR(item: *const vk.VkExternalSemaphorePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalSemaphorePropertiesKHR);
}
pub fn size_of_VkExportSemaphoreCreateInfo(item: *const vk.VkExportSemaphoreCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportSemaphoreCreateInfo);
}
pub fn size_of_VkExportSemaphoreCreateInfoKHR(item: *const vk.VkExportSemaphoreCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportSemaphoreCreateInfoKHR);
}
pub fn size_of_VkImportSemaphoreWin32HandleInfoKHR(item: *const vk.VkImportSemaphoreWin32HandleInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportSemaphoreWin32HandleInfoKHR);
}
pub fn size_of_VkExportSemaphoreWin32HandleInfoKHR(item: *const vk.VkExportSemaphoreWin32HandleInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pAttributes) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkExportSemaphoreWin32HandleInfoKHR);
}
pub fn size_of_VkD3D12FenceSubmitInfoKHR(item: *const vk.VkD3D12FenceSubmitInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.waitSemaphoreValuesCount) |_|
        size += @sizeOf(u64);
    for (0..item.signalSemaphoreValuesCount) |_|
        size += @sizeOf(u64);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkD3D12FenceSubmitInfoKHR);
}
pub fn size_of_VkSemaphoreGetWin32HandleInfoKHR(item: *const vk.VkSemaphoreGetWin32HandleInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreGetWin32HandleInfoKHR);
}
pub fn size_of_VkImportSemaphoreFdInfoKHR(item: *const vk.VkImportSemaphoreFdInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportSemaphoreFdInfoKHR);
}
pub fn size_of_VkSemaphoreGetFdInfoKHR(item: *const vk.VkSemaphoreGetFdInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreGetFdInfoKHR);
}
pub fn size_of_VkImportSemaphoreZirconHandleInfoFUCHSIA(item: *const vk.VkImportSemaphoreZirconHandleInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportSemaphoreZirconHandleInfoFUCHSIA);
}
pub fn size_of_VkSemaphoreGetZirconHandleInfoFUCHSIA(item: *const vk.VkSemaphoreGetZirconHandleInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreGetZirconHandleInfoFUCHSIA);
}
pub fn size_of_VkPhysicalDeviceExternalFenceInfo(item: *const vk.VkPhysicalDeviceExternalFenceInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalFenceInfo);
}
pub fn size_of_VkPhysicalDeviceExternalFenceInfoKHR(item: *const vk.VkPhysicalDeviceExternalFenceInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalFenceInfoKHR);
}
pub fn size_of_VkExternalFenceProperties(item: *const vk.VkExternalFenceProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalFenceProperties);
}
pub fn size_of_VkExternalFencePropertiesKHR(item: *const vk.VkExternalFencePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalFencePropertiesKHR);
}
pub fn size_of_VkExportFenceCreateInfo(item: *const vk.VkExportFenceCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportFenceCreateInfo);
}
pub fn size_of_VkExportFenceCreateInfoKHR(item: *const vk.VkExportFenceCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportFenceCreateInfoKHR);
}
pub fn size_of_VkImportFenceWin32HandleInfoKHR(item: *const vk.VkImportFenceWin32HandleInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportFenceWin32HandleInfoKHR);
}
pub fn size_of_VkExportFenceWin32HandleInfoKHR(item: *const vk.VkExportFenceWin32HandleInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pAttributes) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkExportFenceWin32HandleInfoKHR);
}
pub fn size_of_VkFenceGetWin32HandleInfoKHR(item: *const vk.VkFenceGetWin32HandleInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFenceGetWin32HandleInfoKHR);
}
pub fn size_of_VkImportFenceFdInfoKHR(item: *const vk.VkImportFenceFdInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportFenceFdInfoKHR);
}
pub fn size_of_VkFenceGetFdInfoKHR(item: *const vk.VkFenceGetFdInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFenceGetFdInfoKHR);
}
pub fn size_of_VkPhysicalDeviceMultiviewFeatures(item: *const vk.VkPhysicalDeviceMultiviewFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMultiviewFeatures);
}
pub fn size_of_VkPhysicalDeviceMultiviewFeaturesKHR(item: *const vk.VkPhysicalDeviceMultiviewFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMultiviewFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMultiviewProperties(item: *const vk.VkPhysicalDeviceMultiviewProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMultiviewProperties);
}
pub fn size_of_VkPhysicalDeviceMultiviewPropertiesKHR(item: *const vk.VkPhysicalDeviceMultiviewPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMultiviewPropertiesKHR);
}
pub fn size_of_VkRenderPassMultiviewCreateInfo(item: *const vk.VkRenderPassMultiviewCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.subpassCount) |_|
        size += @sizeOf(u32);
    for (0..item.dependencyCount) |_|
        size += @sizeOf(i32);
    for (0..item.correlationMaskCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderPassMultiviewCreateInfo);
}
pub fn size_of_VkRenderPassMultiviewCreateInfoKHR(item: *const vk.VkRenderPassMultiviewCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassMultiviewCreateInfoKHR);
}
pub fn size_of_VkSurfaceCapabilities2EXT(item: *const vk.VkSurfaceCapabilities2EXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceCapabilities2EXT);
}
pub fn size_of_VkDisplayPowerInfoEXT(item: *const vk.VkDisplayPowerInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayPowerInfoEXT);
}
pub fn size_of_VkDeviceEventInfoEXT(item: *const vk.VkDeviceEventInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceEventInfoEXT);
}
pub fn size_of_VkDisplayEventInfoEXT(item: *const vk.VkDisplayEventInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayEventInfoEXT);
}
pub fn size_of_VkSwapchainCounterCreateInfoEXT(item: *const vk.VkSwapchainCounterCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainCounterCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceGroupProperties(item: *const vk.VkPhysicalDeviceGroupProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceGroupProperties);
}
pub fn size_of_VkPhysicalDeviceGroupPropertiesKHR(item: *const vk.VkPhysicalDeviceGroupPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceGroupPropertiesKHR);
}
pub fn size_of_VkMemoryAllocateFlagsInfo(item: *const vk.VkMemoryAllocateFlagsInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryAllocateFlagsInfo);
}
pub fn size_of_VkMemoryAllocateFlagsInfoKHR(item: *const vk.VkMemoryAllocateFlagsInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryAllocateFlagsInfoKHR);
}
pub fn size_of_VkBindBufferMemoryInfo(item: *const vk.VkBindBufferMemoryInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
                => size += size_of_VkBindBufferMemoryDeviceGroupInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
                => size += size_of_VkBindMemoryStatus(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBindBufferMemoryInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkBindBufferMemoryInfo);
}
pub fn size_of_VkBindBufferMemoryInfoKHR(item: *const vk.VkBindBufferMemoryInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindBufferMemoryInfoKHR);
}
pub fn size_of_VkBindBufferMemoryDeviceGroupInfo(item: *const vk.VkBindBufferMemoryDeviceGroupInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.deviceIndexCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkBindBufferMemoryDeviceGroupInfo);
}
pub fn size_of_VkBindBufferMemoryDeviceGroupInfoKHR(item: *const vk.VkBindBufferMemoryDeviceGroupInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindBufferMemoryDeviceGroupInfoKHR);
}
pub fn size_of_VkBindImageMemoryInfo(item: *const vk.VkBindImageMemoryInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
                => size += size_of_VkBindImageMemoryDeviceGroupInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
                => size += size_of_VkBindImageMemorySwapchainInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
                => size += size_of_VkBindImagePlaneMemoryInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
                => size += size_of_VkBindMemoryStatus(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBindImageMemoryInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkBindImageMemoryInfo);
}
pub fn size_of_VkBindImageMemoryInfoKHR(item: *const vk.VkBindImageMemoryInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindImageMemoryInfoKHR);
}
pub fn size_of_VkBindImageMemoryDeviceGroupInfo(item: *const vk.VkBindImageMemoryDeviceGroupInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.deviceIndexCount) |_|
        size += @sizeOf(u32);
    for (0..item.splitInstanceBindRegionCount) |i|
        size += size_of_VkRect2D(@ptrCast(&item.pSplitInstanceBindRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkBindImageMemoryDeviceGroupInfo);
}
pub fn size_of_VkBindImageMemoryDeviceGroupInfoKHR(item: *const vk.VkBindImageMemoryDeviceGroupInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindImageMemoryDeviceGroupInfoKHR);
}
pub fn size_of_VkDeviceGroupRenderPassBeginInfo(item: *const vk.VkDeviceGroupRenderPassBeginInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.deviceRenderAreaCount) |i|
        size += size_of_VkRect2D(@ptrCast(&item.pDeviceRenderAreas[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceGroupRenderPassBeginInfo);
}
pub fn size_of_VkDeviceGroupRenderPassBeginInfoKHR(item: *const vk.VkDeviceGroupRenderPassBeginInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupRenderPassBeginInfoKHR);
}
pub fn size_of_VkDeviceGroupCommandBufferBeginInfo(item: *const vk.VkDeviceGroupCommandBufferBeginInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupCommandBufferBeginInfo);
}
pub fn size_of_VkDeviceGroupCommandBufferBeginInfoKHR(item: *const vk.VkDeviceGroupCommandBufferBeginInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupCommandBufferBeginInfoKHR);
}
pub fn size_of_VkDeviceGroupSubmitInfo(item: *const vk.VkDeviceGroupSubmitInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.waitSemaphoreCount) |_|
        size += @sizeOf(u32);
    for (0..item.commandBufferCount) |_|
        size += @sizeOf(u32);
    for (0..item.signalSemaphoreCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceGroupSubmitInfo);
}
pub fn size_of_VkDeviceGroupSubmitInfoKHR(item: *const vk.VkDeviceGroupSubmitInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupSubmitInfoKHR);
}
pub fn size_of_VkDeviceGroupBindSparseInfo(item: *const vk.VkDeviceGroupBindSparseInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupBindSparseInfo);
}
pub fn size_of_VkDeviceGroupBindSparseInfoKHR(item: *const vk.VkDeviceGroupBindSparseInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupBindSparseInfoKHR);
}
pub fn size_of_VkDeviceGroupPresentCapabilitiesKHR(item: *const vk.VkDeviceGroupPresentCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupPresentCapabilitiesKHR);
}
pub fn size_of_VkImageSwapchainCreateInfoKHR(item: *const vk.VkImageSwapchainCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSwapchainCreateInfoKHR);
}
pub fn size_of_VkBindImageMemorySwapchainInfoKHR(item: *const vk.VkBindImageMemorySwapchainInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindImageMemorySwapchainInfoKHR);
}
pub fn size_of_VkAcquireNextImageInfoKHR(item: *const vk.VkAcquireNextImageInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAcquireNextImageInfoKHR);
}
pub fn size_of_VkDeviceGroupPresentInfoKHR(item: *const vk.VkDeviceGroupPresentInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.swapchainCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceGroupPresentInfoKHR);
}
pub fn size_of_VkDeviceGroupDeviceCreateInfo(item: *const vk.VkDeviceGroupDeviceCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.physicalDeviceCount) |_|
        size += @sizeOf(vk.VkPhysicalDevice);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceGroupDeviceCreateInfo);
}
pub fn size_of_VkDeviceGroupDeviceCreateInfoKHR(item: *const vk.VkDeviceGroupDeviceCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupDeviceCreateInfoKHR);
}
pub fn size_of_VkDeviceGroupSwapchainCreateInfoKHR(item: *const vk.VkDeviceGroupSwapchainCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceGroupSwapchainCreateInfoKHR);
}
pub fn size_of_VkDescriptorUpdateTemplateEntry(item: *const vk.VkDescriptorUpdateTemplateEntry, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorUpdateTemplateEntry);
}
pub fn size_of_VkDescriptorUpdateTemplateEntryKHR(item: *const vk.VkDescriptorUpdateTemplateEntryKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorUpdateTemplateEntryKHR);
}
pub fn size_of_VkDescriptorUpdateTemplateCreateInfo(item: *const vk.VkDescriptorUpdateTemplateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorUpdateEntryCount) |i|
        size += size_of_VkDescriptorUpdateTemplateEntry(@ptrCast(&item.pDescriptorUpdateEntries[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDescriptorUpdateTemplateCreateInfo);
}
pub fn size_of_VkDescriptorUpdateTemplateCreateInfoKHR(item: *const vk.VkDescriptorUpdateTemplateCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorUpdateTemplateCreateInfoKHR);
}
pub fn size_of_VkXYColorEXT(item: *const vk.VkXYColorEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkXYColorEXT);
}
pub fn size_of_VkPhysicalDevicePresentIdFeaturesKHR(item: *const vk.VkPhysicalDevicePresentIdFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePresentIdFeaturesKHR);
}
pub fn size_of_VkPresentIdKHR(item: *const vk.VkPresentIdKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.swapchainCount) |_|
        size += @sizeOf(u64);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPresentIdKHR);
}
pub fn size_of_VkPhysicalDevicePresentId2FeaturesKHR(item: *const vk.VkPhysicalDevicePresentId2FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePresentId2FeaturesKHR);
}
pub fn size_of_VkPresentId2KHR(item: *const vk.VkPresentId2KHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.swapchainCount) |_|
        size += @sizeOf(u64);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPresentId2KHR);
}
pub fn size_of_VkPresentWait2InfoKHR(item: *const vk.VkPresentWait2InfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPresentWait2InfoKHR);
}
pub fn size_of_VkPhysicalDevicePresentWaitFeaturesKHR(item: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePresentWaitFeaturesKHR);
}
pub fn size_of_VkPhysicalDevicePresentWait2FeaturesKHR(item: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePresentWait2FeaturesKHR);
}
pub fn size_of_VkHdrMetadataEXT(item: *const vk.VkHdrMetadataEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkHdrMetadataEXT);
}
pub fn size_of_VkHdrVividDynamicMetadataHUAWEI(item: *const vk.VkHdrVividDynamicMetadataHUAWEI, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.dynamicMetadataSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkHdrVividDynamicMetadataHUAWEI);
}
pub fn size_of_VkIOSSurfaceCreateInfoMVK(item: *const vk.VkIOSSurfaceCreateInfoMVK, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pView) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkIOSSurfaceCreateInfoMVK);
}
pub fn size_of_VkMacOSSurfaceCreateInfoMVK(item: *const vk.VkMacOSSurfaceCreateInfoMVK, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pView) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkMacOSSurfaceCreateInfoMVK);
}
pub fn size_of_VkMetalSurfaceCreateInfoEXT(item: *const vk.VkMetalSurfaceCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pLayer) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkMetalSurfaceCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceDiscardRectanglePropertiesEXT(item: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT);
}
pub fn size_of_VkPipelineDiscardRectangleStateCreateInfoEXT(item: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.discardRectangleCount) |i|
        size += size_of_VkRect2D(@ptrCast(&item.pDiscardRectangles[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineDiscardRectangleStateCreateInfoEXT);
}
pub fn size_of_VkInputAttachmentAspectReference(item: *const vk.VkInputAttachmentAspectReference, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkInputAttachmentAspectReference);
}
pub fn size_of_VkInputAttachmentAspectReferenceKHR(item: *const vk.VkInputAttachmentAspectReferenceKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkInputAttachmentAspectReferenceKHR);
}
pub fn size_of_VkRenderPassInputAttachmentAspectCreateInfo(item: *const vk.VkRenderPassInputAttachmentAspectCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.aspectReferenceCount) |i|
        size += size_of_VkInputAttachmentAspectReference(@ptrCast(&item.pAspectReferences[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderPassInputAttachmentAspectCreateInfo);
}
pub fn size_of_VkRenderPassInputAttachmentAspectCreateInfoKHR(item: *const vk.VkRenderPassInputAttachmentAspectCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassInputAttachmentAspectCreateInfoKHR);
}
pub fn size_of_VkPhysicalDeviceSurfaceInfo2KHR(item: *const vk.VkPhysicalDeviceSurfaceInfo2KHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
                => size += size_of_VkSurfaceFullScreenExclusiveInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
                => size += size_of_VkSurfaceFullScreenExclusiveWin32InfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
                => size += size_of_VkSurfacePresentModeKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSurfaceInfo2KHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceSurfaceInfo2KHR);
}
pub fn size_of_VkSurfaceCapabilities2KHR(item: *const vk.VkSurfaceCapabilities2KHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
                => size += size_of_VkSharedPresentSurfaceCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
                => size += size_of_VkSurfaceProtectedCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
                => size += size_of_VkSurfaceCapabilitiesFullScreenExclusiveEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR,
                => size += size_of_VkSurfaceCapabilitiesPresentId2KHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR,
                => size += size_of_VkSurfaceCapabilitiesPresentWait2KHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR,
                => size += size_of_VkSurfacePresentScalingCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
                => size += size_of_VkSurfacePresentModeCompatibilityKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilities2KHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSurfaceCapabilities2KHR);
}
pub fn size_of_VkSurfaceFormat2KHR(item: *const vk.VkSurfaceFormat2KHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
                => size += size_of_VkImageCompressionPropertiesEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSurfaceFormat2KHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSurfaceFormat2KHR);
}
pub fn size_of_VkDisplayProperties2KHR(item: *const vk.VkDisplayProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayProperties2KHR);
}
pub fn size_of_VkDisplayPlaneProperties2KHR(item: *const vk.VkDisplayPlaneProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayPlaneProperties2KHR);
}
pub fn size_of_VkDisplayModeProperties2KHR(item: *const vk.VkDisplayModeProperties2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayModeProperties2KHR);
}
pub fn size_of_VkDisplayPlaneInfo2KHR(item: *const vk.VkDisplayPlaneInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayPlaneInfo2KHR);
}
pub fn size_of_VkDisplayPlaneCapabilities2KHR(item: *const vk.VkDisplayPlaneCapabilities2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDisplayPlaneCapabilities2KHR);
}
pub fn size_of_VkSharedPresentSurfaceCapabilitiesKHR(item: *const vk.VkSharedPresentSurfaceCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSharedPresentSurfaceCapabilitiesKHR);
}
pub fn size_of_VkPhysicalDevice16BitStorageFeatures(item: *const vk.VkPhysicalDevice16BitStorageFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevice16BitStorageFeatures);
}
pub fn size_of_VkPhysicalDevice16BitStorageFeaturesKHR(item: *const vk.VkPhysicalDevice16BitStorageFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevice16BitStorageFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceSubgroupProperties(item: *const vk.VkPhysicalDeviceSubgroupProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubgroupProperties);
}
pub fn size_of_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR);
}
pub fn size_of_VkBufferMemoryRequirementsInfo2(item: *const vk.VkBufferMemoryRequirementsInfo2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferMemoryRequirementsInfo2);
}
pub fn size_of_VkBufferMemoryRequirementsInfo2KHR(item: *const vk.VkBufferMemoryRequirementsInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferMemoryRequirementsInfo2KHR);
}
pub fn size_of_VkDeviceBufferMemoryRequirements(item: *const vk.VkDeviceBufferMemoryRequirements, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pCreateInfo) |ptr| size += size_of_VkBufferCreateInfo(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceBufferMemoryRequirements);
}
pub fn size_of_VkDeviceBufferMemoryRequirementsKHR(item: *const vk.VkDeviceBufferMemoryRequirementsKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceBufferMemoryRequirementsKHR);
}
pub fn size_of_VkImageMemoryRequirementsInfo2(item: *const vk.VkImageMemoryRequirementsInfo2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
                => size += size_of_VkImagePlaneMemoryRequirementsInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkImageMemoryRequirementsInfo2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkImageMemoryRequirementsInfo2);
}
pub fn size_of_VkImageMemoryRequirementsInfo2KHR(item: *const vk.VkImageMemoryRequirementsInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageMemoryRequirementsInfo2KHR);
}
pub fn size_of_VkImageSparseMemoryRequirementsInfo2(item: *const vk.VkImageSparseMemoryRequirementsInfo2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSparseMemoryRequirementsInfo2);
}
pub fn size_of_VkImageSparseMemoryRequirementsInfo2KHR(item: *const vk.VkImageSparseMemoryRequirementsInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSparseMemoryRequirementsInfo2KHR);
}
pub fn size_of_VkDeviceImageMemoryRequirements(item: *const vk.VkDeviceImageMemoryRequirements, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pCreateInfo) |ptr| size += size_of_VkImageCreateInfo(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceImageMemoryRequirements);
}
pub fn size_of_VkDeviceImageMemoryRequirementsKHR(item: *const vk.VkDeviceImageMemoryRequirementsKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceImageMemoryRequirementsKHR);
}
pub fn size_of_VkMemoryRequirements2(item: *const vk.VkMemoryRequirements2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
                => size += size_of_VkMemoryDedicatedRequirements(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkMemoryRequirements2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkMemoryRequirements2);
}
pub fn size_of_VkMemoryRequirements2KHR(item: *const vk.VkMemoryRequirements2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryRequirements2KHR);
}
pub fn size_of_VkSparseImageMemoryRequirements2(item: *const vk.VkSparseImageMemoryRequirements2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseImageMemoryRequirements2);
}
pub fn size_of_VkSparseImageMemoryRequirements2KHR(item: *const vk.VkSparseImageMemoryRequirements2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSparseImageMemoryRequirements2KHR);
}
pub fn size_of_VkPhysicalDevicePointClippingProperties(item: *const vk.VkPhysicalDevicePointClippingProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePointClippingProperties);
}
pub fn size_of_VkPhysicalDevicePointClippingPropertiesKHR(item: *const vk.VkPhysicalDevicePointClippingPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePointClippingPropertiesKHR);
}
pub fn size_of_VkMemoryDedicatedRequirements(item: *const vk.VkMemoryDedicatedRequirements, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryDedicatedRequirements);
}
pub fn size_of_VkMemoryDedicatedRequirementsKHR(item: *const vk.VkMemoryDedicatedRequirementsKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryDedicatedRequirementsKHR);
}
pub fn size_of_VkMemoryDedicatedAllocateInfo(item: *const vk.VkMemoryDedicatedAllocateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryDedicatedAllocateInfo);
}
pub fn size_of_VkMemoryDedicatedAllocateInfoKHR(item: *const vk.VkMemoryDedicatedAllocateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryDedicatedAllocateInfoKHR);
}
pub fn size_of_VkImageViewUsageCreateInfo(item: *const vk.VkImageViewUsageCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageViewUsageCreateInfo);
}
pub fn size_of_VkImageViewSlicedCreateInfoEXT(item: *const vk.VkImageViewSlicedCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageViewSlicedCreateInfoEXT);
}
pub fn size_of_VkImageViewUsageCreateInfoKHR(item: *const vk.VkImageViewUsageCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageViewUsageCreateInfoKHR);
}
pub fn size_of_VkPipelineTessellationDomainOriginStateCreateInfo(item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineTessellationDomainOriginStateCreateInfo);
}
pub fn size_of_VkPipelineTessellationDomainOriginStateCreateInfoKHR(item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineTessellationDomainOriginStateCreateInfoKHR);
}
pub fn size_of_VkSamplerYcbcrConversionInfo(item: *const vk.VkSamplerYcbcrConversionInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerYcbcrConversionInfo);
}
pub fn size_of_VkSamplerYcbcrConversionInfoKHR(item: *const vk.VkSamplerYcbcrConversionInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerYcbcrConversionInfoKHR);
}
pub fn size_of_VkSamplerYcbcrConversionCreateInfo(item: *const vk.VkSamplerYcbcrConversionCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                => size += size_of_VkExternalFormatQNX(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionCreateInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSamplerYcbcrConversionCreateInfo);
}
pub fn size_of_VkSamplerYcbcrConversionCreateInfoKHR(item: *const vk.VkSamplerYcbcrConversionCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerYcbcrConversionCreateInfoKHR);
}
pub fn size_of_VkBindImagePlaneMemoryInfo(item: *const vk.VkBindImagePlaneMemoryInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindImagePlaneMemoryInfo);
}
pub fn size_of_VkBindImagePlaneMemoryInfoKHR(item: *const vk.VkBindImagePlaneMemoryInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindImagePlaneMemoryInfoKHR);
}
pub fn size_of_VkImagePlaneMemoryRequirementsInfo(item: *const vk.VkImagePlaneMemoryRequirementsInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImagePlaneMemoryRequirementsInfo);
}
pub fn size_of_VkImagePlaneMemoryRequirementsInfoKHR(item: *const vk.VkImagePlaneMemoryRequirementsInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImagePlaneMemoryRequirementsInfoKHR);
}
pub fn size_of_VkPhysicalDeviceSamplerYcbcrConversionFeatures(item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures);
}
pub fn size_of_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR);
}
pub fn size_of_VkSamplerYcbcrConversionImageFormatProperties(item: *const vk.VkSamplerYcbcrConversionImageFormatProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerYcbcrConversionImageFormatProperties);
}
pub fn size_of_VkSamplerYcbcrConversionImageFormatPropertiesKHR(item: *const vk.VkSamplerYcbcrConversionImageFormatPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerYcbcrConversionImageFormatPropertiesKHR);
}
pub fn size_of_VkConditionalRenderingBeginInfoEXT(item: *const vk.VkConditionalRenderingBeginInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkConditionalRenderingBeginInfoEXT);
}
pub fn size_of_VkProtectedSubmitInfo(item: *const vk.VkProtectedSubmitInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkProtectedSubmitInfo);
}
pub fn size_of_VkPhysicalDeviceProtectedMemoryFeatures(item: *const vk.VkPhysicalDeviceProtectedMemoryFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceProtectedMemoryFeatures);
}
pub fn size_of_VkPhysicalDeviceProtectedMemoryProperties(item: *const vk.VkPhysicalDeviceProtectedMemoryProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceProtectedMemoryProperties);
}
pub fn size_of_VkDeviceQueueInfo2(item: *const vk.VkDeviceQueueInfo2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceQueueInfo2);
}
pub fn size_of_VkPhysicalDeviceSamplerFilterMinmaxProperties(item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSamplerFilterMinmaxProperties);
}
pub fn size_of_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT);
}
pub fn size_of_VkSampleLocationEXT(item: *const vk.VkSampleLocationEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSampleLocationEXT);
}
pub fn size_of_VkSampleLocationsInfoEXT(item: *const vk.VkSampleLocationsInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.sampleLocationsCount) |i|
        size += size_of_VkSampleLocationEXT(@ptrCast(&item.pSampleLocations[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSampleLocationsInfoEXT);
}
pub fn size_of_VkAttachmentSampleLocationsEXT(item: *const vk.VkAttachmentSampleLocationsEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentSampleLocationsEXT);
}
pub fn size_of_VkSubpassSampleLocationsEXT(item: *const vk.VkSubpassSampleLocationsEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassSampleLocationsEXT);
}
pub fn size_of_VkRenderPassSampleLocationsBeginInfoEXT(item: *const vk.VkRenderPassSampleLocationsBeginInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentInitialSampleLocationsCount) |i|
        size += size_of_VkAttachmentSampleLocationsEXT(@ptrCast(&item.pAttachmentInitialSampleLocations[i]), false);
    for (0..item.postSubpassSampleLocationsCount) |i|
        size += size_of_VkSubpassSampleLocationsEXT(@ptrCast(&item.pPostSubpassSampleLocations[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderPassSampleLocationsBeginInfoEXT);
}
pub fn size_of_VkPipelineSampleLocationsStateCreateInfoEXT(item: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineSampleLocationsStateCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceSampleLocationsPropertiesEXT(item: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSampleLocationsPropertiesEXT);
}
pub fn size_of_VkMultisamplePropertiesEXT(item: *const vk.VkMultisamplePropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMultisamplePropertiesEXT);
}
pub fn size_of_VkSamplerReductionModeCreateInfo(item: *const vk.VkSamplerReductionModeCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerReductionModeCreateInfo);
}
pub fn size_of_VkSamplerReductionModeCreateInfoEXT(item: *const vk.VkSamplerReductionModeCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerReductionModeCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(item: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceMultiDrawFeaturesEXT(item: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMultiDrawFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(item: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
}
pub fn size_of_VkPipelineColorBlendAdvancedStateCreateInfoEXT(item: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceInlineUniformBlockFeatures(item: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceInlineUniformBlockFeatures);
}
pub fn size_of_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(item: *const vk.VkPhysicalDeviceInlineUniformBlockFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceInlineUniformBlockFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceInlineUniformBlockProperties(item: *const vk.VkPhysicalDeviceInlineUniformBlockProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceInlineUniformBlockProperties);
}
pub fn size_of_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(item: *const vk.VkPhysicalDeviceInlineUniformBlockPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceInlineUniformBlockPropertiesEXT);
}
pub fn size_of_VkWriteDescriptorSetInlineUniformBlock(item: *const vk.VkWriteDescriptorSetInlineUniformBlock, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.dataSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkWriteDescriptorSetInlineUniformBlock);
}
pub fn size_of_VkWriteDescriptorSetInlineUniformBlockEXT(item: *const vk.VkWriteDescriptorSetInlineUniformBlockEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkWriteDescriptorSetInlineUniformBlockEXT);
}
pub fn size_of_VkDescriptorPoolInlineUniformBlockCreateInfo(item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorPoolInlineUniformBlockCreateInfo);
}
pub fn size_of_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorPoolInlineUniformBlockCreateInfoEXT);
}
pub fn size_of_VkImageFormatListCreateInfo(item: *const vk.VkImageFormatListCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.viewFormatCount) |_|
        size += @sizeOf(vk.VkFormat);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImageFormatListCreateInfo);
}
pub fn size_of_VkImageFormatListCreateInfoKHR(item: *const vk.VkImageFormatListCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageFormatListCreateInfoKHR);
}
pub fn size_of_VkValidationCacheCreateInfoEXT(item: *const vk.VkValidationCacheCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.initialDataSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkValidationCacheCreateInfoEXT);
}
pub fn size_of_VkShaderModuleValidationCacheCreateInfoEXT(item: *const vk.VkShaderModuleValidationCacheCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkShaderModuleValidationCacheCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceMaintenance3Properties(item: *const vk.VkPhysicalDeviceMaintenance3Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance3Properties);
}
pub fn size_of_VkPhysicalDeviceMaintenance3PropertiesKHR(item: *const vk.VkPhysicalDeviceMaintenance3PropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance3PropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance4Features(item: *const vk.VkPhysicalDeviceMaintenance4Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance4Features);
}
pub fn size_of_VkPhysicalDeviceMaintenance4FeaturesKHR(item: *const vk.VkPhysicalDeviceMaintenance4FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance4FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance4Properties(item: *const vk.VkPhysicalDeviceMaintenance4Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance4Properties);
}
pub fn size_of_VkPhysicalDeviceMaintenance4PropertiesKHR(item: *const vk.VkPhysicalDeviceMaintenance4PropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance4PropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance5Features(item: *const vk.VkPhysicalDeviceMaintenance5Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance5Features);
}
pub fn size_of_VkPhysicalDeviceMaintenance5FeaturesKHR(item: *const vk.VkPhysicalDeviceMaintenance5FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance5FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance5Properties(item: *const vk.VkPhysicalDeviceMaintenance5Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance5Properties);
}
pub fn size_of_VkPhysicalDeviceMaintenance5PropertiesKHR(item: *const vk.VkPhysicalDeviceMaintenance5PropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance5PropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance6Features(item: *const vk.VkPhysicalDeviceMaintenance6Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance6Features);
}
pub fn size_of_VkPhysicalDeviceMaintenance6FeaturesKHR(item: *const vk.VkPhysicalDeviceMaintenance6FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance6FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance6Properties(item: *const vk.VkPhysicalDeviceMaintenance6Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance6Properties);
}
pub fn size_of_VkPhysicalDeviceMaintenance6PropertiesKHR(item: *const vk.VkPhysicalDeviceMaintenance6PropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance6PropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance7FeaturesKHR(item: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance7FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance7PropertiesKHR(item: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance7PropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceLayeredApiPropertiesListKHR(item: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.layeredApiCount) |i|
        size += size_of_VkPhysicalDeviceLayeredApiPropertiesKHR(@ptrCast(&item.pLayeredApis[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPhysicalDeviceLayeredApiPropertiesListKHR);
}
pub fn size_of_VkPhysicalDeviceLayeredApiPropertiesKHR(item: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR,
                => size += size_of_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiPropertiesKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceLayeredApiPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(item: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance8FeaturesKHR(item: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance8FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance9FeaturesKHR(item: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance9FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMaintenance9PropertiesKHR(item: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMaintenance9PropertiesKHR);
}
pub fn size_of_VkQueueFamilyOwnershipTransferPropertiesKHR(item: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyOwnershipTransferPropertiesKHR);
}
pub fn size_of_VkRenderingAreaInfo(item: *const vk.VkRenderingAreaInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.colorAttachmentCount) |_|
        size += @sizeOf(vk.VkFormat);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderingAreaInfo);
}
pub fn size_of_VkRenderingAreaInfoKHR(item: *const vk.VkRenderingAreaInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderingAreaInfoKHR);
}
pub fn size_of_VkDescriptorSetLayoutSupport(item: *const vk.VkDescriptorSetLayoutSupport, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
                => size += size_of_VkDescriptorSetVariableDescriptorCountLayoutSupport(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutSupport: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkDescriptorSetLayoutSupport);
}
pub fn size_of_VkDescriptorSetLayoutSupportKHR(item: *const vk.VkDescriptorSetLayoutSupportKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorSetLayoutSupportKHR);
}
pub fn size_of_VkPhysicalDeviceShaderDrawParametersFeatures(item: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderDrawParametersFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderDrawParameterFeatures(item: *const vk.VkPhysicalDeviceShaderDrawParameterFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderDrawParameterFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderFloat16Int8Features(item: *const vk.VkPhysicalDeviceShaderFloat16Int8Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderFloat16Int8Features);
}
pub fn size_of_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(item: *const vk.VkPhysicalDeviceShaderFloat16Int8FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderFloat16Int8FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceFloat16Int8FeaturesKHR(item: *const vk.VkPhysicalDeviceFloat16Int8FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFloat16Int8FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceFloatControlsProperties(item: *const vk.VkPhysicalDeviceFloatControlsProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFloatControlsProperties);
}
pub fn size_of_VkPhysicalDeviceFloatControlsPropertiesKHR(item: *const vk.VkPhysicalDeviceFloatControlsPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFloatControlsPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceHostQueryResetFeatures(item: *const vk.VkPhysicalDeviceHostQueryResetFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceHostQueryResetFeatures);
}
pub fn size_of_VkPhysicalDeviceHostQueryResetFeaturesEXT(item: *const vk.VkPhysicalDeviceHostQueryResetFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceHostQueryResetFeaturesEXT);
}
pub fn size_of_VkNativeBufferUsage2ANDROID(item: *const vk.VkNativeBufferUsage2ANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkNativeBufferUsage2ANDROID);
}
pub fn size_of_VkNativeBufferANDROID(item: *const vk.VkNativeBufferANDROID, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.handle) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkNativeBufferANDROID);
}
pub fn size_of_VkSwapchainImageCreateInfoANDROID(item: *const vk.VkSwapchainImageCreateInfoANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainImageCreateInfoANDROID);
}
pub fn size_of_VkPhysicalDevicePresentationPropertiesANDROID(item: *const vk.VkPhysicalDevicePresentationPropertiesANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePresentationPropertiesANDROID);
}
pub fn size_of_VkDeviceQueueGlobalPriorityCreateInfo(item: *const vk.VkDeviceQueueGlobalPriorityCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceQueueGlobalPriorityCreateInfo);
}
pub fn size_of_VkDeviceQueueGlobalPriorityCreateInfoKHR(item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceQueueGlobalPriorityCreateInfoKHR);
}
pub fn size_of_VkDeviceQueueGlobalPriorityCreateInfoEXT(item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceQueueGlobalPriorityCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceGlobalPriorityQueryFeatures(item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceGlobalPriorityQueryFeatures);
}
pub fn size_of_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT(item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT);
}
pub fn size_of_VkQueueFamilyGlobalPriorityProperties(item: *const vk.VkQueueFamilyGlobalPriorityProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyGlobalPriorityProperties);
}
pub fn size_of_VkQueueFamilyGlobalPriorityPropertiesKHR(item: *const vk.VkQueueFamilyGlobalPriorityPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyGlobalPriorityPropertiesKHR);
}
pub fn size_of_VkQueueFamilyGlobalPriorityPropertiesEXT(item: *const vk.VkQueueFamilyGlobalPriorityPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyGlobalPriorityPropertiesEXT);
}
pub fn size_of_VkDebugUtilsObjectNameInfoEXT(item: *const vk.VkDebugUtilsObjectNameInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pObjectName)) |i|
        size += @sizeOf(i);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugUtilsObjectNameInfoEXT);
}
pub fn size_of_VkDebugUtilsObjectTagInfoEXT(item: *const vk.VkDebugUtilsObjectTagInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.tagSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugUtilsObjectTagInfoEXT);
}
pub fn size_of_VkDebugUtilsLabelEXT(item: *const vk.VkDebugUtilsLabelEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pLabelName)) |i|
        size += @sizeOf(i);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugUtilsLabelEXT);
}
pub fn size_of_VkDebugUtilsMessengerCreateInfoEXT(item: *const vk.VkDebugUtilsMessengerCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pUserData) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDebugUtilsMessengerCreateInfoEXT);
}
pub fn size_of_VkDebugUtilsMessengerCallbackDataEXT(item: *const vk.VkDebugUtilsMessengerCallbackDataEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (std.mem.span(item.pMessageIdName)) |i|
        size += @sizeOf(i);
    for (std.mem.span(item.pMessage)) |i|
        size += @sizeOf(i);
    for (0..item.queueLabelCount) |i|
        size += size_of_VkDebugUtilsLabelEXT(@ptrCast(&item.pQueueLabels[i]), false);
    for (0..item.cmdBufLabelCount) |i|
        size += size_of_VkDebugUtilsLabelEXT(@ptrCast(&item.pCmdBufLabels[i]), false);
    for (0..item.objectCount) |i|
        size += size_of_VkDebugUtilsObjectNameInfoEXT(@ptrCast(&item.pObjects[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT,
                => size += size_of_VkDeviceAddressBindingCallbackDataEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsMessengerCallbackDataEXT: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkDebugUtilsMessengerCallbackDataEXT);
}
pub fn size_of_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(item: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
}
pub fn size_of_VkDeviceDeviceMemoryReportCreateInfoEXT(item: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pUserData) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceDeviceMemoryReportCreateInfoEXT);
}
pub fn size_of_VkDeviceMemoryReportCallbackDataEXT(item: *const vk.VkDeviceMemoryReportCallbackDataEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceMemoryReportCallbackDataEXT);
}
pub fn size_of_VkImportMemoryHostPointerInfoEXT(item: *const vk.VkImportMemoryHostPointerInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pHostPointer) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImportMemoryHostPointerInfoEXT);
}
pub fn size_of_VkMemoryHostPointerPropertiesEXT(item: *const vk.VkMemoryHostPointerPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryHostPointerPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(item: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(item: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT);
}
pub fn size_of_VkCalibratedTimestampInfoKHR(item: *const vk.VkCalibratedTimestampInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCalibratedTimestampInfoKHR);
}
pub fn size_of_VkCalibratedTimestampInfoEXT(item: *const vk.VkCalibratedTimestampInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCalibratedTimestampInfoEXT);
}
pub fn size_of_VkPipelineRasterizationConservativeStateCreateInfoEXT(item: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRasterizationConservativeStateCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceDescriptorIndexingFeatures(item: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorIndexingFeatures);
}
pub fn size_of_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(item: *const vk.VkPhysicalDeviceDescriptorIndexingFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorIndexingFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDescriptorIndexingProperties(item: *const vk.VkPhysicalDeviceDescriptorIndexingProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorIndexingProperties);
}
pub fn size_of_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(item: *const vk.VkPhysicalDeviceDescriptorIndexingPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorIndexingPropertiesEXT);
}
pub fn size_of_VkDescriptorSetLayoutBindingFlagsCreateInfo(item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.bindingCount) |_|
        size += @sizeOf(vk.VkDescriptorBindingFlags);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDescriptorSetLayoutBindingFlagsCreateInfo);
}
pub fn size_of_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT);
}
pub fn size_of_VkDescriptorSetVariableDescriptorCountAllocateInfo(item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorSetCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDescriptorSetVariableDescriptorCountAllocateInfo);
}
pub fn size_of_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT);
}
pub fn size_of_VkDescriptorSetVariableDescriptorCountLayoutSupport(item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorSetVariableDescriptorCountLayoutSupport);
}
pub fn size_of_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT);
}
pub fn size_of_VkAttachmentDescription2(item: *const vk.VkAttachmentDescription2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
                => size += size_of_VkAttachmentDescriptionStencilLayout(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkAttachmentDescription2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkAttachmentDescription2);
}
pub fn size_of_VkAttachmentDescription2KHR(item: *const vk.VkAttachmentDescription2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentDescription2KHR);
}
pub fn size_of_VkAttachmentReference2(item: *const vk.VkAttachmentReference2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
                => size += size_of_VkAttachmentReferenceStencilLayout(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkAttachmentReference2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkAttachmentReference2);
}
pub fn size_of_VkAttachmentReference2KHR(item: *const vk.VkAttachmentReference2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentReference2KHR);
}
pub fn size_of_VkSubpassDescription2(item: *const vk.VkSubpassDescription2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.inputAttachmentCount) |i|
        size += size_of_VkAttachmentReference2(@ptrCast(&item.pInputAttachments[i]), false);
    for (0..item.colorAttachmentCount) |i|
        size += size_of_VkAttachmentReference2(@ptrCast(&item.pColorAttachments[i]), false);
    for (0..item.colorAttachmentCount) |i|
        size += size_of_VkAttachmentReference2(@ptrCast(&item.pResolveAttachments[i]), false);
    if (item.pDepthStencilAttachment) |ptr| size += size_of_VkAttachmentReference2(@ptrCast(ptr), false);
    for (0..item.preserveAttachmentCount) |_|
        size += @sizeOf(u32);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
                => size += size_of_VkSubpassDescriptionDepthStencilResolve(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
                => size += size_of_VkFragmentShadingRateAttachmentInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
                => size += size_of_VkMultisampledRenderToSingleSampledInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
                => size += size_of_VkRenderPassCreationControlEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
                => size += size_of_VkRenderPassSubpassFeedbackCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSubpassDescription2: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkSubpassDescription2);
}
pub fn size_of_VkSubpassDescription2KHR(item: *const vk.VkSubpassDescription2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassDescription2KHR);
}
pub fn size_of_VkSubpassDependency2(item: *const vk.VkSubpassDependency2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
                => size += size_of_VkMemoryBarrier2(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
                => size += size_of_VkMemoryBarrierAccessFlags3KHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSubpassDependency2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSubpassDependency2);
}
pub fn size_of_VkSubpassDependency2KHR(item: *const vk.VkSubpassDependency2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassDependency2KHR);
}
pub fn size_of_VkRenderPassCreateInfo2(item: *const vk.VkRenderPassCreateInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentCount) |i|
        size += size_of_VkAttachmentDescription2(@ptrCast(&item.pAttachments[i]), false);
    for (0..item.subpassCount) |i|
        size += size_of_VkSubpassDescription2(@ptrCast(&item.pSubpasses[i]), false);
    for (0..item.dependencyCount) |i|
        size += size_of_VkSubpassDependency2(@ptrCast(&item.pDependencies[i]), false);
    for (0..item.correlatedViewMaskCount) |_|
        size += @sizeOf(u32);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
                => size += size_of_VkRenderPassFragmentDensityMapCreateInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
                => size += size_of_VkRenderPassCreationControlEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
                => size += size_of_VkRenderPassCreationFeedbackCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo2: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkRenderPassCreateInfo2);
}
pub fn size_of_VkRenderPassCreateInfo2KHR(item: *const vk.VkRenderPassCreateInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassCreateInfo2KHR);
}
pub fn size_of_VkSubpassBeginInfo(item: *const vk.VkSubpassBeginInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassBeginInfo);
}
pub fn size_of_VkSubpassBeginInfoKHR(item: *const vk.VkSubpassBeginInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassBeginInfoKHR);
}
pub fn size_of_VkSubpassEndInfo(item: *const vk.VkSubpassEndInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
                => size += size_of_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSubpassEndInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSubpassEndInfo);
}
pub fn size_of_VkSubpassEndInfoKHR(item: *const vk.VkSubpassEndInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassEndInfoKHR);
}
pub fn size_of_VkPhysicalDeviceTimelineSemaphoreFeatures(item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTimelineSemaphoreFeatures);
}
pub fn size_of_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTimelineSemaphoreFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceTimelineSemaphoreProperties(item: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTimelineSemaphoreProperties);
}
pub fn size_of_VkPhysicalDeviceTimelineSemaphorePropertiesKHR(item: *const vk.VkPhysicalDeviceTimelineSemaphorePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTimelineSemaphorePropertiesKHR);
}
pub fn size_of_VkSemaphoreTypeCreateInfo(item: *const vk.VkSemaphoreTypeCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreTypeCreateInfo);
}
pub fn size_of_VkSemaphoreTypeCreateInfoKHR(item: *const vk.VkSemaphoreTypeCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreTypeCreateInfoKHR);
}
pub fn size_of_VkTimelineSemaphoreSubmitInfo(item: *const vk.VkTimelineSemaphoreSubmitInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.waitSemaphoreValueCount) |_|
        size += @sizeOf(u64);
    for (0..item.signalSemaphoreValueCount) |_|
        size += @sizeOf(u64);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkTimelineSemaphoreSubmitInfo);
}
pub fn size_of_VkTimelineSemaphoreSubmitInfoKHR(item: *const vk.VkTimelineSemaphoreSubmitInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkTimelineSemaphoreSubmitInfoKHR);
}
pub fn size_of_VkSemaphoreWaitInfo(item: *const vk.VkSemaphoreWaitInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.semaphoreCount) |_|
        size += @sizeOf(vk.VkSemaphore);
    for (0..item.semaphoreCount) |_|
        size += @sizeOf(u64);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSemaphoreWaitInfo);
}
pub fn size_of_VkSemaphoreWaitInfoKHR(item: *const vk.VkSemaphoreWaitInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreWaitInfoKHR);
}
pub fn size_of_VkSemaphoreSignalInfo(item: *const vk.VkSemaphoreSignalInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreSignalInfo);
}
pub fn size_of_VkSemaphoreSignalInfoKHR(item: *const vk.VkSemaphoreSignalInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreSignalInfoKHR);
}
pub fn size_of_VkVertexInputBindingDivisorDescription(item: *const vk.VkVertexInputBindingDivisorDescription, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVertexInputBindingDivisorDescription);
}
pub fn size_of_VkVertexInputBindingDivisorDescriptionKHR(item: *const vk.VkVertexInputBindingDivisorDescriptionKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVertexInputBindingDivisorDescriptionKHR);
}
pub fn size_of_VkVertexInputBindingDivisorDescriptionEXT(item: *const vk.VkVertexInputBindingDivisorDescriptionEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVertexInputBindingDivisorDescriptionEXT);
}
pub fn size_of_VkPipelineVertexInputDivisorStateCreateInfo(item: *const vk.VkPipelineVertexInputDivisorStateCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.vertexBindingDivisorCount) |i|
        size += size_of_VkVertexInputBindingDivisorDescription(@ptrCast(&item.pVertexBindingDivisors[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineVertexInputDivisorStateCreateInfo);
}
pub fn size_of_VkPipelineVertexInputDivisorStateCreateInfoKHR(item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineVertexInputDivisorStateCreateInfoKHR);
}
pub fn size_of_VkPipelineVertexInputDivisorStateCreateInfoEXT(item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineVertexInputDivisorStateCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceVertexAttributeDivisorProperties(item: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexAttributeDivisorProperties);
}
pub fn size_of_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR(item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR);
}
pub fn size_of_VkPhysicalDevicePCIBusInfoPropertiesEXT(item: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePCIBusInfoPropertiesEXT);
}
pub fn size_of_VkImportAndroidHardwareBufferInfoANDROID(item: *const vk.VkImportAndroidHardwareBufferInfoANDROID, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.buffer) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImportAndroidHardwareBufferInfoANDROID);
}
pub fn size_of_VkAndroidHardwareBufferUsageANDROID(item: *const vk.VkAndroidHardwareBufferUsageANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAndroidHardwareBufferUsageANDROID);
}
pub fn size_of_VkAndroidHardwareBufferPropertiesANDROID(item: *const vk.VkAndroidHardwareBufferPropertiesANDROID, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
                => size += size_of_VkAndroidHardwareBufferFormatPropertiesANDROID(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
                => size += size_of_VkAndroidHardwareBufferFormatProperties2ANDROID(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID,
                => size += size_of_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferPropertiesANDROID: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkAndroidHardwareBufferPropertiesANDROID);
}
pub fn size_of_VkMemoryGetAndroidHardwareBufferInfoANDROID(item: *const vk.VkMemoryGetAndroidHardwareBufferInfoANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryGetAndroidHardwareBufferInfoANDROID);
}
pub fn size_of_VkAndroidHardwareBufferFormatPropertiesANDROID(item: *const vk.VkAndroidHardwareBufferFormatPropertiesANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAndroidHardwareBufferFormatPropertiesANDROID);
}
pub fn size_of_VkCommandBufferInheritanceConditionalRenderingInfoEXT(item: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT);
}
pub fn size_of_VkPhysicalDevice8BitStorageFeatures(item: *const vk.VkPhysicalDevice8BitStorageFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevice8BitStorageFeatures);
}
pub fn size_of_VkPhysicalDevice8BitStorageFeaturesKHR(item: *const vk.VkPhysicalDevice8BitStorageFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevice8BitStorageFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceConditionalRenderingFeaturesEXT(item: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceVulkanMemoryModelFeatures(item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkanMemoryModelFeatures);
}
pub fn size_of_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceShaderAtomicInt64Features(item: *const vk.VkPhysicalDeviceShaderAtomicInt64Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderAtomicInt64Features);
}
pub fn size_of_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(item: *const vk.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(item: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(item: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceVertexAttributeDivisorFeatures(item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexAttributeDivisorFeatures);
}
pub fn size_of_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR(item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDepthStencilResolveProperties(item: *const vk.VkPhysicalDeviceDepthStencilResolveProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthStencilResolveProperties);
}
pub fn size_of_VkPhysicalDeviceDepthStencilResolvePropertiesKHR(item: *const vk.VkPhysicalDeviceDepthStencilResolvePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthStencilResolvePropertiesKHR);
}
pub fn size_of_VkSubpassDescriptionDepthStencilResolve(item: *const vk.VkSubpassDescriptionDepthStencilResolve, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pDepthStencilResolveAttachment) |ptr| size += size_of_VkAttachmentReference2(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSubpassDescriptionDepthStencilResolve);
}
pub fn size_of_VkSubpassDescriptionDepthStencilResolveKHR(item: *const vk.VkSubpassDescriptionDepthStencilResolveKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassDescriptionDepthStencilResolveKHR);
}
pub fn size_of_VkImageViewASTCDecodeModeEXT(item: *const vk.VkImageViewASTCDecodeModeEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageViewASTCDecodeModeEXT);
}
pub fn size_of_VkPhysicalDeviceASTCDecodeFeaturesEXT(item: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceASTCDecodeFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceTransformFeedbackFeaturesEXT(item: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceTransformFeedbackPropertiesEXT(item: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT);
}
pub fn size_of_VkPipelineRasterizationStateStreamCreateInfoEXT(item: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRasterizationStateStreamCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(item: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(item: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(item: *const vk.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI);
}
pub fn size_of_VkPhysicalDeviceMeshShaderFeaturesEXT(item: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMeshShaderFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceMeshShaderPropertiesEXT(item: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMeshShaderPropertiesEXT);
}
pub fn size_of_VkDrawMeshTasksIndirectCommandEXT(item: *const vk.VkDrawMeshTasksIndirectCommandEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDrawMeshTasksIndirectCommandEXT);
}
pub fn size_of_VkRayTracingShaderGroupCreateInfoKHR(item: *const vk.VkRayTracingShaderGroupCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pShaderGroupCaptureReplayHandle) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRayTracingShaderGroupCreateInfoKHR);
}
pub fn size_of_VkRayTracingPipelineCreateInfoKHR(item: *const vk.VkRayTracingPipelineCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.stageCount) |i|
        size += size_of_VkPipelineShaderStageCreateInfo(@ptrCast(&item.pStages[i]), false);
    for (0..item.groupCount) |i|
        size += size_of_VkRayTracingShaderGroupCreateInfoKHR(@ptrCast(&item.pGroups[i]), false);
    if (item.pLibraryInfo) |ptr| size += size_of_VkPipelineLibraryCreateInfoKHR(@ptrCast(ptr), false);
    if (item.pLibraryInterface) |ptr| size += size_of_VkRayTracingPipelineInterfaceCreateInfoKHR(@ptrCast(ptr), false);
    if (item.pDynamicState) |ptr| size += size_of_VkPipelineDynamicStateCreateInfo(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
                => size += size_of_VkPipelineCreateFlags2CreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
                => size += size_of_VkPipelineBinaryInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
                => size += size_of_VkPipelineCreationFeedbackCreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                => size += size_of_VkPipelineRobustnessCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineCreateInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkRayTracingPipelineCreateInfoKHR);
}
pub fn size_of_VkWriteDescriptorSetAccelerationStructureKHR(item: *const vk.VkWriteDescriptorSetAccelerationStructureKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.accelerationStructureCount) |_|
        size += @sizeOf(vk.VkAccelerationStructureKHR);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkWriteDescriptorSetAccelerationStructureKHR);
}
pub fn size_of_VkPhysicalDeviceAccelerationStructureFeaturesKHR(item: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(item: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceRayQueryFeaturesKHR(item: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRayQueryFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceAccelerationStructurePropertiesKHR(item: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(item: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR);
}
pub fn size_of_VkStridedDeviceAddressRegionKHR(item: *const vk.VkStridedDeviceAddressRegionKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkStridedDeviceAddressRegionKHR);
}
pub fn size_of_VkTraceRaysIndirectCommandKHR(item: *const vk.VkTraceRaysIndirectCommandKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkTraceRaysIndirectCommandKHR);
}
pub fn size_of_VkTraceRaysIndirectCommand2KHR(item: *const vk.VkTraceRaysIndirectCommand2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkTraceRaysIndirectCommand2KHR);
}
pub fn size_of_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(item: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR);
}
pub fn size_of_VkDrmFormatModifierPropertiesListEXT(item: *const vk.VkDrmFormatModifierPropertiesListEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.drmFormatModifierCount) |i|
        size += size_of_VkDrmFormatModifierPropertiesEXT(@ptrCast(&item.pDrmFormatModifierProperties[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDrmFormatModifierPropertiesListEXT);
}
pub fn size_of_VkDrmFormatModifierPropertiesEXT(item: *const vk.VkDrmFormatModifierPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDrmFormatModifierPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(item: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.queueFamilyIndexCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT);
}
pub fn size_of_VkImageDrmFormatModifierListCreateInfoEXT(item: *const vk.VkImageDrmFormatModifierListCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.drmFormatModifierCount) |_|
        size += @sizeOf(u64);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImageDrmFormatModifierListCreateInfoEXT);
}
pub fn size_of_VkImageDrmFormatModifierExplicitCreateInfoEXT(item: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.drmFormatModifierPlaneCount) |i|
        size += size_of_VkSubresourceLayout(@ptrCast(&item.pPlaneLayouts[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImageDrmFormatModifierExplicitCreateInfoEXT);
}
pub fn size_of_VkImageDrmFormatModifierPropertiesEXT(item: *const vk.VkImageDrmFormatModifierPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageDrmFormatModifierPropertiesEXT);
}
pub fn size_of_VkImageStencilUsageCreateInfo(item: *const vk.VkImageStencilUsageCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageStencilUsageCreateInfo);
}
pub fn size_of_VkImageStencilUsageCreateInfoEXT(item: *const vk.VkImageStencilUsageCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageStencilUsageCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(item: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(item: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(item: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(item: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT);
}
pub fn size_of_VkRenderPassFragmentDensityMapCreateInfoEXT(item: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassFragmentDensityMapCreateInfoEXT);
}
pub fn size_of_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(item: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.fragmentDensityOffsetCount) |i|
        size += size_of_VkOffset2D(@ptrCast(&item.pFragmentDensityOffsets[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT);
}
pub fn size_of_VkPhysicalDeviceScalarBlockLayoutFeatures(item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceScalarBlockLayoutFeatures);
}
pub fn size_of_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT);
}
pub fn size_of_VkSurfaceProtectedCapabilitiesKHR(item: *const vk.VkSurfaceProtectedCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceProtectedCapabilitiesKHR);
}
pub fn size_of_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
}
pub fn size_of_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceDepthClipEnableFeaturesEXT(item: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT);
}
pub fn size_of_VkPipelineRasterizationDepthClipStateCreateInfoEXT(item: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceMemoryBudgetPropertiesEXT(item: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceMemoryPriorityFeaturesEXT(item: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT);
}
pub fn size_of_VkMemoryPriorityAllocateInfoEXT(item: *const vk.VkMemoryPriorityAllocateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryPriorityAllocateInfoEXT);
}
pub fn size_of_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(item: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceBufferDeviceAddressFeatures(item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceBufferDeviceAddressFeatures);
}
pub fn size_of_VkPhysicalDeviceBufferDeviceAddressFeaturesKHR(item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceBufferDeviceAddressFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceBufferAddressFeaturesEXT(item: *const vk.VkPhysicalDeviceBufferAddressFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceBufferAddressFeaturesEXT);
}
pub fn size_of_VkBufferDeviceAddressInfo(item: *const vk.VkBufferDeviceAddressInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferDeviceAddressInfo);
}
pub fn size_of_VkBufferDeviceAddressInfoKHR(item: *const vk.VkBufferDeviceAddressInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferDeviceAddressInfoKHR);
}
pub fn size_of_VkBufferDeviceAddressInfoEXT(item: *const vk.VkBufferDeviceAddressInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferDeviceAddressInfoEXT);
}
pub fn size_of_VkBufferOpaqueCaptureAddressCreateInfo(item: *const vk.VkBufferOpaqueCaptureAddressCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferOpaqueCaptureAddressCreateInfo);
}
pub fn size_of_VkBufferOpaqueCaptureAddressCreateInfoKHR(item: *const vk.VkBufferOpaqueCaptureAddressCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferOpaqueCaptureAddressCreateInfoKHR);
}
pub fn size_of_VkBufferDeviceAddressCreateInfoEXT(item: *const vk.VkBufferDeviceAddressCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferDeviceAddressCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceImageViewImageFormatInfoEXT(item: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageViewImageFormatInfoEXT);
}
pub fn size_of_VkFilterCubicImageViewImageFormatPropertiesEXT(item: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFilterCubicImageViewImageFormatPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceImagelessFramebufferFeatures(item: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImagelessFramebufferFeatures);
}
pub fn size_of_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(item: *const vk.VkPhysicalDeviceImagelessFramebufferFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImagelessFramebufferFeaturesKHR);
}
pub fn size_of_VkFramebufferAttachmentsCreateInfo(item: *const vk.VkFramebufferAttachmentsCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentImageInfoCount) |i|
        size += size_of_VkFramebufferAttachmentImageInfo(@ptrCast(&item.pAttachmentImageInfos[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkFramebufferAttachmentsCreateInfo);
}
pub fn size_of_VkFramebufferAttachmentsCreateInfoKHR(item: *const vk.VkFramebufferAttachmentsCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFramebufferAttachmentsCreateInfoKHR);
}
pub fn size_of_VkFramebufferAttachmentImageInfo(item: *const vk.VkFramebufferAttachmentImageInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.viewFormatCount) |_|
        size += @sizeOf(vk.VkFormat);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkFramebufferAttachmentImageInfo);
}
pub fn size_of_VkFramebufferAttachmentImageInfoKHR(item: *const vk.VkFramebufferAttachmentImageInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFramebufferAttachmentImageInfoKHR);
}
pub fn size_of_VkRenderPassAttachmentBeginInfo(item: *const vk.VkRenderPassAttachmentBeginInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentCount) |_|
        size += @sizeOf(vk.VkImageView);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderPassAttachmentBeginInfo);
}
pub fn size_of_VkRenderPassAttachmentBeginInfoKHR(item: *const vk.VkRenderPassAttachmentBeginInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassAttachmentBeginInfoKHR);
}
pub fn size_of_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures);
}
pub fn size_of_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(item: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
}
pub fn size_of_VkPipelineCreationFeedback(item: *const vk.VkPipelineCreationFeedback, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCreationFeedback);
}
pub fn size_of_VkPipelineCreationFeedbackEXT(item: *const vk.VkPipelineCreationFeedbackEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCreationFeedbackEXT);
}
pub fn size_of_VkPipelineCreationFeedbackCreateInfo(item: *const vk.VkPipelineCreationFeedbackCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pPipelineCreationFeedback) |ptr| size += size_of_VkPipelineCreationFeedback(@ptrCast(ptr), false);
    for (0..item.pipelineStageCreationFeedbackCount) |i|
        size += size_of_VkPipelineCreationFeedback(@ptrCast(&item.pPipelineStageCreationFeedbacks[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineCreationFeedbackCreateInfo);
}
pub fn size_of_VkPipelineCreationFeedbackCreateInfoEXT(item: *const vk.VkPipelineCreationFeedbackCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineCreationFeedbackCreateInfoEXT);
}
pub fn size_of_VkSurfaceFullScreenExclusiveInfoEXT(item: *const vk.VkSurfaceFullScreenExclusiveInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceFullScreenExclusiveInfoEXT);
}
pub fn size_of_VkSurfaceFullScreenExclusiveWin32InfoEXT(item: *const vk.VkSurfaceFullScreenExclusiveWin32InfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceFullScreenExclusiveWin32InfoEXT);
}
pub fn size_of_VkSurfaceCapabilitiesFullScreenExclusiveEXT(item: *const vk.VkSurfaceCapabilitiesFullScreenExclusiveEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceCapabilitiesFullScreenExclusiveEXT);
}
pub fn size_of_VkPhysicalDevicePerformanceQueryFeaturesKHR(item: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePerformanceQueryFeaturesKHR);
}
pub fn size_of_VkPhysicalDevicePerformanceQueryPropertiesKHR(item: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePerformanceQueryPropertiesKHR);
}
pub fn size_of_VkPerformanceCounterKHR(item: *const vk.VkPerformanceCounterKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceCounterKHR);
}
pub fn size_of_VkPerformanceCounterDescriptionKHR(item: *const vk.VkPerformanceCounterDescriptionKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceCounterDescriptionKHR);
}
pub fn size_of_VkQueryPoolPerformanceCreateInfoKHR(item: *const vk.VkQueryPoolPerformanceCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.counterIndexCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkQueryPoolPerformanceCreateInfoKHR);
}
pub fn size_of_VkAcquireProfilingLockInfoKHR(item: *const vk.VkAcquireProfilingLockInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAcquireProfilingLockInfoKHR);
}
pub fn size_of_VkPerformanceQuerySubmitInfoKHR(item: *const vk.VkPerformanceQuerySubmitInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceQuerySubmitInfoKHR);
}
pub fn size_of_VkPerformanceQueryReservationInfoKHR(item: *const vk.VkPerformanceQueryReservationInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceQueryReservationInfoKHR);
}
pub fn size_of_VkHeadlessSurfaceCreateInfoEXT(item: *const vk.VkHeadlessSurfaceCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkHeadlessSurfaceCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(item: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
}
pub fn size_of_VkPerformanceValueINTEL(item: *const vk.VkPerformanceValueINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceValueINTEL);
}
pub fn size_of_VkInitializePerformanceApiInfoINTEL(item: *const vk.VkInitializePerformanceApiInfoINTEL, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pUserData) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkInitializePerformanceApiInfoINTEL);
}
pub fn size_of_VkQueryPoolPerformanceQueryCreateInfoINTEL(item: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueryPoolPerformanceQueryCreateInfoINTEL);
}
pub fn size_of_VkQueryPoolCreateInfoINTEL(item: *const vk.VkQueryPoolCreateInfoINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueryPoolCreateInfoINTEL);
}
pub fn size_of_VkPerformanceMarkerInfoINTEL(item: *const vk.VkPerformanceMarkerInfoINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceMarkerInfoINTEL);
}
pub fn size_of_VkPerformanceStreamMarkerInfoINTEL(item: *const vk.VkPerformanceStreamMarkerInfoINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceStreamMarkerInfoINTEL);
}
pub fn size_of_VkPerformanceOverrideInfoINTEL(item: *const vk.VkPerformanceOverrideInfoINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceOverrideInfoINTEL);
}
pub fn size_of_VkPerformanceConfigurationAcquireInfoINTEL(item: *const vk.VkPerformanceConfigurationAcquireInfoINTEL, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPerformanceConfigurationAcquireInfoINTEL);
}
pub fn size_of_VkPhysicalDeviceShaderClockFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderClockFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceIndexTypeUint8Features(item: *const vk.VkPhysicalDeviceIndexTypeUint8Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceIndexTypeUint8Features);
}
pub fn size_of_VkPhysicalDeviceIndexTypeUint8FeaturesKHR(item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceIndexTypeUint8FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceIndexTypeUint8FeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(item: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
}
pub fn size_of_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR(item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR);
}
pub fn size_of_VkAttachmentReferenceStencilLayout(item: *const vk.VkAttachmentReferenceStencilLayout, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentReferenceStencilLayout);
}
pub fn size_of_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(item: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
}
pub fn size_of_VkAttachmentReferenceStencilLayoutKHR(item: *const vk.VkAttachmentReferenceStencilLayoutKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentReferenceStencilLayoutKHR);
}
pub fn size_of_VkAttachmentDescriptionStencilLayout(item: *const vk.VkAttachmentDescriptionStencilLayout, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentDescriptionStencilLayout);
}
pub fn size_of_VkAttachmentDescriptionStencilLayoutKHR(item: *const vk.VkAttachmentDescriptionStencilLayoutKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentDescriptionStencilLayoutKHR);
}
pub fn size_of_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(item: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
}
pub fn size_of_VkPipelineInfoKHR(item: *const vk.VkPipelineInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineInfoKHR);
}
pub fn size_of_VkPipelineInfoEXT(item: *const vk.VkPipelineInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineInfoEXT);
}
pub fn size_of_VkPipelineExecutablePropertiesKHR(item: *const vk.VkPipelineExecutablePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineExecutablePropertiesKHR);
}
pub fn size_of_VkPipelineExecutableInfoKHR(item: *const vk.VkPipelineExecutableInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineExecutableInfoKHR);
}
pub fn size_of_VkPipelineExecutableStatisticKHR(item: *const vk.VkPipelineExecutableStatisticKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineExecutableStatisticKHR);
}
pub fn size_of_VkPipelineExecutableInternalRepresentationKHR(item: *const vk.VkPipelineExecutableInternalRepresentationKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.dataSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineExecutableInternalRepresentationKHR);
}
pub fn size_of_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(item: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceTexelBufferAlignmentProperties(item: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTexelBufferAlignmentProperties);
}
pub fn size_of_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(item: *const vk.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceSubgroupSizeControlFeatures(item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubgroupSizeControlFeatures);
}
pub fn size_of_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceSubgroupSizeControlProperties(item: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubgroupSizeControlProperties);
}
pub fn size_of_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(item: *const vk.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);
}
pub fn size_of_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo);
}
pub fn size_of_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);
}
pub fn size_of_VkShaderRequiredSubgroupSizeCreateInfoEXT(item: *const vk.VkShaderRequiredSubgroupSizeCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkShaderRequiredSubgroupSizeCreateInfoEXT);
}
pub fn size_of_VkSubpassShadingPipelineCreateInfoHUAWEI(item: *const vk.VkSubpassShadingPipelineCreateInfoHUAWEI, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassShadingPipelineCreateInfoHUAWEI);
}
pub fn size_of_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(item: *const vk.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI);
}
pub fn size_of_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(item: *const vk.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI);
}
pub fn size_of_VkMemoryOpaqueCaptureAddressAllocateInfo(item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryOpaqueCaptureAddressAllocateInfo);
}
pub fn size_of_VkMemoryOpaqueCaptureAddressAllocateInfoKHR(item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryOpaqueCaptureAddressAllocateInfoKHR);
}
pub fn size_of_VkDeviceMemoryOpaqueCaptureAddressInfo(item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceMemoryOpaqueCaptureAddressInfo);
}
pub fn size_of_VkDeviceMemoryOpaqueCaptureAddressInfoKHR(item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceMemoryOpaqueCaptureAddressInfoKHR);
}
pub fn size_of_VkPhysicalDeviceLineRasterizationFeatures(item: *const vk.VkPhysicalDeviceLineRasterizationFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLineRasterizationFeatures);
}
pub fn size_of_VkPhysicalDeviceLineRasterizationFeaturesKHR(item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLineRasterizationFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceLineRasterizationFeaturesEXT(item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLineRasterizationFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceLineRasterizationProperties(item: *const vk.VkPhysicalDeviceLineRasterizationProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLineRasterizationProperties);
}
pub fn size_of_VkPhysicalDeviceLineRasterizationPropertiesKHR(item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLineRasterizationPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceLineRasterizationPropertiesEXT(item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLineRasterizationPropertiesEXT);
}
pub fn size_of_VkPipelineRasterizationLineStateCreateInfo(item: *const vk.VkPipelineRasterizationLineStateCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRasterizationLineStateCreateInfo);
}
pub fn size_of_VkPipelineRasterizationLineStateCreateInfoKHR(item: *const vk.VkPipelineRasterizationLineStateCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRasterizationLineStateCreateInfoKHR);
}
pub fn size_of_VkPipelineRasterizationLineStateCreateInfoEXT(item: *const vk.VkPipelineRasterizationLineStateCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRasterizationLineStateCreateInfoEXT);
}
pub fn size_of_VkPhysicalDevicePipelineCreationCacheControlFeatures(item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineCreationCacheControlFeatures);
}
pub fn size_of_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceVulkan11Features(item: *const vk.VkPhysicalDeviceVulkan11Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkan11Features);
}
pub fn size_of_VkPhysicalDeviceVulkan11Properties(item: *const vk.VkPhysicalDeviceVulkan11Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkan11Properties);
}
pub fn size_of_VkPhysicalDeviceVulkan12Features(item: *const vk.VkPhysicalDeviceVulkan12Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkan12Features);
}
pub fn size_of_VkPhysicalDeviceVulkan12Properties(item: *const vk.VkPhysicalDeviceVulkan12Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkan12Properties);
}
pub fn size_of_VkPhysicalDeviceVulkan13Features(item: *const vk.VkPhysicalDeviceVulkan13Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkan13Features);
}
pub fn size_of_VkPhysicalDeviceVulkan13Properties(item: *const vk.VkPhysicalDeviceVulkan13Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkan13Properties);
}
pub fn size_of_VkPhysicalDeviceVulkan14Features(item: *const vk.VkPhysicalDeviceVulkan14Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkan14Features);
}
pub fn size_of_VkPhysicalDeviceVulkan14Properties(item: *const vk.VkPhysicalDeviceVulkan14Properties, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.copySrcLayoutCount) |_|
        size += @sizeOf(vk.VkImageLayout);
    for (0..item.copyDstLayoutCount) |_|
        size += @sizeOf(vk.VkImageLayout);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPhysicalDeviceVulkan14Properties);
}
pub fn size_of_VkFaultData(item: *const vk.VkFaultData, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFaultData);
}
pub fn size_of_VkFaultCallbackInfo(item: *const vk.VkFaultCallbackInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.faultCount) |i|
        size += size_of_VkFaultData(@ptrCast(&item.pFaults[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkFaultCallbackInfo);
}
pub fn size_of_VkPhysicalDeviceToolProperties(item: *const vk.VkPhysicalDeviceToolProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceToolProperties);
}
pub fn size_of_VkPhysicalDeviceToolPropertiesEXT(item: *const vk.VkPhysicalDeviceToolPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceToolPropertiesEXT);
}
pub fn size_of_VkSamplerCustomBorderColorCreateInfoEXT(item: *const vk.VkSamplerCustomBorderColorCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerCustomBorderColorCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceCustomBorderColorPropertiesEXT(item: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceCustomBorderColorFeaturesEXT(item: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT);
}
pub fn size_of_VkSamplerBorderColorComponentMappingCreateInfoEXT(item: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerBorderColorComponentMappingCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(item: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT);
}
pub fn size_of_VkAccelerationStructureGeometryTrianglesDataKHR(item: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT,
                => size += size_of_VkAccelerationStructureTrianglesOpacityMicromapEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryTrianglesDataKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkAccelerationStructureGeometryTrianglesDataKHR);
}
pub fn size_of_VkAccelerationStructureGeometryAabbsDataKHR(item: *const vk.VkAccelerationStructureGeometryAabbsDataKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureGeometryAabbsDataKHR);
}
pub fn size_of_VkAccelerationStructureGeometryInstancesDataKHR(item: *const vk.VkAccelerationStructureGeometryInstancesDataKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureGeometryInstancesDataKHR);
}
pub fn size_of_VkAccelerationStructureGeometryKHR(item: *const vk.VkAccelerationStructureGeometryKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureGeometryKHR);
}
pub fn size_of_VkAccelerationStructureBuildGeometryInfoKHR(item: *const vk.VkAccelerationStructureBuildGeometryInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.geometryCount) |i|
        size += size_of_VkAccelerationStructureGeometryKHR(@ptrCast(&item.pGeometries[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkAccelerationStructureBuildGeometryInfoKHR);
}
pub fn size_of_VkAccelerationStructureBuildRangeInfoKHR(item: *const vk.VkAccelerationStructureBuildRangeInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureBuildRangeInfoKHR);
}
pub fn size_of_VkAccelerationStructureCreateInfoKHR(item: *const vk.VkAccelerationStructureCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                => size += size_of_VkOpaqueCaptureDescriptorDataCreateInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCreateInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkAccelerationStructureCreateInfoKHR);
}
pub fn size_of_VkAabbPositionsKHR(item: *const vk.VkAabbPositionsKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAabbPositionsKHR);
}
pub fn size_of_VkTransformMatrixKHR(item: *const vk.VkTransformMatrixKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkTransformMatrixKHR);
}
pub fn size_of_VkAccelerationStructureInstanceKHR(item: *const vk.VkAccelerationStructureInstanceKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureInstanceKHR);
}
pub fn size_of_VkAccelerationStructureDeviceAddressInfoKHR(item: *const vk.VkAccelerationStructureDeviceAddressInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureDeviceAddressInfoKHR);
}
pub fn size_of_VkAccelerationStructureVersionInfoKHR(item: *const vk.VkAccelerationStructureVersionInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureVersionInfoKHR);
}
pub fn size_of_VkCopyAccelerationStructureInfoKHR(item: *const vk.VkCopyAccelerationStructureInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyAccelerationStructureInfoKHR);
}
pub fn size_of_VkCopyAccelerationStructureToMemoryInfoKHR(item: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyAccelerationStructureToMemoryInfoKHR);
}
pub fn size_of_VkCopyMemoryToAccelerationStructureInfoKHR(item: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyMemoryToAccelerationStructureInfoKHR);
}
pub fn size_of_VkRayTracingPipelineInterfaceCreateInfoKHR(item: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRayTracingPipelineInterfaceCreateInfoKHR);
}
pub fn size_of_VkPipelineLibraryCreateInfoKHR(item: *const vk.VkPipelineLibraryCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.libraryCount) |_|
        size += @sizeOf(vk.VkPipeline);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineLibraryCreateInfoKHR);
}
pub fn size_of_VkRefreshObjectKHR(item: *const vk.VkRefreshObjectKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRefreshObjectKHR);
}
pub fn size_of_VkRefreshObjectListKHR(item: *const vk.VkRefreshObjectListKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.objectCount) |i|
        size += size_of_VkRefreshObjectKHR(@ptrCast(&item.pObjects[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRefreshObjectListKHR);
}
pub fn size_of_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(item: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(item: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(item: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(item: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT);
}
pub fn size_of_VkColorBlendEquationEXT(item: *const vk.VkColorBlendEquationEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkColorBlendEquationEXT);
}
pub fn size_of_VkColorBlendAdvancedEXT(item: *const vk.VkColorBlendAdvancedEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkColorBlendAdvancedEXT);
}
pub fn size_of_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures);
}
pub fn size_of_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceRobustness2FeaturesKHR(item: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRobustness2FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceRobustness2FeaturesEXT(item: *const vk.VkPhysicalDeviceRobustness2FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRobustness2FeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceRobustness2PropertiesKHR(item: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRobustness2PropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceRobustness2PropertiesEXT(item: *const vk.VkPhysicalDeviceRobustness2PropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRobustness2PropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceImageRobustnessFeatures(item: *const vk.VkPhysicalDeviceImageRobustnessFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageRobustnessFeatures);
}
pub fn size_of_VkPhysicalDeviceImageRobustnessFeaturesEXT(item: *const vk.VkPhysicalDeviceImageRobustnessFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageRobustnessFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(item: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
}
pub fn size_of_VkPhysicalDevicePortabilitySubsetFeaturesKHR(item: *const vk.VkPhysicalDevicePortabilitySubsetFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePortabilitySubsetFeaturesKHR);
}
pub fn size_of_VkPhysicalDevicePortabilitySubsetPropertiesKHR(item: *const vk.VkPhysicalDevicePortabilitySubsetPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePortabilitySubsetPropertiesKHR);
}
pub fn size_of_VkPhysicalDevice4444FormatsFeaturesEXT(item: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevice4444FormatsFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(item: *const vk.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI);
}
pub fn size_of_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(item: *const vk.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI,
                => size += size_of_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI);
}
pub fn size_of_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(item: *const vk.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI);
}
pub fn size_of_VkBufferCopy2(item: *const vk.VkBufferCopy2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCopy2);
}
pub fn size_of_VkBufferCopy2KHR(item: *const vk.VkBufferCopy2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCopy2KHR);
}
pub fn size_of_VkImageCopy2(item: *const vk.VkImageCopy2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageCopy2);
}
pub fn size_of_VkImageCopy2KHR(item: *const vk.VkImageCopy2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageCopy2KHR);
}
pub fn size_of_VkImageBlit2(item: *const vk.VkImageBlit2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageBlit2);
}
pub fn size_of_VkImageBlit2KHR(item: *const vk.VkImageBlit2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageBlit2KHR);
}
pub fn size_of_VkBufferImageCopy2(item: *const vk.VkBufferImageCopy2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferImageCopy2);
}
pub fn size_of_VkBufferImageCopy2KHR(item: *const vk.VkBufferImageCopy2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferImageCopy2KHR);
}
pub fn size_of_VkImageResolve2(item: *const vk.VkImageResolve2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageResolve2);
}
pub fn size_of_VkImageResolve2KHR(item: *const vk.VkImageResolve2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageResolve2KHR);
}
pub fn size_of_VkCopyBufferInfo2(item: *const vk.VkCopyBufferInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkBufferCopy2(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCopyBufferInfo2);
}
pub fn size_of_VkCopyBufferInfo2KHR(item: *const vk.VkCopyBufferInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyBufferInfo2KHR);
}
pub fn size_of_VkCopyImageInfo2(item: *const vk.VkCopyImageInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkImageCopy2(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCopyImageInfo2);
}
pub fn size_of_VkCopyImageInfo2KHR(item: *const vk.VkCopyImageInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyImageInfo2KHR);
}
pub fn size_of_VkBlitImageInfo2(item: *const vk.VkBlitImageInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkImageBlit2(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkBlitImageInfo2);
}
pub fn size_of_VkBlitImageInfo2KHR(item: *const vk.VkBlitImageInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBlitImageInfo2KHR);
}
pub fn size_of_VkCopyBufferToImageInfo2(item: *const vk.VkCopyBufferToImageInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkBufferImageCopy2(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCopyBufferToImageInfo2);
}
pub fn size_of_VkCopyBufferToImageInfo2KHR(item: *const vk.VkCopyBufferToImageInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyBufferToImageInfo2KHR);
}
pub fn size_of_VkCopyImageToBufferInfo2(item: *const vk.VkCopyImageToBufferInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkBufferImageCopy2(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCopyImageToBufferInfo2);
}
pub fn size_of_VkCopyImageToBufferInfo2KHR(item: *const vk.VkCopyImageToBufferInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyImageToBufferInfo2KHR);
}
pub fn size_of_VkResolveImageInfo2(item: *const vk.VkResolveImageInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkImageResolve2(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkResolveImageInfo2);
}
pub fn size_of_VkResolveImageInfo2KHR(item: *const vk.VkResolveImageInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkResolveImageInfo2KHR);
}
pub fn size_of_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(item: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
}
pub fn size_of_VkFragmentShadingRateAttachmentInfoKHR(item: *const vk.VkFragmentShadingRateAttachmentInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pFragmentShadingRateAttachment) |ptr| size += size_of_VkAttachmentReference2(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkFragmentShadingRateAttachmentInfoKHR);
}
pub fn size_of_VkPipelineFragmentShadingRateStateCreateInfoKHR(item: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineFragmentShadingRateStateCreateInfoKHR);
}
pub fn size_of_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(item: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(item: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceFragmentShadingRateKHR(item: *const vk.VkPhysicalDeviceFragmentShadingRateKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentShadingRateKHR);
}
pub fn size_of_VkPhysicalDeviceShaderTerminateInvocationFeatures(item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderTerminateInvocationFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);
}
pub fn size_of_VkAccelerationStructureBuildSizesInfoKHR(item: *const vk.VkAccelerationStructureBuildSizesInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureBuildSizesInfoKHR);
}
pub fn size_of_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(item: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(item: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(item: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(item: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE(item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE);
}
pub fn size_of_VkMutableDescriptorTypeListEXT(item: *const vk.VkMutableDescriptorTypeListEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorTypeCount) |_|
        size += @sizeOf(vk.VkDescriptorType);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkMutableDescriptorTypeListEXT);
}
pub fn size_of_VkMutableDescriptorTypeListVALVE(item: *const vk.VkMutableDescriptorTypeListVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMutableDescriptorTypeListVALVE);
}
pub fn size_of_VkMutableDescriptorTypeCreateInfoEXT(item: *const vk.VkMutableDescriptorTypeCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.mutableDescriptorTypeListCount) |i|
        size += size_of_VkMutableDescriptorTypeListEXT(@ptrCast(&item.pMutableDescriptorTypeLists[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkMutableDescriptorTypeCreateInfoEXT);
}
pub fn size_of_VkMutableDescriptorTypeCreateInfoVALVE(item: *const vk.VkMutableDescriptorTypeCreateInfoVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMutableDescriptorTypeCreateInfoVALVE);
}
pub fn size_of_VkPhysicalDeviceDepthClipControlFeaturesEXT(item: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthClipControlFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(item: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT);
}
pub fn size_of_VkGeneratedCommandsPipelineInfoEXT(item: *const vk.VkGeneratedCommandsPipelineInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkGeneratedCommandsPipelineInfoEXT);
}
pub fn size_of_VkGeneratedCommandsShaderInfoEXT(item: *const vk.VkGeneratedCommandsShaderInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.shaderCount) |_|
        size += @sizeOf(vk.VkShaderEXT);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkGeneratedCommandsShaderInfoEXT);
}
pub fn size_of_VkGeneratedCommandsMemoryRequirementsInfoEXT(item: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
                => size += size_of_VkGeneratedCommandsPipelineInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
                => size += size_of_VkGeneratedCommandsShaderInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsMemoryRequirementsInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkGeneratedCommandsMemoryRequirementsInfoEXT);
}
pub fn size_of_VkIndirectExecutionSetPipelineInfoEXT(item: *const vk.VkIndirectExecutionSetPipelineInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkIndirectExecutionSetPipelineInfoEXT);
}
pub fn size_of_VkIndirectExecutionSetShaderLayoutInfoEXT(item: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.setLayoutCount) |_|
        size += @sizeOf(vk.VkDescriptorSetLayout);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkIndirectExecutionSetShaderLayoutInfoEXT);
}
pub fn size_of_VkIndirectExecutionSetShaderInfoEXT(item: *const vk.VkIndirectExecutionSetShaderInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.shaderCount) |_|
        size += @sizeOf(vk.VkShaderEXT);
    for (0..item.shaderCount) |i|
        size += size_of_VkIndirectExecutionSetShaderLayoutInfoEXT(@ptrCast(&item.pSetLayoutInfos[i]), false);
    for (0..item.pushConstantRangeCount) |i|
        size += size_of_VkPushConstantRange(@ptrCast(&item.pPushConstantRanges[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkIndirectExecutionSetShaderInfoEXT);
}
pub fn size_of_VkIndirectExecutionSetCreateInfoEXT(item: *const vk.VkIndirectExecutionSetCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkIndirectExecutionSetCreateInfoEXT);
}
pub fn size_of_VkGeneratedCommandsInfoEXT(item: *const vk.VkGeneratedCommandsInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
                => size += size_of_VkGeneratedCommandsPipelineInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
                => size += size_of_VkGeneratedCommandsShaderInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkGeneratedCommandsInfoEXT);
}
pub fn size_of_VkWriteIndirectExecutionSetPipelineEXT(item: *const vk.VkWriteIndirectExecutionSetPipelineEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkWriteIndirectExecutionSetPipelineEXT);
}
pub fn size_of_VkWriteIndirectExecutionSetShaderEXT(item: *const vk.VkWriteIndirectExecutionSetShaderEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkWriteIndirectExecutionSetShaderEXT);
}
pub fn size_of_VkIndirectCommandsLayoutCreateInfoEXT(item: *const vk.VkIndirectCommandsLayoutCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.tokenCount) |i|
        size += size_of_VkIndirectCommandsLayoutTokenEXT(@ptrCast(&item.pTokens[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                => size += size_of_VkPipelineLayoutCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutCreateInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkIndirectCommandsLayoutCreateInfoEXT);
}
pub fn size_of_VkIndirectCommandsLayoutTokenEXT(item: *const vk.VkIndirectCommandsLayoutTokenEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkIndirectCommandsLayoutTokenEXT);
}
pub fn size_of_VkDrawIndirectCountIndirectCommandEXT(item: *const vk.VkDrawIndirectCountIndirectCommandEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDrawIndirectCountIndirectCommandEXT);
}
pub fn size_of_VkIndirectCommandsVertexBufferTokenEXT(item: *const vk.VkIndirectCommandsVertexBufferTokenEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkIndirectCommandsVertexBufferTokenEXT);
}
pub fn size_of_VkBindVertexBufferIndirectCommandEXT(item: *const vk.VkBindVertexBufferIndirectCommandEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindVertexBufferIndirectCommandEXT);
}
pub fn size_of_VkIndirectCommandsIndexBufferTokenEXT(item: *const vk.VkIndirectCommandsIndexBufferTokenEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkIndirectCommandsIndexBufferTokenEXT);
}
pub fn size_of_VkBindIndexBufferIndirectCommandEXT(item: *const vk.VkBindIndexBufferIndirectCommandEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindIndexBufferIndirectCommandEXT);
}
pub fn size_of_VkIndirectCommandsPushConstantTokenEXT(item: *const vk.VkIndirectCommandsPushConstantTokenEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkIndirectCommandsPushConstantTokenEXT);
}
pub fn size_of_VkIndirectCommandsExecutionSetTokenEXT(item: *const vk.VkIndirectCommandsExecutionSetTokenEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkIndirectCommandsExecutionSetTokenEXT);
}
pub fn size_of_VkPipelineViewportDepthClipControlCreateInfoEXT(item: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineViewportDepthClipControlCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceDepthClampControlFeaturesEXT(item: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthClampControlFeaturesEXT);
}
pub fn size_of_VkPipelineViewportDepthClampControlCreateInfoEXT(item: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pDepthClampRange) |ptr| size += size_of_VkDepthClampRangeEXT(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineViewportDepthClampControlCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(item: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR);
}
pub fn size_of_VkVertexInputBindingDescription2EXT(item: *const vk.VkVertexInputBindingDescription2EXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVertexInputBindingDescription2EXT);
}
pub fn size_of_VkVertexInputAttributeDescription2EXT(item: *const vk.VkVertexInputAttributeDescription2EXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVertexInputAttributeDescription2EXT);
}
pub fn size_of_VkPhysicalDeviceColorWriteEnableFeaturesEXT(item: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT);
}
pub fn size_of_VkPipelineColorWriteCreateInfoEXT(item: *const vk.VkPipelineColorWriteCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.attachmentCount) |_|
        size += @sizeOf(vk.VkBool32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineColorWriteCreateInfoEXT);
}
pub fn size_of_VkMemoryBarrier2(item: *const vk.VkMemoryBarrier2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryBarrier2);
}
pub fn size_of_VkMemoryBarrier2KHR(item: *const vk.VkMemoryBarrier2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryBarrier2KHR);
}
pub fn size_of_VkImageMemoryBarrier2(item: *const vk.VkImageMemoryBarrier2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
                => size += size_of_VkSampleLocationsInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
                => size += size_of_VkMemoryBarrierAccessFlags3KHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                => size += size_of_VkExternalMemoryAcquireUnmodifiedEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkImageMemoryBarrier2);
}
pub fn size_of_VkImageMemoryBarrier2KHR(item: *const vk.VkImageMemoryBarrier2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageMemoryBarrier2KHR);
}
pub fn size_of_VkBufferMemoryBarrier2(item: *const vk.VkBufferMemoryBarrier2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
                => size += size_of_VkMemoryBarrierAccessFlags3KHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                => size += size_of_VkExternalMemoryAcquireUnmodifiedEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkBufferMemoryBarrier2);
}
pub fn size_of_VkBufferMemoryBarrier2KHR(item: *const vk.VkBufferMemoryBarrier2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferMemoryBarrier2KHR);
}
pub fn size_of_VkMemoryBarrierAccessFlags3KHR(item: *const vk.VkMemoryBarrierAccessFlags3KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryBarrierAccessFlags3KHR);
}
pub fn size_of_VkDependencyInfo(item: *const vk.VkDependencyInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.memoryBarrierCount) |i|
        size += size_of_VkMemoryBarrier2(@ptrCast(&item.pMemoryBarriers[i]), false);
    for (0..item.bufferMemoryBarrierCount) |i|
        size += size_of_VkBufferMemoryBarrier2(@ptrCast(&item.pBufferMemoryBarriers[i]), false);
    for (0..item.imageMemoryBarrierCount) |i|
        size += size_of_VkImageMemoryBarrier2(@ptrCast(&item.pImageMemoryBarriers[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDependencyInfo);
}
pub fn size_of_VkDependencyInfoKHR(item: *const vk.VkDependencyInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDependencyInfoKHR);
}
pub fn size_of_VkSemaphoreSubmitInfo(item: *const vk.VkSemaphoreSubmitInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreSubmitInfo);
}
pub fn size_of_VkSemaphoreSubmitInfoKHR(item: *const vk.VkSemaphoreSubmitInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSemaphoreSubmitInfoKHR);
}
pub fn size_of_VkCommandBufferSubmitInfo(item: *const vk.VkCommandBufferSubmitInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCommandBufferSubmitInfo);
}
pub fn size_of_VkCommandBufferSubmitInfoKHR(item: *const vk.VkCommandBufferSubmitInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCommandBufferSubmitInfoKHR);
}
pub fn size_of_VkSubmitInfo2(item: *const vk.VkSubmitInfo2, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.waitSemaphoreInfoCount) |i|
        size += size_of_VkSemaphoreSubmitInfo(@ptrCast(&item.pWaitSemaphoreInfos[i]), false);
    for (0..item.commandBufferInfoCount) |i|
        size += size_of_VkCommandBufferSubmitInfo(@ptrCast(&item.pCommandBufferInfos[i]), false);
    for (0..item.signalSemaphoreInfoCount) |i|
        size += size_of_VkSemaphoreSubmitInfo(@ptrCast(&item.pSignalSemaphoreInfos[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
                => size += size_of_VkWin32KeyedMutexAcquireReleaseInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
                => size += size_of_VkPerformanceQuerySubmitInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                => size += size_of_VkFrameBoundaryEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo2: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkSubmitInfo2);
}
pub fn size_of_VkSubmitInfo2KHR(item: *const vk.VkSubmitInfo2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubmitInfo2KHR);
}
pub fn size_of_VkPhysicalDeviceSynchronization2Features(item: *const vk.VkPhysicalDeviceSynchronization2Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSynchronization2Features);
}
pub fn size_of_VkPhysicalDeviceSynchronization2FeaturesKHR(item: *const vk.VkPhysicalDeviceSynchronization2FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSynchronization2FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(item: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceHostImageCopyFeatures(item: *const vk.VkPhysicalDeviceHostImageCopyFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceHostImageCopyFeatures);
}
pub fn size_of_VkPhysicalDeviceHostImageCopyFeaturesEXT(item: *const vk.VkPhysicalDeviceHostImageCopyFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceHostImageCopyFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceHostImageCopyProperties(item: *const vk.VkPhysicalDeviceHostImageCopyProperties, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.copySrcLayoutCount) |_|
        size += @sizeOf(vk.VkImageLayout);
    for (0..item.copyDstLayoutCount) |_|
        size += @sizeOf(vk.VkImageLayout);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPhysicalDeviceHostImageCopyProperties);
}
pub fn size_of_VkPhysicalDeviceHostImageCopyPropertiesEXT(item: *const vk.VkPhysicalDeviceHostImageCopyPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceHostImageCopyPropertiesEXT);
}
pub fn size_of_VkMemoryToImageCopy(item: *const vk.VkMemoryToImageCopy, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pHostPointer) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkMemoryToImageCopy);
}
pub fn size_of_VkMemoryToImageCopyEXT(item: *const vk.VkMemoryToImageCopyEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryToImageCopyEXT);
}
pub fn size_of_VkImageToMemoryCopy(item: *const vk.VkImageToMemoryCopy, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pHostPointer) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImageToMemoryCopy);
}
pub fn size_of_VkImageToMemoryCopyEXT(item: *const vk.VkImageToMemoryCopyEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageToMemoryCopyEXT);
}
pub fn size_of_VkCopyMemoryToImageInfo(item: *const vk.VkCopyMemoryToImageInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkMemoryToImageCopy(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCopyMemoryToImageInfo);
}
pub fn size_of_VkCopyMemoryToImageInfoEXT(item: *const vk.VkCopyMemoryToImageInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyMemoryToImageInfoEXT);
}
pub fn size_of_VkCopyImageToMemoryInfo(item: *const vk.VkCopyImageToMemoryInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkImageToMemoryCopy(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCopyImageToMemoryInfo);
}
pub fn size_of_VkCopyImageToMemoryInfoEXT(item: *const vk.VkCopyImageToMemoryInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyImageToMemoryInfoEXT);
}
pub fn size_of_VkCopyImageToImageInfo(item: *const vk.VkCopyImageToImageInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.regionCount) |i|
        size += size_of_VkImageCopy2(@ptrCast(&item.pRegions[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCopyImageToImageInfo);
}
pub fn size_of_VkCopyImageToImageInfoEXT(item: *const vk.VkCopyImageToImageInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyImageToImageInfoEXT);
}
pub fn size_of_VkHostImageLayoutTransitionInfo(item: *const vk.VkHostImageLayoutTransitionInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkHostImageLayoutTransitionInfo);
}
pub fn size_of_VkHostImageLayoutTransitionInfoEXT(item: *const vk.VkHostImageLayoutTransitionInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkHostImageLayoutTransitionInfoEXT);
}
pub fn size_of_VkSubresourceHostMemcpySize(item: *const vk.VkSubresourceHostMemcpySize, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubresourceHostMemcpySize);
}
pub fn size_of_VkSubresourceHostMemcpySizeEXT(item: *const vk.VkSubresourceHostMemcpySizeEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubresourceHostMemcpySizeEXT);
}
pub fn size_of_VkHostImageCopyDevicePerformanceQuery(item: *const vk.VkHostImageCopyDevicePerformanceQuery, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkHostImageCopyDevicePerformanceQuery);
}
pub fn size_of_VkHostImageCopyDevicePerformanceQueryEXT(item: *const vk.VkHostImageCopyDevicePerformanceQueryEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkHostImageCopyDevicePerformanceQueryEXT);
}
pub fn size_of_VkPhysicalDeviceVulkanSC10Properties(item: *const vk.VkPhysicalDeviceVulkanSC10Properties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkanSC10Properties);
}
pub fn size_of_VkPipelinePoolSize(item: *const vk.VkPipelinePoolSize, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelinePoolSize);
}
pub fn size_of_VkDeviceObjectReservationCreateInfo(item: *const vk.VkDeviceObjectReservationCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.pipelineCacheCreateInfoCount) |i|
        size += size_of_VkPipelineCacheCreateInfo(@ptrCast(&item.pPipelineCacheCreateInfos[i]), false);
    for (0..item.pipelinePoolSizeCount) |i|
        size += size_of_VkPipelinePoolSize(@ptrCast(&item.pPipelinePoolSizes[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceObjectReservationCreateInfo);
}
pub fn size_of_VkCommandPoolMemoryReservationCreateInfo(item: *const vk.VkCommandPoolMemoryReservationCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCommandPoolMemoryReservationCreateInfo);
}
pub fn size_of_VkCommandPoolMemoryConsumption(item: *const vk.VkCommandPoolMemoryConsumption, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCommandPoolMemoryConsumption);
}
pub fn size_of_VkPhysicalDeviceVulkanSC10Features(item: *const vk.VkPhysicalDeviceVulkanSC10Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVulkanSC10Features);
}
pub fn size_of_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(item: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceLegacyDitheringFeaturesEXT(item: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(item: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT);
}
pub fn size_of_VkSurfaceCapabilitiesPresentId2KHR(item: *const vk.VkSurfaceCapabilitiesPresentId2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceCapabilitiesPresentId2KHR);
}
pub fn size_of_VkSurfaceCapabilitiesPresentWait2KHR(item: *const vk.VkSurfaceCapabilitiesPresentWait2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceCapabilitiesPresentWait2KHR);
}
pub fn size_of_VkSubpassResolvePerformanceQueryEXT(item: *const vk.VkSubpassResolvePerformanceQueryEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubpassResolvePerformanceQueryEXT);
}
pub fn size_of_VkMultisampledRenderToSingleSampledInfoEXT(item: *const vk.VkMultisampledRenderToSingleSampledInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMultisampledRenderToSingleSampledInfoEXT);
}
pub fn size_of_VkPhysicalDevicePipelineProtectedAccessFeatures(item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineProtectedAccessFeatures);
}
pub fn size_of_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT);
}
pub fn size_of_VkQueueFamilyVideoPropertiesKHR(item: *const vk.VkQueueFamilyVideoPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyVideoPropertiesKHR);
}
pub fn size_of_VkQueueFamilyQueryResultStatusPropertiesKHR(item: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueueFamilyQueryResultStatusPropertiesKHR);
}
pub fn size_of_VkVideoProfileListInfoKHR(item: *const vk.VkVideoProfileListInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.profileCount) |i|
        size += size_of_VkVideoProfileInfoKHR(@ptrCast(&item.pProfiles[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoProfileListInfoKHR);
}
pub fn size_of_VkPhysicalDeviceVideoFormatInfoKHR(item: *const vk.VkPhysicalDeviceVideoFormatInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
                => size += size_of_VkVideoProfileListInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoFormatInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkPhysicalDeviceVideoFormatInfoKHR);
}
pub fn size_of_VkVideoFormatPropertiesKHR(item: *const vk.VkVideoFormatPropertiesKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR,
                => size += size_of_VkVideoFormatQuantizationMapPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR,
                => size += size_of_VkVideoFormatH265QuantizationMapPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR,
                => size += size_of_VkVideoFormatAV1QuantizationMapPropertiesKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoFormatPropertiesKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoFormatPropertiesKHR);
}
pub fn size_of_VkVideoEncodeQuantizationMapCapabilitiesKHR(item: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeQuantizationMapCapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(item: *const vk.VkVideoEncodeH264QuantizationMapCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264QuantizationMapCapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(item: *const vk.VkVideoEncodeH265QuantizationMapCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265QuantizationMapCapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(item: *const vk.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR);
}
pub fn size_of_VkVideoFormatQuantizationMapPropertiesKHR(item: *const vk.VkVideoFormatQuantizationMapPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoFormatQuantizationMapPropertiesKHR);
}
pub fn size_of_VkVideoFormatH265QuantizationMapPropertiesKHR(item: *const vk.VkVideoFormatH265QuantizationMapPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoFormatH265QuantizationMapPropertiesKHR);
}
pub fn size_of_VkVideoFormatAV1QuantizationMapPropertiesKHR(item: *const vk.VkVideoFormatAV1QuantizationMapPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoFormatAV1QuantizationMapPropertiesKHR);
}
pub fn size_of_VkVideoProfileInfoKHR(item: *const vk.VkVideoProfileInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
                => size += size_of_VkVideoDecodeUsageInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeH264ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeH265ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeVP9ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
                => size += size_of_VkVideoDecodeAV1ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
                => size += size_of_VkVideoEncodeUsageInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
                => size += size_of_VkVideoEncodeH264ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
                => size += size_of_VkVideoEncodeH265ProfileInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1ProfileInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoProfileInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoProfileInfoKHR);
}
pub fn size_of_VkVideoCapabilitiesKHR(item: *const vk.VkVideoCapabilitiesKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeQuantizationMapCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
                => size += size_of_VkVideoDecodeCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR,
                => size += size_of_VkVideoDecodeH264CapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR,
                => size += size_of_VkVideoDecodeH265CapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR,
                => size += size_of_VkVideoDecodeVP9CapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR,
                => size += size_of_VkVideoDecodeAV1CapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeCapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeH264CapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeH265CapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeAV1CapabilitiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR,
                => size += size_of_VkVideoEncodeIntraRefreshCapabilitiesKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoCapabilitiesKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoCapabilitiesKHR);
}
pub fn size_of_VkVideoSessionMemoryRequirementsKHR(item: *const vk.VkVideoSessionMemoryRequirementsKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoSessionMemoryRequirementsKHR);
}
pub fn size_of_VkBindVideoSessionMemoryInfoKHR(item: *const vk.VkBindVideoSessionMemoryInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindVideoSessionMemoryInfoKHR);
}
pub fn size_of_VkVideoPictureResourceInfoKHR(item: *const vk.VkVideoPictureResourceInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoPictureResourceInfoKHR);
}
pub fn size_of_VkVideoReferenceSlotInfoKHR(item: *const vk.VkVideoReferenceSlotInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pPictureResource) |ptr| size += size_of_VkVideoPictureResourceInfoKHR(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                => size += size_of_VkVideoDecodeH264DpbSlotInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR,
                => size += size_of_VkVideoDecodeH265DpbSlotInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,
                => size += size_of_VkVideoDecodeAV1DpbSlotInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
                => size += size_of_VkVideoEncodeH264DpbSlotInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR,
                => size += size_of_VkVideoEncodeH265DpbSlotInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1DpbSlotInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR,
                => size += size_of_VkVideoReferenceIntraRefreshInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoReferenceSlotInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkVideoReferenceSlotInfoKHR);
}
pub fn size_of_VkVideoDecodeCapabilitiesKHR(item: *const vk.VkVideoDecodeCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeCapabilitiesKHR);
}
pub fn size_of_VkVideoDecodeUsageInfoKHR(item: *const vk.VkVideoDecodeUsageInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeUsageInfoKHR);
}
pub fn size_of_VkVideoDecodeInfoKHR(item: *const vk.VkVideoDecodeInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pSetupReferenceSlot) |ptr| size += size_of_VkVideoReferenceSlotInfoKHR(@ptrCast(ptr), false);
    for (0..item.referenceSlotCount) |i|
        size += size_of_VkVideoReferenceSlotInfoKHR(@ptrCast(&item.pReferenceSlots[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
                => size += size_of_VkVideoInlineQueryInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR,
                => size += size_of_VkVideoDecodeH264InlineSessionParametersInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR,
                => size += size_of_VkVideoDecodeH264PictureInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR,
                => size += size_of_VkVideoDecodeH265InlineSessionParametersInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR,
                => size += size_of_VkVideoDecodeH265PictureInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR,
                => size += size_of_VkVideoDecodeVP9PictureInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR,
                => size += size_of_VkVideoDecodeAV1InlineSessionParametersInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR,
                => size += size_of_VkVideoDecodeAV1PictureInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkVideoDecodeInfoKHR);
}
pub fn size_of_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(item: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(item: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR);
}
pub fn size_of_VkVideoInlineQueryInfoKHR(item: *const vk.VkVideoInlineQueryInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoInlineQueryInfoKHR);
}
pub fn size_of_VkVideoDecodeH264ProfileInfoKHR(item: *const vk.VkVideoDecodeH264ProfileInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeH264ProfileInfoKHR);
}
pub fn size_of_VkVideoDecodeH264CapabilitiesKHR(item: *const vk.VkVideoDecodeH264CapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeH264CapabilitiesKHR);
}
pub fn size_of_VkVideoDecodeH264SessionParametersAddInfoKHR(item: *const vk.VkVideoDecodeH264SessionParametersAddInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.stdSPSCount) |_|
        size += @sizeOf(vk.StdVideoH264SequenceParameterSet);
    for (0..item.stdPPSCount) |_|
        size += @sizeOf(vk.StdVideoH264PictureParameterSet);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH264SessionParametersAddInfoKHR);
}
pub fn size_of_VkVideoDecodeH264SessionParametersCreateInfoKHR(item: *const vk.VkVideoDecodeH264SessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pParametersAddInfo) |ptr| size += size_of_VkVideoDecodeH264SessionParametersAddInfoKHR(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH264SessionParametersCreateInfoKHR);
}
pub fn size_of_VkVideoDecodeH264InlineSessionParametersInfoKHR(item: *const vk.VkVideoDecodeH264InlineSessionParametersInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdSPS) |ptr| size += @sizeOf(ptr.*);
    if (item.pStdPPS) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH264InlineSessionParametersInfoKHR);
}
pub fn size_of_VkVideoDecodeH264PictureInfoKHR(item: *const vk.VkVideoDecodeH264PictureInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdPictureInfo) |ptr| size += @sizeOf(ptr.*);
    for (0..item.sliceCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH264PictureInfoKHR);
}
pub fn size_of_VkVideoDecodeH264DpbSlotInfoKHR(item: *const vk.VkVideoDecodeH264DpbSlotInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdReferenceInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH264DpbSlotInfoKHR);
}
pub fn size_of_VkVideoDecodeH265ProfileInfoKHR(item: *const vk.VkVideoDecodeH265ProfileInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeH265ProfileInfoKHR);
}
pub fn size_of_VkVideoDecodeH265CapabilitiesKHR(item: *const vk.VkVideoDecodeH265CapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeH265CapabilitiesKHR);
}
pub fn size_of_VkVideoDecodeH265SessionParametersAddInfoKHR(item: *const vk.VkVideoDecodeH265SessionParametersAddInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.stdVPSCount) |_|
        size += @sizeOf(vk.StdVideoH265VideoParameterSet);
    for (0..item.stdSPSCount) |_|
        size += @sizeOf(vk.StdVideoH265SequenceParameterSet);
    for (0..item.stdPPSCount) |_|
        size += @sizeOf(vk.StdVideoH265PictureParameterSet);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH265SessionParametersAddInfoKHR);
}
pub fn size_of_VkVideoDecodeH265SessionParametersCreateInfoKHR(item: *const vk.VkVideoDecodeH265SessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pParametersAddInfo) |ptr| size += size_of_VkVideoDecodeH265SessionParametersAddInfoKHR(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH265SessionParametersCreateInfoKHR);
}
pub fn size_of_VkVideoDecodeH265InlineSessionParametersInfoKHR(item: *const vk.VkVideoDecodeH265InlineSessionParametersInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdVPS) |ptr| size += @sizeOf(ptr.*);
    if (item.pStdSPS) |ptr| size += @sizeOf(ptr.*);
    if (item.pStdPPS) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH265InlineSessionParametersInfoKHR);
}
pub fn size_of_VkVideoDecodeH265PictureInfoKHR(item: *const vk.VkVideoDecodeH265PictureInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdPictureInfo) |ptr| size += @sizeOf(ptr.*);
    for (0..item.sliceSegmentCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH265PictureInfoKHR);
}
pub fn size_of_VkVideoDecodeH265DpbSlotInfoKHR(item: *const vk.VkVideoDecodeH265DpbSlotInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdReferenceInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeH265DpbSlotInfoKHR);
}
pub fn size_of_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(item: *const vk.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR);
}
pub fn size_of_VkVideoDecodeVP9ProfileInfoKHR(item: *const vk.VkVideoDecodeVP9ProfileInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeVP9ProfileInfoKHR);
}
pub fn size_of_VkVideoDecodeVP9CapabilitiesKHR(item: *const vk.VkVideoDecodeVP9CapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeVP9CapabilitiesKHR);
}
pub fn size_of_VkVideoDecodeVP9PictureInfoKHR(item: *const vk.VkVideoDecodeVP9PictureInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdPictureInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeVP9PictureInfoKHR);
}
pub fn size_of_VkVideoDecodeAV1ProfileInfoKHR(item: *const vk.VkVideoDecodeAV1ProfileInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeAV1ProfileInfoKHR);
}
pub fn size_of_VkVideoDecodeAV1CapabilitiesKHR(item: *const vk.VkVideoDecodeAV1CapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoDecodeAV1CapabilitiesKHR);
}
pub fn size_of_VkVideoDecodeAV1SessionParametersCreateInfoKHR(item: *const vk.VkVideoDecodeAV1SessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdSequenceHeader) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeAV1SessionParametersCreateInfoKHR);
}
pub fn size_of_VkVideoDecodeAV1InlineSessionParametersInfoKHR(item: *const vk.VkVideoDecodeAV1InlineSessionParametersInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdSequenceHeader) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeAV1InlineSessionParametersInfoKHR);
}
pub fn size_of_VkVideoDecodeAV1PictureInfoKHR(item: *const vk.VkVideoDecodeAV1PictureInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdPictureInfo) |ptr| size += @sizeOf(ptr.*);
    for (0..item.tileCount) |_|
        size += @sizeOf(u32);
    for (0..item.tileCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeAV1PictureInfoKHR);
}
pub fn size_of_VkVideoDecodeAV1DpbSlotInfoKHR(item: *const vk.VkVideoDecodeAV1DpbSlotInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdReferenceInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoDecodeAV1DpbSlotInfoKHR);
}
pub fn size_of_VkVideoSessionCreateInfoKHR(item: *const vk.VkVideoSessionCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pVideoProfile) |ptr| size += size_of_VkVideoProfileInfoKHR(@ptrCast(ptr), false);
    if (item.pStdHeaderVersion) |ptr| size += size_of_VkExtensionProperties(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeH264SessionCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeH265SessionCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1SessionCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoSessionCreateInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkVideoSessionCreateInfoKHR);
}
pub fn size_of_VkVideoSessionParametersCreateInfoKHR(item: *const vk.VkVideoSessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
                => size += size_of_VkVideoDecodeH264SessionParametersCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
                => size += size_of_VkVideoDecodeH265SessionParametersCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
                => size += size_of_VkVideoDecodeAV1SessionParametersCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
                => size += size_of_VkVideoEncodeQualityLevelInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeH264SessionParametersCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeH265SessionParametersCreateInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1SessionParametersCreateInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersCreateInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoSessionParametersCreateInfoKHR);
}
pub fn size_of_VkVideoSessionParametersUpdateInfoKHR(item: *const vk.VkVideoSessionParametersUpdateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
                => size += size_of_VkVideoDecodeH264SessionParametersAddInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
                => size += size_of_VkVideoDecodeH265SessionParametersAddInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
                => size += size_of_VkVideoEncodeH264SessionParametersAddInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
                => size += size_of_VkVideoEncodeH265SessionParametersAddInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersUpdateInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoSessionParametersUpdateInfoKHR);
}
pub fn size_of_VkVideoEncodeSessionParametersGetInfoKHR(item: *const vk.VkVideoEncodeSessionParametersGetInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR,
                => size += size_of_VkVideoEncodeH264SessionParametersGetInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR,
                => size += size_of_VkVideoEncodeH265SessionParametersGetInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersGetInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoEncodeSessionParametersGetInfoKHR);
}
pub fn size_of_VkVideoEncodeSessionParametersFeedbackInfoKHR(item: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
                => size += size_of_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
                => size += size_of_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersFeedbackInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoEncodeSessionParametersFeedbackInfoKHR);
}
pub fn size_of_VkVideoBeginCodingInfoKHR(item: *const vk.VkVideoBeginCodingInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.referenceSlotCount) |i|
        size += size_of_VkVideoReferenceSlotInfoKHR(@ptrCast(&item.pReferenceSlots[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeRateControlInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeH264RateControlInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR,
                => size += size_of_VkVideoEncodeH264GopRemainingFrameInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeH265RateControlInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR,
                => size += size_of_VkVideoEncodeH265GopRemainingFrameInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1RateControlInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1GopRemainingFrameInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoBeginCodingInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkVideoBeginCodingInfoKHR);
}
pub fn size_of_VkVideoEndCodingInfoKHR(item: *const vk.VkVideoEndCodingInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEndCodingInfoKHR);
}
pub fn size_of_VkVideoCodingControlInfoKHR(item: *const vk.VkVideoCodingControlInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
                => size += size_of_VkVideoEncodeQualityLevelInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeRateControlInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeH264RateControlInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeH265RateControlInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1RateControlInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoCodingControlInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoCodingControlInfoKHR);
}
pub fn size_of_VkVideoEncodeUsageInfoKHR(item: *const vk.VkVideoEncodeUsageInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeUsageInfoKHR);
}
pub fn size_of_VkVideoEncodeInfoKHR(item: *const vk.VkVideoEncodeInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pSetupReferenceSlot) |ptr| size += size_of_VkVideoReferenceSlotInfoKHR(@ptrCast(ptr), false);
    for (0..item.referenceSlotCount) |i|
        size += size_of_VkVideoReferenceSlotInfoKHR(@ptrCast(&item.pReferenceSlots[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
                => size += size_of_VkVideoInlineQueryInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
                => size += size_of_VkVideoEncodeQuantizationMapInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
                => size += size_of_VkVideoEncodeH264PictureInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR,
                => size += size_of_VkVideoEncodeH265PictureInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1PictureInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR,
                => size += size_of_VkVideoEncodeIntraRefreshInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkVideoEncodeInfoKHR);
}
pub fn size_of_VkVideoEncodeQuantizationMapInfoKHR(item: *const vk.VkVideoEncodeQuantizationMapInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeQuantizationMapInfoKHR);
}
pub fn size_of_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(item: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR);
}
pub fn size_of_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(item: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR);
}
pub fn size_of_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(item: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeQualityLevelInfoKHR(item: *const vk.VkVideoEncodeQualityLevelInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeQualityLevelInfoKHR);
}
pub fn size_of_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(item: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pVideoProfile) |ptr| size += size_of_VkVideoProfileInfoKHR(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR);
}
pub fn size_of_VkVideoEncodeQualityLevelPropertiesKHR(item: *const vk.VkVideoEncodeQualityLevelPropertiesKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR,
                => size += size_of_VkVideoEncodeH264QualityLevelPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR,
                => size += size_of_VkVideoEncodeH265QualityLevelPropertiesKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR,
                => size += size_of_VkVideoEncodeAV1QualityLevelPropertiesKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQualityLevelPropertiesKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoEncodeQualityLevelPropertiesKHR);
}
pub fn size_of_VkVideoEncodeRateControlInfoKHR(item: *const vk.VkVideoEncodeRateControlInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.layerCount) |i|
        size += size_of_VkVideoEncodeRateControlLayerInfoKHR(@ptrCast(&item.pLayers[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeRateControlInfoKHR);
}
pub fn size_of_VkVideoEncodeRateControlLayerInfoKHR(item: *const vk.VkVideoEncodeRateControlLayerInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR,
                => size += size_of_VkVideoEncodeH264RateControlLayerInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR,
                => size += size_of_VkVideoEncodeH265RateControlLayerInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR,
                => size += size_of_VkVideoEncodeAV1RateControlLayerInfoKHR(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRateControlLayerInfoKHR: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkVideoEncodeRateControlLayerInfoKHR);
}
pub fn size_of_VkVideoEncodeCapabilitiesKHR(item: *const vk.VkVideoEncodeCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeCapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeH264CapabilitiesKHR(item: *const vk.VkVideoEncodeH264CapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264CapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeH264QualityLevelPropertiesKHR(item: *const vk.VkVideoEncodeH264QualityLevelPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264QualityLevelPropertiesKHR);
}
pub fn size_of_VkVideoEncodeH264SessionCreateInfoKHR(item: *const vk.VkVideoEncodeH264SessionCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264SessionCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeH264SessionParametersAddInfoKHR(item: *const vk.VkVideoEncodeH264SessionParametersAddInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.stdSPSCount) |_|
        size += @sizeOf(vk.StdVideoH264SequenceParameterSet);
    for (0..item.stdPPSCount) |_|
        size += @sizeOf(vk.StdVideoH264PictureParameterSet);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH264SessionParametersAddInfoKHR);
}
pub fn size_of_VkVideoEncodeH264SessionParametersCreateInfoKHR(item: *const vk.VkVideoEncodeH264SessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pParametersAddInfo) |ptr| size += size_of_VkVideoEncodeH264SessionParametersAddInfoKHR(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH264SessionParametersCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeH264SessionParametersGetInfoKHR(item: *const vk.VkVideoEncodeH264SessionParametersGetInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264SessionParametersGetInfoKHR);
}
pub fn size_of_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(item: *const vk.VkVideoEncodeH264SessionParametersFeedbackInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264SessionParametersFeedbackInfoKHR);
}
pub fn size_of_VkVideoEncodeH264DpbSlotInfoKHR(item: *const vk.VkVideoEncodeH264DpbSlotInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdReferenceInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH264DpbSlotInfoKHR);
}
pub fn size_of_VkVideoEncodeH264PictureInfoKHR(item: *const vk.VkVideoEncodeH264PictureInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.naluSliceEntryCount) |i|
        size += size_of_VkVideoEncodeH264NaluSliceInfoKHR(@ptrCast(&item.pNaluSliceEntries[i]), false);
    if (item.pStdPictureInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH264PictureInfoKHR);
}
pub fn size_of_VkVideoEncodeH264ProfileInfoKHR(item: *const vk.VkVideoEncodeH264ProfileInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264ProfileInfoKHR);
}
pub fn size_of_VkVideoEncodeH264NaluSliceInfoKHR(item: *const vk.VkVideoEncodeH264NaluSliceInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdSliceHeader) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH264NaluSliceInfoKHR);
}
pub fn size_of_VkVideoEncodeH264RateControlInfoKHR(item: *const vk.VkVideoEncodeH264RateControlInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264RateControlInfoKHR);
}
pub fn size_of_VkVideoEncodeH264QpKHR(item: *const vk.VkVideoEncodeH264QpKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264QpKHR);
}
pub fn size_of_VkVideoEncodeH264FrameSizeKHR(item: *const vk.VkVideoEncodeH264FrameSizeKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264FrameSizeKHR);
}
pub fn size_of_VkVideoEncodeH264GopRemainingFrameInfoKHR(item: *const vk.VkVideoEncodeH264GopRemainingFrameInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264GopRemainingFrameInfoKHR);
}
pub fn size_of_VkVideoEncodeH264RateControlLayerInfoKHR(item: *const vk.VkVideoEncodeH264RateControlLayerInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH264RateControlLayerInfoKHR);
}
pub fn size_of_VkVideoEncodeH265CapabilitiesKHR(item: *const vk.VkVideoEncodeH265CapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265CapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeH265QualityLevelPropertiesKHR(item: *const vk.VkVideoEncodeH265QualityLevelPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265QualityLevelPropertiesKHR);
}
pub fn size_of_VkVideoEncodeH265SessionCreateInfoKHR(item: *const vk.VkVideoEncodeH265SessionCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265SessionCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeH265SessionParametersAddInfoKHR(item: *const vk.VkVideoEncodeH265SessionParametersAddInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.stdVPSCount) |_|
        size += @sizeOf(vk.StdVideoH265VideoParameterSet);
    for (0..item.stdSPSCount) |_|
        size += @sizeOf(vk.StdVideoH265SequenceParameterSet);
    for (0..item.stdPPSCount) |_|
        size += @sizeOf(vk.StdVideoH265PictureParameterSet);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH265SessionParametersAddInfoKHR);
}
pub fn size_of_VkVideoEncodeH265SessionParametersCreateInfoKHR(item: *const vk.VkVideoEncodeH265SessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pParametersAddInfo) |ptr| size += size_of_VkVideoEncodeH265SessionParametersAddInfoKHR(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH265SessionParametersCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeH265SessionParametersGetInfoKHR(item: *const vk.VkVideoEncodeH265SessionParametersGetInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265SessionParametersGetInfoKHR);
}
pub fn size_of_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(item: *const vk.VkVideoEncodeH265SessionParametersFeedbackInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265SessionParametersFeedbackInfoKHR);
}
pub fn size_of_VkVideoEncodeH265PictureInfoKHR(item: *const vk.VkVideoEncodeH265PictureInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.naluSliceSegmentEntryCount) |i|
        size += size_of_VkVideoEncodeH265NaluSliceSegmentInfoKHR(@ptrCast(&item.pNaluSliceSegmentEntries[i]), false);
    if (item.pStdPictureInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH265PictureInfoKHR);
}
pub fn size_of_VkVideoEncodeH265NaluSliceSegmentInfoKHR(item: *const vk.VkVideoEncodeH265NaluSliceSegmentInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdSliceSegmentHeader) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH265NaluSliceSegmentInfoKHR);
}
pub fn size_of_VkVideoEncodeH265RateControlInfoKHR(item: *const vk.VkVideoEncodeH265RateControlInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265RateControlInfoKHR);
}
pub fn size_of_VkVideoEncodeH265QpKHR(item: *const vk.VkVideoEncodeH265QpKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265QpKHR);
}
pub fn size_of_VkVideoEncodeH265FrameSizeKHR(item: *const vk.VkVideoEncodeH265FrameSizeKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265FrameSizeKHR);
}
pub fn size_of_VkVideoEncodeH265GopRemainingFrameInfoKHR(item: *const vk.VkVideoEncodeH265GopRemainingFrameInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265GopRemainingFrameInfoKHR);
}
pub fn size_of_VkVideoEncodeH265RateControlLayerInfoKHR(item: *const vk.VkVideoEncodeH265RateControlLayerInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265RateControlLayerInfoKHR);
}
pub fn size_of_VkVideoEncodeH265ProfileInfoKHR(item: *const vk.VkVideoEncodeH265ProfileInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeH265ProfileInfoKHR);
}
pub fn size_of_VkVideoEncodeH265DpbSlotInfoKHR(item: *const vk.VkVideoEncodeH265DpbSlotInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdReferenceInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeH265DpbSlotInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1CapabilitiesKHR(item: *const vk.VkVideoEncodeAV1CapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1CapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeAV1QualityLevelPropertiesKHR(item: *const vk.VkVideoEncodeAV1QualityLevelPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1QualityLevelPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(item: *const vk.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR);
}
pub fn size_of_VkVideoEncodeAV1SessionCreateInfoKHR(item: *const vk.VkVideoEncodeAV1SessionCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1SessionCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1SessionParametersCreateInfoKHR(item: *const vk.VkVideoEncodeAV1SessionParametersCreateInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdSequenceHeader) |ptr| size += @sizeOf(ptr.*);
    if (item.pStdDecoderModelInfo) |ptr| size += @sizeOf(ptr.*);
    for (0..item.stdOperatingPointCount) |_|
        size += @sizeOf(vk.StdVideoEncodeAV1OperatingPointInfo);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeAV1SessionParametersCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1DpbSlotInfoKHR(item: *const vk.VkVideoEncodeAV1DpbSlotInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdReferenceInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeAV1DpbSlotInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1PictureInfoKHR(item: *const vk.VkVideoEncodeAV1PictureInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pStdPictureInfo) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkVideoEncodeAV1PictureInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1ProfileInfoKHR(item: *const vk.VkVideoEncodeAV1ProfileInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1ProfileInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1RateControlInfoKHR(item: *const vk.VkVideoEncodeAV1RateControlInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1RateControlInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1QIndexKHR(item: *const vk.VkVideoEncodeAV1QIndexKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1QIndexKHR);
}
pub fn size_of_VkVideoEncodeAV1FrameSizeKHR(item: *const vk.VkVideoEncodeAV1FrameSizeKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1FrameSizeKHR);
}
pub fn size_of_VkVideoEncodeAV1GopRemainingFrameInfoKHR(item: *const vk.VkVideoEncodeAV1GopRemainingFrameInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1GopRemainingFrameInfoKHR);
}
pub fn size_of_VkVideoEncodeAV1RateControlLayerInfoKHR(item: *const vk.VkVideoEncodeAV1RateControlLayerInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeAV1RateControlLayerInfoKHR);
}
pub fn size_of_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(item: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceProvokingVertexFeaturesEXT(item: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceProvokingVertexFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceProvokingVertexPropertiesEXT(item: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceProvokingVertexPropertiesEXT);
}
pub fn size_of_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(item: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT);
}
pub fn size_of_VkVideoEncodeIntraRefreshCapabilitiesKHR(item: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeIntraRefreshCapabilitiesKHR);
}
pub fn size_of_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(item: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR);
}
pub fn size_of_VkVideoEncodeIntraRefreshInfoKHR(item: *const vk.VkVideoEncodeIntraRefreshInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoEncodeIntraRefreshInfoKHR);
}
pub fn size_of_VkVideoReferenceIntraRefreshInfoKHR(item: *const vk.VkVideoReferenceIntraRefreshInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkVideoReferenceIntraRefreshInfoKHR);
}
pub fn size_of_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(item: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceDescriptorBufferFeaturesEXT(item: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDescriptorBufferPropertiesEXT(item: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(item: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT);
}
pub fn size_of_VkDescriptorAddressInfoEXT(item: *const vk.VkDescriptorAddressInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorAddressInfoEXT);
}
pub fn size_of_VkDescriptorBufferBindingInfoEXT(item: *const vk.VkDescriptorBufferBindingInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                => size += size_of_VkBufferUsageFlags2CreateInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT,
                => size += size_of_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDescriptorBufferBindingInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkDescriptorBufferBindingInfoEXT);
}
pub fn size_of_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(item: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT);
}
pub fn size_of_VkDescriptorGetInfoEXT(item: *const vk.VkDescriptorGetInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorGetInfoEXT);
}
pub fn size_of_VkBufferCaptureDescriptorDataInfoEXT(item: *const vk.VkBufferCaptureDescriptorDataInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCaptureDescriptorDataInfoEXT);
}
pub fn size_of_VkImageCaptureDescriptorDataInfoEXT(item: *const vk.VkImageCaptureDescriptorDataInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageCaptureDescriptorDataInfoEXT);
}
pub fn size_of_VkImageViewCaptureDescriptorDataInfoEXT(item: *const vk.VkImageViewCaptureDescriptorDataInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageViewCaptureDescriptorDataInfoEXT);
}
pub fn size_of_VkSamplerCaptureDescriptorDataInfoEXT(item: *const vk.VkSamplerCaptureDescriptorDataInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSamplerCaptureDescriptorDataInfoEXT);
}
pub fn size_of_VkAccelerationStructureCaptureDescriptorDataInfoEXT(item: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT);
}
pub fn size_of_VkOpaqueCaptureDescriptorDataCreateInfoEXT(item: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.opaqueCaptureDescriptorData) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceShaderIntegerDotProductFeatures(item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderIntegerDotProductFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceShaderIntegerDotProductProperties(item: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderIntegerDotProductProperties);
}
pub fn size_of_VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR(item: *const vk.VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceDrmPropertiesEXT(item: *const vk.VkPhysicalDeviceDrmPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDrmPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR);
}
pub fn size_of_VkImportMemoryBufferCollectionFUCHSIA(item: *const vk.VkImportMemoryBufferCollectionFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMemoryBufferCollectionFUCHSIA);
}
pub fn size_of_VkBufferCollectionImageCreateInfoFUCHSIA(item: *const vk.VkBufferCollectionImageCreateInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCollectionImageCreateInfoFUCHSIA);
}
pub fn size_of_VkBufferCollectionBufferCreateInfoFUCHSIA(item: *const vk.VkBufferCollectionBufferCreateInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCollectionBufferCreateInfoFUCHSIA);
}
pub fn size_of_VkBufferCollectionCreateInfoFUCHSIA(item: *const vk.VkBufferCollectionCreateInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCollectionCreateInfoFUCHSIA);
}
pub fn size_of_VkBufferCollectionPropertiesFUCHSIA(item: *const vk.VkBufferCollectionPropertiesFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCollectionPropertiesFUCHSIA);
}
pub fn size_of_VkBufferConstraintsInfoFUCHSIA(item: *const vk.VkBufferConstraintsInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferConstraintsInfoFUCHSIA);
}
pub fn size_of_VkSysmemColorSpaceFUCHSIA(item: *const vk.VkSysmemColorSpaceFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSysmemColorSpaceFUCHSIA);
}
pub fn size_of_VkImageFormatConstraintsInfoFUCHSIA(item: *const vk.VkImageFormatConstraintsInfoFUCHSIA, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.colorSpaceCount) |i|
        size += size_of_VkSysmemColorSpaceFUCHSIA(@ptrCast(&item.pColorSpaces[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImageFormatConstraintsInfoFUCHSIA);
}
pub fn size_of_VkImageConstraintsInfoFUCHSIA(item: *const vk.VkImageConstraintsInfoFUCHSIA, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.formatConstraintsCount) |i|
        size += size_of_VkImageFormatConstraintsInfoFUCHSIA(@ptrCast(&item.pFormatConstraints[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImageConstraintsInfoFUCHSIA);
}
pub fn size_of_VkBufferCollectionConstraintsInfoFUCHSIA(item: *const vk.VkBufferCollectionConstraintsInfoFUCHSIA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBufferCollectionConstraintsInfoFUCHSIA);
}
pub fn size_of_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(item: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
}
pub fn size_of_VkFormatProperties3(item: *const vk.VkFormatProperties3, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFormatProperties3);
}
pub fn size_of_VkFormatProperties3KHR(item: *const vk.VkFormatProperties3KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkFormatProperties3KHR);
}
pub fn size_of_VkDrmFormatModifierPropertiesList2EXT(item: *const vk.VkDrmFormatModifierPropertiesList2EXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.drmFormatModifierCount) |i|
        size += size_of_VkDrmFormatModifierProperties2EXT(@ptrCast(&item.pDrmFormatModifierProperties[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDrmFormatModifierPropertiesList2EXT);
}
pub fn size_of_VkDrmFormatModifierProperties2EXT(item: *const vk.VkDrmFormatModifierProperties2EXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDrmFormatModifierProperties2EXT);
}
pub fn size_of_VkAndroidHardwareBufferFormatProperties2ANDROID(item: *const vk.VkAndroidHardwareBufferFormatProperties2ANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAndroidHardwareBufferFormatProperties2ANDROID);
}
pub fn size_of_VkPipelineRenderingCreateInfo(item: *const vk.VkPipelineRenderingCreateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.colorAttachmentCount) |_|
        size += @sizeOf(vk.VkFormat);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineRenderingCreateInfo);
}
pub fn size_of_VkPipelineRenderingCreateInfoKHR(item: *const vk.VkPipelineRenderingCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRenderingCreateInfoKHR);
}
pub fn size_of_VkRenderingInfo(item: *const vk.VkRenderingInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.colorAttachmentCount) |i|
        size += size_of_VkRenderingAttachmentInfo(@ptrCast(&item.pColorAttachments[i]), false);
    if (item.pDepthAttachment) |ptr| size += size_of_VkRenderingAttachmentInfo(@ptrCast(ptr), false);
    if (item.pStencilAttachment) |ptr| size += size_of_VkRenderingAttachmentInfo(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
                => size += size_of_VkDeviceGroupRenderPassBeginInfo(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
                => size += size_of_VkMultisampledRenderToSingleSampledInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
                => size += size_of_VkRenderingFragmentShadingRateAttachmentInfoKHR(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
                => size += size_of_VkRenderingFragmentDensityMapAttachmentInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkRenderingInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkRenderingInfo);
}
pub fn size_of_VkRenderingInfoKHR(item: *const vk.VkRenderingInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderingInfoKHR);
}
pub fn size_of_VkRenderingEndInfoEXT(item: *const vk.VkRenderingEndInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
                => size += size_of_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkRenderingEndInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkRenderingEndInfoEXT);
}
pub fn size_of_VkRenderingAttachmentInfo(item: *const vk.VkRenderingAttachmentInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT,
                => size += size_of_VkAttachmentFeedbackLoopInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkRenderingAttachmentInfo);
}
pub fn size_of_VkRenderingAttachmentInfoKHR(item: *const vk.VkRenderingAttachmentInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderingAttachmentInfoKHR);
}
pub fn size_of_VkRenderingFragmentShadingRateAttachmentInfoKHR(item: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderingFragmentShadingRateAttachmentInfoKHR);
}
pub fn size_of_VkRenderingFragmentDensityMapAttachmentInfoEXT(item: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderingFragmentDensityMapAttachmentInfoEXT);
}
pub fn size_of_VkPhysicalDeviceDynamicRenderingFeatures(item: *const vk.VkPhysicalDeviceDynamicRenderingFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDynamicRenderingFeatures);
}
pub fn size_of_VkPhysicalDeviceDynamicRenderingFeaturesKHR(item: *const vk.VkPhysicalDeviceDynamicRenderingFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDynamicRenderingFeaturesKHR);
}
pub fn size_of_VkCommandBufferInheritanceRenderingInfo(item: *const vk.VkCommandBufferInheritanceRenderingInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.colorAttachmentCount) |_|
        size += @sizeOf(vk.VkFormat);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkCommandBufferInheritanceRenderingInfo);
}
pub fn size_of_VkCommandBufferInheritanceRenderingInfoKHR(item: *const vk.VkCommandBufferInheritanceRenderingInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCommandBufferInheritanceRenderingInfoKHR);
}
pub fn size_of_VkPhysicalDeviceImageViewMinLodFeaturesEXT(item: *const vk.VkPhysicalDeviceImageViewMinLodFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageViewMinLodFeaturesEXT);
}
pub fn size_of_VkImageViewMinLodCreateInfoEXT(item: *const vk.VkImageViewMinLodCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageViewMinLodCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(item: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT);
}
pub fn size_of_VkPhysicalDevicePipelineBinaryFeaturesKHR(item: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineBinaryFeaturesKHR);
}
pub fn size_of_VkDevicePipelineBinaryInternalCacheControlKHR(item: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDevicePipelineBinaryInternalCacheControlKHR);
}
pub fn size_of_VkPhysicalDevicePipelineBinaryPropertiesKHR(item: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineBinaryPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT);
}
pub fn size_of_VkGraphicsPipelineLibraryCreateInfoEXT(item: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkGraphicsPipelineLibraryCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(item: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE);
}
pub fn size_of_VkDescriptorSetBindingReferenceVALVE(item: *const vk.VkDescriptorSetBindingReferenceVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorSetBindingReferenceVALVE);
}
pub fn size_of_VkDescriptorSetLayoutHostMappingInfoVALVE(item: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDescriptorSetLayoutHostMappingInfoVALVE);
}
pub fn size_of_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(item: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(item: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(item: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(item: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT);
}
pub fn size_of_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(item: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.identifierSize) |_|
        size += @sizeOf(u8);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT);
}
pub fn size_of_VkShaderModuleIdentifierEXT(item: *const vk.VkShaderModuleIdentifierEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkShaderModuleIdentifierEXT);
}
pub fn size_of_VkImageCompressionControlEXT(item: *const vk.VkImageCompressionControlEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.compressionControlPlaneCount) |_|
        size += @sizeOf(vk.VkImageCompressionFixedRateFlagsEXT);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImageCompressionControlEXT);
}
pub fn size_of_VkPhysicalDeviceImageCompressionControlFeaturesEXT(item: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT);
}
pub fn size_of_VkImageCompressionPropertiesEXT(item: *const vk.VkImageCompressionPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageCompressionPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(item: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT);
}
pub fn size_of_VkImageSubresource2(item: *const vk.VkImageSubresource2, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSubresource2);
}
pub fn size_of_VkImageSubresource2KHR(item: *const vk.VkImageSubresource2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSubresource2KHR);
}
pub fn size_of_VkImageSubresource2EXT(item: *const vk.VkImageSubresource2EXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageSubresource2EXT);
}
pub fn size_of_VkSubresourceLayout2(item: *const vk.VkSubresourceLayout2, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
                => size += size_of_VkSubresourceHostMemcpySize(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
                => size += size_of_VkImageCompressionPropertiesEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSubresourceLayout2: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkSubresourceLayout2);
}
pub fn size_of_VkSubresourceLayout2KHR(item: *const vk.VkSubresourceLayout2KHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubresourceLayout2KHR);
}
pub fn size_of_VkSubresourceLayout2EXT(item: *const vk.VkSubresourceLayout2EXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSubresourceLayout2EXT);
}
pub fn size_of_VkRenderPassCreationControlEXT(item: *const vk.VkRenderPassCreationControlEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassCreationControlEXT);
}
pub fn size_of_VkRenderPassCreationFeedbackInfoEXT(item: *const vk.VkRenderPassCreationFeedbackInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassCreationFeedbackInfoEXT);
}
pub fn size_of_VkRenderPassCreationFeedbackCreateInfoEXT(item: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pRenderPassFeedback) |ptr| size += size_of_VkRenderPassCreationFeedbackInfoEXT(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderPassCreationFeedbackCreateInfoEXT);
}
pub fn size_of_VkRenderPassSubpassFeedbackInfoEXT(item: *const vk.VkRenderPassSubpassFeedbackInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderPassSubpassFeedbackInfoEXT);
}
pub fn size_of_VkRenderPassSubpassFeedbackCreateInfoEXT(item: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pSubpassFeedback) |ptr| size += size_of_VkRenderPassSubpassFeedbackInfoEXT(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderPassSubpassFeedbackCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(item: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT);
}
pub fn size_of_VkMicromapBuildInfoEXT(item: *const vk.VkMicromapBuildInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.usageCountsCount) |i|
        size += size_of_VkMicromapUsageEXT(@ptrCast(&item.pUsageCounts[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkMicromapBuildInfoEXT);
}
pub fn size_of_VkMicromapCreateInfoEXT(item: *const vk.VkMicromapCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMicromapCreateInfoEXT);
}
pub fn size_of_VkMicromapVersionInfoEXT(item: *const vk.VkMicromapVersionInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMicromapVersionInfoEXT);
}
pub fn size_of_VkCopyMicromapInfoEXT(item: *const vk.VkCopyMicromapInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyMicromapInfoEXT);
}
pub fn size_of_VkCopyMicromapToMemoryInfoEXT(item: *const vk.VkCopyMicromapToMemoryInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyMicromapToMemoryInfoEXT);
}
pub fn size_of_VkCopyMemoryToMicromapInfoEXT(item: *const vk.VkCopyMemoryToMicromapInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCopyMemoryToMicromapInfoEXT);
}
pub fn size_of_VkMicromapBuildSizesInfoEXT(item: *const vk.VkMicromapBuildSizesInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMicromapBuildSizesInfoEXT);
}
pub fn size_of_VkMicromapUsageEXT(item: *const vk.VkMicromapUsageEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMicromapUsageEXT);
}
pub fn size_of_VkMicromapTriangleEXT(item: *const vk.VkMicromapTriangleEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMicromapTriangleEXT);
}
pub fn size_of_VkPhysicalDeviceOpacityMicromapFeaturesEXT(item: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceOpacityMicromapPropertiesEXT(item: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT);
}
pub fn size_of_VkAccelerationStructureTrianglesOpacityMicromapEXT(item: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.usageCountsCount) |i|
        size += size_of_VkMicromapUsageEXT(@ptrCast(&item.pUsageCounts[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkAccelerationStructureTrianglesOpacityMicromapEXT);
}
pub fn size_of_VkPipelinePropertiesIdentifierEXT(item: *const vk.VkPipelinePropertiesIdentifierEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelinePropertiesIdentifierEXT);
}
pub fn size_of_VkPhysicalDevicePipelinePropertiesFeaturesEXT(item: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT);
}
pub fn size_of_VkExternalMemoryAcquireUnmodifiedEXT(item: *const vk.VkExternalMemoryAcquireUnmodifiedEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalMemoryAcquireUnmodifiedEXT);
}
pub fn size_of_VkExportMetalObjectCreateInfoEXT(item: *const vk.VkExportMetalObjectCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMetalObjectCreateInfoEXT);
}
pub fn size_of_VkExportMetalObjectsInfoEXT(item: *const vk.VkExportMetalObjectsInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT,
                => size += size_of_VkExportMetalDeviceInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
                => size += size_of_VkExportMetalCommandQueueInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT,
                => size += size_of_VkExportMetalBufferInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT,
                => size += size_of_VkExportMetalTextureInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT,
                => size += size_of_VkExportMetalIOSurfaceInfoEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT,
                => size += size_of_VkExportMetalSharedEventInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkExportMetalObjectsInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkExportMetalObjectsInfoEXT);
}
pub fn size_of_VkExportMetalDeviceInfoEXT(item: *const vk.VkExportMetalDeviceInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMetalDeviceInfoEXT);
}
pub fn size_of_VkExportMetalCommandQueueInfoEXT(item: *const vk.VkExportMetalCommandQueueInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMetalCommandQueueInfoEXT);
}
pub fn size_of_VkExportMetalBufferInfoEXT(item: *const vk.VkExportMetalBufferInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMetalBufferInfoEXT);
}
pub fn size_of_VkImportMetalBufferInfoEXT(item: *const vk.VkImportMetalBufferInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMetalBufferInfoEXT);
}
pub fn size_of_VkExportMetalTextureInfoEXT(item: *const vk.VkExportMetalTextureInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMetalTextureInfoEXT);
}
pub fn size_of_VkImportMetalTextureInfoEXT(item: *const vk.VkImportMetalTextureInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMetalTextureInfoEXT);
}
pub fn size_of_VkExportMetalIOSurfaceInfoEXT(item: *const vk.VkExportMetalIOSurfaceInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMetalIOSurfaceInfoEXT);
}
pub fn size_of_VkImportMetalIOSurfaceInfoEXT(item: *const vk.VkImportMetalIOSurfaceInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMetalIOSurfaceInfoEXT);
}
pub fn size_of_VkExportMetalSharedEventInfoEXT(item: *const vk.VkExportMetalSharedEventInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExportMetalSharedEventInfoEXT);
}
pub fn size_of_VkImportMetalSharedEventInfoEXT(item: *const vk.VkImportMetalSharedEventInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImportMetalSharedEventInfoEXT);
}
pub fn size_of_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(item: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT);
}
pub fn size_of_VkPhysicalDevicePipelineRobustnessFeatures(item: *const vk.VkPhysicalDevicePipelineRobustnessFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineRobustnessFeatures);
}
pub fn size_of_VkPhysicalDevicePipelineRobustnessFeaturesEXT(item: *const vk.VkPhysicalDevicePipelineRobustnessFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineRobustnessFeaturesEXT);
}
pub fn size_of_VkPipelineRobustnessCreateInfo(item: *const vk.VkPipelineRobustnessCreateInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRobustnessCreateInfo);
}
pub fn size_of_VkPipelineRobustnessCreateInfoEXT(item: *const vk.VkPipelineRobustnessCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineRobustnessCreateInfoEXT);
}
pub fn size_of_VkPhysicalDevicePipelineRobustnessProperties(item: *const vk.VkPhysicalDevicePipelineRobustnessProperties, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineRobustnessProperties);
}
pub fn size_of_VkPhysicalDevicePipelineRobustnessPropertiesEXT(item: *const vk.VkPhysicalDevicePipelineRobustnessPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineRobustnessPropertiesEXT);
}
pub fn size_of_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthClampZeroOneFeaturesEXT);
}
pub fn size_of_VkAttachmentFeedbackLoopInfoEXT(item: *const vk.VkAttachmentFeedbackLoopInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAttachmentFeedbackLoopInfoEXT);
}
pub fn size_of_VkPhysicalDeviceAddressBindingReportFeaturesEXT(item: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT);
}
pub fn size_of_VkDeviceAddressBindingCallbackDataEXT(item: *const vk.VkDeviceAddressBindingCallbackDataEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceAddressBindingCallbackDataEXT);
}
pub fn size_of_VkPhysicalDeviceFaultFeaturesEXT(item: *const vk.VkPhysicalDeviceFaultFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFaultFeaturesEXT);
}
pub fn size_of_VkDeviceFaultAddressInfoEXT(item: *const vk.VkDeviceFaultAddressInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceFaultAddressInfoEXT);
}
pub fn size_of_VkDeviceFaultVendorInfoEXT(item: *const vk.VkDeviceFaultVendorInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceFaultVendorInfoEXT);
}
pub fn size_of_VkDeviceFaultCountsEXT(item: *const vk.VkDeviceFaultCountsEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceFaultCountsEXT);
}
pub fn size_of_VkDeviceFaultInfoEXT(item: *const vk.VkDeviceFaultInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pAddressInfos) |ptr| size += size_of_VkDeviceFaultAddressInfoEXT(@ptrCast(ptr), false);
    if (item.pVendorInfos) |ptr| size += size_of_VkDeviceFaultVendorInfoEXT(@ptrCast(ptr), false);
    if (item.pVendorBinaryData) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceFaultInfoEXT);
}
pub fn size_of_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionOneEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceFaultVendorBinaryHeaderVersionOneEXT);
}
pub fn size_of_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(item: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT);
}
pub fn size_of_VkDepthBiasInfoEXT(item: *const vk.VkDepthBiasInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
                => size += size_of_VkDepthBiasRepresentationInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkDepthBiasInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkDepthBiasInfoEXT);
}
pub fn size_of_VkDepthBiasRepresentationInfoEXT(item: *const vk.VkDepthBiasRepresentationInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDepthBiasRepresentationInfoEXT);
}
pub fn size_of_VkFrameBoundaryEXT(item: *const vk.VkFrameBoundaryEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.imageCount) |_|
        size += @sizeOf(vk.VkImage);
    for (0..item.bufferCount) |_|
        size += @sizeOf(vk.VkBuffer);
    for (0..item.tagSize) |_|
        size += @sizeOf(void);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkFrameBoundaryEXT);
}
pub fn size_of_VkPhysicalDeviceFrameBoundaryFeaturesEXT(item: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(item: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT);
}
pub fn size_of_VkSurfacePresentModeKHR(item: *const vk.VkSurfacePresentModeKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfacePresentModeKHR);
}
pub fn size_of_VkSurfacePresentModeEXT(item: *const vk.VkSurfacePresentModeEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfacePresentModeEXT);
}
pub fn size_of_VkSurfacePresentScalingCapabilitiesKHR(item: *const vk.VkSurfacePresentScalingCapabilitiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfacePresentScalingCapabilitiesKHR);
}
pub fn size_of_VkSurfacePresentScalingCapabilitiesEXT(item: *const vk.VkSurfacePresentScalingCapabilitiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfacePresentScalingCapabilitiesEXT);
}
pub fn size_of_VkSurfacePresentModeCompatibilityKHR(item: *const vk.VkSurfacePresentModeCompatibilityKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.presentModeCount) |_|
        size += @sizeOf(vk.VkPresentModeKHR);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSurfacePresentModeCompatibilityKHR);
}
pub fn size_of_VkSurfacePresentModeCompatibilityEXT(item: *const vk.VkSurfacePresentModeCompatibilityEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfacePresentModeCompatibilityEXT);
}
pub fn size_of_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT);
}
pub fn size_of_VkSwapchainPresentFenceInfoKHR(item: *const vk.VkSwapchainPresentFenceInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.swapchainCount) |_|
        size += @sizeOf(vk.VkFence);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSwapchainPresentFenceInfoKHR);
}
pub fn size_of_VkSwapchainPresentFenceInfoEXT(item: *const vk.VkSwapchainPresentFenceInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainPresentFenceInfoEXT);
}
pub fn size_of_VkSwapchainPresentModesCreateInfoKHR(item: *const vk.VkSwapchainPresentModesCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainPresentModesCreateInfoKHR);
}
pub fn size_of_VkSwapchainPresentModesCreateInfoEXT(item: *const vk.VkSwapchainPresentModesCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainPresentModesCreateInfoEXT);
}
pub fn size_of_VkSwapchainPresentModeInfoKHR(item: *const vk.VkSwapchainPresentModeInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.swapchainCount) |_|
        size += @sizeOf(vk.VkPresentModeKHR);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkSwapchainPresentModeInfoKHR);
}
pub fn size_of_VkSwapchainPresentModeInfoEXT(item: *const vk.VkSwapchainPresentModeInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainPresentModeInfoEXT);
}
pub fn size_of_VkSwapchainPresentScalingCreateInfoKHR(item: *const vk.VkSwapchainPresentScalingCreateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainPresentScalingCreateInfoKHR);
}
pub fn size_of_VkSwapchainPresentScalingCreateInfoEXT(item: *const vk.VkSwapchainPresentScalingCreateInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSwapchainPresentScalingCreateInfoEXT);
}
pub fn size_of_VkReleaseSwapchainImagesInfoKHR(item: *const vk.VkReleaseSwapchainImagesInfoKHR, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.imageIndexCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkReleaseSwapchainImagesInfoKHR);
}
pub fn size_of_VkReleaseSwapchainImagesInfoEXT(item: *const vk.VkReleaseSwapchainImagesInfoEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkReleaseSwapchainImagesInfoEXT);
}
pub fn size_of_VkPhysicalDeviceDepthBiasControlFeaturesEXT(item: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT);
}
pub fn size_of_VkDirectDriverLoadingInfoLUNARG(item: *const vk.VkDirectDriverLoadingInfoLUNARG, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDirectDriverLoadingInfoLUNARG);
}
pub fn size_of_VkDirectDriverLoadingListLUNARG(item: *const vk.VkDirectDriverLoadingListLUNARG, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.driverCount) |i|
        size += size_of_VkDirectDriverLoadingInfoLUNARG(@ptrCast(&item.pDrivers[i]), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDirectDriverLoadingListLUNARG);
}
pub fn size_of_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(item: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR);
}
pub fn size_of_VkDeviceImageSubresourceInfo(item: *const vk.VkDeviceImageSubresourceInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pCreateInfo) |ptr| size += size_of_VkImageCreateInfo(@ptrCast(ptr), false);
    if (item.pSubresource) |ptr| size += size_of_VkImageSubresource2(@ptrCast(ptr), false);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkDeviceImageSubresourceInfo);
}
pub fn size_of_VkDeviceImageSubresourceInfoKHR(item: *const vk.VkDeviceImageSubresourceInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDeviceImageSubresourceInfoKHR);
}
pub fn size_of_VkMemoryMapInfo(item: *const vk.VkMemoryMapInfo, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
                => size += size_of_VkMemoryMapPlacedInfoEXT(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkMemoryMapInfo: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkMemoryMapInfo);
}
pub fn size_of_VkMemoryMapInfoKHR(item: *const vk.VkMemoryMapInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryMapInfoKHR);
}
pub fn size_of_VkMemoryUnmapInfo(item: *const vk.VkMemoryUnmapInfo, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryUnmapInfo);
}
pub fn size_of_VkMemoryUnmapInfoKHR(item: *const vk.VkMemoryUnmapInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkMemoryUnmapInfoKHR);
}
pub fn size_of_VkPhysicalDeviceShaderObjectFeaturesEXT(item: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderObjectFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceShaderObjectPropertiesEXT(item: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderObjectPropertiesEXT);
}
pub fn size_of_VkShaderCreateInfoEXT(item: *const vk.VkShaderCreateInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.codeSize) |_|
        size += @sizeOf(void);
    for (std.mem.span(item.pName)) |i|
        size += @sizeOf(i);
    for (0..item.setLayoutCount) |_|
        size += @sizeOf(vk.VkDescriptorSetLayout);
    for (0..item.pushConstantRangeCount) |i|
        size += size_of_VkPushConstantRange(@ptrCast(&item.pPushConstantRanges[i]), false);
    if (item.pSpecializationInfo) |ptr| size += size_of_VkSpecializationInfo(@ptrCast(ptr), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
                => size += size_of_VkValidationFeaturesEXT(@ptrCast(next), false),
                vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                => size += size_of_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkShaderCreateInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkShaderCreateInfoEXT);
}
pub fn size_of_VkPhysicalDeviceShaderTileImageFeaturesEXT(item: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderTileImageFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceShaderTileImagePropertiesEXT(item: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderTileImagePropertiesEXT);
}
pub fn size_of_VkImportScreenBufferInfoQNX(item: *const vk.VkImportScreenBufferInfoQNX, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.buffer) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkImportScreenBufferInfoQNX);
}
pub fn size_of_VkScreenBufferPropertiesQNX(item: *const vk.VkScreenBufferPropertiesQNX, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX,
                => size += size_of_VkScreenBufferFormatPropertiesQNX(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkScreenBufferPropertiesQNX: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkScreenBufferPropertiesQNX);
}
pub fn size_of_VkScreenBufferFormatPropertiesQNX(item: *const vk.VkScreenBufferFormatPropertiesQNX, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkScreenBufferFormatPropertiesQNX);
}
pub fn size_of_VkExternalFormatQNX(item: *const vk.VkExternalFormatQNX, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkExternalFormatQNX);
}
pub fn size_of_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(item: *const vk.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX);
}
pub fn size_of_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(item: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR);
}
pub fn size_of_VkCooperativeMatrixPropertiesKHR(item: *const vk.VkCooperativeMatrixPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkCooperativeMatrixPropertiesKHR);
}
pub fn size_of_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(item: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR);
}
pub fn size_of_VkBindMemoryStatus(item: *const vk.VkBindMemoryStatus, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pResult) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkBindMemoryStatus);
}
pub fn size_of_VkBindMemoryStatusKHR(item: *const vk.VkBindMemoryStatusKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindMemoryStatusKHR);
}
pub fn size_of_VkBindDescriptorSetsInfo(item: *const vk.VkBindDescriptorSetsInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorSetCount) |_|
        size += @sizeOf(vk.VkDescriptorSet);
    for (0..item.dynamicOffsetCount) |_|
        size += @sizeOf(u32);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                => size += size_of_VkPipelineLayoutCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorSetsInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkBindDescriptorSetsInfo);
}
pub fn size_of_VkBindDescriptorSetsInfoKHR(item: *const vk.VkBindDescriptorSetsInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkBindDescriptorSetsInfoKHR);
}
pub fn size_of_VkPushConstantsInfo(item: *const vk.VkPushConstantsInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.size) |_|
        size += @sizeOf(void);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                => size += size_of_VkPipelineLayoutCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPushConstantsInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPushConstantsInfo);
}
pub fn size_of_VkPushConstantsInfoKHR(item: *const vk.VkPushConstantsInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPushConstantsInfoKHR);
}
pub fn size_of_VkPushDescriptorSetInfo(item: *const vk.VkPushDescriptorSetInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.descriptorWriteCount) |i|
        size += size_of_VkWriteDescriptorSet(@ptrCast(&item.pDescriptorWrites[i]), false);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                => size += size_of_VkPipelineLayoutCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPushDescriptorSetInfo);
}
pub fn size_of_VkPushDescriptorSetInfoKHR(item: *const vk.VkPushDescriptorSetInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPushDescriptorSetInfoKHR);
}
pub fn size_of_VkPushDescriptorSetWithTemplateInfo(item: *const vk.VkPushDescriptorSetWithTemplateInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pData) |ptr| size += @sizeOf(ptr.*);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                => size += size_of_VkPipelineLayoutCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetWithTemplateInfo: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkPushDescriptorSetWithTemplateInfo);
}
pub fn size_of_VkPushDescriptorSetWithTemplateInfoKHR(item: *const vk.VkPushDescriptorSetWithTemplateInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPushDescriptorSetWithTemplateInfoKHR);
}
pub fn size_of_VkSetDescriptorBufferOffsetsInfoEXT(item: *const vk.VkSetDescriptorBufferOffsetsInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.setCount) |_|
        size += @sizeOf(u32);
    for (0..item.setCount) |_|
        size += @sizeOf(vk.VkDeviceSize);

    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                => size += size_of_VkPipelineLayoutCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkSetDescriptorBufferOffsetsInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return size + @sizeOf(vk.VkSetDescriptorBufferOffsetsInfoEXT);
}
pub fn size_of_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(item: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;
    if (follow_pnext) {
        var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
        while (pnext) |next| {
            pnext = next.pNext;
            switch (next.sType) {
                vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                => size += size_of_VkPipelineLayoutCreateInfo(@ptrCast(next), false),
                else => |v| {
                    log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorBufferEmbeddedSamplersInfoEXT: {d}", .{v});
                },
            }
        }
    }

    return @sizeOf(vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT);
}
pub fn size_of_VkPhysicalDeviceLayeredDriverPropertiesMSFT(item: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT);
}
pub fn size_of_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(item: *const vk.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID);
}
pub fn size_of_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(item: *const vk.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID);
}
pub fn size_of_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(item: *const vk.VkAndroidHardwareBufferFormatResolvePropertiesANDROID, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkAndroidHardwareBufferFormatResolvePropertiesANDROID);
}
pub fn size_of_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(item: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG);
}
pub fn size_of_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceShaderSubgroupRotateFeatures(item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderSubgroupRotateFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceShaderExpectAssumeFeatures(item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderExpectAssumeFeatures);
}
pub fn size_of_VkPhysicalDeviceShaderExpectAssumeFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceShaderFloatControls2Features(item: *const vk.VkPhysicalDeviceShaderFloatControls2Features, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderFloatControls2Features);
}
pub fn size_of_VkPhysicalDeviceShaderFloatControls2FeaturesKHR(item: *const vk.VkPhysicalDeviceShaderFloatControls2FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderFloatControls2FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures);
}
pub fn size_of_VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR(item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR);
}
pub fn size_of_VkRenderingAttachmentLocationInfo(item: *const vk.VkRenderingAttachmentLocationInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.colorAttachmentCount) |_|
        size += @sizeOf(u32);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderingAttachmentLocationInfo);
}
pub fn size_of_VkRenderingAttachmentLocationInfoKHR(item: *const vk.VkRenderingAttachmentLocationInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderingAttachmentLocationInfoKHR);
}
pub fn size_of_VkRenderingInputAttachmentIndexInfo(item: *const vk.VkRenderingInputAttachmentIndexInfo, follow_pnext: bool) usize {
    var size: usize = 0;

    for (0..item.colorAttachmentCount) |_|
        size += @sizeOf(u32);
    if (item.pDepthInputAttachmentIndex) |ptr| size += @sizeOf(ptr.*);
    if (item.pStencilInputAttachmentIndex) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkRenderingInputAttachmentIndexInfo);
}
pub fn size_of_VkRenderingInputAttachmentIndexInfoKHR(item: *const vk.VkRenderingInputAttachmentIndexInfoKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkRenderingInputAttachmentIndexInfoKHR);
}
pub fn size_of_VkPhysicalDeviceShaderQuadControlFeaturesKHR(item: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(item: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(item: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT);
}
pub fn size_of_VkMemoryMapPlacedInfoEXT(item: *const vk.VkMemoryMapPlacedInfoEXT, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.pPlacedAddress) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkMemoryMapPlacedInfoEXT);
}
pub fn size_of_VkPhysicalDeviceShaderBfloat16FeaturesKHR(item: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(item: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA);
}
pub fn size_of_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(item: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA);
}
pub fn size_of_VkImageAlignmentControlCreateInfoMESA(item: *const vk.VkImageAlignmentControlCreateInfoMESA, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkImageAlignmentControlCreateInfoMESA);
}
pub fn size_of_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(item: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT);
}
pub fn size_of_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT(item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT);
}
pub fn size_of_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR);
}
pub fn size_of_VkDepthClampRangeEXT(item: *const vk.VkDepthClampRangeEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkDepthClampRangeEXT);
}
pub fn size_of_VkPhysicalDeviceHdrVividFeaturesHUAWEI(item: *const vk.VkPhysicalDeviceHdrVividFeaturesHUAWEI, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceHdrVividFeaturesHUAWEI);
}
pub fn size_of_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(item: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT);
}
pub fn size_of_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE);
}
pub fn size_of_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE);
}
pub fn size_of_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(item: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE);
}
pub fn size_of_VkPhysicalDeviceShaderFloat8FeaturesEXT(item: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkPhysicalDeviceShaderFloat8FeaturesEXT);
}
pub fn size_of_VkOHSurfaceCreateInfoOHOS(item: *const vk.VkOHSurfaceCreateInfoOHOS, follow_pnext: bool) usize {
    var size: usize = 0;

    if (item.window) |ptr| size += @sizeOf(ptr.*);

    _ = follow_pnext;
    return size + @sizeOf(vk.VkOHSurfaceCreateInfoOHOS);
}
pub fn size_of_VkSurfaceCreateInfoOHOS(item: *const vk.VkSurfaceCreateInfoOHOS, follow_pnext: bool) usize {
    _ = item;
    _ = follow_pnext;
    return @sizeOf(vk.VkSurfaceCreateInfoOHOS);
}
pub fn check_result(result: vk.VkResult) !void {
    switch (result) {
        vk.VK_SUCCESS => return,
        vk.VK_NOT_READY => {
            log.err(@src(), "Vulkan error: VK_NOT_READY (A fence or query has not yet completed)", .{});
            return error.VK_NOT_READY;
        },
        vk.VK_TIMEOUT => {
            log.err(@src(), "Vulkan error: VK_TIMEOUT (A wait operation has not completed in the specified time)", .{});
            return error.VK_TIMEOUT;
        },
        vk.VK_EVENT_SET => {
            log.err(@src(), "Vulkan error: VK_EVENT_SET (An event is signaled)", .{});
            return error.VK_EVENT_SET;
        },
        vk.VK_EVENT_RESET => {
            log.err(@src(), "Vulkan error: VK_EVENT_RESET (An event is unsignaled)", .{});
            return error.VK_EVENT_RESET;
        },
        vk.VK_INCOMPLETE => {
            log.err(@src(), "Vulkan error: VK_INCOMPLETE (A return array was too small for the result)", .{});
            return error.VK_INCOMPLETE;
        },
        vk.VK_ERROR_OUT_OF_HOST_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_HOST_MEMORY (A host memory allocation has failed)", .{});
            return error.VK_ERROR_OUT_OF_HOST_MEMORY;
        },
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DEVICE_MEMORY (A device memory allocation has failed)", .{});
            return error.VK_ERROR_OUT_OF_DEVICE_MEMORY;
        },
        vk.VK_ERROR_INITIALIZATION_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_INITIALIZATION_FAILED (Initialization of an object has failed)", .{});
            return error.VK_ERROR_INITIALIZATION_FAILED;
        },
        vk.VK_ERROR_DEVICE_LOST => {
            log.err(@src(), "Vulkan error: VK_ERROR_DEVICE_LOST (The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;)", .{});
            return error.VK_ERROR_DEVICE_LOST;
        },
        vk.VK_ERROR_MEMORY_MAP_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_MEMORY_MAP_FAILED (Mapping of a memory object has failed)", .{});
            return error.VK_ERROR_MEMORY_MAP_FAILED;
        },
        vk.VK_ERROR_LAYER_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_LAYER_NOT_PRESENT (Layer specified does not exist)", .{});
            return error.VK_ERROR_LAYER_NOT_PRESENT;
        },
        vk.VK_ERROR_EXTENSION_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_EXTENSION_NOT_PRESENT (Extension specified does not exist)", .{});
            return error.VK_ERROR_EXTENSION_NOT_PRESENT;
        },
        vk.VK_ERROR_FEATURE_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FEATURE_NOT_PRESENT (Requested feature is not available on this device)", .{});
            return error.VK_ERROR_FEATURE_NOT_PRESENT;
        },
        vk.VK_ERROR_INCOMPATIBLE_DRIVER => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DRIVER (Unable to find a Vulkan driver)", .{});
            return error.VK_ERROR_INCOMPATIBLE_DRIVER;
        },
        vk.VK_ERROR_TOO_MANY_OBJECTS => {
            log.err(@src(), "Vulkan error: VK_ERROR_TOO_MANY_OBJECTS (Too many objects of the type have already been created)", .{});
            return error.VK_ERROR_TOO_MANY_OBJECTS;
        },
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_FORMAT_NOT_SUPPORTED (Requested format is not supported on this device)", .{});
            return error.VK_ERROR_FORMAT_NOT_SUPPORTED;
        },
        vk.VK_ERROR_FRAGMENTED_POOL => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTED_POOL (A requested pool allocation has failed due to fragmentation of the pool's memory)", .{});
            return error.VK_ERROR_FRAGMENTED_POOL;
        },
        vk.VK_ERROR_UNKNOWN => {
            log.err(@src(), "Vulkan error: VK_ERROR_UNKNOWN (An unknown error has occurred, due to an implementation or application bug)", .{});
            return error.VK_ERROR_UNKNOWN;
        },
        vk.VK_ERROR_SURFACE_LOST_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_SURFACE_LOST_KHR (VK_KHR_surface)", .{});
            return error.VK_ERROR_SURFACE_LOST_KHR;
        },
        vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR (VK_KHR_surface)", .{});
            return error.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;
        },
        vk.VK_SUBOPTIMAL_KHR => {
            log.err(@src(), "Vulkan error: VK_SUBOPTIMAL_KHR (VK_KHR_swapchain)", .{});
            return error.VK_SUBOPTIMAL_KHR;
        },
        vk.VK_ERROR_OUT_OF_DATE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR (VK_KHR_swapchain)", .{});
            return error.VK_ERROR_OUT_OF_DATE_KHR;
        },
        vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR (VK_KHR_display_swapchain)", .{});
            return error.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR;
        },
        vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_OUT_OF_POOL_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY (VK_KHR_maintenance1)", .{});
            return error.VK_ERROR_OUT_OF_POOL_MEMORY;
        },
        vk.VK_ERROR_INVALID_EXTERNAL_HANDLE => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE (VK_KHR_external_memory)", .{});
            return error.VK_ERROR_INVALID_EXTERNAL_HANDLE;
        },
        vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT (VK_EXT_image_drm_format_modifier)", .{});
            return error.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT;
        },
        vk.VK_ERROR_FRAGMENTATION => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTATION (VK_EXT_descriptor_indexing)", .{});
            return error.VK_ERROR_FRAGMENTATION;
        },
        vk.VK_ERROR_NOT_PERMITTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_PERMITTED (VK_EXT_global_priority)", .{});
            return error.VK_ERROR_NOT_PERMITTED;
        },
        vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS (VK_EXT_buffer_device_address)", .{});
            return error.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
        },
        vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT (VK_EXT_full_screen_exclusive)", .{});
            return error.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT;
        },
        vk.VK_THREAD_IDLE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_IDLE_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_THREAD_IDLE_KHR;
        },
        vk.VK_THREAD_DONE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_DONE_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_THREAD_DONE_KHR;
        },
        vk.VK_OPERATION_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_DEFERRED_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_OPERATION_DEFERRED_KHR;
        },
        vk.VK_OPERATION_NOT_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_NOT_DEFERRED_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_OPERATION_NOT_DEFERRED_KHR;
        },
        vk.VK_PIPELINE_COMPILE_REQUIRED => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_COMPILE_REQUIRED (VK_EXT_pipeline_creation_cache_control)", .{});
            return error.VK_PIPELINE_COMPILE_REQUIRED;
        },
        vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR (VK_KHR_video_encode_queue)", .{});
            return error.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR;
        },
        vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_COMPRESSION_EXHAUSTED_EXT (VK_EXT_image_compression_control)", .{});
            return error.VK_ERROR_COMPRESSION_EXHAUSTED_EXT;
        },
        vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT => {
            log.err(@src(), "Vulkan error: VK_INCOMPATIBLE_SHADER_BINARY_EXT (VK_EXT_shader_object)", .{});
            return error.VK_INCOMPATIBLE_SHADER_BINARY_EXT;
        },
        vk.VK_PIPELINE_BINARY_MISSING_KHR => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_BINARY_MISSING_KHR (VK_KHR_pipeline_binary)", .{});
            return error.VK_PIPELINE_BINARY_MISSING_KHR;
        },
        vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_ENOUGH_SPACE_KHR (VK_KHR_pipeline_binary)", .{});
            return error.VK_ERROR_NOT_ENOUGH_SPACE_KHR;
        },
        else => {
            log.err(@src(), "Vulkan error: UNKNOWN {}", .{result});
            return error.UNKNOWN;
        },
    }
}
pub const Extensions = struct {
    instance: packed struct(u25) {
        VK_KHR_surface: bool = false,
        VK_KHR_display: bool = false,
        VK_EXT_debug_report: bool = false,
        VK_KHR_get_physical_device_properties2: bool = false,
        VK_EXT_validation_flags: bool = false,
        VK_KHR_device_group_creation: bool = false,
        VK_KHR_external_memory_capabilities: bool = false,
        VK_KHR_external_semaphore_capabilities: bool = false,
        VK_EXT_direct_mode_display: bool = false,
        VK_EXT_display_surface_counter: bool = false,
        VK_EXT_swapchain_colorspace: bool = false,
        VK_KHR_external_fence_capabilities: bool = false,
        VK_KHR_get_surface_capabilities2: bool = false,
        VK_KHR_get_display_properties2: bool = false,
        VK_EXT_debug_utils: bool = false,
        VK_EXT_metal_surface: bool = false,
        VK_KHR_surface_protected_capabilities: bool = false,
        VK_EXT_validation_features: bool = false,
        VK_EXT_headless_surface: bool = false,
        VK_EXT_surface_maintenance1: bool = false,
        VK_EXT_acquire_drm_display: bool = false,
        VK_EXT_directfb_surface: bool = false,
        VK_KHR_portability_enumeration: bool = false,
        VK_KHR_surface_maintenance1: bool = false,
        VK_EXT_layer_settings: bool = false,
    } = .{},
    device: packed struct(u257) {
        VK_KHR_swapchain: bool = false,
        VK_KHR_display_swapchain: bool = false,
        VK_EXT_depth_range_unrestricted: bool = false,
        VK_IMG_filter_cubic: bool = false,
        VK_EXT_debug_marker: bool = false,
        VK_KHR_video_queue: bool = false,
        VK_KHR_video_decode_queue: bool = false,
        VK_EXT_transform_feedback: bool = false,
        VK_KHR_video_encode_h264: bool = false,
        VK_KHR_video_encode_h265: bool = false,
        VK_KHR_video_decode_h264: bool = false,
        VK_KHR_dynamic_rendering: bool = false,
        VK_KHR_multiview: bool = false,
        VK_IMG_format_pvrtc: bool = false,
        VK_KHR_device_group: bool = false,
        VK_KHR_shader_draw_parameters: bool = false,
        VK_EXT_shader_subgroup_ballot: bool = false,
        VK_EXT_shader_subgroup_vote: bool = false,
        VK_EXT_texture_compression_astc_hdr: bool = false,
        VK_EXT_astc_decode_mode: bool = false,
        VK_EXT_pipeline_robustness: bool = false,
        VK_KHR_maintenance1: bool = false,
        VK_KHR_external_memory: bool = false,
        VK_KHR_external_memory_fd: bool = false,
        VK_KHR_external_semaphore: bool = false,
        VK_KHR_external_semaphore_fd: bool = false,
        VK_KHR_push_descriptor: bool = false,
        VK_EXT_conditional_rendering: bool = false,
        VK_KHR_shader_float16_int8: bool = false,
        VK_KHR_16bit_storage: bool = false,
        VK_KHR_incremental_present: bool = false,
        VK_KHR_descriptor_update_template: bool = false,
        VK_EXT_display_control: bool = false,
        VK_EXT_discard_rectangles: bool = false,
        VK_EXT_conservative_rasterization: bool = false,
        VK_EXT_depth_clip_enable: bool = false,
        VK_EXT_hdr_metadata: bool = false,
        VK_KHR_imageless_framebuffer: bool = false,
        VK_KHR_create_renderpass2: bool = false,
        VK_IMG_relaxed_line_rasterization: bool = false,
        VK_KHR_shared_presentable_image: bool = false,
        VK_KHR_external_fence: bool = false,
        VK_KHR_external_fence_fd: bool = false,
        VK_KHR_maintenance2: bool = false,
        VK_KHR_variable_pointers: bool = false,
        VK_EXT_external_memory_dma_buf: bool = false,
        VK_EXT_queue_family_foreign: bool = false,
        VK_KHR_dedicated_allocation: bool = false,
        VK_EXT_sampler_filter_minmax: bool = false,
        VK_KHR_storage_buffer_storage_class: bool = false,
        VK_EXT_inline_uniform_block: bool = false,
        VK_EXT_shader_stencil_export: bool = false,
        VK_KHR_shader_bfloat16: bool = false,
        VK_EXT_sample_locations: bool = false,
        VK_KHR_relaxed_block_layout: bool = false,
        VK_KHR_get_memory_requirements2: bool = false,
        VK_KHR_image_format_list: bool = false,
        VK_EXT_blend_operation_advanced: bool = false,
        VK_KHR_acceleration_structure: bool = false,
        VK_KHR_ray_tracing_pipeline: bool = false,
        VK_KHR_ray_query: bool = false,
        VK_EXT_post_depth_coverage: bool = false,
        VK_KHR_sampler_ycbcr_conversion: bool = false,
        VK_KHR_bind_memory2: bool = false,
        VK_EXT_image_drm_format_modifier: bool = false,
        VK_EXT_validation_cache: bool = false,
        VK_EXT_descriptor_indexing: bool = false,
        VK_EXT_shader_viewport_index_layer: bool = false,
        VK_KHR_maintenance3: bool = false,
        VK_KHR_draw_indirect_count: bool = false,
        VK_EXT_filter_cubic: bool = false,
        VK_QCOM_render_pass_shader_resolve: bool = false,
        VK_EXT_global_priority: bool = false,
        VK_KHR_shader_subgroup_extended_types: bool = false,
        VK_KHR_8bit_storage: bool = false,
        VK_EXT_external_memory_host: bool = false,
        VK_KHR_shader_atomic_int64: bool = false,
        VK_KHR_shader_clock: bool = false,
        VK_EXT_calibrated_timestamps: bool = false,
        VK_KHR_video_decode_h265: bool = false,
        VK_KHR_global_priority: bool = false,
        VK_EXT_vertex_attribute_divisor: bool = false,
        VK_EXT_pipeline_creation_feedback: bool = false,
        VK_KHR_driver_properties: bool = false,
        VK_KHR_shader_float_controls: bool = false,
        VK_KHR_depth_stencil_resolve: bool = false,
        VK_KHR_swapchain_mutable_format: bool = false,
        VK_KHR_timeline_semaphore: bool = false,
        VK_INTEL_shader_integer_functions2: bool = false,
        VK_INTEL_performance_query: bool = false,
        VK_KHR_vulkan_memory_model: bool = false,
        VK_EXT_pci_bus_info: bool = false,
        VK_KHR_shader_terminate_invocation: bool = false,
        VK_EXT_fragment_density_map: bool = false,
        VK_EXT_scalar_block_layout: bool = false,
        VK_EXT_subgroup_size_control: bool = false,
        VK_KHR_fragment_shading_rate: bool = false,
        VK_KHR_dynamic_rendering_local_read: bool = false,
        VK_EXT_shader_image_atomic_int64: bool = false,
        VK_KHR_shader_quad_control: bool = false,
        VK_KHR_spirv_1_4: bool = false,
        VK_EXT_memory_budget: bool = false,
        VK_EXT_memory_priority: bool = false,
        VK_KHR_separate_depth_stencil_layouts: bool = false,
        VK_EXT_buffer_device_address: bool = false,
        VK_EXT_tooling_info: bool = false,
        VK_EXT_separate_stencil_usage: bool = false,
        VK_KHR_present_wait: bool = false,
        VK_EXT_fragment_shader_interlock: bool = false,
        VK_EXT_ycbcr_image_arrays: bool = false,
        VK_KHR_uniform_buffer_standard_layout: bool = false,
        VK_EXT_provoking_vertex: bool = false,
        VK_EXT_full_screen_exclusive: bool = false,
        VK_KHR_buffer_device_address: bool = false,
        VK_EXT_line_rasterization: bool = false,
        VK_EXT_shader_atomic_float: bool = false,
        VK_EXT_host_query_reset: bool = false,
        VK_EXT_index_type_uint8: bool = false,
        VK_EXT_extended_dynamic_state: bool = false,
        VK_KHR_deferred_host_operations: bool = false,
        VK_KHR_pipeline_executable_properties: bool = false,
        VK_EXT_host_image_copy: bool = false,
        VK_KHR_map_memory2: bool = false,
        VK_EXT_map_memory_placed: bool = false,
        VK_EXT_shader_atomic_float2: bool = false,
        VK_EXT_swapchain_maintenance1: bool = false,
        VK_EXT_shader_demote_to_helper_invocation: bool = false,
        VK_KHR_shader_integer_dot_product: bool = false,
        VK_EXT_texel_buffer_alignment: bool = false,
        VK_QCOM_render_pass_transform: bool = false,
        VK_EXT_depth_bias_control: bool = false,
        VK_EXT_device_memory_report: bool = false,
        VK_EXT_robustness2: bool = false,
        VK_EXT_custom_border_color: bool = false,
        VK_KHR_pipeline_library: bool = false,
        VK_KHR_shader_non_semantic_info: bool = false,
        VK_KHR_present_id: bool = false,
        VK_EXT_private_data: bool = false,
        VK_EXT_pipeline_creation_cache_control: bool = false,
        VK_KHR_video_encode_queue: bool = false,
        VK_QCOM_render_pass_store_ops: bool = false,
        VK_QCOM_tile_shading: bool = false,
        VK_EXT_metal_objects: bool = false,
        VK_KHR_synchronization2: bool = false,
        VK_EXT_descriptor_buffer: bool = false,
        VK_EXT_graphics_pipeline_library: bool = false,
        VK_KHR_fragment_shader_barycentric: bool = false,
        VK_KHR_shader_subgroup_uniform_control_flow: bool = false,
        VK_KHR_zero_initialize_workgroup_memory: bool = false,
        VK_EXT_mesh_shader: bool = false,
        VK_EXT_ycbcr_2plane_444_formats: bool = false,
        VK_EXT_fragment_density_map2: bool = false,
        VK_QCOM_rotated_copy_commands: bool = false,
        VK_EXT_image_robustness: bool = false,
        VK_KHR_workgroup_memory_explicit_layout: bool = false,
        VK_KHR_copy_commands2: bool = false,
        VK_EXT_image_compression_control: bool = false,
        VK_EXT_attachment_feedback_loop_layout: bool = false,
        VK_EXT_4444_formats: bool = false,
        VK_EXT_device_fault: bool = false,
        VK_EXT_rgba10x6_formats: bool = false,
        VK_VALVE_mutable_descriptor_type: bool = false,
        VK_EXT_vertex_input_dynamic_state: bool = false,
        VK_EXT_physical_device_drm: bool = false,
        VK_EXT_device_address_binding_report: bool = false,
        VK_EXT_depth_clip_control: bool = false,
        VK_EXT_primitive_topology_list_restart: bool = false,
        VK_KHR_format_feature_flags2: bool = false,
        VK_EXT_present_mode_fifo_latest_ready: bool = false,
        VK_EXT_pipeline_properties: bool = false,
        VK_EXT_frame_boundary: bool = false,
        VK_EXT_multisampled_render_to_single_sampled: bool = false,
        VK_EXT_extended_dynamic_state2: bool = false,
        VK_EXT_color_write_enable: bool = false,
        VK_EXT_primitives_generated_query: bool = false,
        VK_KHR_ray_tracing_maintenance1: bool = false,
        VK_EXT_global_priority_query: bool = false,
        VK_EXT_image_view_min_lod: bool = false,
        VK_EXT_multi_draw: bool = false,
        VK_EXT_image_2d_view_of_3d: bool = false,
        VK_EXT_shader_tile_image: bool = false,
        VK_EXT_opacity_micromap: bool = false,
        VK_EXT_load_store_op_none: bool = false,
        VK_EXT_border_color_swizzle: bool = false,
        VK_EXT_pageable_device_local_memory: bool = false,
        VK_KHR_maintenance4: bool = false,
        VK_KHR_shader_subgroup_rotate: bool = false,
        VK_EXT_image_sliced_view_of_3d: bool = false,
        VK_VALVE_descriptor_set_host_mapping: bool = false,
        VK_EXT_depth_clamp_zero_one: bool = false,
        VK_EXT_non_seamless_cube_map: bool = false,
        VK_QCOM_fragment_density_map_offset: bool = false,
        VK_KHR_shader_maximal_reconvergence: bool = false,
        VK_EXT_image_compression_control_swapchain: bool = false,
        VK_QCOM_image_processing: bool = false,
        VK_EXT_nested_command_buffer: bool = false,
        VK_EXT_external_memory_acquire_unmodified: bool = false,
        VK_EXT_extended_dynamic_state3: bool = false,
        VK_EXT_subpass_merge_feedback: bool = false,
        VK_EXT_shader_module_identifier: bool = false,
        VK_EXT_rasterization_order_attachment_access: bool = false,
        VK_EXT_legacy_dithering: bool = false,
        VK_EXT_pipeline_protected_access: bool = false,
        VK_KHR_maintenance5: bool = false,
        VK_KHR_present_id2: bool = false,
        VK_KHR_present_wait2: bool = false,
        VK_KHR_ray_tracing_position_fetch: bool = false,
        VK_EXT_shader_object: bool = false,
        VK_KHR_pipeline_binary: bool = false,
        VK_QCOM_tile_properties: bool = false,
        VK_KHR_swapchain_maintenance1: bool = false,
        VK_QCOM_multiview_per_view_viewports: bool = false,
        VK_EXT_mutable_descriptor_type: bool = false,
        VK_EXT_legacy_vertex_attributes: bool = false,
        VK_EXT_pipeline_library_group_handles: bool = false,
        VK_EXT_dynamic_rendering_unused_attachments: bool = false,
        VK_KHR_cooperative_matrix: bool = false,
        VK_QCOM_multiview_per_view_render_areas: bool = false,
        VK_KHR_compute_shader_derivatives: bool = false,
        VK_KHR_video_decode_av1: bool = false,
        VK_KHR_video_encode_av1: bool = false,
        VK_KHR_video_decode_vp9: bool = false,
        VK_KHR_video_maintenance1: bool = false,
        VK_QCOM_image_processing2: bool = false,
        VK_QCOM_filter_cubic_weights: bool = false,
        VK_QCOM_ycbcr_degamma: bool = false,
        VK_QCOM_filter_cubic_clamp: bool = false,
        VK_EXT_attachment_feedback_loop_dynamic_state: bool = false,
        VK_KHR_vertex_attribute_divisor: bool = false,
        VK_KHR_load_store_op_none: bool = false,
        VK_KHR_unified_image_layouts: bool = false,
        VK_KHR_shader_float_controls2: bool = false,
        VK_KHR_index_type_uint8: bool = false,
        VK_KHR_line_rasterization: bool = false,
        VK_KHR_calibrated_timestamps: bool = false,
        VK_KHR_shader_expect_assume: bool = false,
        VK_KHR_maintenance6: bool = false,
        VK_QCOM_tile_memory_heap: bool = false,
        VK_KHR_video_encode_intra_refresh: bool = false,
        VK_KHR_video_encode_quantization_map: bool = false,
        VK_KHR_shader_relaxed_extended_instruction: bool = false,
        VK_KHR_maintenance7: bool = false,
        VK_EXT_shader_replicated_composites: bool = false,
        VK_EXT_shader_float8: bool = false,
        VK_EXT_device_generated_commands: bool = false,
        VK_KHR_maintenance8: bool = false,
        VK_EXT_depth_clamp_control: bool = false,
        VK_KHR_maintenance9: bool = false,
        VK_KHR_video_maintenance2: bool = false,
        VK_EXT_external_memory_metal: bool = false,
        VK_KHR_depth_clamp_zero_one: bool = false,
        VK_EXT_vertex_attribute_robustness: bool = false,
        VK_VALVE_fragment_density_map_layered: bool = false,
        VK_KHR_robustness2: bool = false,
        VK_EXT_fragment_density_map_offset: bool = false,
        VK_EXT_zero_initialize_device_memory: bool = false,
        VK_KHR_present_mode_fifo_latest_ready: bool = false,
    } = .{},

    const Self = @This();

    pub fn init(
        tmp_alloc: Allocator,
        api_version: u32,
        instance_extensions: []const [*c]const u8,
        device_extensions: []const [*c]const u8,
    ) !Self {
        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        var self: Self = .{};
        if (vk.VK_API_VERSION_1_1 <= api_version) {
            self.instance.VK_KHR_get_physical_device_properties2 = true;
            self.instance.VK_KHR_device_group_creation = true;
            self.instance.VK_KHR_external_memory_capabilities = true;
            self.instance.VK_KHR_external_semaphore_capabilities = true;
            self.instance.VK_KHR_external_fence_capabilities = true;
            self.device.VK_KHR_multiview = true;
            self.device.VK_KHR_device_group = true;
            self.device.VK_KHR_shader_draw_parameters = true;
            self.device.VK_KHR_maintenance1 = true;
            self.device.VK_KHR_external_memory = true;
            self.device.VK_KHR_external_semaphore = true;
            self.device.VK_KHR_16bit_storage = true;
            self.device.VK_KHR_descriptor_update_template = true;
            self.device.VK_KHR_external_fence = true;
            self.device.VK_KHR_maintenance2 = true;
            self.device.VK_KHR_variable_pointers = true;
            self.device.VK_KHR_dedicated_allocation = true;
            self.device.VK_KHR_storage_buffer_storage_class = true;
            self.device.VK_KHR_relaxed_block_layout = true;
            self.device.VK_KHR_get_memory_requirements2 = true;
            self.device.VK_KHR_sampler_ycbcr_conversion = true;
            self.device.VK_KHR_bind_memory2 = true;
            self.device.VK_KHR_maintenance3 = true;
        }
        if (vk.VK_API_VERSION_1_2 <= api_version) {
            self.device.VK_KHR_shader_float16_int8 = true;
            self.device.VK_KHR_imageless_framebuffer = true;
            self.device.VK_KHR_create_renderpass2 = true;
            self.device.VK_EXT_sampler_filter_minmax = true;
            self.device.VK_KHR_image_format_list = true;
            self.device.VK_EXT_descriptor_indexing = true;
            self.device.VK_EXT_shader_viewport_index_layer = true;
            self.device.VK_KHR_draw_indirect_count = true;
            self.device.VK_KHR_shader_subgroup_extended_types = true;
            self.device.VK_KHR_8bit_storage = true;
            self.device.VK_KHR_shader_atomic_int64 = true;
            self.device.VK_KHR_driver_properties = true;
            self.device.VK_KHR_shader_float_controls = true;
            self.device.VK_KHR_depth_stencil_resolve = true;
            self.device.VK_KHR_timeline_semaphore = true;
            self.device.VK_KHR_vulkan_memory_model = true;
            self.device.VK_EXT_scalar_block_layout = true;
            self.device.VK_KHR_spirv_1_4 = true;
            self.device.VK_KHR_separate_depth_stencil_layouts = true;
            self.device.VK_EXT_separate_stencil_usage = true;
            self.device.VK_KHR_uniform_buffer_standard_layout = true;
            self.device.VK_KHR_buffer_device_address = true;
            self.device.VK_EXT_host_query_reset = true;
        }
        if (vk.VK_API_VERSION_1_3 <= api_version) {
            self.device.VK_KHR_dynamic_rendering = true;
            self.device.VK_EXT_texture_compression_astc_hdr = true;
            self.device.VK_EXT_inline_uniform_block = true;
            self.device.VK_EXT_pipeline_creation_feedback = true;
            self.device.VK_KHR_shader_terminate_invocation = true;
            self.device.VK_EXT_subgroup_size_control = true;
            self.device.VK_EXT_tooling_info = true;
            self.device.VK_EXT_extended_dynamic_state = true;
            self.device.VK_EXT_shader_demote_to_helper_invocation = true;
            self.device.VK_KHR_shader_integer_dot_product = true;
            self.device.VK_EXT_texel_buffer_alignment = true;
            self.device.VK_KHR_shader_non_semantic_info = true;
            self.device.VK_EXT_private_data = true;
            self.device.VK_EXT_pipeline_creation_cache_control = true;
            self.device.VK_KHR_synchronization2 = true;
            self.device.VK_KHR_zero_initialize_workgroup_memory = true;
            self.device.VK_EXT_ycbcr_2plane_444_formats = true;
            self.device.VK_EXT_image_robustness = true;
            self.device.VK_KHR_copy_commands2 = true;
            self.device.VK_EXT_4444_formats = true;
            self.device.VK_KHR_format_feature_flags2 = true;
            self.device.VK_EXT_extended_dynamic_state2 = true;
            self.device.VK_KHR_maintenance4 = true;
        }
        if (vk.VK_API_VERSION_1_4 <= api_version) {
            self.device.VK_EXT_pipeline_robustness = true;
            self.device.VK_KHR_push_descriptor = true;
            self.device.VK_KHR_global_priority = true;
            self.device.VK_KHR_dynamic_rendering_local_read = true;
            self.device.VK_EXT_host_image_copy = true;
            self.device.VK_KHR_map_memory2 = true;
            self.device.VK_KHR_shader_subgroup_rotate = true;
            self.device.VK_EXT_pipeline_protected_access = true;
            self.device.VK_KHR_maintenance5 = true;
            self.device.VK_KHR_vertex_attribute_divisor = true;
            self.device.VK_KHR_load_store_op_none = true;
            self.device.VK_KHR_shader_float_controls2 = true;
            self.device.VK_KHR_index_type_uint8 = true;
            self.device.VK_KHR_line_rasterization = true;
            self.device.VK_KHR_shader_expect_assume = true;
            self.device.VK_KHR_maintenance6 = true;
        }
        // Instance extensions
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface")) {
                self.instance.VK_KHR_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_report")) {
                self.instance.VK_EXT_debug_report = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_physical_device_properties2")) {
                self.instance.VK_KHR_get_physical_device_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_flags")) {
                self.instance.VK_EXT_validation_flags = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group_creation")) {
                self.instance.VK_KHR_device_group_creation = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_memory_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_semaphore_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_direct_mode_display") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_direct_mode_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_surface_counter") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_display_surface_counter = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_colorspace") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_swapchain_colorspace = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_fence_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_surface_capabilities2") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_get_surface_capabilities2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_display_properties2") and (self.instance.VK_KHR_display)) {
                self.instance.VK_KHR_get_display_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_utils")) {
                self.instance.VK_EXT_debug_utils = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_metal_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_protected_capabilities") and (vk.VK_API_VERSION_1_1 <= api_version and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_protected_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_features")) {
                self.instance.VK_EXT_validation_features = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_headless_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_headless_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_surface_maintenance1") and (self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_EXT_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_acquire_drm_display") and (self.instance.VK_EXT_direct_mode_display)) {
                self.instance.VK_EXT_acquire_drm_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_directfb_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_directfb_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_portability_enumeration")) {
                self.instance.VK_KHR_portability_enumeration = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_maintenance1") and (self.instance.VK_KHR_surface or self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_layer_settings")) {
                self.instance.VK_EXT_layer_settings = true;
                break;
            }
        }
        // Device extensions
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain") and (self.instance.VK_KHR_surface)) {
                self.device.VK_KHR_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display_swapchain") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_display)) {
                self.device.VK_KHR_display_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_range_unrestricted")) {
                self.device.VK_EXT_depth_range_unrestricted = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_filter_cubic")) {
                self.device.VK_IMG_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_marker") and (self.instance.VK_EXT_debug_report)) {
                self.device.VK_EXT_debug_marker = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_queue") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_video_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_decode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_transform_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_transform_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h264") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h265") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h264") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_multiview") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_multiview = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_format_pvrtc")) {
                self.device.VK_IMG_format_pvrtc = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group") and (self.instance.VK_KHR_device_group_creation)) {
                self.device.VK_KHR_device_group = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_draw_parameters")) {
                self.device.VK_KHR_shader_draw_parameters = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_ballot")) {
                self.device.VK_EXT_shader_subgroup_ballot = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_vote")) {
                self.device.VK_EXT_shader_subgroup_vote = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texture_compression_astc_hdr") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texture_compression_astc_hdr = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_astc_decode_mode") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_astc_decode_mode = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance1")) {
                self.device.VK_KHR_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory") and (self.instance.VK_KHR_external_memory_capabilities or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_fd") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore") and (self.instance.VK_KHR_external_semaphore_capabilities)) {
                self.device.VK_KHR_external_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_fd") and (self.device.VK_KHR_external_semaphore or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_semaphore_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_push_descriptor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_push_descriptor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conditional_rendering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conditional_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float16_int8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float16_int8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_16bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_16bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_incremental_present") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_incremental_present = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_descriptor_update_template")) {
                self.device.VK_KHR_descriptor_update_template = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_control") and (self.instance.VK_EXT_display_surface_counter and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_display_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_discard_rectangles") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_discard_rectangles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conservative_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conservative_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_hdr_metadata") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_hdr_metadata = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_imageless_framebuffer") and ((((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_imageless_framebuffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_create_renderpass2") and ((self.device.VK_KHR_multiview and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_create_renderpass2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_relaxed_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_IMG_relaxed_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shared_presentable_image") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_surface_capabilities2 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_KHR_shared_presentable_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence") and (self.instance.VK_KHR_external_fence_capabilities)) {
                self.device.VK_KHR_external_fence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_fd") and (self.device.VK_KHR_external_fence or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_fence_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance2")) {
                self.device.VK_KHR_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_variable_pointers") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_variable_pointers = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_dma_buf") and (self.device.VK_KHR_external_memory_fd)) {
                self.device.VK_EXT_external_memory_dma_buf = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_queue_family_foreign") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_queue_family_foreign = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dedicated_allocation") and (self.device.VK_KHR_get_memory_requirements2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_dedicated_allocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sampler_filter_minmax") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sampler_filter_minmax = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_storage_buffer_storage_class")) {
                self.device.VK_KHR_storage_buffer_storage_class = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_inline_uniform_block") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance1) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_inline_uniform_block = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_stencil_export")) {
                self.device.VK_EXT_shader_stencil_export = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_bfloat16") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_bfloat16 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sample_locations") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sample_locations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_relaxed_block_layout")) {
                self.device.VK_KHR_relaxed_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_memory_requirements2")) {
                self.device.VK_KHR_get_memory_requirements2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_image_format_list")) {
                self.device.VK_KHR_image_format_list = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_blend_operation_advanced") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_blend_operation_advanced = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_acceleration_structure") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_EXT_descriptor_indexing and self.device.VK_KHR_buffer_device_address) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_deferred_host_operations)) {
                self.device.VK_KHR_acceleration_structure = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_pipeline") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_pipeline = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_query") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_post_depth_coverage")) {
                self.device.VK_EXT_post_depth_coverage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_sampler_ycbcr_conversion") and ((self.device.VK_KHR_maintenance1 and self.device.VK_KHR_bind_memory2 and self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_sampler_ycbcr_conversion = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_bind_memory2")) {
                self.device.VK_KHR_bind_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_drm_format_modifier") and ((((self.device.VK_KHR_bind_memory2 and self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_sampler_ycbcr_conversion) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_image_drm_format_modifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_cache")) {
                self.device.VK_EXT_validation_cache = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_indexing") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance3) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_descriptor_indexing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_viewport_index_layer")) {
                self.device.VK_EXT_shader_viewport_index_layer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_draw_indirect_count")) {
                self.device.VK_KHR_draw_indirect_count = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_filter_cubic")) {
                self.device.VK_EXT_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_shader_resolve")) {
                self.device.VK_QCOM_render_pass_shader_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority")) {
                self.device.VK_EXT_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_extended_types") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_extended_types = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_8bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_8bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_host") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_host = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_clock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_clock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h265") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_global_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_feedback")) {
                self.device.VK_EXT_pipeline_creation_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_driver_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_driver_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float_controls = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_stencil_resolve") and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_depth_stencil_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_mutable_format") and (self.device.VK_KHR_swapchain and (self.device.VK_KHR_maintenance2 or vk.VK_API_VERSION_1_1 <= api_version) and (self.device.VK_KHR_image_format_list or vk.VK_API_VERSION_1_2 <= api_version))) {
                self.device.VK_KHR_swapchain_mutable_format = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_timeline_semaphore") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_timeline_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_shader_integer_functions2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_INTEL_shader_integer_functions2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_performance_query")) {
                self.device.VK_INTEL_performance_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vulkan_memory_model") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vulkan_memory_model = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pci_bus_info") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pci_bus_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_terminate_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_terminate_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_density_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_scalar_block_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_scalar_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subgroup_size_control") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subgroup_size_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shading_rate") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_fragment_shading_rate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering_local_read") and (self.device.VK_KHR_dynamic_rendering or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering_local_read = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_image_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_image_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_quad_control") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_vulkan_memory_model) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_shader_maximal_reconvergence)) {
                self.device.VK_KHR_shader_quad_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_spirv_1_4") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_spirv_1_4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_budget") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_budget = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_separate_depth_stencil_layouts") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_separate_depth_stencil_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_buffer_device_address") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_tooling_info")) {
                self.device.VK_EXT_tooling_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_separate_stencil_usage")) {
                self.device.VK_EXT_separate_stencil_usage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait") and (self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id)) {
                self.device.VK_KHR_present_wait = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_shader_interlock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_shader_interlock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_image_arrays") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_image_arrays = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_uniform_buffer_standard_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_uniform_buffer_standard_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_provoking_vertex") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_provoking_vertex = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_full_screen_exclusive") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_full_screen_exclusive = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_buffer_device_address") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_device_group) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_atomic_float = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_query_reset") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_host_query_reset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_deferred_host_operations")) {
                self.device.VK_KHR_deferred_host_operations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_executable_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_pipeline_executable_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_image_copy") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_copy_commands2 and self.device.VK_KHR_format_feature_flags2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_host_image_copy = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_map_memory2")) {
                self.device.VK_KHR_map_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_map_memory_placed") and (self.device.VK_KHR_map_memory2 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_EXT_map_memory_placed = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float2") and (self.device.VK_EXT_shader_atomic_float)) {
                self.device.VK_EXT_shader_atomic_float2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_maintenance1") and (self.device.VK_KHR_swapchain and self.instance.VK_EXT_surface_maintenance1 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_demote_to_helper_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_demote_to_helper_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_integer_dot_product") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_integer_dot_product = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texel_buffer_alignment") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texel_buffer_alignment = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_transform")) {
                self.device.VK_QCOM_render_pass_transform = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_bias_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_bias_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_memory_report") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_memory_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_custom_border_color") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_custom_border_color = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_library")) {
                self.device.VK_KHR_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_non_semantic_info")) {
                self.device.VK_KHR_shader_non_semantic_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_present_id = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_private_data") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_private_data = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_cache_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_creation_cache_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_store_ops")) {
                self.device.VK_QCOM_render_pass_store_ops = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_shading") and (self.device.VK_QCOM_tile_properties or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_QCOM_tile_shading = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_objects")) {
                self.device.VK_EXT_metal_objects = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_synchronization2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_synchronization2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_buffer") and (((((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_buffer_device_address and self.device.VK_EXT_descriptor_indexing) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_descriptor_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_graphics_pipeline_library") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_graphics_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shader_barycentric") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_fragment_shader_barycentric = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_uniform_control_flow") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_uniform_control_flow = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_zero_initialize_workgroup_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_zero_initialize_workgroup_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mesh_shader") and (self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_mesh_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_2plane_444_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_2plane_444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map2") and (self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_EXT_fragment_density_map2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_rotated_copy_commands") and (self.device.VK_KHR_copy_commands2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_rotated_copy_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_workgroup_memory_explicit_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_workgroup_memory_explicit_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_copy_commands2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_copy_commands2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_compression_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_attachment_feedback_loop_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_4444_formats") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_4444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_fault") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_fault = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rgba10x6_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rgba10x6_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3)) {
                self.device.VK_VALVE_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_input_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_input_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_physical_device_drm") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_physical_device_drm = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_address_binding_report") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_EXT_debug_utils)) {
                self.device.VK_EXT_device_address_binding_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitive_topology_list_restart") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_primitive_topology_list_restart = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_format_feature_flags2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_format_feature_flags2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_frame_boundary")) {
                self.device.VK_EXT_frame_boundary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multisampled_render_to_single_sampled") and ((self.device.VK_KHR_create_renderpass2 and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_multisampled_render_to_single_sampled = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_color_write_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_color_write_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitives_generated_query") and (self.device.VK_EXT_transform_feedback)) {
                self.device.VK_EXT_primitives_generated_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_maintenance1") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority_query") and (self.device.VK_EXT_global_priority and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_global_priority_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_view_min_lod") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_view_min_lod = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multi_draw") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_multi_draw = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_2d_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_2d_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_tile_image") and (vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_tile_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_opacity_micromap") and (self.device.VK_KHR_acceleration_structure and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_EXT_opacity_micromap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_load_store_op_none")) {
                self.device.VK_EXT_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_border_color_swizzle") and (self.device.VK_EXT_custom_border_color)) {
                self.device.VK_EXT_border_color_swizzle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pageable_device_local_memory") and (self.device.VK_EXT_memory_priority)) {
                self.device.VK_EXT_pageable_device_local_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance4") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_rotate")) {
                self.device.VK_KHR_shader_subgroup_rotate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_sliced_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_sliced_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_descriptor_set_host_mapping") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_VALVE_descriptor_set_host_mapping = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_non_seamless_cube_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_non_seamless_cube_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_QCOM_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_maximal_reconvergence") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_maximal_reconvergence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control_swapchain") and (self.device.VK_EXT_image_compression_control)) {
                self.device.VK_EXT_image_compression_control_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing") and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_image_processing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_nested_command_buffer") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_nested_command_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_acquire_unmodified") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_acquire_unmodified = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subpass_merge_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subpass_merge_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_module_identifier") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_pipeline_creation_cache_control) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_module_identifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rasterization_order_attachment_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rasterization_order_attachment_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_dithering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_legacy_dithering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_protected_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_protected_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance5") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_maintenance5 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_id2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id2)) {
                self.device.VK_KHR_present_wait2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_position_fetch") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_position_fetch = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_object") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_object = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_binary") and (self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_KHR_pipeline_binary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_maintenance1") and (self.device.VK_KHR_swapchain or self.instance.VK_KHR_surface_maintenance1 or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_KHR_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_viewports") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_multiview_per_view_viewports = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_vertex_attributes") and (self.device.VK_EXT_vertex_input_dynamic_state)) {
                self.device.VK_EXT_legacy_vertex_attributes = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_library_group_handles") and (self.device.VK_KHR_ray_tracing_pipeline and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_pipeline_library_group_handles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_dynamic_rendering_unused_attachments") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_dynamic_rendering_unused_attachments = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_cooperative_matrix") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_cooperative_matrix = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_render_areas")) {
                self.device.VK_QCOM_multiview_per_view_render_areas = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_compute_shader_derivatives") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_compute_shader_derivatives = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_av1") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_av1") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_vp9") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_vp9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance1") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing2") and (self.device.VK_QCOM_image_processing)) {
                self.device.VK_QCOM_image_processing2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_weights") and (self.device.VK_EXT_filter_cubic)) {
                self.device.VK_QCOM_filter_cubic_weights = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_ycbcr_degamma")) {
                self.device.VK_QCOM_ycbcr_degamma = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_clamp") and ((self.device.VK_EXT_filter_cubic) and (vk.VK_API_VERSION_1_2 <= api_version or self.device.VK_EXT_sampler_filter_minmax))) {
                self.device.VK_QCOM_filter_cubic_clamp = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_dynamic_state") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_attachment_feedback_loop_layout)) {
                self.device.VK_EXT_attachment_feedback_loop_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_load_store_op_none")) {
                self.device.VK_KHR_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_unified_image_layouts")) {
                self.device.VK_KHR_unified_image_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls2") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_shader_float_controls2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_expect_assume") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_expect_assume = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance6") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance6 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_memory_heap") and ((self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_memory_heap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_intra_refresh") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_intra_refresh = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_quantization_map") and (self.device.VK_KHR_video_encode_queue and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_quantization_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_relaxed_extended_instruction")) {
                self.device.VK_KHR_shader_relaxed_extended_instruction = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance7") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance7 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_replicated_composites")) {
                self.device.VK_EXT_shader_replicated_composites = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_float8")) {
                self.device.VK_EXT_shader_float8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_generated_commands") and (((self.device.VK_KHR_buffer_device_address or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_maintenance5) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_device_generated_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance8") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance9") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance2") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_metal") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_metal = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_fragment_density_map_layered") and ((self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_VALVE_fragment_density_map_layered = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version) and (vk.VK_API_VERSION_1_3 <= api_version or self.device.VK_KHR_dynamic_rendering))) {
                self.device.VK_EXT_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_zero_initialize_device_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_zero_initialize_device_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        return self;
    }
};

pub fn check_VkBaseOutStructure(extensions: *const Extensions, item: *const vk.VkBaseOutStructure, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBaseOutStructure: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBaseInStructure(extensions: *const Extensions, item: *const vk.VkBaseInStructure, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBaseInStructure: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkOffset2D(extensions: *const Extensions, item: *const vk.VkOffset2D, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkOffset3D(extensions: *const Extensions, item: *const vk.VkOffset3D, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExtent2D(extensions: *const Extensions, item: *const vk.VkExtent2D, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExtent3D(extensions: *const Extensions, item: *const vk.VkExtent3D, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkViewport(extensions: *const Extensions, item: *const vk.VkViewport, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRect2D(extensions: *const Extensions, item: *const vk.VkRect2D, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkClearRect(extensions: *const Extensions, item: *const vk.VkClearRect, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkComponentMapping(extensions: *const Extensions, item: *const vk.VkComponentMapping, check_pnext: bool) bool {
    if (!check_enum_VkComponentSwizzle(extensions, @ptrCast(&item.r)))
        return false;
    if (!check_enum_VkComponentSwizzle(extensions, @ptrCast(&item.g)))
        return false;
    if (!check_enum_VkComponentSwizzle(extensions, @ptrCast(&item.b)))
        return false;
    if (!check_enum_VkComponentSwizzle(extensions, @ptrCast(&item.a)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties, check_pnext: bool) bool {
    if (!check_enum_VkPhysicalDeviceType(extensions, @ptrCast(&item.deviceType)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkExtensionProperties(extensions: *const Extensions, item: *const vk.VkExtensionProperties, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkLayerProperties(extensions: *const Extensions, item: *const vk.VkLayerProperties, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkApplicationInfo(extensions: *const Extensions, item: *const vk.VkApplicationInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT,
            => if (!check_VkApplicationParametersEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkApplicationInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAllocationCallbacks(extensions: *const Extensions, item: *const vk.VkAllocationCallbacks, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceQueueCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDeviceQueueCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
            => if (!check_VkDeviceQueueGlobalPriorityCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT,
            => if (!check_VkApplicationParametersEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
            => if (!check_VkDevicePrivateDataCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            => if (!check_VkPhysicalDevicePrivateDataFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!check_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            => if (!check_VkPhysicalDeviceVariablePointersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            => if (!check_VkPhysicalDeviceMultiviewFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
            => if (!check_VkDeviceGroupDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentIdFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentId2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentWaitFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentWait2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            => if (!check_VkPhysicalDevice16BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            => if (!check_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            => if (!check_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            => if (!check_VkPhysicalDeviceProtectedMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            => if (!check_VkPhysicalDeviceInlineUniformBlockFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            => if (!check_VkPhysicalDeviceMaintenance4Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
            => if (!check_VkPhysicalDeviceMaintenance5Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
            => if (!check_VkPhysicalDeviceMaintenance6Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            => if (!check_VkPhysicalDeviceShaderDrawParametersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            => if (!check_VkPhysicalDeviceShaderFloat16Int8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            => if (!check_VkPhysicalDeviceHostQueryResetFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
            => if (!check_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            => if (!check_VkDeviceDeviceMemoryReportCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            => if (!check_VkPhysicalDeviceDescriptorIndexingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            => if (!check_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            => if (!check_VkPhysicalDevice8BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            => if (!check_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            => if (!check_VkPhysicalDeviceShaderAtomicInt64Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
            => if (!check_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            => if (!check_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            => if (!check_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            => if (!check_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            => if (!check_VkPhysicalDeviceImagelessFramebufferFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            => if (!check_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR,
            => if (!check_VkPerformanceQueryReservationInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            => if (!check_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderClockFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
            => if (!check_VkPhysicalDeviceIndexTypeUint8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            => if (!check_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            => if (!check_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            => if (!check_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
            => if (!check_VkPhysicalDeviceLineRasterizationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            => if (!check_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan11Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan12Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan13Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan14Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO,
            => if (!check_VkFaultCallbackInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            => if (!check_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRobustness2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            => if (!check_VkPhysicalDeviceImageRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            => if (!check_VkPhysicalDevice4444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            => if (!check_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            => if (!check_VkPhysicalDeviceSynchronization2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
            => if (!check_VkPhysicalDeviceHostImageCopyFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO,
            => if (!check_VkDeviceObjectReservationCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES,
            => if (!check_VkPhysicalDeviceVulkanSC10Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
            => if (!check_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            => if (!check_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            => if (!check_VkPhysicalDeviceDynamicRenderingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
            => if (!check_VkDevicePipelineBinaryInternalCacheControlKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            => if (!check_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
            => if (!check_VkPhysicalDevicePipelineRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFaultFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
            => if (!check_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
            => if (!check_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
            => if (!check_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
            => if (!check_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
            => if (!check_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
            => if (!check_VkPhysicalDeviceShaderFloatControls2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
            => if (!check_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
            => if (!check_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
            => if (!check_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkInstanceCreateInfo(extensions: *const Extensions, item: *const vk.VkInstanceCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkInstanceCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
            => if (!check_VkDebugReportCallbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
            => if (!check_VkValidationFlagsEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
            => if (!check_VkValidationFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
            => if (!check_VkLayerSettingsCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            => if (!check_VkDebugUtilsMessengerCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!check_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG,
            => if (!check_VkDirectDriverLoadingListLUNARG(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkInstanceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueueFamilyProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties, check_pnext: bool) bool {
    if (!check_bitmask_VkQueueFlagBits(extensions, @ptrCast(&item.queueFlags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
            => if (!check_VkExportMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            => if (!check_VkImportMemoryWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            => if (!check_VkExportMemoryWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
            => if (!check_VkImportMemoryZirconHandleInfoFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
            => if (!check_VkImportMemoryFdInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
            => if (!check_VkImportMemoryMetalHandleInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
            => if (!check_VkMemoryAllocateFlagsInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
            => if (!check_VkMemoryDedicatedAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
            => if (!check_VkImportMemoryHostPointerInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            => if (!check_VkImportAndroidHardwareBufferInfoANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
            => if (!check_VkMemoryPriorityAllocateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
            => if (!check_VkMemoryOpaqueCaptureAddressAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
            => if (!check_VkImportMemoryBufferCollectionFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!check_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
            => if (!check_VkImportMetalBufferInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
            => if (!check_VkImportScreenBufferInfoQNX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryRequirements(extensions: *const Extensions, item: *const vk.VkMemoryRequirements, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties, check_pnext: bool) bool {
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    if (!check_bitmask_VkSparseImageFormatFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryType(extensions: *const Extensions, item: *const vk.VkMemoryType, check_pnext: bool) bool {
    if (!check_bitmask_VkMemoryPropertyFlagBits(extensions, @ptrCast(&item.propertyFlags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryHeap(extensions: *const Extensions, item: *const vk.VkMemoryHeap, check_pnext: bool) bool {
    if (!check_bitmask_VkMemoryHeapFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkMappedMemoryRange(extensions: *const Extensions, item: *const vk.VkMappedMemoryRange, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMappedMemoryRange: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFormatProperties(extensions: *const Extensions, item: *const vk.VkFormatProperties, check_pnext: bool) bool {
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.linearTilingFeatures)))
        return false;
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.optimalTilingFeatures)))
        return false;
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.bufferFeatures)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageFormatProperties(extensions: *const Extensions, item: *const vk.VkImageFormatProperties, check_pnext: bool) bool {
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleCounts)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorBufferInfo(extensions: *const Extensions, item: *const vk.VkDescriptorBufferInfo, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorImageInfo(extensions: *const Extensions, item: *const vk.VkDescriptorImageInfo, check_pnext: bool) bool {
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkWriteDescriptorSet(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSet, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDescriptorType(extensions, @ptrCast(&item.descriptorType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
            => if (!check_VkWriteDescriptorSetInlineUniformBlock(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
            => if (!check_VkWriteDescriptorSetAccelerationStructureKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSet: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyDescriptorSet(extensions: *const Extensions, item: *const vk.VkCopyDescriptorSet, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyDescriptorSet: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferUsageFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2CreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferUsageFlags2CreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferUsageFlags2CreateInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2CreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkBufferCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkBufferUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_enum_VkSharingMode(extensions, @ptrCast(&item.sharingMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!check_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
            => if (!check_VkExternalMemoryBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
            => if (!check_VkBufferOpaqueCaptureAddressCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
            => if (!check_VkBufferDeviceAddressCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!check_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!check_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
            => if (!check_VkBufferCollectionBufferCreateInfoFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferViewCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferViewCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!check_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!check_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferViewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageSubresource(extensions: *const Extensions, item: *const vk.VkImageSubresource, check_pnext: bool) bool {
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageSubresourceLayers(extensions: *const Extensions, item: *const vk.VkImageSubresourceLayers, check_pnext: bool) bool {
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageSubresourceRange(extensions: *const Extensions, item: *const vk.VkImageSubresourceRange, check_pnext: bool) bool {
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryBarrier(extensions: *const Extensions, item: *const vk.VkMemoryBarrier, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferMemoryBarrier(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!check_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!check_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageMemoryBarrier(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.oldLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.newLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
            => if (!check_VkSampleLocationsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!check_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!check_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkImageType(extensions, @ptrCast(&item.imageType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!check_enum_VkImageTiling(extensions, @ptrCast(&item.tiling)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_enum_VkSharingMode(extensions, @ptrCast(&item.sharingMode)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.initialLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            => if (!check_VkExternalMemoryImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!check_VkImageSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            => if (!check_VkImageFormatListCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            => if (!check_VkImageDrmFormatModifierListCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            => if (!check_VkImageDrmFormatModifierExplicitCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            => if (!check_VkImageStencilUsageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!check_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!check_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
            => if (!check_VkBufferCollectionImageCreateInfoFUCHSIA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            => if (!check_VkImageCompressionControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!check_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
            => if (!check_VkImportMetalTextureInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
            => if (!check_VkImportMetalIOSurfaceInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            => if (!check_VkExternalFormatQNX(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
            => if (!check_VkImageAlignmentControlCreateInfoMESA(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubresourceLayout(extensions: *const Extensions, item: *const vk.VkSubresourceLayout, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageViewCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageViewCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkImageViewType(extensions, @ptrCast(&item.viewType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
            => if (!check_VkImageViewUsageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
            => if (!check_VkImageViewSlicedCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
            => if (!check_VkSamplerYcbcrConversionInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            => if (!check_VkImageViewASTCDecodeModeEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!check_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            => if (!check_VkImageViewMinLodCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!check_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCopy(extensions: *const Extensions, item: *const vk.VkBufferCopy, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseMemoryBind, check_pnext: bool) bool {
    if (!check_bitmask_VkSparseMemoryBindFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseImageMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBind, check_pnext: bool) bool {
    if (!check_bitmask_VkSparseMemoryBindFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseBufferMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseBufferMemoryBindInfo, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseImageOpaqueMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageOpaqueMemoryBindInfo, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseImageMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBindInfo, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindSparseInfo(extensions: *const Extensions, item: *const vk.VkBindSparseInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
            => if (!check_VkDeviceGroupBindSparseInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
            => if (!check_VkTimelineSemaphoreSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!check_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindSparseInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageCopy(extensions: *const Extensions, item: *const vk.VkImageCopy, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageBlit(extensions: *const Extensions, item: *const vk.VkImageBlit, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferImageCopy(extensions: *const Extensions, item: *const vk.VkBufferImageCopy, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageResolve(extensions: *const Extensions, item: *const vk.VkImageResolve, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkShaderModuleCreateInfo(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
            => if (!check_VkValidationFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            => if (!check_VkShaderModuleValidationCacheCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetLayoutBinding(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBinding, check_pnext: bool) bool {
    if (!check_enum_VkDescriptorType(extensions, @ptrCast(&item.descriptorType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorSetLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDescriptorSetLayoutCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            => if (!check_VkDescriptorSetLayoutBindingFlagsCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
            => if (!check_VkMutableDescriptorTypeCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorPoolSize(extensions: *const Extensions, item: *const vk.VkDescriptorPoolSize, check_pnext: bool) bool {
    if (!check_enum_VkDescriptorType(extensions, @ptrCast(&item.type)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDescriptorPoolCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            => if (!check_VkDescriptorPoolInlineUniformBlockCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
            => if (!check_VkMutableDescriptorTypeCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetAllocateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
            => if (!check_VkDescriptorSetVariableDescriptorCountAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSpecializationMapEntry(extensions: *const Extensions, item: *const vk.VkSpecializationMapEntry, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSpecializationInfo(extensions: *const Extensions, item: *const vk.VkSpecializationInfo, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineShaderStageCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineShaderStageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stage)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            => if (!check_VkShaderModuleCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            => if (!check_VkShaderModuleValidationCacheCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            => if (!check_VkDebugUtilsObjectNameInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            => if (!check_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
            => if (!check_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!check_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkComputePipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkComputePipelineCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
            => if (!check_VkPipelineCreateFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            => if (!check_VkPipelineBinaryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            => if (!check_VkPipelineCreationFeedbackCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
            => if (!check_VkSubpassShadingPipelineCreateInfoHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!check_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkComputePipelineCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineCreateFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2CreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreateFlags2CreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineCreateFlags2CreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2CreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVertexInputBindingDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription, check_pnext: bool) bool {
    if (!check_enum_VkVertexInputRate(extensions, @ptrCast(&item.inputRate)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkVertexInputAttributeDescription(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription, check_pnext: bool) bool {
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineVertexInputStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
            => if (!check_VkPipelineVertexInputDivisorStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineVertexInputStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineInputAssemblyStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineInputAssemblyStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPrimitiveTopology(extensions, @ptrCast(&item.topology)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineInputAssemblyStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineTessellationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
            => if (!check_VkPipelineTessellationDomainOriginStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineTessellationStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineViewportStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineViewportStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
            => if (!check_VkPipelineViewportDepthClipControlCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
            => if (!check_VkPipelineViewportDepthClampControlCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRasterizationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPolygonMode(extensions, @ptrCast(&item.polygonMode)))
        return false;
    if (!check_bitmask_VkCullModeFlagBits(extensions, @ptrCast(&item.cullMode)))
        return false;
    if (!check_enum_VkFrontFace(extensions, @ptrCast(&item.frontFace)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
            => if (!check_VkPipelineRasterizationConservativeStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
            => if (!check_VkPipelineRasterizationStateStreamCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
            => if (!check_VkPipelineRasterizationDepthClipStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
            => if (!check_VkPipelineRasterizationLineStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
            => if (!check_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
            => if (!check_VkDepthBiasRepresentationInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineMultisampleStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineMultisampleStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.rasterizationSamples)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
            => if (!check_VkPipelineSampleLocationsStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineMultisampleStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineColorBlendAttachmentState(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAttachmentState, check_pnext: bool) bool {
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.srcColorBlendFactor)))
        return false;
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.dstColorBlendFactor)))
        return false;
    if (!check_enum_VkBlendOp(extensions, @ptrCast(&item.colorBlendOp)))
        return false;
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.srcAlphaBlendFactor)))
        return false;
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.dstAlphaBlendFactor)))
        return false;
    if (!check_enum_VkBlendOp(extensions, @ptrCast(&item.alphaBlendOp)))
        return false;
    if (!check_bitmask_VkColorComponentFlagBits(extensions, @ptrCast(&item.colorWriteMask)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineColorBlendStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineColorBlendStateCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkLogicOp(extensions, @ptrCast(&item.logicOp)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
            => if (!check_VkPipelineColorBlendAdvancedStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
            => if (!check_VkPipelineColorWriteCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorBlendStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineDynamicStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDynamicStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.dynamicStateCount) |i| {
        if (!check_enum_VkDynamicState(extensions, @ptrCast(&item.pDynamicStates[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDynamicStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkStencilOpState(extensions: *const Extensions, item: *const vk.VkStencilOpState, check_pnext: bool) bool {
    if (!check_enum_VkStencilOp(extensions, @ptrCast(&item.failOp)))
        return false;
    if (!check_enum_VkStencilOp(extensions, @ptrCast(&item.passOp)))
        return false;
    if (!check_enum_VkStencilOp(extensions, @ptrCast(&item.depthFailOp)))
        return false;
    if (!check_enum_VkCompareOp(extensions, @ptrCast(&item.compareOp)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineDepthStencilStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineDepthStencilStateCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkCompareOp(extensions, @ptrCast(&item.depthCompareOp)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDepthStencilStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkGraphicsPipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
            => if (!check_VkPipelineCreateFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            => if (!check_VkPipelineBinaryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
            => if (!check_VkPipelineDiscardRectangleStateCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            => if (!check_VkPipelineCreationFeedbackCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
            => if (!check_VkPipelineLibraryCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
            => if (!check_VkPipelineFragmentShadingRateStateCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
            => if (!check_VkPipelineRenderingCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
            => if (!check_VkGraphicsPipelineLibraryCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!check_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
            => if (!check_VkRenderingAttachmentLocationInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
            => if (!check_VkRenderingInputAttachmentIndexInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE,
            => if (!check_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineCacheCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineCacheCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCacheCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineCacheHeaderVersionOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionOne, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineCacheStageValidationIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheStageValidationIndexEntry, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineCacheSafetyCriticalIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheSafetyCriticalIndexEntry, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineCacheHeaderVersionSafetyCriticalOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionSafetyCriticalOne, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPushConstantRange(extensions: *const Extensions, item: *const vk.VkPushConstantRange, check_pnext: bool) bool {
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineBinaryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineBinaryHandlesInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryHandlesInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryHandlesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineBinaryDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineBinaryKeysAndDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeysAndDataKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineBinaryKeyKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeyKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryKeyKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineBinaryInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkReleaseCapturedPipelineDataInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseCapturedPipelineDataInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkReleaseCapturedPipelineDataInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineBinaryDataInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryDataInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineLayoutCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineLayoutCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSamplerCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkFilter(extensions, @ptrCast(&item.magFilter)))
        return false;
    if (!check_enum_VkFilter(extensions, @ptrCast(&item.minFilter)))
        return false;
    if (!check_enum_VkSamplerMipmapMode(extensions, @ptrCast(&item.mipmapMode)))
        return false;
    if (!check_enum_VkSamplerAddressMode(extensions, @ptrCast(&item.addressModeU)))
        return false;
    if (!check_enum_VkSamplerAddressMode(extensions, @ptrCast(&item.addressModeV)))
        return false;
    if (!check_enum_VkSamplerAddressMode(extensions, @ptrCast(&item.addressModeW)))
        return false;
    if (!check_enum_VkCompareOp(extensions, @ptrCast(&item.compareOp)))
        return false;
    if (!check_enum_VkBorderColor(extensions, @ptrCast(&item.borderColor)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
            => if (!check_VkSamplerYcbcrConversionInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
            => if (!check_VkSamplerReductionModeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            => if (!check_VkSamplerCustomBorderColorCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            => if (!check_VkSamplerBorderColorComponentMappingCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!check_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkCommandPoolCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO,
            => if (!check_VkCommandPoolMemoryReservationCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandBufferAllocateInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferAllocateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkCommandBufferLevel(extensions, @ptrCast(&item.level)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandBufferInheritanceInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkQueryControlFlagBits(extensions, @ptrCast(&item.queryFlags)))
        return false;
    if (!check_bitmask_VkQueryPipelineStatisticFlagBits(extensions, @ptrCast(&item.pipelineStatistics)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
            => if (!check_VkCommandBufferInheritanceConditionalRenderingInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
            => if (!check_VkCommandBufferInheritanceRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
            => if (!check_VkRenderingAttachmentLocationInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
            => if (!check_VkRenderingInputAttachmentIndexInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferBeginInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkCommandBufferUsageFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
            => if (!check_VkDeviceGroupCommandBufferBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassBeginInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            => if (!check_VkDeviceGroupRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            => if (!check_VkRenderPassSampleLocationsBeginInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            => if (!check_VkRenderPassAttachmentBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkClearDepthStencilValue(extensions: *const Extensions, item: *const vk.VkClearDepthStencilValue, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkClearAttachment(extensions: *const Extensions, item: *const vk.VkClearAttachment, check_pnext: bool) bool {
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkAttachmentDescription(extensions: *const Extensions, item: *const vk.VkAttachmentDescription, check_pnext: bool) bool {
    if (!check_bitmask_VkAttachmentDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!check_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.loadOp)))
        return false;
    if (!check_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.storeOp)))
        return false;
    if (!check_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.stencilLoadOp)))
        return false;
    if (!check_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.stencilStoreOp)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.initialLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.finalLayout)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkAttachmentReference(extensions: *const Extensions, item: *const vk.VkAttachmentReference, check_pnext: bool) bool {
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.layout)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassDescription(extensions: *const Extensions, item: *const vk.VkSubpassDescription, check_pnext: bool) bool {
    if (!check_bitmask_VkSubpassDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkPipelineBindPoint(extensions, @ptrCast(&item.pipelineBindPoint)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassDependency(extensions: *const Extensions, item: *const vk.VkSubpassDependency, check_pnext: bool) bool {
    if (!check_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.srcStageMask)))
        return false;
    if (!check_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.dstStageMask)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!check_bitmask_VkDependencyFlagBits(extensions, @ptrCast(&item.dependencyFlags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkRenderPassCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
            => if (!check_VkRenderPassMultiviewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
            => if (!check_VkRenderPassInputAttachmentAspectCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            => if (!check_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
            => if (!check_VkRenderPassCreationControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            => if (!check_VkRenderPassCreationFeedbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkEventCreateInfo(extensions: *const Extensions, item: *const vk.VkEventCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkEventCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!check_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            => if (!check_VkImportMetalSharedEventInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkEventCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkFenceCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFenceCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
            => if (!check_VkExportFenceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            => if (!check_VkExportFenceWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSparseProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseProperties, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceLimits(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLimits, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
            => if (!check_VkExportSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            => if (!check_VkExportSemaphoreWin32HandleInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
            => if (!check_VkSemaphoreTypeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            => if (!check_VkExportMetalObjectCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            => if (!check_VkImportMetalSharedEventInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueryPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkQueryPoolCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkQueryType(extensions, @ptrCast(&item.queryType)))
        return false;
    if (!check_bitmask_VkQueryPipelineStatisticFlagBits(extensions, @ptrCast(&item.pipelineStatistics)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            => if (!check_VkQueryPoolPerformanceCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            => if (!check_VkQueryPoolPerformanceQueryCreateInfoINTEL(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!check_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            => if (!check_VkVideoDecodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeVP9ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
            => if (!check_VkVideoEncodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
            => if (!check_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
            => if (!check_VkVideoEncodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
            => if (!check_VkVideoEncodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
            => if (!check_VkVideoEncodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFramebufferCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFramebufferCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
            => if (!check_VkFramebufferAttachmentsCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDrawIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndirectCommand, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDrawIndexedIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndexedIndirectCommand, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDispatchIndirectCommand(extensions: *const Extensions, item: *const vk.VkDispatchIndirectCommand, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMultiDrawInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMultiDrawIndexedInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawIndexedInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubmitInfo(extensions: *const Extensions, item: *const vk.VkSubmitInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.waitSemaphoreCount) |i| {
        if (!check_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.pWaitDstStageMask[i]))) 
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            => if (!check_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
            => if (!check_VkD3D12FenceSubmitInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
            => if (!check_VkDeviceGroupSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
            => if (!check_VkProtectedSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
            => if (!check_VkTimelineSemaphoreSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            => if (!check_VkPerformanceQuerySubmitInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!check_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayPropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPropertiesKHR, check_pnext: bool) bool {
    if (!check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.supportedTransforms)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkDisplayPlanePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlanePropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDisplayModeParametersKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeParametersKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDisplayModePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayModePropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDisplayModeCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayModeCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayPlaneCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions, @ptrCast(&item.supportedAlpha)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkDisplaySurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.transform)))
        return false;
    if (!check_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions, @ptrCast(&item.alphaMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplaySurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayPresentInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.supportedTransforms)))
        return false;
    if (!check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.currentTransform)))
        return false;
    if (!check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, @ptrCast(&item.supportedCompositeAlpha)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.supportedUsageFlags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkAndroidSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAndroidSurfaceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkViSurfaceCreateInfoNN(extensions: *const Extensions, item: *const vk.VkViSurfaceCreateInfoNN, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkViSurfaceCreateInfoNN: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkWaylandSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWaylandSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkWin32SurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32SurfaceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWin32SurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkXlibSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXlibSurfaceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkXlibSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkXcbSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXcbSurfaceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkXcbSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDirectFBSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDirectFBSurfaceCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectFBSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImagePipeSurfaceCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImagePipeSurfaceCreateInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImagePipeSurfaceCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkScreenSurfaceCreateInfoQNX(extensions: *const Extensions, item: *const vk.VkScreenSurfaceCreateInfoQNX, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenSurfaceCreateInfoQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceFormatKHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormatKHR, check_pnext: bool) bool {
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_enum_VkColorSpaceKHR(extensions, @ptrCast(&item.colorSpace)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSwapchainCreateFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.imageFormat)))
        return false;
    if (!check_enum_VkColorSpaceKHR(extensions, @ptrCast(&item.imageColorSpace)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.imageUsage)))
        return false;
    if (!check_enum_VkSharingMode(extensions, @ptrCast(&item.imageSharingMode)))
        return false;
    if (!check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.preTransform)))
        return false;
    if (!check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, @ptrCast(&item.compositeAlpha)))
        return false;
    if (!check_enum_VkPresentModeKHR(extensions, @ptrCast(&item.presentMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            => if (!check_VkSwapchainCounterCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!check_VkDeviceGroupSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            => if (!check_VkImageFormatListCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            => if (!check_VkSurfaceFullScreenExclusiveInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            => if (!check_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            => if (!check_VkImageCompressionControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
            => if (!check_VkSwapchainPresentModesCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR,
            => if (!check_VkSwapchainPresentScalingCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkPresentInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.swapchainCount) |i| {
        if (!check_enum_VkResult(extensions, @ptrCast(&item.pResults[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
            => if (!check_VkDisplayPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
            => if (!check_VkPresentRegionsKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
            => if (!check_VkDeviceGroupPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PRESENT_ID_KHR,
            => if (!check_VkPresentIdKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR,
            => if (!check_VkPresentId2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!check_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
            => if (!check_VkSwapchainPresentFenceInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
            => if (!check_VkSwapchainPresentModeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugReportCallbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugReportCallbackCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDebugReportFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugReportCallbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkValidationFlagsEXT(extensions: *const Extensions, item: *const vk.VkValidationFlagsEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.disabledValidationCheckCount) |i| {
        if (!check_enum_VkValidationCheckEXT(extensions, @ptrCast(&item.pDisabledValidationChecks[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationFlagsEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkValidationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkValidationFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.enabledValidationFeatureCount) |i| {
        if (!check_enum_VkValidationFeatureEnableEXT(extensions, @ptrCast(&item.pEnabledValidationFeatures[i])))
            return false;
    }
    for (0..item.disabledValidationFeatureCount) |i| {
        if (!check_enum_VkValidationFeatureDisableEXT(extensions, @ptrCast(&item.pDisabledValidationFeatures[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkLayerSettingsCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingsCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLayerSettingsCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkLayerSettingEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingEXT, check_pnext: bool) bool {
    if (!check_enum_VkLayerSettingTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkApplicationParametersEXT(extensions: *const Extensions, item: *const vk.VkApplicationParametersEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkApplicationParametersEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugMarkerObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectNameInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDebugReportObjectTypeEXT(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerObjectNameInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugMarkerObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectTagInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDebugReportObjectTypeEXT(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerObjectTagInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugMarkerMarkerInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerMarkerInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerMarkerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDevicePrivateDataCreateInfo(extensions: *const Extensions, item: *const vk.VkDevicePrivateDataCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDevicePrivateDataCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDevicePrivateDataCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDevicePrivateDataCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPrivateDataSlotCreateInfo(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPrivateDataSlotCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPrivateDataSlotCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePrivateDataFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrivateDataFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrivateDataFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePrivateDataFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrivateDataFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMultiDrawPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiDrawPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFeatures2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            => if (!check_VkPhysicalDevicePrivateDataFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            => if (!check_VkPhysicalDeviceVariablePointersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            => if (!check_VkPhysicalDeviceMultiviewFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentIdFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentId2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentWaitFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentWait2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            => if (!check_VkPhysicalDevice16BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            => if (!check_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            => if (!check_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            => if (!check_VkPhysicalDeviceProtectedMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            => if (!check_VkPhysicalDeviceInlineUniformBlockFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            => if (!check_VkPhysicalDeviceMaintenance4Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
            => if (!check_VkPhysicalDeviceMaintenance5Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
            => if (!check_VkPhysicalDeviceMaintenance6Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            => if (!check_VkPhysicalDeviceShaderDrawParametersFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            => if (!check_VkPhysicalDeviceShaderFloat16Int8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            => if (!check_VkPhysicalDeviceHostQueryResetFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
            => if (!check_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            => if (!check_VkPhysicalDeviceDescriptorIndexingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            => if (!check_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            => if (!check_VkPhysicalDevice8BitStorageFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            => if (!check_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            => if (!check_VkPhysicalDeviceShaderAtomicInt64Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
            => if (!check_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            => if (!check_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            => if (!check_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            => if (!check_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            => if (!check_VkPhysicalDeviceImagelessFramebufferFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            => if (!check_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            => if (!check_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderClockFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
            => if (!check_VkPhysicalDeviceIndexTypeUint8Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            => if (!check_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            => if (!check_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            => if (!check_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
            => if (!check_VkPhysicalDeviceLineRasterizationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            => if (!check_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan11Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan12Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan13Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
            => if (!check_VkPhysicalDeviceVulkan14Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            => if (!check_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRobustness2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            => if (!check_VkPhysicalDeviceImageRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            => if (!check_VkPhysicalDevice4444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            => if (!check_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            => if (!check_VkPhysicalDeviceSynchronization2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
            => if (!check_VkPhysicalDeviceHostImageCopyFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES,
            => if (!check_VkPhysicalDeviceVulkanSC10Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
            => if (!check_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            => if (!check_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            => if (!check_VkPhysicalDeviceDynamicRenderingFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            => if (!check_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
            => if (!check_VkPhysicalDevicePipelineRobustnessFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFaultFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
            => if (!check_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
            => if (!check_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
            => if (!check_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
            => if (!check_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
            => if (!check_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
            => if (!check_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
            => if (!check_VkPhysicalDeviceShaderFloatControls2Features(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
            => if (!check_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
            => if (!check_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
            => if (!check_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
            => if (!check_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
            => if (!check_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
            => if (!check_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFeatures2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFeatures2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceMultiDrawPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
            => if (!check_VkPhysicalDevicePushDescriptorProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            => if (!check_VkPhysicalDeviceDriverProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
            => if (!check_VkPhysicalDeviceIDProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            => if (!check_VkPhysicalDeviceMultiviewProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceDiscardRectanglePropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            => if (!check_VkPhysicalDeviceSubgroupProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            => if (!check_VkPhysicalDevicePointClippingProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            => if (!check_VkPhysicalDeviceProtectedMemoryProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            => if (!check_VkPhysicalDeviceSamplerFilterMinmaxProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceSampleLocationsPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            => if (!check_VkPhysicalDeviceInlineUniformBlockProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            => if (!check_VkPhysicalDeviceMaintenance3Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
            => if (!check_VkPhysicalDeviceMaintenance4Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
            => if (!check_VkPhysicalDeviceMaintenance5Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
            => if (!check_VkPhysicalDeviceMaintenance6Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance7PropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
            => if (!check_VkPhysicalDeviceLayeredApiPropertiesListKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceMaintenance9PropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            => if (!check_VkPhysicalDeviceFloatControlsProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            => if (!check_VkPhysicalDeviceDescriptorIndexingProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            => if (!check_VkPhysicalDeviceTimelineSemaphoreProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
            => if (!check_VkPhysicalDeviceVertexAttributeDivisorProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            => if (!check_VkPhysicalDevicePCIBusInfoPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            => if (!check_VkPhysicalDeviceDepthStencilResolveProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceTransformFeedbackPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceMeshShaderPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceAccelerationStructurePropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            => if (!check_VkPhysicalDevicePerformanceQueryPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            => if (!check_VkPhysicalDeviceTexelBufferAlignmentProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            => if (!check_VkPhysicalDeviceSubgroupSizeControlProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            => if (!check_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
            => if (!check_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
            => if (!check_VkPhysicalDeviceLineRasterizationProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            => if (!check_VkPhysicalDeviceVulkan11Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            => if (!check_VkPhysicalDeviceVulkan12Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
            => if (!check_VkPhysicalDeviceVulkan13Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES,
            => if (!check_VkPhysicalDeviceVulkan14Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceCustomBorderColorPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceRobustness2PropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            => if (!check_VkPhysicalDevicePortabilitySubsetPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
            => if (!check_VkPhysicalDeviceHostImageCopyProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES,
            => if (!check_VkPhysicalDeviceVulkanSC10Properties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceProvokingVertexPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceDescriptorBufferPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            => if (!check_VkPhysicalDeviceShaderIntegerDotProductProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceDrmPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
            => if (!check_VkPhysicalDevicePipelineBinaryPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceOpacityMicromapPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
            => if (!check_VkPhysicalDevicePipelineRobustnessProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceShaderObjectPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceShaderTileImagePropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
            => if (!check_VkPhysicalDeviceLayeredDriverPropertiesMSFT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID,
            => if (!check_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
            => if (!check_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE,
            => if (!check_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceProperties2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkFormatProperties2(extensions: *const Extensions, item: *const vk.VkFormatProperties2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            => if (!check_VkDrmFormatModifierPropertiesListEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT,
            => if (!check_VkSubpassResolvePerformanceQueryEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
            => if (!check_VkFormatProperties3(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT,
            => if (!check_VkDrmFormatModifierPropertiesList2EXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkFormatProperties2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkImageFormatProperties2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            => if (!check_VkExternalImageFormatProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            => if (!check_VkSamplerYcbcrConversionImageFormatProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            => if (!check_VkAndroidHardwareBufferUsageANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            => if (!check_VkFilterCubicImageViewImageFormatPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
            => if (!check_VkHostImageCopyDevicePerformanceQuery(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            => if (!check_VkImageCompressionPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkImageFormatProperties2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageFormatInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_enum_VkImageType(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_enum_VkImageTiling(extensions, @ptrCast(&item.tiling)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            => if (!check_VkPhysicalDeviceExternalImageFormatInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            => if (!check_VkImageFormatListCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            => if (!check_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            => if (!check_VkImageStencilUsageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            => if (!check_VkPhysicalDeviceImageViewImageFormatInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!check_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            => if (!check_VkImageCompressionControlEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageFormatInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageFormatInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageFormatInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkQueueFamilyProperties2(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR,
            => if (!check_VkQueueFamilyOwnershipTransferPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
            => if (!check_VkQueueFamilyGlobalPriorityProperties(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR,
            => if (!check_VkQueueFamilyVideoPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
            => if (!check_VkQueueFamilyQueryResultStatusPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueueFamilyProperties2KHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMemoryProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
            => if (!check_VkPhysicalDeviceMemoryBudgetPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMemoryProperties2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSparseImageFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSparseImageFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSparseImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_enum_VkImageType(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_enum_VkImageTiling(extensions, @ptrCast(&item.tiling)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSparseImageFormatInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSparseImageFormatInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePushDescriptorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePushDescriptorProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePushDescriptorProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePushDescriptorPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePushDescriptorPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkConformanceVersion(extensions: *const Extensions, item: *const vk.VkConformanceVersion, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkConformanceVersionKHR(extensions: *const Extensions, item: *const vk.VkConformanceVersionKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDriverProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDriverProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDriverId(extensions, @ptrCast(&item.driverID)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDriverProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDriverPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDriverPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPresentRegionsKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionsKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentRegionsKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPresentRegionKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRectLayerKHR(extensions: *const Extensions, item: *const vk.VkRectLayerKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceVariablePointersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointersFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVariablePointersFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVariablePointersFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointersFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceVariablePointerFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointerFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceVariablePointerFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointerFeatures, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalMemoryProperties(extensions: *const Extensions, item: *const vk.VkExternalMemoryProperties, check_pnext: bool) bool {
    if (!check_bitmask_VkExternalMemoryFeatureFlagBits(extensions, @ptrCast(&item.externalMemoryFeatures)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.exportFromImportedHandleTypes)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.compatibleHandleTypes)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalMemoryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceExternalImageFormatInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalImageFormatInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalImageFormatInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalImageFormatInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalImageFormatInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalImageFormatProperties(extensions: *const Extensions, item: *const vk.VkExternalImageFormatProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalImageFormatProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalImageFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalImageFormatPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceExternalBufferInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalBufferInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkBufferCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkBufferUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!check_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalBufferInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalBufferInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalBufferInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalBufferProperties(extensions: *const Extensions, item: *const vk.VkExternalBufferProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalBufferProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalBufferPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalBufferPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceIDProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIDProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceIDProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceIDPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIDPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalMemoryImageCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryImageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalMemoryImageCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalMemoryBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryBufferCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryBufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalMemoryBufferCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryBufferCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExportMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMemoryAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportMemoryWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMemoryZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryZirconHandleInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryZirconHandlePropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryZirconHandlePropertiesFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryZirconHandlePropertiesFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryGetZirconHandleInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryWin32HandlePropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryWin32HandlePropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryWin32HandlePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMemoryFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryFdInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryFdPropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryFdPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryFdPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetFdInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32KeyedMutexAcquireReleaseInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWin32KeyedMutexAcquireReleaseInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMemoryMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryMetalHandleInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryMetalHandleInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryMetalHandlePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryMetalHandlePropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMetalHandlePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryGetMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryGetMetalHandleInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetMetalHandleInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalSemaphoreInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSemaphoreInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
            => if (!check_VkSemaphoreTypeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalSemaphoreInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalSemaphoreInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSemaphoreInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.exportFromImportedHandleTypes)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.compatibleHandleTypes)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreFeatureFlagBits(extensions, @ptrCast(&item.externalSemaphoreFeatures)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalSemaphoreProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalSemaphorePropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalSemaphorePropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExportSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkExportSemaphoreCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportSemaphoreCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportSemaphoreCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportSemaphoreCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSemaphoreImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportSemaphoreWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportSemaphoreWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkD3D12FenceSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkD3D12FenceSubmitInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkD3D12FenceSubmitInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSemaphoreGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportSemaphoreFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreFdInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSemaphoreImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSemaphoreGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetFdInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportSemaphoreZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportSemaphoreZirconHandleInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSemaphoreImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSemaphoreGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkSemaphoreGetZirconHandleInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalFenceInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFenceInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFenceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalFenceInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFenceInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExternalFenceProperties(extensions: *const Extensions, item: *const vk.VkExternalFenceProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.exportFromImportedHandleTypes)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.compatibleHandleTypes)))
        return false;
    if (!check_bitmask_VkExternalFenceFeatureFlagBits(extensions, @ptrCast(&item.externalFenceFeatures)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFenceProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalFencePropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalFencePropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkExportFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkExportFenceCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleTypes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportFenceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportFenceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportFenceCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFenceImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportFenceWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportFenceWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportFenceWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFenceGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetWin32HandleInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportFenceFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceFdInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFenceImportFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportFenceFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFenceGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetFdInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMultiviewFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMultiviewFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMultiviewProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMultiviewPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassMultiviewCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassMultiviewCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassMultiviewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassMultiviewCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassMultiviewCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSurfaceCapabilities2EXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2EXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.supportedTransforms)))
        return false;
    if (!check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, @ptrCast(&item.currentTransform)))
        return false;
    if (!check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, @ptrCast(&item.supportedCompositeAlpha)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.supportedUsageFlags)))
        return false;
    if (!check_bitmask_VkSurfaceCounterFlagBitsEXT(extensions, @ptrCast(&item.supportedSurfaceCounters)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilities2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayPowerInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDisplayPowerStateEXT(extensions, @ptrCast(&item.powerState)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPowerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDeviceEventTypeEXT(extensions, @ptrCast(&item.deviceEvent)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDisplayEventTypeEXT(extensions, @ptrCast(&item.displayEvent)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSwapchainCounterCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainCounterCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSurfaceCounterFlagBitsEXT(extensions, @ptrCast(&item.surfaceCounters)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainCounterCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceGroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGroupProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGroupProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceGroupPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGroupPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryAllocateFlagsInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagsInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkMemoryAllocateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryAllocateFlagsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryAllocateFlagsInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagsInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindBufferMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
            => if (!check_VkBindBufferMemoryDeviceGroupInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
            => if (!check_VkBindMemoryStatus(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindBufferMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindBufferMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindBufferMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryDeviceGroupInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindBufferMemoryDeviceGroupInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindBufferMemoryDeviceGroupInfoKHR(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryDeviceGroupInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindImageMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
            => if (!check_VkBindImageMemoryDeviceGroupInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
            => if (!check_VkBindImageMemorySwapchainInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
            => if (!check_VkBindImagePlaneMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
            => if (!check_VkBindMemoryStatus(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindImageMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemoryInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindImageMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryDeviceGroupInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemoryDeviceGroupInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindImageMemoryDeviceGroupInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemoryDeviceGroupInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceGroupRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupRenderPassBeginInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupRenderPassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceGroupRenderPassBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupRenderPassBeginInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceGroupCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupCommandBufferBeginInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupCommandBufferBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceGroupCommandBufferBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupCommandBufferBeginInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceGroupSubmitInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupSubmitInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceGroupSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupSubmitInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceGroupBindSparseInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupBindSparseInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupBindSparseInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceGroupBindSparseInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupBindSparseInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceGroupPresentCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, @ptrCast(&item.modes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupPresentCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageSwapchainCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindImageMemorySwapchainInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemorySwapchainInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemorySwapchainInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAcquireNextImageInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireNextImageInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAcquireNextImageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceGroupPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceGroupDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupDeviceCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupDeviceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceGroupDeviceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupDeviceCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceGroupSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupSwapchainCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, @ptrCast(&item.modes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorUpdateTemplateEntry(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateEntry, check_pnext: bool) bool {
    if (!check_enum_VkDescriptorType(extensions, @ptrCast(&item.descriptorType)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorUpdateTemplateEntryKHR(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateEntryKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorUpdateTemplateCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDescriptorUpdateTemplateType(extensions, @ptrCast(&item.templateType)))
        return false;
    if (!check_enum_VkPipelineBindPoint(extensions, @ptrCast(&item.pipelineBindPoint)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorUpdateTemplateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorUpdateTemplateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkXYColorEXT(extensions: *const Extensions, item: *const vk.VkXYColorEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePresentIdFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentIdFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentIdFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPresentIdKHR(extensions: *const Extensions, item: *const vk.VkPresentIdKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentIdKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePresentId2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentId2FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentId2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPresentId2KHR(extensions: *const Extensions, item: *const vk.VkPresentId2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentId2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPresentWait2InfoKHR(extensions: *const Extensions, item: *const vk.VkPresentWait2InfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentWait2InfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePresentWaitFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentWaitFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePresentWait2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentWait2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkHdrMetadataEXT(extensions: *const Extensions, item: *const vk.VkHdrMetadataEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkHdrVividDynamicMetadataHUAWEI(extensions: *const Extensions, item: *const vk.VkHdrVividDynamicMetadataHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHdrVividDynamicMetadataHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkIOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkIOSSurfaceCreateInfoMVK, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIOSSurfaceCreateInfoMVK: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMacOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkMacOSSurfaceCreateInfoMVK, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMacOSSurfaceCreateInfoMVK: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMetalSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMetalSurfaceCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMetalSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDiscardRectanglePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDiscardRectanglePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineDiscardRectangleStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDiscardRectangleModeEXT(extensions, @ptrCast(&item.discardRectangleMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDiscardRectangleStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkInputAttachmentAspectReference(extensions: *const Extensions, item: *const vk.VkInputAttachmentAspectReference, check_pnext: bool) bool {
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkInputAttachmentAspectReferenceKHR(extensions: *const Extensions, item: *const vk.VkInputAttachmentAspectReferenceKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassInputAttachmentAspectCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassInputAttachmentAspectCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassInputAttachmentAspectCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassInputAttachmentAspectCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassInputAttachmentAspectCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSurfaceInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSurfaceInfo2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            => if (!check_VkSurfaceFullScreenExclusiveInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            => if (!check_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
            => if (!check_VkSurfacePresentModeKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSurfaceInfo2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            => if (!check_VkSharedPresentSurfaceCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
            => if (!check_VkSurfaceProtectedCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            => if (!check_VkSurfaceCapabilitiesFullScreenExclusiveEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR,
            => if (!check_VkSurfaceCapabilitiesPresentId2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR,
            => if (!check_VkSurfaceCapabilitiesPresentWait2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR,
            => if (!check_VkSurfacePresentScalingCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
            => if (!check_VkSurfacePresentModeCompatibilityKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilities2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceFormat2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormat2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            => if (!check_VkImageCompressionPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFormat2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayProperties2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayPlaneProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneProperties2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayModeProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayModeProperties2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayModeProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayPlaneInfo2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneInfo2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneInfo2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDisplayPlaneCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilities2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneCapabilities2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSharedPresentSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSharedPresentSurfaceCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.sharedPresentSupportedUsageFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSharedPresentSurfaceCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevice16BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice16BitStorageFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice16BitStorageFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevice16BitStorageFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevice16BitStorageFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedStages)))
        return false;
    if (!check_bitmask_VkSubgroupFeatureFlagBits(extensions, @ptrCast(&item.supportedOperations)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkBufferMemoryRequirementsInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkBufferMemoryRequirementsInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceBufferMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceBufferMemoryRequirements, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceBufferMemoryRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceBufferMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkDeviceBufferMemoryRequirementsKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageMemoryRequirementsInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
            => if (!check_VkImagePlaneMemoryRequirementsInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkImageMemoryRequirementsInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageSparseMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageSparseMemoryRequirementsInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSparseMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageSparseMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkImageSparseMemoryRequirementsInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceImageMemoryRequirements, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.planeAspect)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceImageMemoryRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceImageMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkDeviceImageMemoryRequirementsKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkMemoryRequirements2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
            => if (!check_VkMemoryDedicatedRequirements(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryRequirements2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryRequirements2KHR(extensions: *const Extensions, item: *const vk.VkMemoryRequirements2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSparseImageMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSparseImageMemoryRequirements2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSparseImageMemoryRequirements2KHR(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePointClippingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePointClippingProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPointClippingBehavior(extensions, @ptrCast(&item.pointClippingBehavior)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePointClippingProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePointClippingPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePointClippingPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryDedicatedRequirements(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedRequirements, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryDedicatedRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryDedicatedRequirementsKHR(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedRequirementsKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryDedicatedAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryDedicatedAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryDedicatedAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageViewUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewUsageCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewUsageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageViewSlicedCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewSlicedCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewSlicedCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageViewUsageCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageViewUsageCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineTessellationDomainOriginStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkTessellationDomainOrigin(extensions, @ptrCast(&item.domainOrigin)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineTessellationDomainOriginStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineTessellationDomainOriginStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSamplerYcbcrConversionInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerYcbcrConversionInfoKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSamplerYcbcrConversionCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.ycbcrModel)))
        return false;
    if (!check_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.ycbcrRange)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.xChromaOffset)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.yChromaOffset)))
        return false;
    if (!check_enum_VkFilter(extensions, @ptrCast(&item.chromaFilter)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            => if (!check_VkExternalFormatQNX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerYcbcrConversionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindImagePlaneMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImagePlaneMemoryInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.planeAspect)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImagePlaneMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindImagePlaneMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImagePlaneMemoryInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImagePlaneMemoryRequirementsInfo(extensions: *const Extensions, item: *const vk.VkImagePlaneMemoryRequirementsInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.planeAspect)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImagePlaneMemoryRequirementsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImagePlaneMemoryRequirementsInfoKHR(extensions: *const Extensions, item: *const vk.VkImagePlaneMemoryRequirementsInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSamplerYcbcrConversionFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSamplerYcbcrConversionImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionImageFormatProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionImageFormatProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerYcbcrConversionImageFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionImageFormatPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkConditionalRenderingBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingBeginInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkConditionalRenderingFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkConditionalRenderingBeginInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkProtectedSubmitInfo(extensions: *const Extensions, item: *const vk.VkProtectedSubmitInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkProtectedSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceProtectedMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProtectedMemoryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceProtectedMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProtectedMemoryProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceQueueInfo2(extensions: *const Extensions, item: *const vk.VkDeviceQueueInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDeviceQueueCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSamplerFilterMinmaxProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSamplerFilterMinmaxProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSampleLocationEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSampleLocationsInfoEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationsInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleLocationsPerPixel)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSampleLocationsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAttachmentSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkAttachmentSampleLocationsEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkSubpassSampleLocationsEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassSampleLocationsBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSampleLocationsBeginInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassSampleLocationsBeginInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineSampleLocationsStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineSampleLocationsStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSampleLocationsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleLocationSampleCounts)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSampleLocationsPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMultisamplePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMultisamplePropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultisamplePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerReductionModeCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerReductionModeCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkSamplerReductionMode(extensions, @ptrCast(&item.reductionMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerReductionModeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerReductionModeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerReductionModeCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiDrawFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineColorBlendAdvancedStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkBlendOverlapEXT(extensions, @ptrCast(&item.blendOverlap)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorBlendAdvancedStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceInlineUniformBlockFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInlineUniformBlockFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceInlineUniformBlockProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInlineUniformBlockProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkWriteDescriptorSetInlineUniformBlock(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetInlineUniformBlock, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetInlineUniformBlock: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkWriteDescriptorSetInlineUniformBlockEXT(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetInlineUniformBlockEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorPoolInlineUniformBlockCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorPoolInlineUniformBlockCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageFormatListCreateInfo(extensions: *const Extensions, item: *const vk.VkImageFormatListCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.viewFormatCount) |i| {
        if (!check_enum_VkFormat(extensions, @ptrCast(&item.pViewFormats[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatListCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageFormatListCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageFormatListCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationCacheCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkShaderModuleValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleValidationCacheCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleValidationCacheCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance3Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance3Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance3Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance3PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance3PropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance4Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance4Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance4FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance4Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance4Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance4PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4PropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance5Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance5Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance5FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance5Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance5Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance5PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5PropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance6Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance6Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance6FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance6Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance6Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance6PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6PropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance7FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance7PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance7PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLayeredApiPropertiesListKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiPropertiesListKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLayeredApiPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPhysicalDeviceLayeredApiKHR(extensions, @ptrCast(&item.layeredAPI)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR,
            => if (!check_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiVulkanPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance8FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance9FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance9PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDefaultVertexAttributeValueKHR(extensions, @ptrCast(&item.defaultVertexAttributeValue)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance9PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueueFamilyOwnershipTransferPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyOwnershipTransferPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingAreaInfo(extensions: *const Extensions, item: *const vk.VkRenderingAreaInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.colorAttachmentCount) |i| {
        if (!check_enum_VkFormat(extensions, @ptrCast(&item.pColorAttachmentFormats[i])))
            return false;
    }
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.depthAttachmentFormat)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.stencilAttachmentFormat)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAreaInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingAreaInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAreaInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorSetLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutSupport, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
            => if (!check_VkDescriptorSetVariableDescriptorCountLayoutSupport(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutSupport: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetLayoutSupportKHR(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutSupportKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderDrawParametersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderDrawParametersFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderDrawParameterFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDrawParameterFeatures, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderFloat16Int8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat16Int8Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloat16Int8Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat16Int8FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceFloat16Int8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloat16Int8FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceFloatControlsProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloatControlsProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.denormBehaviorIndependence)))
        return false;
    if (!check_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.roundingModeIndependence)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFloatControlsProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFloatControlsPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloatControlsPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceHostQueryResetFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostQueryResetFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostQueryResetFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceHostQueryResetFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostQueryResetFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkNativeBufferUsage2ANDROID(extensions: *const Extensions, item: *const vk.VkNativeBufferUsage2ANDROID, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkNativeBufferANDROID(extensions: *const Extensions, item: *const vk.VkNativeBufferANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkNativeBufferANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSwapchainImageCreateInfoANDROID(extensions: *const Extensions, item: *const vk.VkSwapchainImageCreateInfoANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSwapchainImageUsageFlagBitsANDROID(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainImageCreateInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePresentationPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentationPropertiesANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentationPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceQueueGlobalPriorityCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkQueueGlobalPriority(extensions, @ptrCast(&item.globalPriority)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueGlobalPriorityCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceQueueGlobalPriorityCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceQueueGlobalPriorityCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGlobalPriorityQueryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkQueueFamilyGlobalPriorityProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.priorityCount) |i| {
        if (!check_enum_VkQueueGlobalPriority(extensions, @ptrCast(&item.priorities[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyGlobalPriorityProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueueFamilyGlobalPriorityPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkQueueFamilyGlobalPriorityPropertiesEXT(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDebugUtilsObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectNameInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsObjectNameInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugUtilsObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectTagInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsObjectTagInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugUtilsLabelEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsLabelEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsLabelEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugUtilsMessengerCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDebugUtilsMessageSeverityFlagBitsEXT(extensions, @ptrCast(&item.messageSeverity)))
        return false;
    if (!check_bitmask_VkDebugUtilsMessageTypeFlagBitsEXT(extensions, @ptrCast(&item.messageType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsMessengerCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDebugUtilsMessengerCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCallbackDataEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT,
            => if (!check_VkDeviceAddressBindingCallbackDataEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsMessengerCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceDeviceMemoryReportCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceDeviceMemoryReportCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceMemoryReportCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportCallbackDataEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDeviceMemoryReportEventTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceMemoryReportCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMemoryHostPointerInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryHostPointerInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, @ptrCast(&item.handleType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryHostPointerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryHostPointerPropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryHostPointerPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryHostPointerPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemoryHostPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceConservativeRasterizationPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCalibratedTimestampInfoKHR(extensions: *const Extensions, item: *const vk.VkCalibratedTimestampInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkTimeDomainKHR(extensions, @ptrCast(&item.timeDomain)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCalibratedTimestampInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCalibratedTimestampInfoEXT(extensions: *const Extensions, item: *const vk.VkCalibratedTimestampInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineRasterizationConservativeStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkConservativeRasterizationModeEXT(extensions, @ptrCast(&item.conservativeRasterizationMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationConservativeStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorIndexingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorIndexingFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorIndexingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorIndexingProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorSetLayoutBindingFlagsCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.bindingCount) |i| {
        if (!check_bitmask_VkDescriptorBindingFlagBits(extensions, @ptrCast(&item.pBindingFlags[i]))) 
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutBindingFlagsCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorSetVariableDescriptorCountAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetVariableDescriptorCountAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDescriptorSetVariableDescriptorCountLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetVariableDescriptorCountLayoutSupport: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAttachmentDescription2(extensions: *const Extensions, item: *const vk.VkAttachmentDescription2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkAttachmentDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.samples)))
        return false;
    if (!check_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.loadOp)))
        return false;
    if (!check_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.storeOp)))
        return false;
    if (!check_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.stencilLoadOp)))
        return false;
    if (!check_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.stencilStoreOp)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.initialLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.finalLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
            => if (!check_VkAttachmentDescriptionStencilLayout(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentDescription2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAttachmentDescription2KHR(extensions: *const Extensions, item: *const vk.VkAttachmentDescription2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAttachmentReference2(extensions: *const Extensions, item: *const vk.VkAttachmentReference2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.layout)))
        return false;
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.aspectMask)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
            => if (!check_VkAttachmentReferenceStencilLayout(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentReference2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAttachmentReference2KHR(extensions: *const Extensions, item: *const vk.VkAttachmentReference2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassDescription2(extensions: *const Extensions, item: *const vk.VkSubpassDescription2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSubpassDescriptionFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkPipelineBindPoint(extensions, @ptrCast(&item.pipelineBindPoint)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
            => if (!check_VkSubpassDescriptionDepthStencilResolve(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            => if (!check_VkFragmentShadingRateAttachmentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            => if (!check_VkMultisampledRenderToSingleSampledInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
            => if (!check_VkRenderPassCreationControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
            => if (!check_VkRenderPassSubpassFeedbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDescription2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubpassDescription2KHR(extensions: *const Extensions, item: *const vk.VkSubpassDescription2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassDependency2(extensions: *const Extensions, item: *const vk.VkSubpassDependency2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.srcStageMask)))
        return false;
    if (!check_bitmask_VkPipelineStageFlagBits(extensions, @ptrCast(&item.dstStageMask)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.srcAccessMask)))
        return false;
    if (!check_bitmask_VkAccessFlagBits(extensions, @ptrCast(&item.dstAccessMask)))
        return false;
    if (!check_bitmask_VkDependencyFlagBits(extensions, @ptrCast(&item.dependencyFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
            => if (!check_VkMemoryBarrier2(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!check_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDependency2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubpassDependency2KHR(extensions: *const Extensions, item: *const vk.VkSubpassDependency2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassCreateInfo2(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkRenderPassCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            => if (!check_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
            => if (!check_VkRenderPassCreationControlEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            => if (!check_VkRenderPassCreationFeedbackCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassCreateInfo2KHR(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassBeginInfo(extensions: *const Extensions, item: *const vk.VkSubpassBeginInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkSubpassContents(extensions, @ptrCast(&item.contents)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubpassBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkSubpassBeginInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassEndInfo(extensions: *const Extensions, item: *const vk.VkSubpassEndInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
            => if (!check_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassEndInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubpassEndInfoKHR(extensions: *const Extensions, item: *const vk.VkSubpassEndInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTimelineSemaphoreFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceTimelineSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTimelineSemaphoreProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceTimelineSemaphorePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphorePropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSemaphoreTypeCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreTypeCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkSemaphoreType(extensions, @ptrCast(&item.semaphoreType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreTypeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSemaphoreTypeCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreTypeCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkTimelineSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkTimelineSemaphoreSubmitInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTimelineSemaphoreSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkTimelineSemaphoreSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkTimelineSemaphoreSubmitInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSemaphoreWaitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSemaphoreWaitFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreWaitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSemaphoreWaitInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSemaphoreSignalInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSignalInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSignalInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSemaphoreSignalInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreSignalInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVertexInputBindingDivisorDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescription, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVertexInputBindingDivisorDescriptionKHR(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescriptionKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVertexInputBindingDivisorDescriptionEXT(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescriptionEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineVertexInputDivisorStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineVertexInputDivisorStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineVertexInputDivisorStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineVertexInputDivisorStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePCIBusInfoPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePCIBusInfoPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkImportAndroidHardwareBufferInfoANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportAndroidHardwareBufferInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAndroidHardwareBufferUsageANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferUsageANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferUsageANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAndroidHardwareBufferPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferPropertiesANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            => if (!check_VkAndroidHardwareBufferFormatPropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
            => if (!check_VkAndroidHardwareBufferFormatProperties2ANDROID(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID,
            => if (!check_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryGetAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkMemoryGetAndroidHardwareBufferInfoANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetAndroidHardwareBufferInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAndroidHardwareBufferFormatPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatPropertiesANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.formatFeatures)))
        return false;
    if (!check_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!check_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandBufferInheritanceConditionalRenderingInfoEXT(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceConditionalRenderingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevice8BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice8BitStorageFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice8BitStorageFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevice8BitStorageFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevice8BitStorageFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceConditionalRenderingFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanMemoryModelFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderAtomicInt64Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicInt64Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicInt64Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDepthStencilResolveProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthStencilResolveProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedDepthResolveModes)))
        return false;
    if (!check_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedStencilResolveModes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthStencilResolveProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDepthStencilResolvePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthStencilResolvePropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassDescriptionDepthStencilResolve(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionDepthStencilResolve, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.depthResolveMode)))
        return false;
    if (!check_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.stencilResolveMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDescriptionDepthStencilResolve: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubpassDescriptionDepthStencilResolveKHR(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionDepthStencilResolveKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageViewASTCDecodeModeEXT(extensions: *const Extensions, item: *const vk.VkImageViewASTCDecodeModeEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.decodeMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewASTCDecodeModeEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceASTCDecodeFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTransformFeedbackFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceTransformFeedbackPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTransformFeedbackPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRasterizationStateStreamCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateStreamCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMeshShaderPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDrawMeshTasksIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawMeshTasksIndirectCommandEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRayTracingShaderGroupCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkRayTracingShaderGroupTypeKHR(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingShaderGroupCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRayTracingPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPipelineCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
            => if (!check_VkPipelineCreateFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            => if (!check_VkPipelineBinaryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            => if (!check_VkPipelineCreationFeedbackCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            => if (!check_VkPipelineRobustnessCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkWriteDescriptorSetAccelerationStructureKHR(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetAccelerationStructureKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetAccelerationStructureKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAccelerationStructureFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPipelineFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRayQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayQueryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceAccelerationStructurePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAccelerationStructurePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPipelinePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkStridedDeviceAddressRegionKHR(extensions: *const Extensions, item: *const vk.VkStridedDeviceAddressRegionKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkTraceRaysIndirectCommandKHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommandKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkTraceRaysIndirectCommand2KHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommand2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDrmFormatModifierPropertiesListEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesListEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDrmFormatModifierPropertiesListEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesEXT, check_pnext: bool) bool {
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.drmFormatModifierTilingFeatures)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkSharingMode(extensions, @ptrCast(&item.sharingMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageDrmFormatModifierInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageDrmFormatModifierListCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierListCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierListCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageDrmFormatModifierExplicitCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierExplicitCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageStencilUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageStencilUsageCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.stencilUsage)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageStencilUsageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageStencilUsageCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageStencilUsageCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassFragmentDensityMapCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassFragmentDensityMapOffsetEndInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceScalarBlockLayoutFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSurfaceProtectedCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceProtectedCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceProtectedCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceUniformBufferStandardLayoutFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClipEnableFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRasterizationDepthClipStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationDepthClipStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMemoryBudgetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryBudgetPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryPriorityFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryPriorityAllocateInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryPriorityAllocateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryPriorityAllocateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBufferDeviceAddressFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceBufferDeviceAddressFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceBufferAddressFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferAddressFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferDeviceAddressInfo(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferDeviceAddressInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferDeviceAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferDeviceAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferOpaqueCaptureAddressCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferOpaqueCaptureAddressCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferOpaqueCaptureAddressCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferOpaqueCaptureAddressCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferOpaqueCaptureAddressCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferDeviceAddressCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferDeviceAddressCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageViewImageFormatInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageViewType(extensions, @ptrCast(&item.imageViewType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageViewImageFormatInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFilterCubicImageViewImageFormatPropertiesEXT(extensions: *const Extensions, item: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFilterCubicImageViewImageFormatPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImagelessFramebufferFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImagelessFramebufferFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImagelessFramebufferFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkFramebufferAttachmentsCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentsCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferAttachmentsCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFramebufferAttachmentsCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentsCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkFramebufferAttachmentImageInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentImageInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    for (0..item.viewFormatCount) |i| {
        if (!check_enum_VkFormat(extensions, @ptrCast(&item.pViewFormats[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferAttachmentImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFramebufferAttachmentImageInfoKHR(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentImageInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassAttachmentBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassAttachmentBeginInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassAttachmentBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassAttachmentBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassAttachmentBeginInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTextureCompressionASTCHDRFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineCreationFeedback(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedback, check_pnext: bool) bool {
    if (!check_bitmask_VkPipelineCreationFeedbackFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineCreationFeedbackEXT(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineCreationFeedbackCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreationFeedbackCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineCreationFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSurfaceFullScreenExclusiveInfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFullScreenExclusiveEXT(extensions, @ptrCast(&item.fullScreenExclusive)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFullScreenExclusiveInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveWin32InfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFullScreenExclusiveWin32InfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceCapabilitiesFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesFullScreenExclusiveEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesFullScreenExclusiveEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceQueryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePerformanceQueryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceQueryPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceCounterKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPerformanceCounterUnitKHR(extensions, @ptrCast(&item.unit)))
        return false;
    if (!check_enum_VkPerformanceCounterScopeKHR(extensions, @ptrCast(&item.scope)))
        return false;
    if (!check_enum_VkPerformanceCounterStorageKHR(extensions, @ptrCast(&item.storage)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceCounterDescriptionKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPerformanceCounterDescriptionFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterDescriptionKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueryPoolPerformanceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolPerformanceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAcquireProfilingLockInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkAcquireProfilingLockFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAcquireProfilingLockInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceQuerySubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQuerySubmitInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceQuerySubmitInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceQueryReservationInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQueryReservationInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceQueryReservationInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkHeadlessSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkHeadlessSurfaceCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHeadlessSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceValueINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueINTEL, check_pnext: bool) bool {
    if (!check_enum_VkPerformanceValueTypeINTEL(extensions, @ptrCast(&item.type)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkInitializePerformanceApiInfoINTEL(extensions: *const Extensions, item: *const vk.VkInitializePerformanceApiInfoINTEL, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkInitializePerformanceApiInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueryPoolPerformanceQueryCreateInfoINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkQueryPoolSamplingModeINTEL(extensions, @ptrCast(&item.performanceCountersSampling)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolPerformanceQueryCreateInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueryPoolCreateInfoINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateInfoINTEL, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPerformanceMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceMarkerInfoINTEL, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceMarkerInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceStreamMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceStreamMarkerInfoINTEL, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceStreamMarkerInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceOverrideInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideInfoINTEL, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPerformanceOverrideTypeINTEL(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceOverrideInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPerformanceConfigurationAcquireInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationAcquireInfoINTEL, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPerformanceConfigurationTypeINTEL(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceConfigurationAcquireInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderClockFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderClockFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceIndexTypeUint8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceIndexTypeUint8Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceIndexTypeUint8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAttachmentReferenceStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentReferenceStencilLayout, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.stencilLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentReferenceStencilLayout: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAttachmentReferenceStencilLayoutKHR(extensions: *const Extensions, item: *const vk.VkAttachmentReferenceStencilLayoutKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAttachmentDescriptionStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionStencilLayout, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.stencilInitialLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.stencilFinalLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentDescriptionStencilLayout: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAttachmentDescriptionStencilLayoutKHR(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionStencilLayoutKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineExecutablePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutablePropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stages)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutablePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineExecutableInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineExecutableStatisticKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPipelineExecutableStatisticFormatKHR(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableStatisticKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineExecutableInternalRepresentationKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInternalRepresentationKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableInternalRepresentationKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceTexelBufferAlignmentProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTexelBufferAlignmentProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupSizeControlFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.requiredSubgroupSizeStages)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupSizeControlProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkShaderRequiredSubgroupSizeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderRequiredSubgroupSizeCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubpassShadingPipelineCreateInfoHUAWEI(extensions: *const Extensions, item: *const vk.VkSubpassShadingPipelineCreateInfoHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassShadingPipelineCreateInfoHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryOpaqueCaptureAddressAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryOpaqueCaptureAddressAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryOpaqueCaptureAddressAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceMemoryOpaqueCaptureAddressInfo(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceMemoryOpaqueCaptureAddressInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceMemoryOpaqueCaptureAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLineRasterizationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLineRasterizationProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineRasterizationLineStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkLineRasterizationMode(extensions, @ptrCast(&item.lineRasterizationMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationLineStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRasterizationLineStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineRasterizationLineStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineCreationCacheControlFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceVulkan11Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan11Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkan11Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.subgroupSupportedStages)))
        return false;
    if (!check_bitmask_VkSubgroupFeatureFlagBits(extensions, @ptrCast(&item.subgroupSupportedOperations)))
        return false;
    if (!check_enum_VkPointClippingBehavior(extensions, @ptrCast(&item.pointClippingBehavior)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan11Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkan12Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan12Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkan12Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDriverId(extensions, @ptrCast(&item.driverID)))
        return false;
    if (!check_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.denormBehaviorIndependence)))
        return false;
    if (!check_enum_VkShaderFloatControlsIndependence(extensions, @ptrCast(&item.roundingModeIndependence)))
        return false;
    if (!check_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedDepthResolveModes)))
        return false;
    if (!check_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.supportedStencilResolveModes)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.framebufferIntegerColorSampleCounts)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan12Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkan13Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan13Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkan13Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.requiredSubgroupSizeStages)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan13Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkan14Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan14Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkan14Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessStorageBuffers)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessUniformBuffers)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessVertexInputs)))
        return false;
    if (!check_enum_VkPipelineRobustnessImageBehavior(extensions, @ptrCast(&item.defaultRobustnessImages)))
        return false;
    for (0..item.copySrcLayoutCount) |i| {
        if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.pCopySrcLayouts[i])))
            return false;
    }
    for (0..item.copyDstLayoutCount) |i| {
        if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.pCopyDstLayouts[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan14Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFaultData(extensions: *const Extensions, item: *const vk.VkFaultData, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFaultLevel(extensions, @ptrCast(&item.faultLevel)))
        return false;
    if (!check_enum_VkFaultType(extensions, @ptrCast(&item.faultType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFaultData: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFaultCallbackInfo(extensions: *const Extensions, item: *const vk.VkFaultCallbackInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFaultCallbackInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceToolProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceToolProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkToolPurposeFlagBits(extensions, @ptrCast(&item.purposes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceToolProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceToolPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceToolPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSamplerCustomBorderColorCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCustomBorderColorCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCustomBorderColorCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceCustomBorderColorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCustomBorderColorPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCustomBorderColorFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerBorderColorComponentMappingCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerBorderColorComponentMappingCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureGeometryTrianglesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.vertexFormat)))
        return false;
    if (!check_enum_VkIndexType(extensions, @ptrCast(&item.indexType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT,
            => if (!check_VkAccelerationStructureTrianglesOpacityMicromapEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryTrianglesDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureGeometryAabbsDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryAabbsDataKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryAabbsDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureGeometryInstancesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryInstancesDataKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryInstancesDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureGeometryKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkGeometryTypeKHR(extensions, @ptrCast(&item.geometryType)))
        return false;
    if (!check_bitmask_VkGeometryFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureBuildGeometryInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildGeometryInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkAccelerationStructureTypeKHR(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkBuildAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureBuildGeometryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureBuildRangeInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildRangeInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAccelerationStructureCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkAccelerationStructureCreateFlagBitsKHR(extensions, @ptrCast(&item.createFlags)))
        return false;
    if (!check_enum_VkAccelerationStructureTypeKHR(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            => if (!check_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAabbPositionsKHR(extensions: *const Extensions, item: *const vk.VkAabbPositionsKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkTransformMatrixKHR(extensions: *const Extensions, item: *const vk.VkTransformMatrixKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAccelerationStructureInstanceKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureInstanceKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAccelerationStructureDeviceAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureDeviceAddressInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureDeviceAddressInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureVersionInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureVersionInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureVersionInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkCopyAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyAccelerationStructureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyAccelerationStructureToMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkCopyAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyAccelerationStructureToMemoryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyMemoryToAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkCopyAccelerationStructureModeKHR(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToAccelerationStructureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRayTracingPipelineInterfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineInterfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineLibraryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineLibraryCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineLibraryCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRefreshObjectKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectKHR, check_pnext: bool) bool {
    if (!check_enum_VkObjectType(extensions, @ptrCast(&item.objectType)))
        return false;
    if (!check_bitmask_VkRefreshObjectFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkRefreshObjectListKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectListKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRefreshObjectListKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState3PropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkColorBlendEquationEXT(extensions: *const Extensions, item: *const vk.VkColorBlendEquationEXT, check_pnext: bool) bool {
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.srcColorBlendFactor)))
        return false;
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.dstColorBlendFactor)))
        return false;
    if (!check_enum_VkBlendOp(extensions, @ptrCast(&item.colorBlendOp)))
        return false;
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.srcAlphaBlendFactor)))
        return false;
    if (!check_enum_VkBlendFactor(extensions, @ptrCast(&item.dstAlphaBlendFactor)))
        return false;
    if (!check_enum_VkBlendOp(extensions, @ptrCast(&item.alphaBlendOp)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkColorBlendAdvancedEXT(extensions: *const Extensions, item: *const vk.VkColorBlendAdvancedEXT, check_pnext: bool) bool {
    if (!check_enum_VkBlendOp(extensions, @ptrCast(&item.advancedBlendOp)))
        return false;
    if (!check_enum_VkBlendOverlapEXT(extensions, @ptrCast(&item.blendOverlap)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRobustness2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRobustness2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRobustness2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2FeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceRobustness2PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRobustness2PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRobustness2PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2PropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceImageRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageRobustnessFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageRobustnessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageRobustnessFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePortabilitySubsetFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePortabilitySubsetPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePortabilitySubsetPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevice4444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice4444FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI,
            => if (!check_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCopy2(extensions: *const Extensions, item: *const vk.VkBufferCopy2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCopy2KHR(extensions: *const Extensions, item: *const vk.VkBufferCopy2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageCopy2(extensions: *const Extensions, item: *const vk.VkImageCopy2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageCopy2KHR(extensions: *const Extensions, item: *const vk.VkImageCopy2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageBlit2(extensions: *const Extensions, item: *const vk.VkImageBlit2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageBlit2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageBlit2KHR(extensions: *const Extensions, item: *const vk.VkImageBlit2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferImageCopy2(extensions: *const Extensions, item: *const vk.VkBufferImageCopy2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferImageCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferImageCopy2KHR(extensions: *const Extensions, item: *const vk.VkBufferImageCopy2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageResolve2(extensions: *const Extensions, item: *const vk.VkImageResolve2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageResolve2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageResolve2KHR(extensions: *const Extensions, item: *const vk.VkImageResolve2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCopyBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyBufferInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyBufferInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyBufferInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCopyImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyImageInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBlitImageInfo2(extensions: *const Extensions, item: *const vk.VkBlitImageInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!check_enum_VkFilter(extensions, @ptrCast(&item.filter)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBlitImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBlitImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkBlitImageInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCopyBufferToImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferToImageInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyBufferToImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyBufferToImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyBufferToImageInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCopyImageToBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageToBufferInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToBufferInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyImageToBufferInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyImageToBufferInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkResolveImageInfo2(extensions: *const Extensions, item: *const vk.VkResolveImageInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkResolveImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkResolveImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkResolveImageInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateAttachmentInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFragmentShadingRateAttachmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineFragmentShadingRateStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFragmentShadingRateCombinerOpKHR(extensions, @ptrCast(&item.combinerOps)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineFragmentShadingRateStateCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.maxFragmentShadingRateRasterizationSamples)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRatePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentShadingRateKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.sampleCounts)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTerminateInvocationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAccelerationStructureBuildSizesInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildSizesInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureBuildSizesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMutableDescriptorTypeListEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeListEXT, check_pnext: bool) bool {
    for (0..item.descriptorTypeCount) |i| {
        if (!check_enum_VkDescriptorType(extensions, @ptrCast(&item.pDescriptorTypes[i])))
            return false;
    }
    _ = check_pnext;
    return true;
}

pub fn check_VkMutableDescriptorTypeListVALVE(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeListVALVE, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMutableDescriptorTypeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMutableDescriptorTypeCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMutableDescriptorTypeCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeCreateInfoVALVE, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClipControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions, @ptrCast(&item.supportedIndirectCommandsInputModes)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedIndirectCommandsShaderStages)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedIndirectCommandsShaderStagesPipelineBinding)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.supportedIndirectCommandsShaderStagesShaderBinding)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkGeneratedCommandsPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsPipelineInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsPipelineInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkGeneratedCommandsShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsShaderInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsShaderInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkGeneratedCommandsMemoryRequirementsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
            => if (!check_VkGeneratedCommandsPipelineInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
            => if (!check_VkGeneratedCommandsShaderInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsMemoryRequirementsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkIndirectExecutionSetPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetPipelineInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetPipelineInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkIndirectExecutionSetShaderLayoutInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetShaderLayoutInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkIndirectExecutionSetShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetShaderInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkIndirectExecutionSetCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkIndirectExecutionSetInfoTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkGeneratedCommandsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.shaderStages)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
            => if (!check_VkGeneratedCommandsPipelineInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
            => if (!check_VkGeneratedCommandsShaderInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkWriteIndirectExecutionSetPipelineEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetPipelineEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteIndirectExecutionSetPipelineEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkWriteIndirectExecutionSetShaderEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetShaderEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteIndirectExecutionSetShaderEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkIndirectCommandsLayoutCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkIndirectCommandsLayoutUsageFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.shaderStages)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!check_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkIndirectCommandsLayoutTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutTokenEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkIndirectCommandsTokenTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutTokenEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDrawIndirectCountIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawIndirectCountIndirectCommandEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkIndirectCommandsVertexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsVertexBufferTokenEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindVertexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindVertexBufferIndirectCommandEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkIndirectCommandsIndexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsIndexBufferTokenEXT, check_pnext: bool) bool {
    if (!check_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions, @ptrCast(&item.mode)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindIndexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindIndexBufferIndirectCommandEXT, check_pnext: bool) bool {
    if (!check_enum_VkIndexType(extensions, @ptrCast(&item.indexType)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkIndirectCommandsPushConstantTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsPushConstantTokenEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkIndirectCommandsExecutionSetTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsExecutionSetTokenEXT, check_pnext: bool) bool {
    if (!check_enum_VkIndirectExecutionSetInfoTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.shaderStages)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineViewportDepthClipControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportDepthClipControlCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClampControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineViewportDepthClampControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDepthClampModeEXT(extensions, @ptrCast(&item.depthClampMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportDepthClampControlCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVertexInputBindingDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription2EXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkVertexInputRate(extensions, @ptrCast(&item.inputRate)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVertexInputBindingDescription2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVertexInputAttributeDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription2EXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVertexInputAttributeDescription2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceColorWriteEnableFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineColorWriteCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorWriteCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorWriteCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkMemoryBarrier2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkMemoryBarrier2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.oldLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.newLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
            => if (!check_VkSampleLocationsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!check_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!check_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBufferMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
            => if (!check_VkMemoryBarrierAccessFlags3KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            => if (!check_VkExternalMemoryAcquireUnmodifiedEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryBarrierAccessFlags3KHR(extensions: *const Extensions, item: *const vk.VkMemoryBarrierAccessFlags3KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrierAccessFlags3KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDependencyInfo(extensions: *const Extensions, item: *const vk.VkDependencyInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDependencyFlagBits(extensions, @ptrCast(&item.dependencyFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDependencyInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDependencyInfoKHR(extensions: *const Extensions, item: *const vk.VkDependencyInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSubmitInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSemaphoreSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreSubmitInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCommandBufferSubmitInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferSubmitInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandBufferSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkCommandBufferSubmitInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubmitInfo2(extensions: *const Extensions, item: *const vk.VkSubmitInfo2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSubmitFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            => if (!check_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            => if (!check_VkPerformanceQuerySubmitInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
            => if (!check_VkFrameBoundaryEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubmitInfo2KHR(extensions: *const Extensions, item: *const vk.VkSubmitInfo2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSynchronization2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSynchronization2Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSynchronization2Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSynchronization2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSynchronization2FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceHostImageCopyFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostImageCopyFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceHostImageCopyFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceHostImageCopyProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.copySrcLayoutCount) |i| {
        if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.pCopySrcLayouts[i])))
            return false;
    }
    for (0..item.copyDstLayoutCount) |i| {
        if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.pCopyDstLayouts[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostImageCopyProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceHostImageCopyPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryToImageCopy(extensions: *const Extensions, item: *const vk.VkMemoryToImageCopy, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryToImageCopy: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryToImageCopyEXT(extensions: *const Extensions, item: *const vk.VkMemoryToImageCopyEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageToMemoryCopy(extensions: *const Extensions, item: *const vk.VkImageToMemoryCopy, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageToMemoryCopy: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageToMemoryCopyEXT(extensions: *const Extensions, item: *const vk.VkImageToMemoryCopyEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCopyMemoryToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkHostImageCopyFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyMemoryToImageInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCopyImageToMemoryInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToMemoryInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkHostImageCopyFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyImageToMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyImageToMemoryInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCopyImageToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToImageInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkHostImageCopyFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.srcImageLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.dstImageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyImageToImageInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyImageToImageInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkHostImageLayoutTransitionInfo(extensions: *const Extensions, item: *const vk.VkHostImageLayoutTransitionInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.oldLayout)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.newLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHostImageLayoutTransitionInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkHostImageLayoutTransitionInfoEXT(extensions: *const Extensions, item: *const vk.VkHostImageLayoutTransitionInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubresourceHostMemcpySize(extensions: *const Extensions, item: *const vk.VkSubresourceHostMemcpySize, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubresourceHostMemcpySize: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubresourceHostMemcpySizeEXT(extensions: *const Extensions, item: *const vk.VkSubresourceHostMemcpySizeEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkHostImageCopyDevicePerformanceQuery(extensions: *const Extensions, item: *const vk.VkHostImageCopyDevicePerformanceQuery, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHostImageCopyDevicePerformanceQuery: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkHostImageCopyDevicePerformanceQueryEXT(extensions: *const Extensions, item: *const vk.VkHostImageCopyDevicePerformanceQueryEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceVulkanSC10Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Properties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanSC10Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelinePoolSize(extensions: *const Extensions, item: *const vk.VkPipelinePoolSize, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelinePoolSize: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceObjectReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceObjectReservationCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceObjectReservationCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandPoolMemoryReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryReservationCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolMemoryReservationCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandPoolMemoryConsumption(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryConsumption, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolMemoryConsumption: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVulkanSC10Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanSC10Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyDitheringFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceCapabilitiesPresentId2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentId2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesPresentId2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceCapabilitiesPresentWait2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentWait2KHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesPresentWait2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubpassResolvePerformanceQueryEXT(extensions: *const Extensions, item: *const vk.VkSubpassResolvePerformanceQueryEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassResolvePerformanceQueryEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMultisampledRenderToSingleSampledInfoEXT(extensions: *const Extensions, item: *const vk.VkMultisampledRenderToSingleSampledInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.rasterizationSamples)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultisampledRenderToSingleSampledInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineProtectedAccessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkQueueFamilyVideoPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyVideoPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions, @ptrCast(&item.videoCodecOperations)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyVideoPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueueFamilyQueryResultStatusPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyQueryResultStatusPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoProfileListInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileListInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoProfileListInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoFormatInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoFormatInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.imageUsage)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            => if (!check_VkVideoProfileListInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoFormatInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_bitmask_VkImageCreateFlagBits(extensions, @ptrCast(&item.imageCreateFlags)))
        return false;
    if (!check_enum_VkImageType(extensions, @ptrCast(&item.imageType)))
        return false;
    if (!check_enum_VkImageTiling(extensions, @ptrCast(&item.imageTiling)))
        return false;
    if (!check_bitmask_VkImageUsageFlagBits(extensions, @ptrCast(&item.imageUsageFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR,
            => if (!check_VkVideoFormatQuantizationMapPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR,
            => if (!check_VkVideoFormatH265QuantizationMapPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR,
            => if (!check_VkVideoFormatAV1QuantizationMapPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeQuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QuantizationMapCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QuantizationMapCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoFormatQuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatQuantizationMapPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatQuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoFormatH265QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatH265QuantizationMapPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions, @ptrCast(&item.compatibleCtbSizes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatH265QuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoFormatAV1QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatAV1QuantizationMapPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions, @ptrCast(&item.compatibleSuperblockSizes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatAV1QuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions, @ptrCast(&item.videoCodecOperation)))
        return false;
    if (!check_bitmask_VkVideoChromaSubsamplingFlagBitsKHR(extensions, @ptrCast(&item.chromaSubsampling)))
        return false;
    if (!check_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions, @ptrCast(&item.lumaBitDepth)))
        return false;
    if (!check_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions, @ptrCast(&item.chromaBitDepth)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            => if (!check_VkVideoDecodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeVP9ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
            => if (!check_VkVideoDecodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
            => if (!check_VkVideoEncodeUsageInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
            => if (!check_VkVideoEncodeH264ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
            => if (!check_VkVideoEncodeH265ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
            => if (!check_VkVideoEncodeAV1ProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoCapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeQuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
            => if (!check_VkVideoDecodeCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR,
            => if (!check_VkVideoDecodeH264CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR,
            => if (!check_VkVideoDecodeH265CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR,
            => if (!check_VkVideoDecodeVP9CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR,
            => if (!check_VkVideoDecodeAV1CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeH264CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeH265CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeAV1CapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR,
            => if (!check_VkVideoEncodeIntraRefreshCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoSessionMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionMemoryRequirementsKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionMemoryRequirementsKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindVideoSessionMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindVideoSessionMemoryInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindVideoSessionMemoryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoPictureResourceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoPictureResourceInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoPictureResourceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoReferenceSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceSlotInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
            => if (!check_VkVideoDecodeH264DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR,
            => if (!check_VkVideoDecodeH265DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,
            => if (!check_VkVideoDecodeAV1DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
            => if (!check_VkVideoEncodeH264DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR,
            => if (!check_VkVideoEncodeH265DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
            => if (!check_VkVideoEncodeAV1DpbSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR,
            => if (!check_VkVideoReferenceIntraRefreshInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoReferenceSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoDecodeCapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoDecodeUsageFlagBitsKHR(extensions, @ptrCast(&item.videoUsageHints)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeUsageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
            => if (!check_VkVideoInlineQueryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR,
            => if (!check_VkVideoDecodeH264InlineSessionParametersInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR,
            => if (!check_VkVideoDecodeH264PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR,
            => if (!check_VkVideoDecodeH265InlineSessionParametersInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR,
            => if (!check_VkVideoDecodeH265PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR,
            => if (!check_VkVideoDecodeVP9PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR,
            => if (!check_VkVideoDecodeAV1InlineSessionParametersInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR,
            => if (!check_VkVideoDecodeAV1PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoMaintenance2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoInlineQueryInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoInlineQueryInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoInlineQueryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264ProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoDecodeH264PictureLayoutFlagBitsKHR(extensions, @ptrCast(&item.pictureLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264CapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersAddInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH264InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264InlineSessionParametersInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264DpbSlotInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265ProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265CapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersAddInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH265InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265InlineSessionParametersInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265PictureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265DpbSlotInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoDecodeVP9FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeVP9ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9ProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeVP9CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9CapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeVP9PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9PictureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1ProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1CapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1SessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeAV1InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1InlineSessionParametersInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1PictureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoDecodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1DpbSlotInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoSessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoSessionCreateFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.pictureFormat)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.referencePictureFormat)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeH264SessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeH265SessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeAV1SessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoSessionParametersCreateFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!check_VkVideoDecodeH264SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!check_VkVideoDecodeH265SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!check_VkVideoDecodeAV1SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            => if (!check_VkVideoEncodeQualityLevelInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeH264SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeH265SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!check_VkVideoEncodeAV1SessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoSessionParametersUpdateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersUpdateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!check_VkVideoDecodeH264SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!check_VkVideoDecodeH265SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!check_VkVideoEncodeH264SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
            => if (!check_VkVideoEncodeH265SessionParametersAddInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersUpdateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeSessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersGetInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR,
            => if (!check_VkVideoEncodeH264SessionParametersGetInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR,
            => if (!check_VkVideoEncodeH265SessionParametersGetInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeSessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            => if (!check_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            => if (!check_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoBeginCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoBeginCodingInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeRateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeH264RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR,
            => if (!check_VkVideoEncodeH264GopRemainingFrameInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeH265RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR,
            => if (!check_VkVideoEncodeH265GopRemainingFrameInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeAV1RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR,
            => if (!check_VkVideoEncodeAV1GopRemainingFrameInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoBeginCodingInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEndCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEndCodingInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEndCodingInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoCodingControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoCodingControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            => if (!check_VkVideoEncodeQualityLevelInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeRateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeH264RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeH265RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
            => if (!check_VkVideoEncodeAV1RateControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoCodingControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeUsageFlagBitsKHR(extensions, @ptrCast(&item.videoUsageHints)))
        return false;
    if (!check_bitmask_VkVideoEncodeContentFlagBitsKHR(extensions, @ptrCast(&item.videoContentHints)))
        return false;
    if (!check_enum_VkVideoEncodeTuningModeKHR(extensions, @ptrCast(&item.tuningMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeUsageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
            => if (!check_VkVideoInlineQueryInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
            => if (!check_VkVideoEncodeQuantizationMapInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
            => if (!check_VkVideoEncodeH264PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR,
            => if (!check_VkVideoEncodeH265PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
            => if (!check_VkVideoEncodeAV1PictureInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR,
            => if (!check_VkVideoEncodeIntraRefreshInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeQuantizationMapInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions, @ptrCast(&item.encodeFeedbackFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolVideoEncodeFeedbackCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQualityLevelInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeQualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!check_VkVideoEncodeH264QualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!check_VkVideoEncodeH265QualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!check_VkVideoEncodeAV1QualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeRateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, @ptrCast(&item.rateControlMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeRateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlLayerInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!check_VkVideoEncodeH264RateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!check_VkVideoEncodeH265RateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!check_VkVideoEncodeAV1RateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeCapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, @ptrCast(&item.rateControlModes)))
        return false;
    if (!check_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions, @ptrCast(&item.supportedEncodeFeedbackFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeH264CapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkVideoEncodeH264StdFlagBitsKHR(extensions, @ptrCast(&item.stdSyntaxFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QualityLevelPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersAddInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersGetInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersFeedbackInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264DpbSlotInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264PictureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264ProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264NaluSliceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264NaluSliceInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264NaluSliceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QpKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVideoEncodeH264FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264FrameSizeKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVideoEncodeH264GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264GopRemainingFrameInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH264RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlLayerInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeH265CapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions, @ptrCast(&item.ctbSizes)))
        return false;
    if (!check_bitmask_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(extensions, @ptrCast(&item.transformBlockSizes)))
        return false;
    if (!check_bitmask_VkVideoEncodeH265StdFlagBitsKHR(extensions, @ptrCast(&item.stdSyntaxFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QualityLevelPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersAddInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersGetInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersFeedbackInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265PictureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265NaluSliceSegmentInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265NaluSliceSegmentInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265NaluSliceSegmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QpKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVideoEncodeH265FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265FrameSizeKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVideoEncodeH265GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265GopRemainingFrameInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlLayerInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265ProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265DpbSlotInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeAV1CapabilityFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions, @ptrCast(&item.superblockSizes)))
        return false;
    if (!check_bitmask_VkVideoEncodeAV1StdFlagBitsKHR(extensions, @ptrCast(&item.stdSyntaxFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QualityLevelPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions, @ptrCast(&item.preferredRateControlFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeAV1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionParametersCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1DpbSlotInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PictureInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkVideoEncodeAV1PredictionModeKHR(extensions, @ptrCast(&item.predictionMode)))
        return false;
    if (!check_enum_VkVideoEncodeAV1RateControlGroupKHR(extensions, @ptrCast(&item.rateControlGroup)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1ProfileInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1QIndexKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QIndexKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVideoEncodeAV1FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1FrameSizeKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkVideoEncodeAV1GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1GopRemainingFrameInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeAV1RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlLayerInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProvokingVertexFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceProvokingVertexPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProvokingVertexPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkProvokingVertexModeEXT(extensions, @ptrCast(&item.provokingVertexMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeIntraRefreshCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions, @ptrCast(&item.intraRefreshModes)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeIntraRefreshCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions, @ptrCast(&item.intraRefreshMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionIntraRefreshCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoEncodeIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeIntraRefreshInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkVideoReferenceIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceIntraRefreshInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoReferenceIntraRefreshInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorAddressInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorAddressInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorBufferBindingInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkBufferUsageFlagBits(extensions, @ptrCast(&item.usage)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
            => if (!check_VkBufferUsageFlags2CreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT,
            => if (!check_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorBufferBindingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorGetInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorGetInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDescriptorType(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorGetInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferCaptureDescriptorDataInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageCaptureDescriptorDataInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageViewCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewCaptureDescriptorDataInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSamplerCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCaptureDescriptorDataInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpaqueCaptureDescriptorDataCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerDotProductFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerDotProductProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDrmPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDrmPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDrmPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMemoryBufferCollectionFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryBufferCollectionFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryBufferCollectionFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCollectionImageCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionImageCreateInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionImageCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCollectionBufferCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionBufferCreateInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionBufferCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCollectionCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionCreateInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCollectionPropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionPropertiesFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.formatFeatures)))
        return false;
    if (!check_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!check_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionPropertiesFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferConstraintsInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.requiredFormatFeatures)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSysmemColorSpaceFUCHSIA(extensions: *const Extensions, item: *const vk.VkSysmemColorSpaceFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSysmemColorSpaceFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageFormatConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.requiredFormatFeatures)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageConstraintsInfoFlagBitsFUCHSIA(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBufferCollectionConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionConstraintsInfoFUCHSIA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFormatProperties3(extensions: *const Extensions, item: *const vk.VkFormatProperties3, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFormatProperties3: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFormatProperties3KHR(extensions: *const Extensions, item: *const vk.VkFormatProperties3KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDrmFormatModifierPropertiesList2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesList2EXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDrmFormatModifierPropertiesList2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDrmFormatModifierProperties2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierProperties2EXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAndroidHardwareBufferFormatProperties2ANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatProperties2ANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!check_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatProperties2ANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRenderingCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRenderingCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.colorAttachmentCount) |i| {
        if (!check_enum_VkFormat(extensions, @ptrCast(&item.pColorAttachmentFormats[i])))
            return false;
    }
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.depthAttachmentFormat)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.stencilAttachmentFormat)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRenderingCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRenderingCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineRenderingCreateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderingInfo(extensions: *const Extensions, item: *const vk.VkRenderingInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkRenderingFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            => if (!check_VkDeviceGroupRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            => if (!check_VkMultisampledRenderToSingleSampledInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            => if (!check_VkRenderingFragmentShadingRateAttachmentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            => if (!check_VkRenderingFragmentDensityMapAttachmentInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderingEndInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderingEndInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
            => if (!check_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingEndInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingAttachmentInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    if (!check_bitmask_VkResolveModeFlagBits(extensions, @ptrCast(&item.resolveMode)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.resolveImageLayout)))
        return false;
    if (!check_enum_VkAttachmentLoadOp(extensions, @ptrCast(&item.loadOp)))
        return false;
    if (!check_enum_VkAttachmentStoreOp(extensions, @ptrCast(&item.storeOp)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT,
            => if (!check_VkAttachmentFeedbackLoopInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderingFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingFragmentShadingRateAttachmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingFragmentDensityMapAttachmentInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkImageLayout(extensions, @ptrCast(&item.imageLayout)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingFragmentDensityMapAttachmentInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDynamicRenderingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDynamicRenderingFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkCommandBufferInheritanceRenderingInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderingInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkRenderingFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    for (0..item.colorAttachmentCount) |i| {
        if (!check_enum_VkFormat(extensions, @ptrCast(&item.pColorAttachmentFormats[i])))
            return false;
    }
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.depthAttachmentFormat)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.stencilAttachmentFormat)))
        return false;
    if (!check_bitmask_VkSampleCountFlagBits(extensions, @ptrCast(&item.rasterizationSamples)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceRenderingInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCommandBufferInheritanceRenderingInfoKHR(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderingInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewMinLodFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageViewMinLodFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageViewMinLodCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewMinLodCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewMinLodCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineBinaryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDevicePipelineBinaryInternalCacheControlKHR(extensions: *const Extensions, item: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDevicePipelineBinaryInternalCacheControlKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineBinaryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineBinaryPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkGraphicsPipelineLibraryCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkGraphicsPipelineLibraryFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineLibraryCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetBindingReferenceVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetBindingReferenceVALVE, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetBindingReferenceVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDescriptorSetLayoutHostMappingInfoVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutHostMappingInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNestedCommandBufferFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNestedCommandBufferPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageModuleIdentifierCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkShaderModuleIdentifierEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleIdentifierEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleIdentifierEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageCompressionControlEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionControlEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageCompressionFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    for (0..item.compressionControlPlaneCount) |i| {
        if (!check_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions, @ptrCast(&item.pFixedRateFlags[i]))) 
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCompressionControlEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageCompressionControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageCompressionPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageCompressionFlagBitsEXT(extensions, @ptrCast(&item.imageCompressionFlags)))
        return false;
    if (!check_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions, @ptrCast(&item.imageCompressionFixedRateFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCompressionPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageSubresource2(extensions: *const Extensions, item: *const vk.VkImageSubresource2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSubresource2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageSubresource2KHR(extensions: *const Extensions, item: *const vk.VkImageSubresource2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkImageSubresource2EXT(extensions: *const Extensions, item: *const vk.VkImageSubresource2EXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubresourceLayout2(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
            => if (!check_VkSubresourceHostMemcpySize(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            => if (!check_VkImageCompressionPropertiesEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubresourceLayout2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSubresourceLayout2KHR(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2KHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSubresourceLayout2EXT(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2EXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassCreationControlEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationControlEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreationControlEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassCreationFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassCreationFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreationFeedbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderPassSubpassFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkSubpassMergeStatusEXT(extensions, @ptrCast(&item.subpassMergeStatus)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderPassSubpassFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassSubpassFeedbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMicromapBuildInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkMicromapTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_bitmask_VkBuildMicromapFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkBuildMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapBuildInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMicromapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkMicromapCreateFlagBitsEXT(extensions, @ptrCast(&item.createFlags)))
        return false;
    if (!check_enum_VkMicromapTypeEXT(extensions, @ptrCast(&item.type)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMicromapVersionInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapVersionInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapVersionInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkCopyMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMicromapInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyMicromapToMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapToMemoryInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkCopyMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMicromapToMemoryInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCopyMemoryToMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMemoryToMicromapInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkCopyMicromapModeEXT(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToMicromapInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMicromapBuildSizesInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildSizesInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapBuildSizesInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMicromapUsageEXT(extensions: *const Extensions, item: *const vk.VkMicromapUsageEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMicromapTriangleEXT(extensions: *const Extensions, item: *const vk.VkMicromapTriangleEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpacityMicromapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceOpacityMicromapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpacityMicromapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAccelerationStructureTrianglesOpacityMicromapEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkIndexType(extensions, @ptrCast(&item.indexType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureTrianglesOpacityMicromapEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelinePropertiesIdentifierEXT(extensions: *const Extensions, item: *const vk.VkPipelinePropertiesIdentifierEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelinePropertiesIdentifierEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelinePropertiesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalMemoryAcquireUnmodifiedEXT(extensions: *const Extensions, item: *const vk.VkExternalMemoryAcquireUnmodifiedEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryAcquireUnmodifiedEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalObjectCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkExportMetalObjectTypeFlagBitsEXT(extensions, @ptrCast(&item.exportObjectType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalObjectCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalObjectsInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectsInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT,
            => if (!check_VkExportMetalDeviceInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
            => if (!check_VkExportMetalCommandQueueInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT,
            => if (!check_VkExportMetalBufferInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT,
            => if (!check_VkExportMetalTextureInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT,
            => if (!check_VkExportMetalIOSurfaceInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT,
            => if (!check_VkExportMetalSharedEventInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalObjectsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalDeviceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalDeviceInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalDeviceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalCommandQueueInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalCommandQueueInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalCommandQueueInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalBufferInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalBufferInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalBufferInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalBufferInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalTextureInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.plane)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalTextureInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalTextureInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkImageAspectFlagBits(extensions, @ptrCast(&item.plane)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalTextureInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalIOSurfaceInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalIOSurfaceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalIOSurfaceInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalIOSurfaceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalSharedEventInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalSharedEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalSharedEventInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalSharedEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineRobustnessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPipelineRobustnessCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessCreateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.storageBuffers)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.uniformBuffers)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.vertexInputs)))
        return false;
    if (!check_enum_VkPipelineRobustnessImageBehavior(extensions, @ptrCast(&item.images)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRobustnessCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineRobustnessCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePipelineRobustnessProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessProperties, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessStorageBuffers)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessUniformBuffers)))
        return false;
    if (!check_enum_VkPipelineRobustnessBufferBehavior(extensions, @ptrCast(&item.defaultRobustnessVertexInputs)))
        return false;
    if (!check_enum_VkPipelineRobustnessImageBehavior(extensions, @ptrCast(&item.defaultRobustnessImages)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineRobustnessProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePipelineRobustnessPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessPropertiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkAttachmentFeedbackLoopInfoEXT(extensions: *const Extensions, item: *const vk.VkAttachmentFeedbackLoopInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentFeedbackLoopInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAddressBindingReportFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceAddressBindingCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingCallbackDataEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkDeviceAddressBindingFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_enum_VkDeviceAddressBindingTypeEXT(extensions, @ptrCast(&item.bindingType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceAddressBindingCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFaultFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFaultFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFaultFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceFaultAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkDeviceFaultAddressTypeEXT(extensions, @ptrCast(&item.addressType)))
        return false;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceFaultVendorInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkDeviceFaultCountsEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultCountsEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceFaultCountsEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceFaultInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceFaultInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionOneEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDepthBiasInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
            => if (!check_VkDepthBiasRepresentationInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDepthBiasInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDepthBiasRepresentationInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDepthBiasRepresentationEXT(extensions, @ptrCast(&item.depthBiasRepresentation)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDepthBiasRepresentationInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkFrameBoundaryEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkFrameBoundaryFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFrameBoundaryEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFrameBoundaryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfacePresentModeKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkPresentModeKHR(extensions, @ptrCast(&item.presentMode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentModeKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfacePresentModeEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSurfacePresentScalingCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentScalingCapabilitiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPresentScalingFlagBitsKHR(extensions, @ptrCast(&item.supportedPresentScaling)))
        return false;
    if (!check_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.supportedPresentGravityX)))
        return false;
    if (!check_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.supportedPresentGravityY)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentScalingCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfacePresentScalingCapabilitiesEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentScalingCapabilitiesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSurfacePresentModeCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeCompatibilityKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.presentModeCount) |i| {
        if (!check_enum_VkPresentModeKHR(extensions, @ptrCast(&item.pPresentModes[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentModeCompatibilityKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfacePresentModeCompatibilityEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeCompatibilityEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSwapchainPresentFenceInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentFenceInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentFenceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSwapchainPresentFenceInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentFenceInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSwapchainPresentModesCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModesCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentModesCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSwapchainPresentModesCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModesCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSwapchainPresentModeInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModeInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    for (0..item.swapchainCount) |i| {
        if (!check_enum_VkPresentModeKHR(extensions, @ptrCast(&item.pPresentModes[i])))
            return false;
    }
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentModeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSwapchainPresentModeInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModeInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSwapchainPresentScalingCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentScalingCreateInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkPresentScalingFlagBitsKHR(extensions, @ptrCast(&item.scalingBehavior)))
        return false;
    if (!check_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.presentGravityX)))
        return false;
    if (!check_bitmask_VkPresentGravityFlagBitsKHR(extensions, @ptrCast(&item.presentGravityY)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentScalingCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSwapchainPresentScalingCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentScalingCreateInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkReleaseSwapchainImagesInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseSwapchainImagesInfoKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkReleaseSwapchainImagesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkReleaseSwapchainImagesInfoEXT(extensions: *const Extensions, item: *const vk.VkReleaseSwapchainImagesInfoEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthBiasControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDirectDriverLoadingInfoLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingInfoLUNARG, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectDriverLoadingInfoLUNARG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDirectDriverLoadingListLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingListLUNARG, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkDirectDriverLoadingModeLUNARG(extensions, @ptrCast(&item.mode)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectDriverLoadingListLUNARG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceImageSubresourceInfo(extensions: *const Extensions, item: *const vk.VkDeviceImageSubresourceInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceImageSubresourceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDeviceImageSubresourceInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceImageSubresourceInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryMapInfo(extensions: *const Extensions, item: *const vk.VkMemoryMapInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkMemoryMapFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
            => if (!check_VkMemoryMapPlacedInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMapInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryMapInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryMapInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkMemoryUnmapInfo(extensions: *const Extensions, item: *const vk.VkMemoryUnmapInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkMemoryUnmapFlagBits(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryUnmapInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryUnmapInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryUnmapInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderObjectFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderObjectPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderObjectPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkShaderCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderCreateFlagBitsEXT(extensions, @ptrCast(&item.flags)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stage)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.nextStage)))
        return false;
    if (!check_enum_VkShaderCodeTypeEXT(extensions, @ptrCast(&item.codeType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
            => if (!check_VkValidationFeaturesEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            => if (!check_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTileImageFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderTileImagePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTileImagePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImportScreenBufferInfoQNX(extensions: *const Extensions, item: *const vk.VkImportScreenBufferInfoQNX, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportScreenBufferInfoQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkScreenBufferPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferPropertiesQNX, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX,
            => if (!check_VkScreenBufferFormatPropertiesQNX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenBufferPropertiesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkScreenBufferFormatPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferFormatPropertiesQNX, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.format)))
        return false;
    if (!check_bitmask_VkFormatFeatureFlagBits(extensions, @ptrCast(&item.formatFeatures)))
        return false;
    if (!check_enum_VkSamplerYcbcrModelConversion(extensions, @ptrCast(&item.suggestedYcbcrModel)))
        return false;
    if (!check_enum_VkSamplerYcbcrRange(extensions, @ptrCast(&item.suggestedYcbcrRange)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedXChromaOffset)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.suggestedYChromaOffset)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenBufferFormatPropertiesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkExternalFormatQNX(extensions: *const Extensions, item: *const vk.VkExternalFormatQNX, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFormatQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.AType)))
        return false;
    if (!check_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.BType)))
        return false;
    if (!check_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.CType)))
        return false;
    if (!check_enum_VkComponentTypeKHR(extensions, @ptrCast(&item.ResultType)))
        return false;
    if (!check_enum_VkScopeKHR(extensions, @ptrCast(&item.scope)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCooperativeMatrixPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.cooperativeMatrixSupportedStages)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindMemoryStatus(extensions: *const Extensions, item: *const vk.VkBindMemoryStatus, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkResult(extensions, @ptrCast(&item.pResult)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindMemoryStatus: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindMemoryStatusKHR(extensions: *const Extensions, item: *const vk.VkBindMemoryStatusKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkBindDescriptorSetsInfo(extensions: *const Extensions, item: *const vk.VkBindDescriptorSetsInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!check_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorSetsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindDescriptorSetsInfoKHR(extensions: *const Extensions, item: *const vk.VkBindDescriptorSetsInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPushConstantsInfo(extensions: *const Extensions, item: *const vk.VkPushConstantsInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!check_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushConstantsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPushConstantsInfoKHR(extensions: *const Extensions, item: *const vk.VkPushConstantsInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPushDescriptorSetInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!check_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPushDescriptorSetInfoKHR(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPushDescriptorSetWithTemplateInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetWithTemplateInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!check_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetWithTemplateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPushDescriptorSetWithTemplateInfoKHR(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetWithTemplateInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkSetDescriptorBufferOffsetsInfoEXT(extensions: *const Extensions, item: *const vk.VkSetDescriptorBufferOffsetsInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!check_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSetDescriptorBufferOffsetsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(extensions: *const Extensions, item: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_bitmask_VkShaderStageFlagBits(extensions, @ptrCast(&item.stageFlags)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            => if (!check_VkPipelineLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorBufferEmbeddedSamplersInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceLayeredDriverPropertiesMSFT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkLayeredDriverUnderlyingApiMSFT(extensions, @ptrCast(&item.underlyingAPI)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredDriverPropertiesMSFT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFormatResolveFeaturesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.externalFormatResolveChromaOffsetX)))
        return false;
    if (!check_enum_VkChromaLocation(extensions, @ptrCast(&item.externalFormatResolveChromaOffsetY)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFormatResolvePropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatResolvePropertiesANDROID, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_enum_VkFormat(extensions, @ptrCast(&item.colorAttachmentFormat)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatResolvePropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupRotateFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderExpectAssumeFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderExpectAssumeFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderFloatControls2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloatControls2Features, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloatControls2Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderFloatControls2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloatControls2FeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingLocalReadFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderingAttachmentLocationInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentLocationInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentLocationInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingAttachmentLocationInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentLocationInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkRenderingInputAttachmentIndexInfo(extensions: *const Extensions, item: *const vk.VkRenderingInputAttachmentIndexInfo, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingInputAttachmentIndexInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkRenderingInputAttachmentIndexInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingInputAttachmentIndexInfoKHR, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderQuadControlFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMapMemoryPlacedFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMapMemoryPlacedPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkMemoryMapPlacedInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryMapPlacedInfoEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMapPlacedInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderBfloat16FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageAlignmentControlFeaturesMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageAlignmentControlPropertiesMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkImageAlignmentControlCreateInfoMESA(extensions: *const Extensions, item: *const vk.VkImageAlignmentControlCreateInfoMESA, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageAlignmentControlCreateInfoMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkDepthClampRangeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampRangeEXT, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHdrVividFeaturesHUAWEI, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHdrVividFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClampZeroOneFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineFragmentDensityMapLayeredCreateInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloat8FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkOHSurfaceCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkOHSurfaceCreateInfoOHOS, check_pnext: bool) bool {
    if (!check_enum_VkStructureType(extensions, @ptrCast(&item.sType)))
        return false;
    if (!check_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOHSurfaceCreateInfoOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn check_VkSurfaceCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkSurfaceCreateInfoOHOS, check_pnext: bool) bool {
    _ = extensions;
    _ = item;
    _ = check_pnext;
    return true;
}

pub fn check_enum_VkImageLayout(extensions: *const Extensions, item: *const vk.VkImageLayout) bool {
    const min = @min(
        vk.VK_IMAGE_LAYOUT_UNDEFINED,
        vk.VK_IMAGE_LAYOUT_GENERAL,
        vk.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_PREINITIALIZED,
    );
    const max = @max(
        vk.VK_IMAGE_LAYOUT_UNDEFINED,
        vk.VK_IMAGE_LAYOUT_GENERAL,
        vk.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_PREINITIALIZED,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == vk.VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == vk.VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT)
        return true;
    return false;
}

pub fn check_enum_VkAttachmentLoadOp(extensions: *const Extensions, item: *const vk.VkAttachmentLoadOp) bool {
    const min = @min(
        vk.VK_ATTACHMENT_LOAD_OP_LOAD,
        vk.VK_ATTACHMENT_LOAD_OP_CLEAR,
        vk.VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    );
    const max = @max(
        vk.VK_ATTACHMENT_LOAD_OP_LOAD,
        vk.VK_ATTACHMENT_LOAD_OP_CLEAR,
        vk.VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_load_store_op_none and item.* == vk.VK_ATTACHMENT_LOAD_OP_NONE_EXT)
        return true;
    if (extensions.device.VK_KHR_load_store_op_none and item.* == vk.VK_ATTACHMENT_LOAD_OP_NONE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkAttachmentStoreOp(extensions: *const Extensions, item: *const vk.VkAttachmentStoreOp) bool {
    const min = @min(
        vk.VK_ATTACHMENT_STORE_OP_STORE,
        vk.VK_ATTACHMENT_STORE_OP_DONT_CARE,
    );
    const max = @max(
        vk.VK_ATTACHMENT_STORE_OP_STORE,
        vk.VK_ATTACHMENT_STORE_OP_DONT_CARE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_KHR)
        return true;
    if (extensions.device.VK_QCOM_render_pass_store_ops and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_QCOM)
        return true;
    if (extensions.device.VK_EXT_load_store_op_none and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_EXT)
        return true;
    if (extensions.device.VK_KHR_load_store_op_none and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkImageType(extensions: *const Extensions, item: *const vk.VkImageType) bool {
    const min = @min(
        vk.VK_IMAGE_TYPE_1D,
        vk.VK_IMAGE_TYPE_2D,
        vk.VK_IMAGE_TYPE_3D,
    );
    const max = @max(
        vk.VK_IMAGE_TYPE_1D,
        vk.VK_IMAGE_TYPE_2D,
        vk.VK_IMAGE_TYPE_3D,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkImageTiling(extensions: *const Extensions, item: *const vk.VkImageTiling) bool {
    const min = @min(
        vk.VK_IMAGE_TILING_OPTIMAL,
        vk.VK_IMAGE_TILING_LINEAR,
    );
    const max = @max(
        vk.VK_IMAGE_TILING_OPTIMAL,
        vk.VK_IMAGE_TILING_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT)
        return true;
    return false;
}

pub fn check_enum_VkImageViewType(extensions: *const Extensions, item: *const vk.VkImageViewType) bool {
    const min = @min(
        vk.VK_IMAGE_VIEW_TYPE_1D,
        vk.VK_IMAGE_VIEW_TYPE_2D,
        vk.VK_IMAGE_VIEW_TYPE_3D,
        vk.VK_IMAGE_VIEW_TYPE_CUBE,
        vk.VK_IMAGE_VIEW_TYPE_1D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_2D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    );
    const max = @max(
        vk.VK_IMAGE_VIEW_TYPE_1D,
        vk.VK_IMAGE_VIEW_TYPE_2D,
        vk.VK_IMAGE_VIEW_TYPE_3D,
        vk.VK_IMAGE_VIEW_TYPE_CUBE,
        vk.VK_IMAGE_VIEW_TYPE_1D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_2D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCommandBufferLevel(extensions: *const Extensions, item: *const vk.VkCommandBufferLevel) bool {
    const min = @min(
        vk.VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        vk.VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    );
    const max = @max(
        vk.VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        vk.VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkComponentSwizzle(extensions: *const Extensions, item: *const vk.VkComponentSwizzle) bool {
    const min = @min(
        vk.VK_COMPONENT_SWIZZLE_IDENTITY,
        vk.VK_COMPONENT_SWIZZLE_ZERO,
        vk.VK_COMPONENT_SWIZZLE_ONE,
        vk.VK_COMPONENT_SWIZZLE_R,
        vk.VK_COMPONENT_SWIZZLE_G,
        vk.VK_COMPONENT_SWIZZLE_B,
        vk.VK_COMPONENT_SWIZZLE_A,
    );
    const max = @max(
        vk.VK_COMPONENT_SWIZZLE_IDENTITY,
        vk.VK_COMPONENT_SWIZZLE_ZERO,
        vk.VK_COMPONENT_SWIZZLE_ONE,
        vk.VK_COMPONENT_SWIZZLE_R,
        vk.VK_COMPONENT_SWIZZLE_G,
        vk.VK_COMPONENT_SWIZZLE_B,
        vk.VK_COMPONENT_SWIZZLE_A,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDescriptorType(extensions: *const Extensions, item: *const vk.VkDescriptorType) bool {
    const min = @min(
        vk.VK_DESCRIPTOR_TYPE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    );
    const max = @max(
        vk.VK_DESCRIPTOR_TYPE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_DESCRIPTOR_TYPE_MUTABLE_VALVE)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_DESCRIPTOR_TYPE_MUTABLE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkQueryType(extensions: *const Extensions, item: *const vk.VkQueryType) bool {
    const min = @min(
        vk.VK_QUERY_TYPE_OCCLUSION,
        vk.VK_QUERY_TYPE_PIPELINE_STATISTICS,
        vk.VK_QUERY_TYPE_TIMESTAMP,
    );
    const max = @max(
        vk.VK_QUERY_TYPE_OCCLUSION,
        vk.VK_QUERY_TYPE_PIPELINE_STATISTICS,
        vk.VK_QUERY_TYPE_TIMESTAMP,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == vk.VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkBorderColor(extensions: *const Extensions, item: *const vk.VkBorderColor) bool {
    const min = @min(
        vk.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_INT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
        vk.VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    );
    const max = @max(
        vk.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_INT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
        vk.VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_BORDER_COLOR_FLOAT_CUSTOM_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_BORDER_COLOR_INT_CUSTOM_EXT)
        return true;
    return false;
}

pub fn check_enum_VkPipelineBindPoint(extensions: *const Extensions, item: *const vk.VkPipelineBindPoint) bool {
    const min = @min(
        vk.VK_PIPELINE_BIND_POINT_GRAPHICS,
        vk.VK_PIPELINE_BIND_POINT_COMPUTE,
    );
    const max = @max(
        vk.VK_PIPELINE_BIND_POINT_GRAPHICS,
        vk.VK_PIPELINE_BIND_POINT_COMPUTE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR)
        return true;
    return false;
}

pub fn check_enum_VkPipelineCacheHeaderVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersion) bool {
    const min = vk.VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
    const max = vk.VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPipelineCacheCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance8)
        valid_bits |= vk.VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPrimitiveTopology(extensions: *const Extensions, item: *const vk.VkPrimitiveTopology) bool {
    const min = @min(
        vk.VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    );
    const max = @max(
        vk.VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSharingMode(extensions: *const Extensions, item: *const vk.VkSharingMode) bool {
    const min = @min(
        vk.VK_SHARING_MODE_EXCLUSIVE,
        vk.VK_SHARING_MODE_CONCURRENT,
    );
    const max = @max(
        vk.VK_SHARING_MODE_EXCLUSIVE,
        vk.VK_SHARING_MODE_CONCURRENT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkIndexType(extensions: *const Extensions, item: *const vk.VkIndexType) bool {
    const min = @min(
        vk.VK_INDEX_TYPE_UINT16,
        vk.VK_INDEX_TYPE_UINT32,
    );
    const max = @max(
        vk.VK_INDEX_TYPE_UINT16,
        vk.VK_INDEX_TYPE_UINT32,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_INDEX_TYPE_NONE_KHR)
        return true;
    if (extensions.device.VK_EXT_index_type_uint8 and item.* == vk.VK_INDEX_TYPE_UINT8_EXT)
        return true;
    if (extensions.device.VK_KHR_index_type_uint8 and item.* == vk.VK_INDEX_TYPE_UINT8_KHR)
        return true;
    return false;
}

pub fn check_enum_VkFilter(extensions: *const Extensions, item: *const vk.VkFilter) bool {
    const min = @min(
        vk.VK_FILTER_NEAREST,
        vk.VK_FILTER_LINEAR,
    );
    const max = @max(
        vk.VK_FILTER_NEAREST,
        vk.VK_FILTER_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_IMG_filter_cubic and item.* == vk.VK_FILTER_CUBIC_IMG)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_FILTER_CUBIC_EXT)
        return true;
    return false;
}

pub fn check_enum_VkSamplerMipmapMode(extensions: *const Extensions, item: *const vk.VkSamplerMipmapMode) bool {
    const min = @min(
        vk.VK_SAMPLER_MIPMAP_MODE_NEAREST,
        vk.VK_SAMPLER_MIPMAP_MODE_LINEAR,
    );
    const max = @max(
        vk.VK_SAMPLER_MIPMAP_MODE_NEAREST,
        vk.VK_SAMPLER_MIPMAP_MODE_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSamplerAddressMode(extensions: *const Extensions, item: *const vk.VkSamplerAddressMode) bool {
    const min = @min(
        vk.VK_SAMPLER_ADDRESS_MODE_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    );
    const max = @max(
        vk.VK_SAMPLER_ADDRESS_MODE_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCompareOp(extensions: *const Extensions, item: *const vk.VkCompareOp) bool {
    const min = @min(
        vk.VK_COMPARE_OP_NEVER,
        vk.VK_COMPARE_OP_LESS,
        vk.VK_COMPARE_OP_EQUAL,
        vk.VK_COMPARE_OP_LESS_OR_EQUAL,
        vk.VK_COMPARE_OP_GREATER,
        vk.VK_COMPARE_OP_NOT_EQUAL,
        vk.VK_COMPARE_OP_GREATER_OR_EQUAL,
        vk.VK_COMPARE_OP_ALWAYS,
    );
    const max = @max(
        vk.VK_COMPARE_OP_NEVER,
        vk.VK_COMPARE_OP_LESS,
        vk.VK_COMPARE_OP_EQUAL,
        vk.VK_COMPARE_OP_LESS_OR_EQUAL,
        vk.VK_COMPARE_OP_GREATER,
        vk.VK_COMPARE_OP_NOT_EQUAL,
        vk.VK_COMPARE_OP_GREATER_OR_EQUAL,
        vk.VK_COMPARE_OP_ALWAYS,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPolygonMode(extensions: *const Extensions, item: *const vk.VkPolygonMode) bool {
    const min = @min(
        vk.VK_POLYGON_MODE_FILL,
        vk.VK_POLYGON_MODE_LINE,
        vk.VK_POLYGON_MODE_POINT,
    );
    const max = @max(
        vk.VK_POLYGON_MODE_FILL,
        vk.VK_POLYGON_MODE_LINE,
        vk.VK_POLYGON_MODE_POINT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFrontFace(extensions: *const Extensions, item: *const vk.VkFrontFace) bool {
    const min = @min(
        vk.VK_FRONT_FACE_COUNTER_CLOCKWISE,
        vk.VK_FRONT_FACE_CLOCKWISE,
    );
    const max = @max(
        vk.VK_FRONT_FACE_COUNTER_CLOCKWISE,
        vk.VK_FRONT_FACE_CLOCKWISE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBlendFactor(extensions: *const Extensions, item: *const vk.VkBlendFactor) bool {
    const min = @min(
        vk.VK_BLEND_FACTOR_ZERO,
        vk.VK_BLEND_FACTOR_ONE,
        vk.VK_BLEND_FACTOR_SRC_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
        vk.VK_BLEND_FACTOR_DST_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
        vk.VK_BLEND_FACTOR_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_DST_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
        vk.VK_BLEND_FACTOR_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
        vk.VK_BLEND_FACTOR_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_SRC1_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    );
    const max = @max(
        vk.VK_BLEND_FACTOR_ZERO,
        vk.VK_BLEND_FACTOR_ONE,
        vk.VK_BLEND_FACTOR_SRC_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
        vk.VK_BLEND_FACTOR_DST_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
        vk.VK_BLEND_FACTOR_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_DST_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
        vk.VK_BLEND_FACTOR_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
        vk.VK_BLEND_FACTOR_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_SRC1_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBlendOp(extensions: *const Extensions, item: *const vk.VkBlendOp) bool {
    const min = @min(
        vk.VK_BLEND_OP_ADD,
        vk.VK_BLEND_OP_SUBTRACT,
        vk.VK_BLEND_OP_REVERSE_SUBTRACT,
        vk.VK_BLEND_OP_MIN,
        vk.VK_BLEND_OP_MAX,
    );
    const max = @max(
        vk.VK_BLEND_OP_ADD,
        vk.VK_BLEND_OP_SUBTRACT,
        vk.VK_BLEND_OP_REVERSE_SUBTRACT,
        vk.VK_BLEND_OP_MIN,
        vk.VK_BLEND_OP_MAX,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_ZERO_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_XOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MULTIPLY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SCREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_OVERLAY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DARKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LIGHTEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_COLORDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_COLORBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HARDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SOFTLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DIFFERENCE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_EXCLUSION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_RGB_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_VIVIDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PINLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HARDMIX_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_HUE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_SATURATION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_COLOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_LUMINOSITY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_DARKER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MINUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MINUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_CONTRAST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_OVG_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_RED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_GREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_BLUE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkStencilOp(extensions: *const Extensions, item: *const vk.VkStencilOp) bool {
    const min = @min(
        vk.VK_STENCIL_OP_KEEP,
        vk.VK_STENCIL_OP_ZERO,
        vk.VK_STENCIL_OP_REPLACE,
        vk.VK_STENCIL_OP_INCREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_DECREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_INVERT,
        vk.VK_STENCIL_OP_INCREMENT_AND_WRAP,
        vk.VK_STENCIL_OP_DECREMENT_AND_WRAP,
    );
    const max = @max(
        vk.VK_STENCIL_OP_KEEP,
        vk.VK_STENCIL_OP_ZERO,
        vk.VK_STENCIL_OP_REPLACE,
        vk.VK_STENCIL_OP_INCREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_DECREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_INVERT,
        vk.VK_STENCIL_OP_INCREMENT_AND_WRAP,
        vk.VK_STENCIL_OP_DECREMENT_AND_WRAP,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLogicOp(extensions: *const Extensions, item: *const vk.VkLogicOp) bool {
    const min = @min(
        vk.VK_LOGIC_OP_CLEAR,
        vk.VK_LOGIC_OP_AND,
        vk.VK_LOGIC_OP_AND_REVERSE,
        vk.VK_LOGIC_OP_COPY,
        vk.VK_LOGIC_OP_AND_INVERTED,
        vk.VK_LOGIC_OP_NO_OP,
        vk.VK_LOGIC_OP_XOR,
        vk.VK_LOGIC_OP_OR,
        vk.VK_LOGIC_OP_NOR,
        vk.VK_LOGIC_OP_EQUIVALENT,
        vk.VK_LOGIC_OP_INVERT,
        vk.VK_LOGIC_OP_OR_REVERSE,
        vk.VK_LOGIC_OP_COPY_INVERTED,
        vk.VK_LOGIC_OP_OR_INVERTED,
        vk.VK_LOGIC_OP_NAND,
        vk.VK_LOGIC_OP_SET,
    );
    const max = @max(
        vk.VK_LOGIC_OP_CLEAR,
        vk.VK_LOGIC_OP_AND,
        vk.VK_LOGIC_OP_AND_REVERSE,
        vk.VK_LOGIC_OP_COPY,
        vk.VK_LOGIC_OP_AND_INVERTED,
        vk.VK_LOGIC_OP_NO_OP,
        vk.VK_LOGIC_OP_XOR,
        vk.VK_LOGIC_OP_OR,
        vk.VK_LOGIC_OP_NOR,
        vk.VK_LOGIC_OP_EQUIVALENT,
        vk.VK_LOGIC_OP_INVERT,
        vk.VK_LOGIC_OP_OR_REVERSE,
        vk.VK_LOGIC_OP_COPY_INVERTED,
        vk.VK_LOGIC_OP_OR_INVERTED,
        vk.VK_LOGIC_OP_NAND,
        vk.VK_LOGIC_OP_SET,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkInternalAllocationType(extensions: *const Extensions, item: *const vk.VkInternalAllocationType) bool {
    const min = vk.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
    const max = vk.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSystemAllocationScope(extensions: *const Extensions, item: *const vk.VkSystemAllocationScope) bool {
    const min = @min(
        vk.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    );
    const max = @max(
        vk.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPhysicalDeviceType(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceType) bool {
    const min = @min(
        vk.VK_PHYSICAL_DEVICE_TYPE_OTHER,
        vk.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_CPU,
    );
    const max = @max(
        vk.VK_PHYSICAL_DEVICE_TYPE_OTHER,
        vk.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_CPU,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkVertexInputRate(extensions: *const Extensions, item: *const vk.VkVertexInputRate) bool {
    const min = @min(
        vk.VK_VERTEX_INPUT_RATE_VERTEX,
        vk.VK_VERTEX_INPUT_RATE_INSTANCE,
    );
    const max = @max(
        vk.VK_VERTEX_INPUT_RATE_VERTEX,
        vk.VK_VERTEX_INPUT_RATE_INSTANCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFormat(extensions: *const Extensions, item: *const vk.VkFormat) bool {
    const min = @min(
        vk.VK_FORMAT_UNDEFINED,
        vk.VK_FORMAT_R4G4_UNORM_PACK8,
        vk.VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        vk.VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        vk.VK_FORMAT_R5G6B5_UNORM_PACK16,
        vk.VK_FORMAT_B5G6R5_UNORM_PACK16,
        vk.VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        vk.VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        vk.VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        vk.VK_FORMAT_R8_UNORM,
        vk.VK_FORMAT_R8_SNORM,
        vk.VK_FORMAT_R8_USCALED,
        vk.VK_FORMAT_R8_SSCALED,
        vk.VK_FORMAT_R8_UINT,
        vk.VK_FORMAT_R8_SINT,
        vk.VK_FORMAT_R8_SRGB,
        vk.VK_FORMAT_R8G8_UNORM,
        vk.VK_FORMAT_R8G8_SNORM,
        vk.VK_FORMAT_R8G8_USCALED,
        vk.VK_FORMAT_R8G8_SSCALED,
        vk.VK_FORMAT_R8G8_UINT,
        vk.VK_FORMAT_R8G8_SINT,
        vk.VK_FORMAT_R8G8_SRGB,
        vk.VK_FORMAT_R8G8B8_UNORM,
        vk.VK_FORMAT_R8G8B8_SNORM,
        vk.VK_FORMAT_R8G8B8_USCALED,
        vk.VK_FORMAT_R8G8B8_SSCALED,
        vk.VK_FORMAT_R8G8B8_UINT,
        vk.VK_FORMAT_R8G8B8_SINT,
        vk.VK_FORMAT_R8G8B8_SRGB,
        vk.VK_FORMAT_B8G8R8_UNORM,
        vk.VK_FORMAT_B8G8R8_SNORM,
        vk.VK_FORMAT_B8G8R8_USCALED,
        vk.VK_FORMAT_B8G8R8_SSCALED,
        vk.VK_FORMAT_B8G8R8_UINT,
        vk.VK_FORMAT_B8G8R8_SINT,
        vk.VK_FORMAT_B8G8R8_SRGB,
        vk.VK_FORMAT_R8G8B8A8_UNORM,
        vk.VK_FORMAT_R8G8B8A8_SNORM,
        vk.VK_FORMAT_R8G8B8A8_USCALED,
        vk.VK_FORMAT_R8G8B8A8_SSCALED,
        vk.VK_FORMAT_R8G8B8A8_UINT,
        vk.VK_FORMAT_R8G8B8A8_SINT,
        vk.VK_FORMAT_R8G8B8A8_SRGB,
        vk.VK_FORMAT_B8G8R8A8_UNORM,
        vk.VK_FORMAT_B8G8R8A8_SNORM,
        vk.VK_FORMAT_B8G8R8A8_USCALED,
        vk.VK_FORMAT_B8G8R8A8_SSCALED,
        vk.VK_FORMAT_B8G8R8A8_UINT,
        vk.VK_FORMAT_B8G8R8A8_SINT,
        vk.VK_FORMAT_B8G8R8A8_SRGB,
        vk.VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_UINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UINT_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SINT_PACK32,
        vk.VK_FORMAT_R16_UNORM,
        vk.VK_FORMAT_R16_SNORM,
        vk.VK_FORMAT_R16_USCALED,
        vk.VK_FORMAT_R16_SSCALED,
        vk.VK_FORMAT_R16_UINT,
        vk.VK_FORMAT_R16_SINT,
        vk.VK_FORMAT_R16_SFLOAT,
        vk.VK_FORMAT_R16G16_UNORM,
        vk.VK_FORMAT_R16G16_SNORM,
        vk.VK_FORMAT_R16G16_USCALED,
        vk.VK_FORMAT_R16G16_SSCALED,
        vk.VK_FORMAT_R16G16_UINT,
        vk.VK_FORMAT_R16G16_SINT,
        vk.VK_FORMAT_R16G16_SFLOAT,
        vk.VK_FORMAT_R16G16B16_UNORM,
        vk.VK_FORMAT_R16G16B16_SNORM,
        vk.VK_FORMAT_R16G16B16_USCALED,
        vk.VK_FORMAT_R16G16B16_SSCALED,
        vk.VK_FORMAT_R16G16B16_UINT,
        vk.VK_FORMAT_R16G16B16_SINT,
        vk.VK_FORMAT_R16G16B16_SFLOAT,
        vk.VK_FORMAT_R16G16B16A16_UNORM,
        vk.VK_FORMAT_R16G16B16A16_SNORM,
        vk.VK_FORMAT_R16G16B16A16_USCALED,
        vk.VK_FORMAT_R16G16B16A16_SSCALED,
        vk.VK_FORMAT_R16G16B16A16_UINT,
        vk.VK_FORMAT_R16G16B16A16_SINT,
        vk.VK_FORMAT_R16G16B16A16_SFLOAT,
        vk.VK_FORMAT_R32_UINT,
        vk.VK_FORMAT_R32_SINT,
        vk.VK_FORMAT_R32_SFLOAT,
        vk.VK_FORMAT_R32G32_UINT,
        vk.VK_FORMAT_R32G32_SINT,
        vk.VK_FORMAT_R32G32_SFLOAT,
        vk.VK_FORMAT_R32G32B32_UINT,
        vk.VK_FORMAT_R32G32B32_SINT,
        vk.VK_FORMAT_R32G32B32_SFLOAT,
        vk.VK_FORMAT_R32G32B32A32_UINT,
        vk.VK_FORMAT_R32G32B32A32_SINT,
        vk.VK_FORMAT_R32G32B32A32_SFLOAT,
        vk.VK_FORMAT_R64_UINT,
        vk.VK_FORMAT_R64_SINT,
        vk.VK_FORMAT_R64_SFLOAT,
        vk.VK_FORMAT_R64G64_UINT,
        vk.VK_FORMAT_R64G64_SINT,
        vk.VK_FORMAT_R64G64_SFLOAT,
        vk.VK_FORMAT_R64G64B64_UINT,
        vk.VK_FORMAT_R64G64B64_SINT,
        vk.VK_FORMAT_R64G64B64_SFLOAT,
        vk.VK_FORMAT_R64G64B64A64_UINT,
        vk.VK_FORMAT_R64G64B64A64_SINT,
        vk.VK_FORMAT_R64G64B64A64_SFLOAT,
        vk.VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        vk.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
        vk.VK_FORMAT_D16_UNORM,
        vk.VK_FORMAT_X8_D24_UNORM_PACK32,
        vk.VK_FORMAT_D32_SFLOAT,
        vk.VK_FORMAT_S8_UINT,
        vk.VK_FORMAT_D16_UNORM_S8_UINT,
        vk.VK_FORMAT_D24_UNORM_S8_UINT,
        vk.VK_FORMAT_D32_SFLOAT_S8_UINT,
        vk.VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
        vk.VK_FORMAT_BC2_UNORM_BLOCK,
        vk.VK_FORMAT_BC2_SRGB_BLOCK,
        vk.VK_FORMAT_BC3_UNORM_BLOCK,
        vk.VK_FORMAT_BC3_SRGB_BLOCK,
        vk.VK_FORMAT_BC4_UNORM_BLOCK,
        vk.VK_FORMAT_BC4_SNORM_BLOCK,
        vk.VK_FORMAT_BC5_UNORM_BLOCK,
        vk.VK_FORMAT_BC5_SNORM_BLOCK,
        vk.VK_FORMAT_BC6H_UFLOAT_BLOCK,
        vk.VK_FORMAT_BC6H_SFLOAT_BLOCK,
        vk.VK_FORMAT_BC7_UNORM_BLOCK,
        vk.VK_FORMAT_BC7_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
        vk.VK_FORMAT_EAC_R11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11_SNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    );
    const max = @max(
        vk.VK_FORMAT_UNDEFINED,
        vk.VK_FORMAT_R4G4_UNORM_PACK8,
        vk.VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        vk.VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        vk.VK_FORMAT_R5G6B5_UNORM_PACK16,
        vk.VK_FORMAT_B5G6R5_UNORM_PACK16,
        vk.VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        vk.VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        vk.VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        vk.VK_FORMAT_R8_UNORM,
        vk.VK_FORMAT_R8_SNORM,
        vk.VK_FORMAT_R8_USCALED,
        vk.VK_FORMAT_R8_SSCALED,
        vk.VK_FORMAT_R8_UINT,
        vk.VK_FORMAT_R8_SINT,
        vk.VK_FORMAT_R8_SRGB,
        vk.VK_FORMAT_R8G8_UNORM,
        vk.VK_FORMAT_R8G8_SNORM,
        vk.VK_FORMAT_R8G8_USCALED,
        vk.VK_FORMAT_R8G8_SSCALED,
        vk.VK_FORMAT_R8G8_UINT,
        vk.VK_FORMAT_R8G8_SINT,
        vk.VK_FORMAT_R8G8_SRGB,
        vk.VK_FORMAT_R8G8B8_UNORM,
        vk.VK_FORMAT_R8G8B8_SNORM,
        vk.VK_FORMAT_R8G8B8_USCALED,
        vk.VK_FORMAT_R8G8B8_SSCALED,
        vk.VK_FORMAT_R8G8B8_UINT,
        vk.VK_FORMAT_R8G8B8_SINT,
        vk.VK_FORMAT_R8G8B8_SRGB,
        vk.VK_FORMAT_B8G8R8_UNORM,
        vk.VK_FORMAT_B8G8R8_SNORM,
        vk.VK_FORMAT_B8G8R8_USCALED,
        vk.VK_FORMAT_B8G8R8_SSCALED,
        vk.VK_FORMAT_B8G8R8_UINT,
        vk.VK_FORMAT_B8G8R8_SINT,
        vk.VK_FORMAT_B8G8R8_SRGB,
        vk.VK_FORMAT_R8G8B8A8_UNORM,
        vk.VK_FORMAT_R8G8B8A8_SNORM,
        vk.VK_FORMAT_R8G8B8A8_USCALED,
        vk.VK_FORMAT_R8G8B8A8_SSCALED,
        vk.VK_FORMAT_R8G8B8A8_UINT,
        vk.VK_FORMAT_R8G8B8A8_SINT,
        vk.VK_FORMAT_R8G8B8A8_SRGB,
        vk.VK_FORMAT_B8G8R8A8_UNORM,
        vk.VK_FORMAT_B8G8R8A8_SNORM,
        vk.VK_FORMAT_B8G8R8A8_USCALED,
        vk.VK_FORMAT_B8G8R8A8_SSCALED,
        vk.VK_FORMAT_B8G8R8A8_UINT,
        vk.VK_FORMAT_B8G8R8A8_SINT,
        vk.VK_FORMAT_B8G8R8A8_SRGB,
        vk.VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_UINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UINT_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SINT_PACK32,
        vk.VK_FORMAT_R16_UNORM,
        vk.VK_FORMAT_R16_SNORM,
        vk.VK_FORMAT_R16_USCALED,
        vk.VK_FORMAT_R16_SSCALED,
        vk.VK_FORMAT_R16_UINT,
        vk.VK_FORMAT_R16_SINT,
        vk.VK_FORMAT_R16_SFLOAT,
        vk.VK_FORMAT_R16G16_UNORM,
        vk.VK_FORMAT_R16G16_SNORM,
        vk.VK_FORMAT_R16G16_USCALED,
        vk.VK_FORMAT_R16G16_SSCALED,
        vk.VK_FORMAT_R16G16_UINT,
        vk.VK_FORMAT_R16G16_SINT,
        vk.VK_FORMAT_R16G16_SFLOAT,
        vk.VK_FORMAT_R16G16B16_UNORM,
        vk.VK_FORMAT_R16G16B16_SNORM,
        vk.VK_FORMAT_R16G16B16_USCALED,
        vk.VK_FORMAT_R16G16B16_SSCALED,
        vk.VK_FORMAT_R16G16B16_UINT,
        vk.VK_FORMAT_R16G16B16_SINT,
        vk.VK_FORMAT_R16G16B16_SFLOAT,
        vk.VK_FORMAT_R16G16B16A16_UNORM,
        vk.VK_FORMAT_R16G16B16A16_SNORM,
        vk.VK_FORMAT_R16G16B16A16_USCALED,
        vk.VK_FORMAT_R16G16B16A16_SSCALED,
        vk.VK_FORMAT_R16G16B16A16_UINT,
        vk.VK_FORMAT_R16G16B16A16_SINT,
        vk.VK_FORMAT_R16G16B16A16_SFLOAT,
        vk.VK_FORMAT_R32_UINT,
        vk.VK_FORMAT_R32_SINT,
        vk.VK_FORMAT_R32_SFLOAT,
        vk.VK_FORMAT_R32G32_UINT,
        vk.VK_FORMAT_R32G32_SINT,
        vk.VK_FORMAT_R32G32_SFLOAT,
        vk.VK_FORMAT_R32G32B32_UINT,
        vk.VK_FORMAT_R32G32B32_SINT,
        vk.VK_FORMAT_R32G32B32_SFLOAT,
        vk.VK_FORMAT_R32G32B32A32_UINT,
        vk.VK_FORMAT_R32G32B32A32_SINT,
        vk.VK_FORMAT_R32G32B32A32_SFLOAT,
        vk.VK_FORMAT_R64_UINT,
        vk.VK_FORMAT_R64_SINT,
        vk.VK_FORMAT_R64_SFLOAT,
        vk.VK_FORMAT_R64G64_UINT,
        vk.VK_FORMAT_R64G64_SINT,
        vk.VK_FORMAT_R64G64_SFLOAT,
        vk.VK_FORMAT_R64G64B64_UINT,
        vk.VK_FORMAT_R64G64B64_SINT,
        vk.VK_FORMAT_R64G64B64_SFLOAT,
        vk.VK_FORMAT_R64G64B64A64_UINT,
        vk.VK_FORMAT_R64G64B64A64_SINT,
        vk.VK_FORMAT_R64G64B64A64_SFLOAT,
        vk.VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        vk.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
        vk.VK_FORMAT_D16_UNORM,
        vk.VK_FORMAT_X8_D24_UNORM_PACK32,
        vk.VK_FORMAT_D32_SFLOAT,
        vk.VK_FORMAT_S8_UINT,
        vk.VK_FORMAT_D16_UNORM_S8_UINT,
        vk.VK_FORMAT_D24_UNORM_S8_UINT,
        vk.VK_FORMAT_D32_SFLOAT_S8_UINT,
        vk.VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
        vk.VK_FORMAT_BC2_UNORM_BLOCK,
        vk.VK_FORMAT_BC2_SRGB_BLOCK,
        vk.VK_FORMAT_BC3_UNORM_BLOCK,
        vk.VK_FORMAT_BC3_SRGB_BLOCK,
        vk.VK_FORMAT_BC4_UNORM_BLOCK,
        vk.VK_FORMAT_BC4_SNORM_BLOCK,
        vk.VK_FORMAT_BC5_UNORM_BLOCK,
        vk.VK_FORMAT_BC5_SNORM_BLOCK,
        vk.VK_FORMAT_BC6H_UFLOAT_BLOCK,
        vk.VK_FORMAT_BC6H_SFLOAT_BLOCK,
        vk.VK_FORMAT_BC7_UNORM_BLOCK,
        vk.VK_FORMAT_BC7_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
        vk.VK_FORMAT_EAC_R11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11_SNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8B8G8R8_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B8G8R8G8_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16B16G16R16_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B16G16R16G16_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_FORMAT_A8_UNORM_KHR)
        return true;
    return false;
}

pub fn check_enum_VkStructureType(extensions: *const Extensions, item: *const vk.VkStructureType) bool {
    const min = @min(
        vk.VK_STRUCTURE_TYPE_APPLICATION_INFO,
        vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SUBMIT_INFO,
        vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
        vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    );
    const max = @max(
        vk.VK_STRUCTURE_TYPE_APPLICATION_INFO,
        vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SUBMIT_INFO,
        vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
        vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_EXT_validation_flags and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT)
        return true;
    if (extensions.instance.VK_KHR_device_group_creation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_device_group_creation and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_EXT_display_surface_counter and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_metal_surface and item.* == vk.VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_protected_capabilities and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
        return true;
    if (extensions.instance.VK_EXT_validation_features and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT)
        return true;
    if (extensions.instance.VK_EXT_headless_surface and item.* == vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT)
        return true;
    if (extensions.instance.VK_EXT_directfb_surface and item.* == vk.VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR)
        return true;
    if (extensions.instance.VK_EXT_layer_settings and item.* == vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_push_descriptor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_float16_int8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float16_int8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_16bit_storage and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_incremental_present and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_hdr_metadata and item.* == vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR)
        return true;
    if (extensions.device.VK_IMG_relaxed_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_variable_pointers and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_variable_pointers and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dedicated_allocation and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_dedicated_allocation and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR)
        return true;
    if (extensions.device.VK_KHR_image_format_list and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_bind_memory2 and item.* == vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_bind_memory2 and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance3 and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_extended_types and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_8bit_storage and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_atomic_int64 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_clock and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_feedback and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_depth_stencil_resolve and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_depth_stencil_resolve and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR)
        return true;
    if (extensions.device.VK_INTEL_shader_integer_functions2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL)
        return true;
    if (extensions.device.VK_KHR_vulkan_memory_model and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_pci_bus_info and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_terminate_invocation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_scalar_block_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_image_atomic_int64 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_quad_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_memory_budget and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_tooling_info and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_separate_stencil_usage and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_present_wait and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_shader_interlock and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_image_arrays and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_uniform_buffer_standard_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_query_reset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_index_type_uint8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT)
        return true;
    if (extensions.device.VK_KHR_map_memory2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_map_memory2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_demote_to_helper_invocation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_integer_dot_product and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_integer_dot_product and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_texel_buffer_alignment and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_texel_buffer_alignment and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_EXT_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_ID_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_uniform_control_flow and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_zero_initialize_workgroup_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_QCOM_rotated_copy_commands and item.* == vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_image_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_workgroup_memory_explicit_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_rgba10x6_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_physical_device_drm and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitive_topology_list_restart and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_format_feature_flags2 and item.* == vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR)
        return true;
    if (extensions.device.VK_EXT_present_mode_fifo_latest_ready and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_global_priority_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority_query and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_2d_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pageable_device_local_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_rotate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_zero_one and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_non_seamless_cube_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_shader_maximal_reconvergence and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control_swapchain and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_acquire_unmodified and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_dithering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_protected_access and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_viewports and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_library_group_handles and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_dynamic_rendering_unused_attachments and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_index_type_uint8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_calibrated_timestamps and item.* == vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_expect_assume and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_relaxed_extended_instruction and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_replicated_composites and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_depth_clamp_zero_one and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSubpassContents(extensions: *const Extensions, item: *const vk.VkSubpassContents) bool {
    const min = @min(
        vk.VK_SUBPASS_CONTENTS_INLINE,
        vk.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    );
    const max = @max(
        vk.VK_SUBPASS_CONTENTS_INLINE,
        vk.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR)
        return true;
    return false;
}

pub fn check_enum_VkResult(extensions: *const Extensions, item: *const vk.VkResult) bool {
    const min = @min(
        vk.VK_SUCCESS,
        vk.VK_NOT_READY,
        vk.VK_TIMEOUT,
        vk.VK_EVENT_SET,
        vk.VK_EVENT_RESET,
        vk.VK_INCOMPLETE,
        vk.VK_ERROR_OUT_OF_HOST_MEMORY,
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY,
        vk.VK_ERROR_INITIALIZATION_FAILED,
        vk.VK_ERROR_DEVICE_LOST,
        vk.VK_ERROR_MEMORY_MAP_FAILED,
        vk.VK_ERROR_LAYER_NOT_PRESENT,
        vk.VK_ERROR_EXTENSION_NOT_PRESENT,
        vk.VK_ERROR_FEATURE_NOT_PRESENT,
        vk.VK_ERROR_INCOMPATIBLE_DRIVER,
        vk.VK_ERROR_TOO_MANY_OBJECTS,
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED,
        vk.VK_ERROR_FRAGMENTED_POOL,
        vk.VK_ERROR_UNKNOWN,
    );
    const max = @max(
        vk.VK_SUCCESS,
        vk.VK_NOT_READY,
        vk.VK_TIMEOUT,
        vk.VK_EVENT_SET,
        vk.VK_EVENT_RESET,
        vk.VK_INCOMPLETE,
        vk.VK_ERROR_OUT_OF_HOST_MEMORY,
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY,
        vk.VK_ERROR_INITIALIZATION_FAILED,
        vk.VK_ERROR_DEVICE_LOST,
        vk.VK_ERROR_MEMORY_MAP_FAILED,
        vk.VK_ERROR_LAYER_NOT_PRESENT,
        vk.VK_ERROR_EXTENSION_NOT_PRESENT,
        vk.VK_ERROR_FEATURE_NOT_PRESENT,
        vk.VK_ERROR_INCOMPATIBLE_DRIVER,
        vk.VK_ERROR_TOO_MANY_OBJECTS,
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED,
        vk.VK_ERROR_FRAGMENTED_POOL,
        vk.VK_ERROR_UNKNOWN,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_ERROR_SURFACE_LOST_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_SUBOPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_ERROR_OUT_OF_DATE_KHR)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance1 and item.* == vk.VK_ERROR_OUT_OF_POOL_MEMORY_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_ERROR_FRAGMENTATION_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_ERROR_NOT_PERMITTED_EXT)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_ERROR_NOT_PERMITTED_KHR)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_ERROR_INVALID_DEVICE_ADDRESS_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_THREAD_IDLE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_THREAD_DONE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OPERATION_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OPERATION_NOT_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_PIPELINE_COMPILE_REQUIRED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_PIPELINE_BINARY_MISSING_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkDynamicState(extensions: *const Extensions, item: *const vk.VkDynamicState) bool {
    const min = @min(
        vk.VK_DYNAMIC_STATE_VIEWPORT,
        vk.VK_DYNAMIC_STATE_SCISSOR,
        vk.VK_DYNAMIC_STATE_LINE_WIDTH,
        vk.VK_DYNAMIC_STATE_DEPTH_BIAS,
        vk.VK_DYNAMIC_STATE_BLEND_CONSTANTS,
        vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS,
        vk.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    );
    const max = @max(
        vk.VK_DYNAMIC_STATE_VIEWPORT,
        vk.VK_DYNAMIC_STATE_SCISSOR,
        vk.VK_DYNAMIC_STATE_LINE_WIDTH,
        vk.VK_DYNAMIC_STATE_DEPTH_BIAS,
        vk.VK_DYNAMIC_STATE_BLEND_CONSTANTS,
        vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS,
        vk.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_CULL_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_FRONT_FACE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_STENCIL_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VERTEX_INPUT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_LOGIC_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_POLYGON_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_KHR)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkDescriptorUpdateTemplateType(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateType) bool {
    const min = vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    const max = vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_push_descriptor and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR)
        return true;
    return false;
}

pub fn check_enum_VkObjectType(extensions: *const Extensions, item: *const vk.VkObjectType) bool {
    const min = @min(
        vk.VK_OBJECT_TYPE_UNKNOWN,
        vk.VK_OBJECT_TYPE_INSTANCE,
        vk.VK_OBJECT_TYPE_PHYSICAL_DEVICE,
        vk.VK_OBJECT_TYPE_DEVICE,
        vk.VK_OBJECT_TYPE_QUEUE,
        vk.VK_OBJECT_TYPE_SEMAPHORE,
        vk.VK_OBJECT_TYPE_COMMAND_BUFFER,
        vk.VK_OBJECT_TYPE_FENCE,
        vk.VK_OBJECT_TYPE_DEVICE_MEMORY,
        vk.VK_OBJECT_TYPE_BUFFER,
        vk.VK_OBJECT_TYPE_IMAGE,
        vk.VK_OBJECT_TYPE_EVENT,
        vk.VK_OBJECT_TYPE_QUERY_POOL,
        vk.VK_OBJECT_TYPE_BUFFER_VIEW,
        vk.VK_OBJECT_TYPE_IMAGE_VIEW,
        vk.VK_OBJECT_TYPE_SHADER_MODULE,
        vk.VK_OBJECT_TYPE_PIPELINE_CACHE,
        vk.VK_OBJECT_TYPE_PIPELINE_LAYOUT,
        vk.VK_OBJECT_TYPE_RENDER_PASS,
        vk.VK_OBJECT_TYPE_PIPELINE,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
        vk.VK_OBJECT_TYPE_SAMPLER,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_POOL,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET,
        vk.VK_OBJECT_TYPE_FRAMEBUFFER,
        vk.VK_OBJECT_TYPE_COMMAND_POOL,
    );
    const max = @max(
        vk.VK_OBJECT_TYPE_UNKNOWN,
        vk.VK_OBJECT_TYPE_INSTANCE,
        vk.VK_OBJECT_TYPE_PHYSICAL_DEVICE,
        vk.VK_OBJECT_TYPE_DEVICE,
        vk.VK_OBJECT_TYPE_QUEUE,
        vk.VK_OBJECT_TYPE_SEMAPHORE,
        vk.VK_OBJECT_TYPE_COMMAND_BUFFER,
        vk.VK_OBJECT_TYPE_FENCE,
        vk.VK_OBJECT_TYPE_DEVICE_MEMORY,
        vk.VK_OBJECT_TYPE_BUFFER,
        vk.VK_OBJECT_TYPE_IMAGE,
        vk.VK_OBJECT_TYPE_EVENT,
        vk.VK_OBJECT_TYPE_QUERY_POOL,
        vk.VK_OBJECT_TYPE_BUFFER_VIEW,
        vk.VK_OBJECT_TYPE_IMAGE_VIEW,
        vk.VK_OBJECT_TYPE_SHADER_MODULE,
        vk.VK_OBJECT_TYPE_PIPELINE_CACHE,
        vk.VK_OBJECT_TYPE_PIPELINE_LAYOUT,
        vk.VK_OBJECT_TYPE_RENDER_PASS,
        vk.VK_OBJECT_TYPE_PIPELINE,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
        vk.VK_OBJECT_TYPE_SAMPLER,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_POOL,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET,
        vk.VK_OBJECT_TYPE_FRAMEBUFFER,
        vk.VK_OBJECT_TYPE_COMMAND_POOL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_OBJECT_TYPE_SURFACE_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_OBJECT_TYPE_DISPLAY_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_OBJECT_TYPE_DISPLAY_MODE_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_OBJECT_TYPE_SWAPCHAIN_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_OBJECT_TYPE_VIDEO_SESSION_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_OBJECT_TYPE_VALIDATION_CACHE_EXT)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_OBJECT_TYPE_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_OBJECT_TYPE_SHADER_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_OBJECT_TYPE_PIPELINE_BINARY_KHR)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT)
        return true;
    return false;
}

pub fn check_enum_VkRayTracingInvocationReorderModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingInvocationReorderModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRayTracingLssIndexingModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssIndexingModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRayTracingLssPrimitiveEndCapsModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssPrimitiveEndCapsModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDirectDriverLoadingModeLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingModeLUNARG) bool {
    const min = @min(
        vk.VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
        vk.VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
    );
    const max = @max(
        vk.VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
        vk.VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAntiLagModeAMD(extensions: *const Extensions, item: *const vk.VkAntiLagModeAMD) bool {
    const min = @min(
        vk.VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
        vk.VK_ANTI_LAG_MODE_ON_AMD,
        vk.VK_ANTI_LAG_MODE_OFF_AMD,
    );
    const max = @max(
        vk.VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
        vk.VK_ANTI_LAG_MODE_ON_AMD,
        vk.VK_ANTI_LAG_MODE_OFF_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAntiLagStageAMD(extensions: *const Extensions, item: *const vk.VkAntiLagStageAMD) bool {
    const min = @min(
        vk.VK_ANTI_LAG_STAGE_INPUT_AMD,
        vk.VK_ANTI_LAG_STAGE_PRESENT_AMD,
    );
    const max = @max(
        vk.VK_ANTI_LAG_STAGE_INPUT_AMD,
        vk.VK_ANTI_LAG_STAGE_PRESENT_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkQueueFlagBits(extensions: *const Extensions, item: *const vk.VkQueueFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUEUE_GRAPHICS_BIT |
        vk.VK_QUEUE_COMPUTE_BIT |
        vk.VK_QUEUE_TRANSFER_BIT |
        vk.VK_QUEUE_SPARSE_BINDING_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_QUEUE_VIDEO_DECODE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_QUEUE_VIDEO_ENCODE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCullModeFlagBits(extensions: *const Extensions, item: *const vk.VkCullModeFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CULL_MODE_NONE |
        vk.VK_CULL_MODE_FRONT_BIT |
        vk.VK_CULL_MODE_BACK_BIT |
        vk.VK_CULL_MODE_FRONT_AND_BACK;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkRenderPassCreateFlagBits(extensions: *const Extensions, item: *const vk.VkRenderPassCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_QCOM_render_pass_transform)
        valid_bits |= vk.VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceQueueCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryPropertyFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryPropertyFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_CACHED_BIT |
        vk.VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryHeapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryHeapFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_MEMORY_HEAP_DEVICE_LOCAL_BIT;
    if (extensions.instance.VK_KHR_device_group_creation)
        valid_bits |= vk.VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAccessFlagBits(extensions: *const Extensions, item: *const vk.VkAccessFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_ACCESS_INDIRECT_COMMAND_READ_BIT |
        vk.VK_ACCESS_INDEX_READ_BIT |
        vk.VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT |
        vk.VK_ACCESS_UNIFORM_READ_BIT |
        vk.VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_SHADER_READ_BIT |
        vk.VK_ACCESS_SHADER_WRITE_BIT |
        vk.VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_TRANSFER_READ_BIT |
        vk.VK_ACCESS_TRANSFER_WRITE_BIT |
        vk.VK_ACCESS_HOST_READ_BIT |
        vk.VK_ACCESS_HOST_WRITE_BIT |
        vk.VK_ACCESS_MEMORY_READ_BIT |
        vk.VK_ACCESS_MEMORY_WRITE_BIT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT;
    if (extensions.device.VK_EXT_blend_operation_advanced)
        valid_bits |= vk.VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_NONE_KHR;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBufferUsageFlagBits(extensions: *const Extensions, item: *const vk.VkBufferUsageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUFFER_USAGE_TRANSFER_SRC_BIT |
        vk.VK_BUFFER_USAGE_TRANSFER_DST_BIT |
        vk.VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_INDEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR;
    if (extensions.device.VK_EXT_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBufferUsageFlagBits2(extensions: *const Extensions, item: *const vk.VkBufferUsageFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT |
        vk.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT |
        vk.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBufferCreateFlagBits(extensions: *const Extensions, item: *const vk.VkBufferCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUFFER_CREATE_SPARSE_BINDING_BIT |
        vk.VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT |
        vk.VK_BUFFER_CREATE_SPARSE_ALIASED_BIT;
    if (extensions.device.VK_EXT_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkShaderStageFlagBits(extensions: *const Extensions, item: *const vk.VkShaderStageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SHADER_STAGE_VERTEX_BIT |
        vk.VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT |
        vk.VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT |
        vk.VK_SHADER_STAGE_GEOMETRY_BIT |
        vk.VK_SHADER_STAGE_FRAGMENT_BIT |
        vk.VK_SHADER_STAGE_COMPUTE_BIT |
        vk.VK_SHADER_STAGE_ALL_GRAPHICS |
        vk.VK_SHADER_STAGE_ALL;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_RAYGEN_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_MISS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_CALLABLE_BIT_KHR;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_SHADER_STAGE_TASK_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_SHADER_STAGE_MESH_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageUsageFlagBits(extensions: *const Extensions, item: *const vk.VkImageUsageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_USAGE_TRANSFER_SRC_BIT |
        vk.VK_IMAGE_USAGE_TRANSFER_DST_BIT |
        vk.VK_IMAGE_USAGE_SAMPLED_BIT |
        vk.VK_IMAGE_USAGE_STORAGE_BIT |
        vk.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageCreateFlagBits(extensions: *const Extensions, item: *const vk.VkImageCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_CREATE_SPARSE_BINDING_BIT |
        vk.VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT |
        vk.VK_IMAGE_CREATE_SPARSE_ALIASED_BIT |
        vk.VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT |
        vk.VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance2)
        valid_bits |= vk.VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance2)
        valid_bits |= vk.VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR;
    if (extensions.device.VK_EXT_sample_locations)
        valid_bits |= vk.VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_CREATE_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_bind_memory2)
        valid_bits |= vk.VK_IMAGE_CREATE_ALIAS_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled)
        valid_bits |= vk.VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_image_2d_view_of_3d)
        valid_bits |= vk.VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT;
    if (extensions.device.VK_QCOM_fragment_density_map_offset)
        valid_bits |= vk.VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map_offset)
        valid_bits |= vk.VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageViewCreateFlagBits(extensions: *const Extensions, item: *const vk.VkImageViewCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map2)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSamplerCreateFlagBits(extensions: *const Extensions, item: *const vk.VkSamplerCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_non_seamless_cube_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT |
        vk.VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT |
        vk.VK_PIPELINE_CREATE_DERIVATIVE_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_DISPATCH_BASE_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_executable_properties)
        valid_bits |= vk.VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_executable_properties)
        valid_bits |= vk.VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_LIBRARY_BIT_KHR;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_protected_access)
        valid_bits |= vk.VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_protected_access)
        valid_bits |= vk.VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCreateFlagBits2(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT |
        vk.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT |
        vk.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT |
        vk.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT |
        vk.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT |
        vk.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT |
        vk.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT |
        vk.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT |
        vk.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM;
    if (extensions.device.VK_KHR_pipeline_binary)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineShaderStageCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_subgroup_size_control)
        valid_bits |= vk.VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    if (extensions.device.VK_EXT_subgroup_size_control)
        valid_bits |= vk.VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkColorComponentFlagBits(extensions: *const Extensions, item: *const vk.VkColorComponentFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COLOR_COMPONENT_R_BIT |
        vk.VK_COLOR_COMPONENT_G_BIT |
        vk.VK_COLOR_COMPONENT_B_BIT |
        vk.VK_COLOR_COMPONENT_A_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFenceCreateFlagBits(extensions: *const Extensions, item: *const vk.VkFenceCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_FENCE_CREATE_SIGNALED_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSemaphoreCreateFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFormatFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT |
        vk.VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_BLIT_SRC_BIT |
        vk.VK_FORMAT_FEATURE_BLIT_DST_BIT |
        vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT;
    if (extensions.device.VK_IMG_filter_cubic)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_EXT_sampler_filter_minmax)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_EXT_filter_cubic)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryControlFlagBits(extensions: *const Extensions, item: *const vk.VkQueryControlFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_QUERY_CONTROL_PRECISE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryResultFlagBits(extensions: *const Extensions, item: *const vk.VkQueryResultFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUERY_RESULT_64_BIT |
        vk.VK_QUERY_RESULT_WAIT_BIT |
        vk.VK_QUERY_RESULT_WITH_AVAILABILITY_BIT |
        vk.VK_QUERY_RESULT_PARTIAL_BIT;
    if (extensions.device.VK_KHR_video_queue)
        valid_bits |= vk.VK_QUERY_RESULT_WITH_STATUS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandBufferUsageFlagBits(extensions: *const Extensions, item: *const vk.VkCommandBufferUsageFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT |
        vk.VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT |
        vk.VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryPipelineStatisticFlagBits(extensions: *const Extensions, item: *const vk.VkQueryPipelineStatisticFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryMapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryMapFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_map_memory_placed)
        valid_bits |= vk.VK_MEMORY_MAP_PLACED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageAspectFlagBits(extensions: *const Extensions, item: *const vk.VkImageAspectFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_ASPECT_COLOR_BIT |
        vk.VK_IMAGE_ASPECT_DEPTH_BIT |
        vk.VK_IMAGE_ASPECT_STENCIL_BIT |
        vk.VK_IMAGE_ASPECT_METADATA_BIT;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_0_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_1_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_2_BIT_KHR;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance4)
        valid_bits |= vk.VK_IMAGE_ASPECT_NONE_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSparseImageFormatFlagBits(extensions: *const Extensions, item: *const vk.VkSparseImageFormatFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT |
        vk.VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT |
        vk.VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSparseMemoryBindFlagBits(extensions: *const Extensions, item: *const vk.VkSparseMemoryBindFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SPARSE_MEMORY_BIND_METADATA_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineStageFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineStageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT |
        vk.VK_PIPELINE_STAGE_VERTEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_VERTEX_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
        vk.VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_HOST_BIT |
        vk.VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT |
        vk.VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_NONE_KHR;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_POOL_CREATE_TRANSIENT_BIT |
        vk.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandPoolResetFlagBits(extensions: *const Extensions, item: *const vk.VkCommandPoolResetFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandBufferResetFlagBits(extensions: *const Extensions, item: *const vk.VkCommandBufferResetFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSampleCountFlagBits(extensions: *const Extensions, item: *const vk.VkSampleCountFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SAMPLE_COUNT_1_BIT |
        vk.VK_SAMPLE_COUNT_2_BIT |
        vk.VK_SAMPLE_COUNT_4_BIT |
        vk.VK_SAMPLE_COUNT_8_BIT |
        vk.VK_SAMPLE_COUNT_16_BIT |
        vk.VK_SAMPLE_COUNT_32_BIT |
        vk.VK_SAMPLE_COUNT_64_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAttachmentDescriptionFlagBits(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkStencilFaceFlagBits(extensions: *const Extensions, item: *const vk.VkStencilFaceFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_STENCIL_FACE_FRONT_BIT |
        vk.VK_STENCIL_FACE_BACK_BIT |
        vk.VK_STENCIL_FACE_FRONT_AND_BACK;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDescriptorPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT;
    if (extensions.device.VK_VALVE_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE;
    if (extensions.device.VK_EXT_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDependencyFlagBits(extensions: *const Extensions, item: *const vk.VkDependencyFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DEPENDENCY_BY_REGION_BIT;
    if (extensions.device.VK_KHR_multiview)
        valid_bits |= vk.VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance8)
        valid_bits |= vk.VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance9)
        valid_bits |= vk.VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkSemaphoreType(extensions: *const Extensions, item: *const vk.VkSemaphoreType) bool {
    const min = @min(
        vk.VK_SEMAPHORE_TYPE_BINARY,
        vk.VK_SEMAPHORE_TYPE_TIMELINE,
    );
    const max = @max(
        vk.VK_SEMAPHORE_TYPE_BINARY,
        vk.VK_SEMAPHORE_TYPE_TIMELINE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_SEMAPHORE_TYPE_BINARY_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_SEMAPHORE_TYPE_TIMELINE_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkSemaphoreWaitFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SEMAPHORE_WAIT_ANY_BIT;
    if (extensions.device.VK_KHR_timeline_semaphore)
        valid_bits |= vk.VK_SEMAPHORE_WAIT_ANY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPresentModeKHR(extensions: *const Extensions, item: *const vk.VkPresentModeKHR) bool {
    const min = @min(
        vk.VK_PRESENT_MODE_IMMEDIATE_KHR,
        vk.VK_PRESENT_MODE_MAILBOX_KHR,
        vk.VK_PRESENT_MODE_FIFO_KHR,
        vk.VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    );
    const max = @max(
        vk.VK_PRESENT_MODE_IMMEDIATE_KHR,
        vk.VK_PRESENT_MODE_MAILBOX_KHR,
        vk.VK_PRESENT_MODE_FIFO_KHR,
        vk.VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR)
        return true;
    if (extensions.device.VK_EXT_present_mode_fifo_latest_ready and item.* == vk.VK_PRESENT_MODE_FIFO_LATEST_READY_EXT)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == vk.VK_PRESENT_MODE_FIFO_LATEST_READY_KHR)
        return true;
    return false;
}

pub fn check_enum_VkColorSpaceKHR(extensions: *const Extensions, item: *const vk.VkColorSpaceKHR) bool {
    const min = vk.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    const max = vk.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT709_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT709_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT2020_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_HDR10_ST2084_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DOLBYVISION_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_HDR10_HLG_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_PASS_THROUGH_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT)
        return true;
    return false;
}

pub fn check_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneAlphaFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkCompositeAlphaFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkSurfaceTransformFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDisplaySurfaceStereoTypeNV(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceStereoTypeNV) bool {
    const min = @min(
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
    );
    const max = @max(
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkSwapchainImageUsageFlagBitsANDROID(extensions: *const Extensions, item: *const vk.VkSwapchainImageUsageFlagBitsANDROID) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkTimeDomainKHR(extensions: *const Extensions, item: *const vk.VkTimeDomainKHR) bool {
    const min = @min(
        vk.VK_TIME_DOMAIN_DEVICE_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
        vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
    );
    const max = @max(
        vk.VK_TIME_DOMAIN_DEVICE_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
        vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_DEVICE_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT)
        return true;
    return false;
}

pub fn check_bitmask_VkDebugReportFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugReportFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEBUG_REPORT_INFORMATION_BIT_EXT |
        vk.VK_DEBUG_REPORT_WARNING_BIT_EXT |
        vk.VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |
        vk.VK_DEBUG_REPORT_ERROR_BIT_EXT |
        vk.VK_DEBUG_REPORT_DEBUG_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDebugReportObjectTypeEXT(extensions: *const Extensions, item: *const vk.VkDebugReportObjectTypeEXT) bool {
    const min = @min(
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    );
    const max = @max(
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT)
        return true;
    return false;
}

pub fn check_enum_VkDeviceMemoryReportEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportEventTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRasterizationOrderAMD(extensions: *const Extensions, item: *const vk.VkRasterizationOrderAMD) bool {
    const min = @min(
        vk.VK_RASTERIZATION_ORDER_STRICT_AMD,
        vk.VK_RASTERIZATION_ORDER_RELAXED_AMD,
    );
    const max = @max(
        vk.VK_RASTERIZATION_ORDER_STRICT_AMD,
        vk.VK_RASTERIZATION_ORDER_RELAXED_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalMemoryFeatureFlagBitsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkClusterAccelerationStructureIndexFormatFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureIndexFormatFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkClusterAccelerationStructureTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureTypeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkClusterAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpTypeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkClusterAccelerationStructureOpModeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpModeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkClusterAccelerationStructureClusterFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureClusterFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkClusterAccelerationStructureGeometryFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGeometryFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkClusterAccelerationStructureAddressResolutionFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureAddressResolutionFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkValidationCheckEXT(extensions: *const Extensions, item: *const vk.VkValidationCheckEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_CHECK_ALL_EXT,
        vk.VK_VALIDATION_CHECK_SHADERS_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_CHECK_ALL_EXT,
        vk.VK_VALIDATION_CHECK_SHADERS_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkValidationFeatureEnableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureEnableEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkValidationFeatureDisableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureDisableEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLayerSettingTypeEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingTypeEXT) bool {
    const min = @min(
        vk.VK_LAYER_SETTING_TYPE_BOOL32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_STRING_EXT,
    );
    const max = @max(
        vk.VK_LAYER_SETTING_TYPE_BOOL32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_STRING_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkSubgroupFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkSubgroupFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SUBGROUP_FEATURE_BASIC_BIT |
        vk.VK_SUBGROUP_FEATURE_VOTE_BIT |
        vk.VK_SUBGROUP_FEATURE_ARITHMETIC_BIT |
        vk.VK_SUBGROUP_FEATURE_BALLOT_BIT |
        vk.VK_SUBGROUP_FEATURE_SHUFFLE_BIT |
        vk.VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT |
        vk.VK_SUBGROUP_FEATURE_CLUSTERED_BIT |
        vk.VK_SUBGROUP_FEATURE_QUAD_BIT;
    if (extensions.device.VK_KHR_shader_subgroup_rotate)
        valid_bits |= vk.VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR;
    if (extensions.device.VK_KHR_shader_subgroup_rotate)
        valid_bits |= vk.VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkIndirectCommandsLayoutUsageFlagBitsNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkIndirectStateFlagBitsNV(extensions: *const Extensions, item: *const vk.VkIndirectStateFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkIndirectCommandsTokenTypeNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeNV) bool {
    const min = @min(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    );
    const max = @max(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV)
        return true;
    return false;
}

pub fn check_bitmask_VkPrivateDataSlotCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDescriptorSetLayoutCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_push_descriptor)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT;
    if (extensions.device.VK_VALVE_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE;
    if (extensions.device.VK_EXT_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR;
    if (extensions.device.VK_EXT_external_memory_dma_buf)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_host)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_host)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalMemoryFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT |
        vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalSemaphoreFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSemaphoreImportFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreImportFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
    if (extensions.device.VK_KHR_external_semaphore)
        valid_bits |= vk.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalFenceHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalFenceFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalFenceFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFenceImportFlagBits(extensions: *const Extensions, item: *const vk.VkFenceImportFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_FENCE_IMPORT_TEMPORARY_BIT;
    if (extensions.device.VK_KHR_external_fence)
        valid_bits |= vk.VK_FENCE_IMPORT_TEMPORARY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSurfaceCounterFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCounterFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SURFACE_COUNTER_VBLANK_BIT_EXT |
        vk.VK_SURFACE_COUNTER_VBLANK_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDisplayPowerStateEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerStateEXT) bool {
    const min = @min(
        vk.VK_DISPLAY_POWER_STATE_OFF_EXT,
        vk.VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
        vk.VK_DISPLAY_POWER_STATE_ON_EXT,
    );
    const max = @max(
        vk.VK_DISPLAY_POWER_STATE_OFF_EXT,
        vk.VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
        vk.VK_DISPLAY_POWER_STATE_ON_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDeviceEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventTypeEXT) bool {
    const min = vk.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
    const max = vk.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDisplayEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventTypeEXT) bool {
    const min = vk.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
    const max = vk.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPeerMemoryFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkPeerMemoryFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT |
        vk.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT |
        vk.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT |
        vk.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryAllocateFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_zero_initialize_device_memory)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSwapchainCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_swapchain)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain_mutable_format)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR;
    if (extensions.device.VK_EXT_swapchain_maintenance1)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT;
    if (extensions.device.VK_KHR_present_id2)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR;
    if (extensions.device.VK_KHR_present_wait2)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain_maintenance1)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkViewportCoordinateSwizzleNV(extensions: *const Extensions, item: *const vk.VkViewportCoordinateSwizzleNV) bool {
    const min = @min(
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    );
    const max = @max(
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDiscardRectangleModeEXT(extensions: *const Extensions, item: *const vk.VkDiscardRectangleModeEXT) bool {
    const min = @min(
        vk.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
        vk.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    );
    const max = @max(
        vk.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
        vk.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkSubpassDescriptionFlagBits(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_QCOM_render_pass_shader_resolve)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM;
    if (extensions.device.VK_QCOM_render_pass_shader_resolve)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPointClippingBehavior(extensions: *const Extensions, item: *const vk.VkPointClippingBehavior) bool {
    const min = @min(
        vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
        vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    );
    const max = @max(
        vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
        vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSamplerReductionMode(extensions: *const Extensions, item: *const vk.VkSamplerReductionMode) bool {
    const min = @min(
        vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
        vk.VK_SAMPLER_REDUCTION_MODE_MIN,
        vk.VK_SAMPLER_REDUCTION_MODE_MAX,
    );
    const max = @max(
        vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
        vk.VK_SAMPLER_REDUCTION_MODE_MIN,
        vk.VK_SAMPLER_REDUCTION_MODE_MAX,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_MIN_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_MAX_EXT)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM)
        return true;
    return false;
}

pub fn check_enum_VkTessellationDomainOrigin(extensions: *const Extensions, item: *const vk.VkTessellationDomainOrigin) bool {
    const min = @min(
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    );
    const max = @max(
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSamplerYcbcrModelConversion(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrModelConversion) bool {
    const min = @min(
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    );
    const max = @max(
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSamplerYcbcrRange(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrRange) bool {
    const min = @min(
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    );
    const max = @max(
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR)
        return true;
    return false;
}

pub fn check_enum_VkChromaLocation(extensions: *const Extensions, item: *const vk.VkChromaLocation) bool {
    const min = @min(
        vk.VK_CHROMA_LOCATION_COSITED_EVEN,
        vk.VK_CHROMA_LOCATION_MIDPOINT,
    );
    const max = @max(
        vk.VK_CHROMA_LOCATION_COSITED_EVEN,
        vk.VK_CHROMA_LOCATION_MIDPOINT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_CHROMA_LOCATION_COSITED_EVEN_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_CHROMA_LOCATION_MIDPOINT_KHR)
        return true;
    return false;
}

pub fn check_enum_VkBlendOverlapEXT(extensions: *const Extensions, item: *const vk.VkBlendOverlapEXT) bool {
    const min = @min(
        vk.VK_BLEND_OVERLAP_UNCORRELATED_EXT,
        vk.VK_BLEND_OVERLAP_DISJOINT_EXT,
        vk.VK_BLEND_OVERLAP_CONJOINT_EXT,
    );
    const max = @max(
        vk.VK_BLEND_OVERLAP_UNCORRELATED_EXT,
        vk.VK_BLEND_OVERLAP_DISJOINT_EXT,
        vk.VK_BLEND_OVERLAP_CONJOINT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCoverageModulationModeNV(extensions: *const Extensions, item: *const vk.VkCoverageModulationModeNV) bool {
    const min = @min(
        vk.VK_COVERAGE_MODULATION_MODE_NONE_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGB_NV,
        vk.VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    );
    const max = @max(
        vk.VK_COVERAGE_MODULATION_MODE_NONE_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGB_NV,
        vk.VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCoverageReductionModeNV(extensions: *const Extensions, item: *const vk.VkCoverageReductionModeNV) bool {
    const min = @min(
        vk.VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
        vk.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
    );
    const max = @max(
        vk.VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
        vk.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkValidationCacheHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheHeaderVersionEXT) bool {
    const min = vk.VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
    const max = vk.VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkShaderInfoTypeAMD(extensions: *const Extensions, item: *const vk.VkShaderInfoTypeAMD) bool {
    const min = @min(
        vk.VK_SHADER_INFO_TYPE_STATISTICS_AMD,
        vk.VK_SHADER_INFO_TYPE_BINARY_AMD,
        vk.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    );
    const max = @max(
        vk.VK_SHADER_INFO_TYPE_STATISTICS_AMD,
        vk.VK_SHADER_INFO_TYPE_BINARY_AMD,
        vk.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkQueueGlobalPriority(extensions: *const Extensions, item: *const vk.VkQueueGlobalPriority) bool {
    const min = @min(
        vk.VK_QUEUE_GLOBAL_PRIORITY_LOW,
        vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
        vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH,
        vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    );
    const max = @max(
        vk.VK_QUEUE_GLOBAL_PRIORITY_LOW,
        vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
        vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH,
        vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkDebugUtilsMessageSeverityFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageSeverityFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDebugUtilsMessageTypeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageTypeFlagBitsEXT) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    if (extensions.device.VK_EXT_device_address_binding_report)
        valid_bits |= vk.VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkConservativeRasterizationModeEXT(extensions: *const Extensions, item: *const vk.VkConservativeRasterizationModeEXT) bool {
    const min = @min(
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    );
    const max = @max(
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkDescriptorBindingFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorBindingFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT |
        vk.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT |
        vk.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT |
        vk.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkVendorId(extensions: *const Extensions, item: *const vk.VkVendorId) bool {
    const min = @min(
        vk.VK_VENDOR_ID_KHRONOS,
        vk.VK_VENDOR_ID_VIV,
        vk.VK_VENDOR_ID_VSI,
        vk.VK_VENDOR_ID_KAZAN,
        vk.VK_VENDOR_ID_CODEPLAY,
        vk.VK_VENDOR_ID_MESA,
        vk.VK_VENDOR_ID_POCL,
        vk.VK_VENDOR_ID_MOBILEYE,
    );
    const max = @max(
        vk.VK_VENDOR_ID_KHRONOS,
        vk.VK_VENDOR_ID_VIV,
        vk.VK_VENDOR_ID_VSI,
        vk.VK_VENDOR_ID_KAZAN,
        vk.VK_VENDOR_ID_CODEPLAY,
        vk.VK_VENDOR_ID_MESA,
        vk.VK_VENDOR_ID_POCL,
        vk.VK_VENDOR_ID_MOBILEYE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDriverId(extensions: *const Extensions, item: *const vk.VkDriverId) bool {
    const min = @min(
        vk.VK_DRIVER_ID_AMD_PROPRIETARY,
        vk.VK_DRIVER_ID_AMD_OPEN_SOURCE,
        vk.VK_DRIVER_ID_MESA_RADV,
        vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY,
        vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
        vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
        vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
        vk.VK_DRIVER_ID_ARM_PROPRIETARY,
        vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
        vk.VK_DRIVER_ID_GGP_PROPRIETARY,
        vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_LLVMPIPE,
        vk.VK_DRIVER_ID_MOLTENVK,
        vk.VK_DRIVER_ID_COREAVI_PROPRIETARY,
        vk.VK_DRIVER_ID_JUICE_PROPRIETARY,
        vk.VK_DRIVER_ID_VERISILICON_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_TURNIP,
        vk.VK_DRIVER_ID_MESA_V3DV,
        vk.VK_DRIVER_ID_MESA_PANVK,
        vk.VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_VENUS,
        vk.VK_DRIVER_ID_MESA_DOZEN,
        vk.VK_DRIVER_ID_MESA_NVK,
        vk.VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_MESA_HONEYKRISP,
        vk.VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
    );
    const max = @max(
        vk.VK_DRIVER_ID_AMD_PROPRIETARY,
        vk.VK_DRIVER_ID_AMD_OPEN_SOURCE,
        vk.VK_DRIVER_ID_MESA_RADV,
        vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY,
        vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
        vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
        vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
        vk.VK_DRIVER_ID_ARM_PROPRIETARY,
        vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
        vk.VK_DRIVER_ID_GGP_PROPRIETARY,
        vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_LLVMPIPE,
        vk.VK_DRIVER_ID_MOLTENVK,
        vk.VK_DRIVER_ID_COREAVI_PROPRIETARY,
        vk.VK_DRIVER_ID_JUICE_PROPRIETARY,
        vk.VK_DRIVER_ID_VERISILICON_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_TURNIP,
        vk.VK_DRIVER_ID_MESA_V3DV,
        vk.VK_DRIVER_ID_MESA_PANVK,
        vk.VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_VENUS,
        vk.VK_DRIVER_ID_MESA_DOZEN,
        vk.VK_DRIVER_ID_MESA_NVK,
        vk.VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_MESA_HONEYKRISP,
        vk.VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_AMD_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_MESA_RADV_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_ARM_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_GGP_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkConditionalRenderingFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkResolveModeFlagBits(extensions: *const Extensions, item: *const vk.VkResolveModeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_RESOLVE_MODE_NONE |
        vk.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT |
        vk.VK_RESOLVE_MODE_AVERAGE_BIT |
        vk.VK_RESOLVE_MODE_MIN_BIT |
        vk.VK_RESOLVE_MODE_MAX_BIT;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_NONE_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_AVERAGE_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_MIN_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_MAX_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkShadingRatePaletteEntryNV(extensions: *const Extensions, item: *const vk.VkShadingRatePaletteEntryNV) bool {
    const min = @min(
        vk.VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    );
    const max = @max(
        vk.VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCoarseSampleOrderTypeNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleOrderTypeNV) bool {
    const min = @min(
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    );
    const max = @max(
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkGeometryInstanceFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkGeometryInstanceFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkGeometryFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkGeometryFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_GEOMETRY_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAccelerationStructureCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkCopyAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureModeKHR) bool {
    const min = @min(
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    );
    const max = @max(
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBuildAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureModeKHR) bool {
    const min = @min(
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
    );
    const max = @max(
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTypeKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkGeometryTypeKHR(extensions: *const Extensions, item: *const vk.VkGeometryTypeKHR) bool {
    const min = @min(
        vk.VK_GEOMETRY_TYPE_TRIANGLES_KHR,
        vk.VK_GEOMETRY_TYPE_AABBS_KHR,
        vk.VK_GEOMETRY_TYPE_INSTANCES_KHR,
    );
    const max = @max(
        vk.VK_GEOMETRY_TYPE_TRIANGLES_KHR,
        vk.VK_GEOMETRY_TYPE_AABBS_KHR,
        vk.VK_GEOMETRY_TYPE_INSTANCES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureMemoryRequirementsTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMemoryRequirementsTypeNV) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureBuildTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildTypeKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRayTracingShaderGroupTypeKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupTypeKHR) bool {
    const min = @min(
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
    );
    const max = @max(
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCompatibilityKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkShaderGroupShaderKHR(extensions: *const Extensions, item: *const vk.VkShaderGroupShaderKHR) bool {
    const min = @min(
        vk.VK_SHADER_GROUP_SHADER_GENERAL_KHR,
        vk.VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
    );
    const max = @max(
        vk.VK_SHADER_GROUP_SHADER_GENERAL_KHR,
        vk.VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkMemoryOverallocationBehaviorAMD(extensions: *const Extensions, item: *const vk.VkMemoryOverallocationBehaviorAMD) bool {
    const min = @min(
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    );
    const max = @max(
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkFramebufferCreateFlagBits(extensions: *const Extensions, item: *const vk.VkFramebufferCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_imageless_framebuffer)
        valid_bits |= vk.VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_maintenance9)
        valid_bits |= vk.VK_QUERY_POOL_CREATE_RESET_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceDiagnosticsConfigFlagBitsNV(extensions: *const Extensions, item: *const vk.VkDeviceDiagnosticsConfigFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCreationFeedbackFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT |
        vk.VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT |
        vk.VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkFullScreenExclusiveEXT) bool {
    const min = @min(
        vk.VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
    );
    const max = @max(
        vk.VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceCounterScopeKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterScopeKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_QUERY_SCOPE_RENDER_PASS_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_QUERY_SCOPE_RENDER_PASS_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkMemoryDecompressionMethodFlagBitsNV(extensions: *const Extensions, item: *const vk.VkMemoryDecompressionMethodFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPerformanceCounterUnitKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterUnitKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceCounterStorageKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterStorageKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPerformanceCounterDescriptionFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAcquireProfilingLockFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkShaderCorePropertiesFlagBitsAMD(extensions: *const Extensions, item: *const vk.VkShaderCorePropertiesFlagBitsAMD) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkRefreshObjectFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPerformanceConfigurationTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationTypeINTEL) bool {
    const min = vk.VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
    const max = vk.VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkQueryPoolSamplingModeINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolSamplingModeINTEL) bool {
    const min = vk.VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
    const max = vk.VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceOverrideTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceParameterTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceParameterTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
        vk.VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
        vk.VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceValueTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkShaderFloatControlsIndependence(extensions: *const Extensions, item: *const vk.VkShaderFloatControlsIndependence) bool {
    const min = @min(
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
    );
    const max = @max(
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkPipelineExecutableStatisticFormatKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticFormatKHR) bool {
    const min = @min(
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
    );
    const max = @max(
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLineRasterizationMode(extensions: *const Extensions, item: *const vk.VkLineRasterizationMode) bool {
    const min = @min(
        vk.VK_LINE_RASTERIZATION_MODE_DEFAULT,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
        vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
    );
    const max = @max(
        vk.VK_LINE_RASTERIZATION_MODE_DEFAULT,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
        vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkShaderModuleCreateFlagBits(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCompilerControlFlagBitsAMD(extensions: *const Extensions, item: *const vk.VkPipelineCompilerControlFlagBitsAMD) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkFaultLevel(extensions: *const Extensions, item: *const vk.VkFaultLevel) bool {
    const min = @min(
        vk.VK_FAULT_LEVEL_UNASSIGNED,
        vk.VK_FAULT_LEVEL_CRITICAL,
        vk.VK_FAULT_LEVEL_RECOVERABLE,
        vk.VK_FAULT_LEVEL_WARNING,
    );
    const max = @max(
        vk.VK_FAULT_LEVEL_UNASSIGNED,
        vk.VK_FAULT_LEVEL_CRITICAL,
        vk.VK_FAULT_LEVEL_RECOVERABLE,
        vk.VK_FAULT_LEVEL_WARNING,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFaultType(extensions: *const Extensions, item: *const vk.VkFaultType) bool {
    const min = @min(
        vk.VK_FAULT_TYPE_INVALID,
        vk.VK_FAULT_TYPE_UNASSIGNED,
        vk.VK_FAULT_TYPE_IMPLEMENTATION,
        vk.VK_FAULT_TYPE_SYSTEM,
        vk.VK_FAULT_TYPE_PHYSICAL_DEVICE,
        vk.VK_FAULT_TYPE_COMMAND_BUFFER_FULL,
        vk.VK_FAULT_TYPE_INVALID_API_USAGE,
    );
    const max = @max(
        vk.VK_FAULT_TYPE_INVALID,
        vk.VK_FAULT_TYPE_UNASSIGNED,
        vk.VK_FAULT_TYPE_IMPLEMENTATION,
        vk.VK_FAULT_TYPE_SYSTEM,
        vk.VK_FAULT_TYPE_PHYSICAL_DEVICE,
        vk.VK_FAULT_TYPE_COMMAND_BUFFER_FULL,
        vk.VK_FAULT_TYPE_INVALID_API_USAGE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFaultQueryBehavior(extensions: *const Extensions, item: *const vk.VkFaultQueryBehavior) bool {
    const min = vk.VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS;
    const max = vk.VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkToolPurposeFlagBits(extensions: *const Extensions, item: *const vk.VkToolPurposeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_TOOL_PURPOSE_VALIDATION_BIT |
        vk.VK_TOOL_PURPOSE_PROFILING_BIT |
        vk.VK_TOOL_PURPOSE_TRACING_BIT |
        vk.VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT |
        vk.VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_VALIDATION_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_PROFILING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_TRACING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPipelineMatchControl(extensions: *const Extensions, item: *const vk.VkPipelineMatchControl) bool {
    const min = vk.VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH;
    const max = vk.VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFragmentShadingRateCombinerOpKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateCombinerOpKHR) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFragmentShadingRateNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateNV) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFragmentShadingRateTypeNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateTypeNV) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSubpassMergeStatusEXT(extensions: *const Extensions, item: *const vk.VkSubpassMergeStatusEXT) bool {
    const min = @min(
        vk.VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
    );
    const max = @max(
        vk.VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkAccessFlagBits2(extensions: *const Extensions, item: *const vk.VkAccessFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_ACCESS_2_NONE |
        vk.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT |
        vk.VK_ACCESS_2_INDEX_READ_BIT |
        vk.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT |
        vk.VK_ACCESS_2_UNIFORM_READ_BIT |
        vk.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_SHADER_READ_BIT |
        vk.VK_ACCESS_2_SHADER_WRITE_BIT |
        vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_2_TRANSFER_READ_BIT |
        vk.VK_ACCESS_2_TRANSFER_WRITE_BIT |
        vk.VK_ACCESS_2_HOST_READ_BIT |
        vk.VK_ACCESS_2_HOST_WRITE_BIT |
        vk.VK_ACCESS_2_MEMORY_READ_BIT |
        vk.VK_ACCESS_2_MEMORY_WRITE_BIT |
        vk.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT |
        vk.VK_ACCESS_2_SHADER_STORAGE_READ_BIT |
        vk.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_NONE_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INDEX_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_UNIFORM_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFER_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_HOST_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_HOST_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_MEMORY_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_MEMORY_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1)
        valid_bits |= vk.VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_ACCESS_2_MICROMAP_READ_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineStageFlagBits2(extensions: *const Extensions, item: *const vk.VkPipelineStageFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_PIPELINE_STAGE_2_NONE |
        vk.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_2_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_2_HOST_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT |
        vk.VK_PIPELINE_STAGE_2_COPY_BIT |
        vk.VK_PIPELINE_STAGE_2_RESOLVE_BIT |
        vk.VK_PIPELINE_STAGE_2_BLIT_BIT |
        vk.VK_PIPELINE_STAGE_2_CLEAR_BIT |
        vk.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_NONE_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_HOST_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COPY_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_BLIT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSubmitFlagBits(extensions: *const Extensions, item: *const vk.VkSubmitFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SUBMIT_PROTECTED_BIT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_SUBMIT_PROTECTED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkEventCreateFlagBits(extensions: *const Extensions, item: *const vk.VkEventCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineLayoutCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkSciSyncClientTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncClientTypeNV) bool {
    const min = @min(
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV,
    );
    const max = @max(
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSciSyncPrimitiveTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncPrimitiveTypeNV) bool {
    const min = @min(
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV,
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV,
    );
    const max = @max(
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV,
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkProvokingVertexModeEXT(extensions: *const Extensions, item: *const vk.VkProvokingVertexModeEXT) bool {
    const min = @min(
        vk.VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
        vk.VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
    );
    const max = @max(
        vk.VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
        vk.VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPipelineCacheValidationVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheValidationVersion) bool {
    const min = vk.VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE;
    const max = vk.VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureMotionInstanceTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInstanceTypeNV) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPipelineColorBlendStateCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineDepthStencilStateCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkGraphicsPipelineLibraryFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceAddressBindingFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDeviceAddressBindingTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkFrameBoundaryFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPresentScalingFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPresentScalingFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR |
        vk.VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT |
        vk.VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR |
        vk.VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT |
        vk.VK_PRESENT_SCALING_STRETCH_BIT_KHR |
        vk.VK_PRESENT_SCALING_STRETCH_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPresentGravityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPresentGravityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PRESENT_GRAVITY_MIN_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_MIN_BIT_EXT |
        vk.VK_PRESENT_GRAVITY_MAX_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_MAX_BIT_EXT |
        vk.VK_PRESENT_GRAVITY_CENTERED_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_CENTERED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPhysicalDeviceSchedulingControlsFlagBitsARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodecOperationFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_CODEC_OPERATION_NONE_KHR;
    if (extensions.device.VK_KHR_video_encode_h264)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_h265)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_h264)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_h265)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_av1)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_av1)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_vp9)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoChromaSubsamplingFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoChromaSubsamplingFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoComponentBitDepthFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR |
        vk.VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoSessionCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_maintenance2)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoSessionParametersCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoDecodeH264PictureLayoutFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureLayoutFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoCodingControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkQueryResultStatusKHR(extensions: *const Extensions, item: *const vk.VkQueryResultStatusKHR) bool {
    const min = @min(
        vk.VK_QUERY_RESULT_STATUS_ERROR_KHR,
        vk.VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
        vk.VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
    );
    const max = @max(
        vk.VK_QUERY_RESULT_STATUS_ERROR_KHR,
        vk.VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
        vk.VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkVideoDecodeUsageFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_USAGE_DEFAULT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoDecodeCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR |
        vk.VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeUsageFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeContentFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeContentFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkVideoEncodeTuningModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeTuningModeKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkVideoEncodeCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFeedbackFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH264CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH264StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkHostImageCopyFlagBits(extensions: *const Extensions, item: *const vk.VkHostImageCopyFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_HOST_IMAGE_COPY_MEMCPY_BIT |
        vk.VK_HOST_IMAGE_COPY_MEMCPY;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_HOST_IMAGE_COPY_MEMCPY_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPartitionedAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureOpTypeNV) bool {
    const min = @min(
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
    );
    const max = @max(
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPartitionedAccelerationStructureInstanceFlagBitsNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureInstanceFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageFormatConstraintsFlagBitsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsFlagBitsFUCHSIA) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageConstraintsInfoFlagBitsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFlagBitsFUCHSIA) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFormatFeatureFlagBits2(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT |
        vk.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT |
        vk.VK_FORMAT_FEATURE_2_BLIT_DST_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT |
        vk.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT |
        vk.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT |
        vk.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT |
        vk.VK_FORMAT_FEATURE_2_DISJOINT_BIT |
        vk.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkRenderingFlagBits(extensions: *const Extensions, item: *const vk.VkRenderingFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT |
        vk.VK_RENDERING_SUSPENDING_BIT |
        vk.VK_RENDERING_RESUMING_BIT;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_SUSPENDING_BIT_KHR;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_RESUMING_BIT_KHR;
    if (extensions.device.VK_EXT_nested_command_buffer)
        valid_bits |= vk.VK_RENDERING_CONTENTS_INLINE_BIT_EXT;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance7)
        valid_bits |= vk.VK_RENDERING_CONTENTS_INLINE_BIT_KHR;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CtbSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkVideoEncodeAV1PredictionModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PredictionModeKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkVideoEncodeAV1RateControlGroupKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlGroupKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkExportMetalObjectTypeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectTypeFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkInstanceCreateFlagBits(extensions: *const Extensions, item: *const vk.VkInstanceCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.instance.VK_KHR_portability_enumeration)
        valid_bits |= vk.VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageCompressionFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_COMPRESSION_DEFAULT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT |
        vk.VK_IMAGE_COMPRESSION_DISABLED_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFixedRateFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPipelineRobustnessBufferBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessBufferBehavior) bool {
    const min = @min(
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
    );
    const max = @max(
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT)
        return true;
    return false;
}

pub fn check_enum_VkPipelineRobustnessImageBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessImageBehavior) bool {
    const min = @min(
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
    );
    const max = @max(
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT)
        return true;
    return false;
}

pub fn check_bitmask_VkOpticalFlowGridSizeFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowGridSizeFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkOpticalFlowUsageFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowUsageFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV |
        vk.VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_COST_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkOpticalFlowPerformanceLevelNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowPerformanceLevelNV) bool {
    const min = @min(
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
    );
    const max = @max(
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOpticalFlowSessionBindingPointNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionBindingPointNV) bool {
    const min = @min(
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
    );
    const max = @max(
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkOpticalFlowSessionCreateFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreateFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkOpticalFlowExecuteFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowExecuteFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkMicromapTypeEXT(extensions: *const Extensions, item: *const vk.VkMicromapTypeEXT) bool {
    const min = vk.VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT;
    const max = vk.VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkBuildMicromapFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT |
        vk.VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT |
        vk.VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMicromapCreateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkCopyMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapModeEXT) bool {
    const min = @min(
        vk.VK_COPY_MICROMAP_MODE_CLONE_EXT,
        vk.VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_COMPACT_EXT,
    );
    const max = @max(
        vk.VK_COPY_MICROMAP_MODE_CLONE_EXT,
        vk.VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_COMPACT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBuildMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapModeEXT) bool {
    const min = vk.VK_BUILD_MICROMAP_MODE_BUILD_EXT;
    const max = vk.VK_BUILD_MICROMAP_MODE_BUILD_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOpacityMicromapFormatEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapFormatEXT) bool {
    const min = @min(
        vk.VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
        vk.VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
    );
    const max = @max(
        vk.VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
        vk.VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOpacityMicromapSpecialIndexEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapSpecialIndexEXT) bool {
    const min = @min(
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
    );
    const max = @max(
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDepthBiasRepresentationEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationEXT) bool {
    const min = @min(
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
    );
    const max = @max(
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDeviceFaultAddressTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDeviceFaultVendorBinaryHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionEXT) bool {
    const min = vk.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT;
    const max = vk.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkIndirectCommandsLayoutUsageFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkIndirectExecutionSetInfoTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetInfoTypeEXT) bool {
    const min = @min(
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
    );
    const max = @max(
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsInputModeFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT |
        vk.VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkIndirectCommandsTokenTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeEXT) bool {
    const min = @min(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    );
    const max = @max(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT)
        return true;
    return false;
}

pub fn check_enum_VkDisplacementMicromapFormatNV(extensions: *const Extensions, item: *const vk.VkDisplacementMicromapFormatNV) bool {
    const min = @min(
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV,
    );
    const max = @max(
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkShaderCreateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateFlagBitsEXT) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SHADER_CREATE_LINK_STAGE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkShaderCodeTypeEXT(extensions: *const Extensions, item: *const vk.VkShaderCodeTypeEXT) bool {
    const min = @min(
        vk.VK_SHADER_CODE_TYPE_BINARY_EXT,
        vk.VK_SHADER_CODE_TYPE_SPIRV_EXT,
    );
    const max = @max(
        vk.VK_SHADER_CODE_TYPE_BINARY_EXT,
        vk.VK_SHADER_CODE_TYPE_SPIRV_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkScopeKHR(extensions: *const Extensions, item: *const vk.VkScopeKHR) bool {
    const min = @min(
        vk.VK_SCOPE_DEVICE_KHR,
        vk.VK_SCOPE_WORKGROUP_KHR,
        vk.VK_SCOPE_SUBGROUP_KHR,
        vk.VK_SCOPE_QUEUE_FAMILY_KHR,
    );
    const max = @max(
        vk.VK_SCOPE_DEVICE_KHR,
        vk.VK_SCOPE_WORKGROUP_KHR,
        vk.VK_SCOPE_SUBGROUP_KHR,
        vk.VK_SCOPE_QUEUE_FAMILY_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkComponentTypeKHR(extensions: *const Extensions, item: *const vk.VkComponentTypeKHR) bool {
    const min = @min(
        vk.VK_COMPONENT_TYPE_FLOAT16_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT32_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT64_KHR,
        vk.VK_COMPONENT_TYPE_SINT8_KHR,
        vk.VK_COMPONENT_TYPE_SINT16_KHR,
        vk.VK_COMPONENT_TYPE_SINT32_KHR,
        vk.VK_COMPONENT_TYPE_SINT64_KHR,
        vk.VK_COMPONENT_TYPE_UINT8_KHR,
        vk.VK_COMPONENT_TYPE_UINT16_KHR,
        vk.VK_COMPONENT_TYPE_UINT32_KHR,
        vk.VK_COMPONENT_TYPE_UINT64_KHR,
    );
    const max = @max(
        vk.VK_COMPONENT_TYPE_FLOAT16_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT32_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT64_KHR,
        vk.VK_COMPONENT_TYPE_SINT8_KHR,
        vk.VK_COMPONENT_TYPE_SINT16_KHR,
        vk.VK_COMPONENT_TYPE_SINT32_KHR,
        vk.VK_COMPONENT_TYPE_SINT64_KHR,
        vk.VK_COMPONENT_TYPE_UINT8_KHR,
        vk.VK_COMPONENT_TYPE_UINT16_KHR,
        vk.VK_COMPONENT_TYPE_UINT32_KHR,
        vk.VK_COMPONENT_TYPE_UINT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == vk.VK_COMPONENT_TYPE_BFLOAT16_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT)
        return true;
    return false;
}

pub fn check_enum_VkCubicFilterWeightsQCOM(extensions: *const Extensions, item: *const vk.VkCubicFilterWeightsQCOM) bool {
    const min = @min(
        vk.VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
    );
    const max = @max(
        vk.VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBlockMatchWindowCompareModeQCOM(extensions: *const Extensions, item: *const vk.VkBlockMatchWindowCompareModeQCOM) bool {
    const min = @min(
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
    );
    const max = @max(
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPhysicalDeviceLayeredApiKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiKHR) bool {
    const min = @min(
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
    );
    const max = @max(
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLayeredDriverUnderlyingApiMSFT(extensions: *const Extensions, item: *const vk.VkLayeredDriverUnderlyingApiMSFT) bool {
    const min = @min(
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
    );
    const max = @max(
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLatencyMarkerNV(extensions: *const Extensions, item: *const vk.VkLatencyMarkerNV) bool {
    const min = @min(
        vk.VK_LATENCY_MARKER_SIMULATION_START_NV,
        vk.VK_LATENCY_MARKER_SIMULATION_END_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_PRESENT_END_NV,
        vk.VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
        vk.VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
    );
    const max = @max(
        vk.VK_LATENCY_MARKER_SIMULATION_START_NV,
        vk.VK_LATENCY_MARKER_SIMULATION_END_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_PRESENT_END_NV,
        vk.VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
        vk.VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOutOfBandQueueTypeNV(extensions: *const Extensions, item: *const vk.VkOutOfBandQueueTypeNV) bool {
    const min = @min(
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
    );
    const max = @max(
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkMemoryUnmapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryUnmapFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_map_memory_placed)
        valid_bits |= vk.VK_MEMORY_UNMAP_RESERVE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkWaylandSurfaceCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDepthClampModeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampModeEXT) bool {
    const min = @min(
        vk.VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
        vk.VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
    );
    const max = @max(
        vk.VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
        vk.VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkAccessFlagBits3KHR(extensions: *const Extensions, item: *const vk.VkAccessFlagBits3KHR) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_ACCESS_3_NONE_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkTileShadingRenderPassFlagBitsQCOM(extensions: *const Extensions, item: *const vk.VkTileShadingRenderPassFlagBitsQCOM) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM |
        vk.VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkCooperativeVectorMatrixLayoutNV(extensions: *const Extensions, item: *const vk.VkCooperativeVectorMatrixLayoutNV) bool {
    const min = @min(
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
    );
    const max = @max(
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkTensorCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM |
        vk.VK_TENSOR_CREATE_PROTECTED_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkTensorUsageFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorUsageFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_TENSOR_USAGE_SHADER_BIT_ARM |
        vk.VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM |
        vk.VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM |
        vk.VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkTensorTilingARM(extensions: *const Extensions, item: *const vk.VkTensorTilingARM) bool {
    const min = @min(
        vk.VK_TENSOR_TILING_OPTIMAL_ARM,
        vk.VK_TENSOR_TILING_LINEAR_ARM,
    );
    const max = @max(
        vk.VK_TENSOR_TILING_OPTIMAL_ARM,
        vk.VK_TENSOR_TILING_LINEAR_ARM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkTensorViewCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorViewCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDefaultVertexAttributeValueKHR(extensions: *const Extensions, item: *const vk.VkDefaultVertexAttributeValueKHR) bool {
    const min = @min(
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR,
    );
    const max = @max(
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkDataGraphPipelineSessionCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDataGraphPipelineSessionBindPointARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointARM) bool {
    const min = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM;
    const max = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDataGraphPipelineSessionBindPointTypeARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointTypeARM) bool {
    const min = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM;
    const max = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDataGraphPipelinePropertyARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelinePropertyARM) bool {
    const min = @min(
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM,
    );
    const max = @max(
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkDataGraphPipelineDispatchFlagBitsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineDispatchFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphProcessingEngineTypeARM) bool {
    const min = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM;
    const max = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPhysicalDeviceDataGraphOperationTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphOperationTypeARM) bool {
    const min = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM;
    const max = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}
