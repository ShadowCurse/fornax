// Copyright (c) 2025 Egor Lazarchuk
// SPDX-License-Identifier: MIT
//
// This file is auto generated by gen/vulkan_utils_gen.zig

const std = @import("std");
const vk = @import("volk");
const log = @import("log.zig");

const Allocator = std.mem.Allocator;
pub fn struct_size(@"struct": anytype) usize {
    var size: usize = 0;
    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    const fields = @typeInfo(t).@"struct".fields;
    inline for (fields) |field| {
        switch (field.type) {
            [*c]const u8 => {},
            [*c]const u32 => {
                if (@hasField(t, "codeSize"))
                    size += @field(@"struct", "codeSize");
            },
            [*c]const vk.VkDescriptorSetLayoutBinding => {
                const len = @field(@"struct", "bindingCount");
                size += @sizeOf(vk.VkDescriptorSetLayoutBinding) * len;
                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkDescriptorSetLayout => {
                const len = if (@hasField(t, "descriptorSetCount"))
                    @field(@"struct", "descriptorSetCount")
                else if (@hasField(t, "setLayoutCount"))
                    @field(@"struct", "setLayoutCount");
                size += @sizeOf(*anyopaque) * len;
            },
            [*c]const vk.VkPushConstantRange => {
                const len = @field(@"struct", "pushConstantRangeCount");
                size += @sizeOf(vk.VkPushConstantRange) * len;
                var elements: []const vk.VkPushConstantRange = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkAttachmentDescription => {
                const len = @field(@"struct", "attachmentCount");
                size += @sizeOf(vk.VkAttachmentDescription) * len;
                var elements: []const vk.VkAttachmentDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkSubpassDescription => {
                const len = @field(@"struct", "subpassCount");
                size += @sizeOf(vk.VkSubpassDescription) * len;
                var elements: []const vk.VkSubpassDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkAttachmentReference => {
                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
                    @field(@"struct", "inputAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
                    @field(@"struct", "colorAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
                    if (@field(@"struct", field.name) != null)
                        break :blk @field(@"struct", "colorAttachmentCount")
                    else
                        break :blk 0;
                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
                    @intFromBool(@field(@"struct", field.name) != null)
                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
                    @field(@"struct", "preserveAttachmentCount")
                else
                    @panic("Cannot find length for the VkAttachmentReference array");

                if (len != 0) {
                    size += @sizeOf(vk.VkAttachmentReference) * len;
                    var elements: []const vk.VkAttachmentReference = undefined;
                    elements.ptr = @field(@"struct", field.name);
                    elements.len = len;
                    for (elements) |*binding| size += struct_size(binding);
                }
            },
            [*c]const vk.VkSubpassDependency => {
                const len = @field(@"struct", "dependencyCount");
                size += @sizeOf(vk.VkSubpassDependency) * len;
                var elements: []const vk.VkSubpassDependency = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkPipelineShaderStageCreateInfo => {
                const len = @field(@"struct", "stageCount");
                size += @sizeOf(vk.VkPipelineShaderStageCreateInfo) * len;
                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkSpecializationMapEntry => {
                const len = @field(@"struct", "mapEntryCount");
                size += @sizeOf(vk.VkSpecializationMapEntry) * len;
                var elements: []const vk.VkSpecializationMapEntry = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
            [*c]const vk.VkPipelineTessellationStateCreateInfo,
            [*c]const vk.VkPipelineViewportStateCreateInfo,
            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
            [*c]const vk.VkPipelineDynamicStateCreateInfo,
            [*c]const vk.VkSpecializationInfo,
            [*c]const vk.VkViewport,
            [*c]const vk.VkRect2D,
            => {
                const element_type = @typeInfo(field.type).pointer.child;
                const element: ?*const element_type = @field(@"struct", field.name);
                if (element) |e| size += struct_size(e);
            },
            else => size += @sizeOf(field.type),
        }
    }
    return size;
}

pub fn print_struct(@"struct": anytype) void {
    print_struct_inner("", @"struct", 0);
}

fn print_offset_output(offset: u32, comptime format: []const u8, args: anytype) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output(format, args);
}

fn print_offset_struct(offset: u32, field_name: []const u8, @"struct": anytype) void {
    for (0..offset) |_| log.output("    ", .{});
    print_struct_inner(
        field_name,
        @"struct",
        offset,
    );
}

fn print_offset_slice(
    offset: u32,
    field_name: []const u8,
    type_name: []const u8,
    comptime T: type,
    elements: []const T,
) void {
    print_offset_output(offset, "{s}: []{s} = [\n", .{ field_name, type_name });
    defer print_offset_output(offset, "]\n", .{});
    for (elements) |*binding| {
        for (0..offset + 1) |_| log.output("    ", .{});
        print_struct_inner(&.{}, binding, offset + 1);
    }
}

fn print_struct_inner(name: []const u8, @"struct": anytype, base_offset: u32) void {
    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    const type_name = @typeName(t)["cimport.struct_".len..];
    log.output("{s}: {s} = .{{\n", .{ name, type_name });
    const fields = @typeInfo(t).@"struct".fields;
    const fields_base_offset = base_offset + 1;
    inline for (fields) |field| {
        switch (field.type) {
            i16, i32, u32, u64, usize, vk.VkStructureType => {
                print_offset_output(fields_base_offset, "{s}: {s} = {d},\n", .{
                    field.name,
                    @typeName(field.type),
                    @field(@"struct", field.name),
                });
            },
            f32, f64 => {
                print_offset_output(
                    fields_base_offset,
                    "{s}: {d},\n",
                    .{ field.name, @field(@"struct", field.name) },
                );
            },
            vk.VkOffset2D,
            vk.VkExtent2D,
            vk.VkOffset3D,
            vk.VkExtent3D,
            vk.VkPhysicalDeviceFeatures,
            => print_offset_struct(
                fields_base_offset,
                field.name,
                &@field(@"struct", field.name),
            ),
            ?*anyopaque,
            ?*const anyopaque,
            vk.VkBuffer,
            vk.VkImage,
            vk.VkInstance,
            vk.VkPhysicalDevice,
            vk.VkDevice,
            vk.VkQueue,
            vk.VkSemaphore,
            vk.VkCommandBuffer,
            vk.VkFence,
            vk.VkDeviceMemory,
            vk.VkEvent,
            vk.VkQueryPool,
            vk.VkBufferView,
            vk.VkImageView,
            vk.VkShaderModule,
            vk.VkPipelineCache,
            vk.VkPipelineLayout,
            vk.VkPipeline,
            vk.VkRenderPass,
            vk.VkDescriptorSetLayout,
            vk.VkSampler,
            vk.VkDescriptorSet,
            vk.VkDescriptorPool,
            vk.VkFramebuffer,
            vk.VkCommandPool,
            => print_offset_output(
                fields_base_offset,
                "{s}: {?},\n",
                .{ field.name, @field(@"struct", field.name) },
            ),
            [*c]const u8 => print_offset_output(
                fields_base_offset,
                "{s}: {s},\n",
                .{ field.name, @field(@"struct", field.name) },
            ),
            [*c]const u32 => {
                if (@hasField(t, "codeSize")) {
                    const len = @field(@"struct", "codeSize") / @sizeOf(u32);
                    print_offset_output(
                        fields_base_offset,
                        "{s}: {d} instructions,\n",
                        .{ field.name, len },
                    );
                }
            },
            [*c]const vk.VkDescriptorSetLayoutBinding => {
                const len = @field(@"struct", "bindingCount");
                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkDescriptorSetLayoutBinding,
                    elements,
                );
            },
            [*c]const vk.VkDescriptorSetLayout => {
                const len = if (@hasField(t, "descriptorSetCount"))
                    @field(@"struct", "descriptorSetCount")
                else if (@hasField(t, "setLayoutCount"))
                    @field(@"struct", "setLayoutCount");
                var elements: []const *anyopaque = undefined;
                elements.ptr = @ptrCast(@field(@"struct", field.name));
                elements.len = len;
                print_offset_output(
                    fields_base_offset,
                    "{s}: {any},\n",
                    .{ field.name, elements },
                );
            },
            [*c]const vk.VkPushConstantRange => {
                const len = @field(@"struct", "pushConstantRangeCount");
                var elements: []const vk.VkPushConstantRange = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkPushConstantRange,
                    elements,
                );
            },
            [*c]const vk.VkAttachmentDescription => {
                const len = @field(@"struct", "attachmentCount");
                var elements: []const vk.VkAttachmentDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkAttachmentDescription,
                    elements,
                );
            },
            [*c]const vk.VkSubpassDescription => {
                const len = @field(@"struct", "subpassCount");
                var elements: []const vk.VkSubpassDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSubpassDescription,
                    elements,
                );
            },
            [*c]const vk.VkAttachmentReference => {
                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
                    @field(@"struct", "inputAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
                    @field(@"struct", "colorAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
                    if (@field(@"struct", field.name) != null)
                        break :blk @field(@"struct", "colorAttachmentCount")
                    else
                        break :blk 0;
                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
                    @intFromBool(@field(@"struct", field.name) != null)
                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
                    @field(@"struct", "preserveAttachmentCount")
                else
                    @panic("Cannot find length for the VkAttachmentReference array");

                if (len != 0) {
                    var elements: []const vk.VkAttachmentReference = undefined;
                    elements.ptr = @field(@"struct", field.name);
                    elements.len = len;
                    print_offset_slice(
                        fields_base_offset,
                        field.name,
                        type_name,
                        vk.VkAttachmentReference,
                        elements,
                    );
                }
            },
            [*c]const vk.VkSubpassDependency => {
                const len = @field(@"struct", "dependencyCount");
                var elements: []const vk.VkSubpassDependency = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSubpassDependency,
                    elements,
                );
            },
            [*c]const vk.VkPipelineShaderStageCreateInfo => {
                const len = @field(@"struct", "stageCount");
                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkPipelineShaderStageCreateInfo,
                    elements,
                );
            },
            [*c]const vk.VkSpecializationMapEntry => {
                const len = @field(@"struct", "mapEntryCount");
                var elements: []const vk.VkSpecializationMapEntry = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSpecializationMapEntry,
                    elements,
                );
            },
            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
            [*c]const vk.VkPipelineTessellationStateCreateInfo,
            [*c]const vk.VkPipelineViewportStateCreateInfo,
            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
            [*c]const vk.VkPipelineDynamicStateCreateInfo,
            [*c]const vk.VkSpecializationInfo,
            [*c]const vk.VkViewport,
            [*c]const vk.VkRect2D,
            => {
                const element_type = @typeInfo(field.type).pointer.child;
                const element: ?*const element_type = @field(@"struct", field.name);
                if (element) |e|
                    print_offset_struct(fields_base_offset, field.name, e)
                else
                    print_offset_output(
                        fields_base_offset,
                        "{s}: {?},\n",
                        .{ field.name, element },
                    );
            },
            else => log.warn(
                @src(),
                "Cannot format field {s} of type {s}",
                .{ field.name, @typeName(field.type) },
            ),
        }
    }
    for (0..base_offset) |_|
        log.output("    ", .{});
    log.output("}},\n", .{});
}

pub fn print_chain(chain: anytype) void {
    var current: ?*const anyopaque = chain;
    while (current) |c| {
        const base_struct: *const vk.VkBaseInStructure = @ptrCast(@alignCast(c));
        switch (base_struct.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_INFO => {
                const nn: *const vk.VkApplicationInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO => {
                const nn: *const vk.VkInstanceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO => {
                const nn: *const vk.VkSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE => {
                const nn: *const vk.VkMappedMemoryRange = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO => {
                const nn: *const vk.VkBindSparseInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO => {
                const nn: *const vk.VkFenceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO => {
                const nn: *const vk.VkEventCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO => {
                const nn: *const vk.VkQueryPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkBufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO => {
                const nn: *const vk.VkBufferViewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkImageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO => {
                const nn: *const vk.VkImageViewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO => {
                const nn: *const vk.VkShaderModuleCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO => {
                const nn: *const vk.VkPipelineCacheCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineInputAssemblyStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineViewportStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineMultisampleStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDepthStencilStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineColorBlendStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDynamicStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkGraphicsPipelineCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkComputePipelineCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkPipelineLayoutCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO => {
                const nn: *const vk.VkSamplerCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET => {
                const nn: *const vk.VkWriteDescriptorSet = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET => {
                const nn: *const vk.VkCopyDescriptorSet = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO => {
                const nn: *const vk.VkFramebufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO => {
                const nn: *const vk.VkRenderPassCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO => {
                const nn: *const vk.VkCommandPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO => {
                const nn: *const vk.VkCommandBufferAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER => {
                const nn: *const vk.VkBufferMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER => {
                const nn: *const vk.VkImageMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER => {
                const nn: *const vk.VkMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO => {
                const nn: *const vk.VkBindBufferMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO => {
                const nn: *const vk.VkBindImageMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice16BitStorageFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS => {
                const nn: *const vk.VkMemoryDedicatedRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO => {
                const nn: *const vk.VkMemoryAllocateFlagsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupRenderPassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO => {
                const nn: *const vk.VkDeviceGroupSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO => {
                const nn: *const vk.VkDeviceGroupBindSparseInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindBufferMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindImageMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceGroupProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceGroupDeviceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkBufferMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageSparseMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkMemoryRequirements2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkSparseImageMemoryRequirements2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 => {
                const nn: *const vk.VkPhysicalDeviceFeatures2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkImageFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceImageFormatInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 => {
                const nn: *const vk.VkQueueFamilyProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceMemoryProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkSparseImageFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceSparseImageFormatInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePointClippingProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO => {
                const nn: *const vk.VkRenderPassInputAttachmentAspectCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageViewUsageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO => {
                const nn: *const vk.VkRenderPassMultiviewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVariablePointersFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO => {
                const nn: *const vk.VkProtectedSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 => {
                const nn: *const vk.VkDeviceQueueInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO => {
                const nn: *const vk.VkBindImagePlaneMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO => {
                const nn: *const vk.VkImagePlaneMemoryRequirementsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkSamplerYcbcrConversionImageFormatProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO => {
                const nn: *const vk.VkDescriptorUpdateTemplateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalImageFormatInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkExternalImageFormatProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalBufferInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES => {
                const nn: *const vk.VkExternalBufferProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceIDProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryBufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryImageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkExportMemoryAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalFenceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES => {
                const nn: *const vk.VkExternalFenceProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO => {
                const nn: *const vk.VkExportFenceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkExportSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalSemaphoreInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkExternalSemaphoreProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance3Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetLayoutSupport = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO => {
                const nn: *const vk.VkImageFormatListCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 => {
                const nn: *const vk.VkAttachmentDescription2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 => {
                const nn: *const vk.VkAttachmentReference2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 => {
                const nn: *const vk.VkSubpassDescription2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 => {
                const nn: *const vk.VkSubpassDependency2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 => {
                const nn: *const vk.VkRenderPassCreateInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO => {
                const nn: *const vk.VkSubpassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO => {
                const nn: *const vk.VkSubpassEndInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice8BitStorageFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDriverProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicInt64Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat16Int8Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceFloatControlsProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDepthStencilResolveProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE => {
                const nn: *const vk.VkSubpassDescriptionDepthStencilResolve = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageStencilUsageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO => {
                const nn: *const vk.VkSamplerReductionModeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentsCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassAttachmentBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentReferenceStencilLayout = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentDescriptionStencilLayout = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostQueryResetFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreTypeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkTimelineSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO => {
                const nn: *const vk.VkSemaphoreWaitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO => {
                const nn: *const vk.VkSemaphoreSignalInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO => {
                const nn: *const vk.VkBufferDeviceAddressInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO => {
                const nn: *const vk.VkBufferOpaqueCaptureAddressCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO => {
                const nn: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreationFeedbackCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceToolProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePrivateDataFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO => {
                const nn: *const vk.VkDevicePrivateDataCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO => {
                const nn: *const vk.VkPrivateDataSlotCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkBufferMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkImageMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO => {
                const nn: *const vk.VkDependencyInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2 => {
                const nn: *const vk.VkSubmitInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO => {
                const nn: *const vk.VkCommandBufferSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSynchronization2Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImageRobustnessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyBufferInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyBufferToImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyImageToBufferInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 => {
                const nn: *const vk.VkBlitImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 => {
                const nn: *const vk.VkResolveImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2 => {
                const nn: *const vk.VkBufferCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2 => {
                const nn: *const vk.VkImageCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2 => {
                const nn: *const vk.VkImageBlit2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 => {
                const nn: *const vk.VkBufferImageCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 => {
                const nn: *const vk.VkImageResolve2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK => {
                const nn: *const vk.VkWriteDescriptorSetInlineUniformBlock = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INFO => {
                const nn: *const vk.VkRenderingInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO => {
                const nn: *const vk.VkRenderingAttachmentInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO => {
                const nn: *const vk.VkPipelineRenderingCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceRenderingInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 => {
                const nn: *const vk.VkFormatProperties3 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceBufferMemoryRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceImageMemoryRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueGlobalPriorityCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES => {
                const nn: *const vk.VkQueueFamilyGlobalPriorityProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloatControls2Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationLineStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputDivisorStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceIndexTypeUint8Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO => {
                const nn: *const vk.VkMemoryMapInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO => {
                const nn: *const vk.VkMemoryUnmapInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO => {
                const nn: *const vk.VkRenderingAreaInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO => {
                const nn: *const vk.VkDeviceImageSubresourceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 => {
                const nn: *const vk.VkSubresourceLayout2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 => {
                const nn: *const vk.VkImageSubresource2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreateFlags2CreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkBufferUsageFlags2CreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePushDescriptorProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO => {
                const nn: *const vk.VkRenderingAttachmentLocationInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO => {
                const nn: *const vk.VkRenderingInputAttachmentIndexInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS => {
                const nn: *const vk.VkBindMemoryStatus = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO => {
                const nn: *const vk.VkBindDescriptorSetsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO => {
                const nn: *const vk.VkPushConstantsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO => {
                const nn: *const vk.VkPushDescriptorSetInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO => {
                const nn: *const vk.VkPushDescriptorSetWithTemplateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO => {
                const nn: *const vk.VkPipelineRobustnessCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY => {
                const nn: *const vk.VkMemoryToImageCopy = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY => {
                const nn: *const vk.VkImageToMemoryCopy = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO => {
                const nn: *const vk.VkCopyImageToMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyMemoryToImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO => {
                const nn: *const vk.VkHostImageLayoutTransitionInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyImageToImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE => {
                const nn: *const vk.VkSubresourceHostMemcpySize = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY => {
                const nn: *const vk.VkHostImageCopyDevicePerformanceQuery = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR => {
                const nn: *const vk.VkPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR => {
                const nn: *const vk.VkDeviceGroupPresentCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkImageSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR => {
                const nn: *const vk.VkBindImageMemorySwapchainInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR => {
                const nn: *const vk.VkAcquireNextImageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplayModeCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplaySurfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDisplayPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugReportCallbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD => {
                const nn: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectNameInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectTagInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerMarkerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR => {
                const nn: *const vk.VkVideoProfileInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR => {
                const nn: *const vk.VkVideoPictureResourceInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR => {
                const nn: *const vk.VkVideoSessionMemoryRequirementsKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR => {
                const nn: *const vk.VkBindVideoSessionMemoryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersUpdateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoBeginCodingInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoEndCodingInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoCodingControlInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceSlotInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyVideoPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR => {
                const nn: *const vk.VkVideoProfileListInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoFormatInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoDecodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeUsageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationImageCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationBufferCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuFunctionCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX => {
                const nn: *const vk.VkCuLaunchInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleTexturingModeCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX => {
                const nn: *const vk.VkImageViewHandleInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX => {
                const nn: *const vk.VkImageViewAddressPropertiesNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD => {
                const nn: *const vk.VkTextureLODGatherFormatPropertiesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalMemoryImageCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkExportMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT => {
                const nn: *const vk.VkValidationFlagsEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT => {
                const nn: *const vk.VkImageViewASTCDecodeModeEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR => {
                const nn: *const vk.VkImportMemoryFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR => {
                const nn: *const vk.VkMemoryFdPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR => {
                const nn: *const vk.VkMemoryGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR => {
                const nn: *const vk.VkImportSemaphoreFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkSemaphoreGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT => {
                const nn: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT => {
                const nn: *const vk.VkConditionalRenderingBeginInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR => {
                const nn: *const vk.VkPresentRegionsKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportWScalingStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT => {
                const nn: *const vk.VkSurfaceCapabilities2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT => {
                const nn: *const vk.VkDisplayPowerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT => {
                const nn: *const vk.VkDeviceEventInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT => {
                const nn: *const vk.VkDisplayEventInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT => {
                const nn: *const vk.VkSwapchainCounterCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX => {
                const nn: *const vk.VkMultiviewPerViewAttributesInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT => {
                const nn: *const vk.VkHdrMetadataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG => {
                const nn: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR => {
                const nn: *const vk.VkSharedPresentSurfaceCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR => {
                const nn: *const vk.VkImportFenceFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkFenceGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolPerformanceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR => {
                const nn: *const vk.VkPerformanceQuerySubmitInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR => {
                const nn: *const vk.VkAcquireProfilingLockInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR => {
                const nn: *const vk.VkPerformanceCounterKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR => {
                const nn: *const vk.VkPerformanceCounterDescriptionKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR => {
                const nn: *const vk.VkPhysicalDeviceSurfaceInfo2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilities2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR => {
                const nn: *const vk.VkSurfaceFormat2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayModeProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR => {
                const nn: *const vk.VkDisplayPlaneInfo2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneCapabilities2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectNameInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectTagInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT => {
                const nn: *const vk.VkDebugUtilsLabelEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD => {
                const nn: *const vk.VkAttachmentSampleCountInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT => {
                const nn: *const vk.VkSampleLocationsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT => {
                const nn: *const vk.VkRenderPassSampleLocationsBeginInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT => {
                const nn: *const vk.VkMultisamplePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageToColorStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildGeometryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureDeviceAddressInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryAabbsDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryInstancesDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureVersionInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildSizesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageModulationStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesListEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierListCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesList2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderModuleValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_NV => {
                const nn: *const vk.VkGeometryNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV => {
                const nn: *const vk.VkGeometryTrianglesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV => {
                const nn: *const vk.VkGeometryAABBNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV => {
                const nn: *const vk.VkBindAccelerationStructureMemoryInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT => {
                const nn: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT => {
                const nn: *const vk.VkImportMemoryHostPointerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT => {
                const nn: *const vk.VkMemoryHostPointerPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD => {
                const nn: *const vk.VkPipelineCompilerControlCreateInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD => {
                const nn: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV => {
                const nn: *const vk.VkCheckpointDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointProperties2NV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV => {
                const nn: *const vk.VkCheckpointData2NV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL => {
                const nn: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL => {
                const nn: *const vk.VkInitializePerformanceApiInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceMarkerInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceStreamMarkerInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceOverrideInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceConfigurationAcquireInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT => {
                const nn: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT => {
                const nn: *const vk.VkMemoryPriorityAllocateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfaceProtectedCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT => {
                const nn: *const vk.VkBufferDeviceAddressCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT => {
                const nn: *const vk.VkValidationFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageReductionStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV => {
                const nn: *const vk.VkFramebufferMixedSamplesCombinationNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT => {
                const nn: *const vk.VkHeadlessSurfaceCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR => {
                const nn: *const vk.VkPipelineInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR => {
                const nn: *const vk.VkPipelineExecutablePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR => {
                const nn: *const vk.VkPipelineExecutableInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR => {
                const nn: *const vk.VkPipelineExecutableStatisticKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR => {
                const nn: *const vk.VkPipelineExecutableInternalRepresentationKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT => {
                const nn: *const vk.VkMemoryMapPlacedInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV => {
                const nn: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTransformBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT => {
                const nn: *const vk.VkDepthBiasInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT => {
                const nn: *const vk.VkDepthBiasRepresentationInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT => {
                const nn: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceMemoryReportCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerCustomBorderColorCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineLibraryCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentBarrierNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainPresentBarrierCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlLayerInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeUsageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersGetInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV => {
                const nn: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTileShadingCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkPerTileBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM => {
                const nn: *const vk.VkPerTileEndInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM => {
                const nn: *const vk.VkDispatchTileInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV => {
                const nn: *const vk.VkQueryLowLatencySupportNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT => {
                const nn: *const vk.VkDescriptorAddressInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT => {
                const nn: *const vk.VkDescriptorGetInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkBufferCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageViewCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkSamplerCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT => {
                const nn: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT => {
                const nn: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMotionInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCopyCommandTransformInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT => {
                const nn: *const vk.VkImageCompressionControlEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT => {
                const nn: *const vk.VkImageCompressionPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFaultFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT => {
                const nn: *const vk.VkDeviceFaultCountsEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT => {
                const nn: *const vk.VkDeviceFaultInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputBindingDescription2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputAttributeDescription2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDrmPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceAddressBindingCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkMemoryGetRemoteAddressInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT => {
                const nn: *const vk.VkPipelinePropertiesIdentifierEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT => {
                const nn: *const vk.VkFrameBoundaryEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT => {
                const nn: *const vk.VkSubpassResolvePerformanceQueryEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT => {
                const nn: *const vk.VkMultisampledRenderToSingleSampledInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorWriteCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT => {
                const nn: *const vk.VkMicromapVersionInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapToMemoryInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMemoryToMicromapInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkMicromapCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildSizesInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT => {
                const nn: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageViewSlicedCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE => {
                const nn: *const vk.VkDescriptorSetBindingReferenceVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE => {
                const nn: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeBeginInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeSubmitInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV => {
                const nn: *const vk.VkComputePipelineIndirectBufferInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkPipelineIndirectDeviceAddressInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometrySpheresDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM => {
                const nn: *const vk.VkImageViewSampleWeightCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT => {
                const nn: *const vk.VkExternalMemoryAcquireUnmodifiedEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT => {
                const nn: *const vk.VkRenderPassCreationControlEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingInfoLUNARG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingListLUNARG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorViewCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindTensorMemoryInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM => {
                const nn: *const vk.VkWriteDescriptorSetTensorARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM => {
                const nn: *const vk.VkTensorFormatPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM => {
                const nn: *const vk.VkTensorDescriptionARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkTensorMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM => {
                const nn: *const vk.VkTensorMemoryBarrierARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM => {
                const nn: *const vk.VkDeviceTensorMemoryRequirementsARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM => {
                const nn: *const vk.VkCopyTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_COPY_ARM => {
                const nn: *const vk.VkTensorCopyARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM => {
                const nn: *const vk.VkTensorDependencyInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfoTensorARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceExternalTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkExternalTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkExternalMemoryTensorCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM => {
                const nn: *const vk.VkDescriptorGetTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorViewCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM => {
                const nn: *const vk.VkFrameBoundaryTensorsARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT => {
                const nn: *const vk.VkShaderModuleIdentifierEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowExecuteInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD => {
                const nn: *const vk.VkAntiLagDataAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD => {
                const nn: *const vk.VkAntiLagPresentationInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentWait2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR => {
                const nn: *const vk.VkPresentWait2InfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR => {
                const nn: *const vk.VkPipelineBinaryKeyKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR => {
                const nn: *const vk.VkReleaseCapturedPipelineDataInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryDataInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR => {
                const nn: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryHandlesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM => {
                const nn: *const vk.VkTilePropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC => {
                const nn: *const vk.VkAmigoProfilingSubmitInfoSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR => {
                const nn: *const vk.VkSurfacePresentModeKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfacePresentScalingCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR => {
                const nn: *const vk.VkSurfacePresentModeCompatibilityKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentFenceInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModesCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentScalingCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR => {
                const nn: *const vk.VkReleaseSwapchainImagesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV => {
                const nn: *const vk.VkConvertCooperativeVectorMatrixInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT => {
                const nn: *const vk.VkMutableDescriptorTypeCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT => {
                const nn: *const vk.VkLayerSettingsCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV => {
                const nn: *const vk.VkLatencySleepModeInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV => {
                const nn: *const vk.VkLatencySleepInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkSetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkGetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV => {
                const nn: *const vk.VkLatencyTimingsFrameReportNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV => {
                const nn: *const vk.VkOutOfBandQueueTypeInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainLatencyCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV => {
                const nn: *const vk.VkLatencySurfaceCapabilitiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineResourceInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDataGraphFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM => {
                const nn: *const vk.VkDataGraphPipelinePropertyQueryResultARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineDispatchInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphProcessingEngineCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR => {
                const nn: *const vk.VkVideoInlineQueryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerCubicWeightsCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM => {
                const nn: *const vk.VkBlitImageCubicWeightsInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT => {
                const nn: *const vk.VkAttachmentFeedbackLoopInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT => {
                const nn: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR => {
                const nn: *const vk.VkCalibratedTimestampInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT => {
                const nn: *const vk.VkSetDescriptorBufferOffsetsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT => {
                const nn: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM => {
                const nn: *const vk.VkTileMemoryRequirementsQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM => {
                const nn: *const vk.VkTileMemoryBindInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM => {
                const nn: *const vk.VkTileMemorySizeInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV => {
                const nn: *const vk.VkDisplaySurfaceStereoCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV => {
                const nn: *const vk.VkDisplayModeStereoPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatQuantizationMapPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueDeviceCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV => {
                const nn: *const vk.VkExternalComputeQueueDataParamsNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureInputInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureCommandsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureInstancesInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkBuildPartitionedAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureFlagsNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetPipelineEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetShaderEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetPipelineInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsPipelineInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsShaderInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR => {
                const nn: *const vk.VkMemoryBarrierAccessFlags3KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA => {
                const nn: *const vk.VkImageAlignmentControlCreateInfoMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceFormatPackFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE => {
                const nn: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT => {
                const nn: *const vk.VkRenderingEndInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            else => {
                log.warn(@src(), "Unknown struct sType: {d}", .{base_struct.sType});
                current = base_struct.pNext;
            },
        }
    }
}
pub fn chain_size(chain: anytype) usize {
    var size: usize = 0;
    var current: ?*const anyopaque = chain;
    while (current) |c| {
        const base_struct: *const vk.VkBaseInStructure = @ptrCast(@alignCast(c));
        switch (base_struct.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_INFO => {
                const nn: *const vk.VkApplicationInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO => {
                const nn: *const vk.VkInstanceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO => {
                const nn: *const vk.VkSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE => {
                const nn: *const vk.VkMappedMemoryRange = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO => {
                const nn: *const vk.VkBindSparseInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO => {
                const nn: *const vk.VkFenceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO => {
                const nn: *const vk.VkEventCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO => {
                const nn: *const vk.VkQueryPoolCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkBufferCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO => {
                const nn: *const vk.VkBufferViewCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkImageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO => {
                const nn: *const vk.VkImageViewCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO => {
                const nn: *const vk.VkShaderModuleCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO => {
                const nn: *const vk.VkPipelineCacheCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineInputAssemblyStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineViewportStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineMultisampleStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDepthStencilStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineColorBlendStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDynamicStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkGraphicsPipelineCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkComputePipelineCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkPipelineLayoutCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO => {
                const nn: *const vk.VkSamplerCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET => {
                const nn: *const vk.VkWriteDescriptorSet = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET => {
                const nn: *const vk.VkCopyDescriptorSet = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO => {
                const nn: *const vk.VkFramebufferCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO => {
                const nn: *const vk.VkRenderPassCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO => {
                const nn: *const vk.VkCommandPoolCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO => {
                const nn: *const vk.VkCommandBufferAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER => {
                const nn: *const vk.VkBufferMemoryBarrier = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER => {
                const nn: *const vk.VkImageMemoryBarrier = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER => {
                const nn: *const vk.VkMemoryBarrier = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO => {
                const nn: *const vk.VkBindBufferMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO => {
                const nn: *const vk.VkBindImageMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice16BitStorageFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS => {
                const nn: *const vk.VkMemoryDedicatedRequirements = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO => {
                const nn: *const vk.VkMemoryAllocateFlagsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupRenderPassBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO => {
                const nn: *const vk.VkDeviceGroupSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO => {
                const nn: *const vk.VkDeviceGroupBindSparseInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindBufferMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindImageMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceGroupProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceGroupDeviceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkBufferMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageSparseMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkMemoryRequirements2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkSparseImageMemoryRequirements2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 => {
                const nn: *const vk.VkPhysicalDeviceFeatures2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkFormatProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkImageFormatProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceImageFormatInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 => {
                const nn: *const vk.VkQueueFamilyProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceMemoryProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkSparseImageFormatProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceSparseImageFormatInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePointClippingProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO => {
                const nn: *const vk.VkRenderPassInputAttachmentAspectCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageViewUsageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO => {
                const nn: *const vk.VkRenderPassMultiviewCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVariablePointersFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO => {
                const nn: *const vk.VkProtectedSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 => {
                const nn: *const vk.VkDeviceQueueInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO => {
                const nn: *const vk.VkBindImagePlaneMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO => {
                const nn: *const vk.VkImagePlaneMemoryRequirementsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkSamplerYcbcrConversionImageFormatProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO => {
                const nn: *const vk.VkDescriptorUpdateTemplateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalImageFormatInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkExternalImageFormatProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalBufferInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES => {
                const nn: *const vk.VkExternalBufferProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceIDProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryBufferCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryImageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkExportMemoryAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalFenceInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES => {
                const nn: *const vk.VkExternalFenceProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO => {
                const nn: *const vk.VkExportFenceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkExportSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalSemaphoreInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkExternalSemaphoreProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance3Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetLayoutSupport = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO => {
                const nn: *const vk.VkImageFormatListCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 => {
                const nn: *const vk.VkAttachmentDescription2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 => {
                const nn: *const vk.VkAttachmentReference2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 => {
                const nn: *const vk.VkSubpassDescription2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 => {
                const nn: *const vk.VkSubpassDependency2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 => {
                const nn: *const vk.VkRenderPassCreateInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO => {
                const nn: *const vk.VkSubpassBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO => {
                const nn: *const vk.VkSubpassEndInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice8BitStorageFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDriverProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicInt64Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat16Int8Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceFloatControlsProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDepthStencilResolveProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE => {
                const nn: *const vk.VkSubpassDescriptionDepthStencilResolve = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageStencilUsageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO => {
                const nn: *const vk.VkSamplerReductionModeCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentsCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentImageInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassAttachmentBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentReferenceStencilLayout = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentDescriptionStencilLayout = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostQueryResetFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreTypeCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkTimelineSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO => {
                const nn: *const vk.VkSemaphoreWaitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO => {
                const nn: *const vk.VkSemaphoreSignalInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO => {
                const nn: *const vk.VkBufferDeviceAddressInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO => {
                const nn: *const vk.VkBufferOpaqueCaptureAddressCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO => {
                const nn: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreationFeedbackCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceToolProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePrivateDataFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO => {
                const nn: *const vk.VkDevicePrivateDataCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO => {
                const nn: *const vk.VkPrivateDataSlotCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkMemoryBarrier2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkBufferMemoryBarrier2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkImageMemoryBarrier2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO => {
                const nn: *const vk.VkDependencyInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2 => {
                const nn: *const vk.VkSubmitInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO => {
                const nn: *const vk.VkCommandBufferSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSynchronization2Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImageRobustnessFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyBufferInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyBufferToImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyImageToBufferInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 => {
                const nn: *const vk.VkBlitImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 => {
                const nn: *const vk.VkResolveImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2 => {
                const nn: *const vk.VkBufferCopy2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2 => {
                const nn: *const vk.VkImageCopy2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2 => {
                const nn: *const vk.VkImageBlit2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 => {
                const nn: *const vk.VkBufferImageCopy2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 => {
                const nn: *const vk.VkImageResolve2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK => {
                const nn: *const vk.VkWriteDescriptorSetInlineUniformBlock = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INFO => {
                const nn: *const vk.VkRenderingInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO => {
                const nn: *const vk.VkRenderingAttachmentInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO => {
                const nn: *const vk.VkPipelineRenderingCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceRenderingInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 => {
                const nn: *const vk.VkFormatProperties3 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceBufferMemoryRequirements = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceImageMemoryRequirements = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueGlobalPriorityCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES => {
                const nn: *const vk.VkQueueFamilyGlobalPriorityProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloatControls2Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationLineStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputDivisorStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceIndexTypeUint8Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO => {
                const nn: *const vk.VkMemoryMapInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO => {
                const nn: *const vk.VkMemoryUnmapInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO => {
                const nn: *const vk.VkRenderingAreaInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO => {
                const nn: *const vk.VkDeviceImageSubresourceInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 => {
                const nn: *const vk.VkSubresourceLayout2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 => {
                const nn: *const vk.VkImageSubresource2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreateFlags2CreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkBufferUsageFlags2CreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePushDescriptorProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO => {
                const nn: *const vk.VkRenderingAttachmentLocationInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO => {
                const nn: *const vk.VkRenderingInputAttachmentIndexInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS => {
                const nn: *const vk.VkBindMemoryStatus = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO => {
                const nn: *const vk.VkBindDescriptorSetsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO => {
                const nn: *const vk.VkPushConstantsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO => {
                const nn: *const vk.VkPushDescriptorSetInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO => {
                const nn: *const vk.VkPushDescriptorSetWithTemplateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO => {
                const nn: *const vk.VkPipelineRobustnessCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY => {
                const nn: *const vk.VkMemoryToImageCopy = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY => {
                const nn: *const vk.VkImageToMemoryCopy = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO => {
                const nn: *const vk.VkCopyImageToMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyMemoryToImageInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO => {
                const nn: *const vk.VkHostImageLayoutTransitionInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyImageToImageInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE => {
                const nn: *const vk.VkSubresourceHostMemcpySize = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY => {
                const nn: *const vk.VkHostImageCopyDevicePerformanceQuery = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR => {
                const nn: *const vk.VkPresentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR => {
                const nn: *const vk.VkDeviceGroupPresentCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkImageSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR => {
                const nn: *const vk.VkBindImageMemorySwapchainInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR => {
                const nn: *const vk.VkAcquireNextImageInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupPresentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplayModeCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplaySurfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDisplayPresentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugReportCallbackCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD => {
                const nn: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectNameInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectTagInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerMarkerInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR => {
                const nn: *const vk.VkVideoProfileInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR => {
                const nn: *const vk.VkVideoPictureResourceInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR => {
                const nn: *const vk.VkVideoSessionMemoryRequirementsKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR => {
                const nn: *const vk.VkBindVideoSessionMemoryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersUpdateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoBeginCodingInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoEndCodingInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoCodingControlInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceSlotInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyVideoPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR => {
                const nn: *const vk.VkVideoProfileListInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoFormatInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoDecodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeUsageInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationImageCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationBufferCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleCreateInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuFunctionCreateInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX => {
                const nn: *const vk.VkCuLaunchInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleTexturingModeCreateInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX => {
                const nn: *const vk.VkImageViewHandleInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX => {
                const nn: *const vk.VkImageViewAddressPropertiesNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD => {
                const nn: *const vk.VkTextureLODGatherFormatPropertiesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalMemoryImageCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkExportMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT => {
                const nn: *const vk.VkValidationFlagsEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT => {
                const nn: *const vk.VkImageViewASTCDecodeModeEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR => {
                const nn: *const vk.VkImportMemoryFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR => {
                const nn: *const vk.VkMemoryFdPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR => {
                const nn: *const vk.VkMemoryGetFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR => {
                const nn: *const vk.VkImportSemaphoreFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkSemaphoreGetFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT => {
                const nn: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT => {
                const nn: *const vk.VkConditionalRenderingBeginInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR => {
                const nn: *const vk.VkPresentRegionsKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportWScalingStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT => {
                const nn: *const vk.VkSurfaceCapabilities2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT => {
                const nn: *const vk.VkDisplayPowerInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT => {
                const nn: *const vk.VkDeviceEventInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT => {
                const nn: *const vk.VkDisplayEventInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT => {
                const nn: *const vk.VkSwapchainCounterCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX => {
                const nn: *const vk.VkMultiviewPerViewAttributesInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT => {
                const nn: *const vk.VkHdrMetadataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG => {
                const nn: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR => {
                const nn: *const vk.VkSharedPresentSurfaceCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR => {
                const nn: *const vk.VkImportFenceFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkFenceGetFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolPerformanceCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR => {
                const nn: *const vk.VkPerformanceQuerySubmitInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR => {
                const nn: *const vk.VkAcquireProfilingLockInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR => {
                const nn: *const vk.VkPerformanceCounterKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR => {
                const nn: *const vk.VkPerformanceCounterDescriptionKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR => {
                const nn: *const vk.VkPhysicalDeviceSurfaceInfo2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilities2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR => {
                const nn: *const vk.VkSurfaceFormat2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayProperties2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneProperties2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayModeProperties2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR => {
                const nn: *const vk.VkDisplayPlaneInfo2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneCapabilities2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectNameInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectTagInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT => {
                const nn: *const vk.VkDebugUtilsLabelEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCallbackDataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD => {
                const nn: *const vk.VkAttachmentSampleCountInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT => {
                const nn: *const vk.VkSampleLocationsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT => {
                const nn: *const vk.VkRenderPassSampleLocationsBeginInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT => {
                const nn: *const vk.VkMultisamplePropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageToColorStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildGeometryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureDeviceAddressInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryAabbsDataKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryInstancesDataKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureVersionInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildSizesInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageModulationStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesListEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierListCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesList2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderModuleValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_NV => {
                const nn: *const vk.VkGeometryNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV => {
                const nn: *const vk.VkGeometryTrianglesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV => {
                const nn: *const vk.VkGeometryAABBNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV => {
                const nn: *const vk.VkBindAccelerationStructureMemoryInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT => {
                const nn: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT => {
                const nn: *const vk.VkImportMemoryHostPointerInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT => {
                const nn: *const vk.VkMemoryHostPointerPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD => {
                const nn: *const vk.VkPipelineCompilerControlCreateInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD => {
                const nn: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV => {
                const nn: *const vk.VkCheckpointDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointProperties2NV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV => {
                const nn: *const vk.VkCheckpointData2NV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL => {
                const nn: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL => {
                const nn: *const vk.VkInitializePerformanceApiInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceMarkerInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceStreamMarkerInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceOverrideInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceConfigurationAcquireInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT => {
                const nn: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT => {
                const nn: *const vk.VkMemoryPriorityAllocateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfaceProtectedCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT => {
                const nn: *const vk.VkBufferDeviceAddressCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT => {
                const nn: *const vk.VkValidationFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageReductionStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV => {
                const nn: *const vk.VkFramebufferMixedSamplesCombinationNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT => {
                const nn: *const vk.VkHeadlessSurfaceCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR => {
                const nn: *const vk.VkPipelineInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR => {
                const nn: *const vk.VkPipelineExecutablePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR => {
                const nn: *const vk.VkPipelineExecutableInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR => {
                const nn: *const vk.VkPipelineExecutableStatisticKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR => {
                const nn: *const vk.VkPipelineExecutableInternalRepresentationKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT => {
                const nn: *const vk.VkMemoryMapPlacedInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV => {
                const nn: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTransformBeginInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT => {
                const nn: *const vk.VkDepthBiasInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT => {
                const nn: *const vk.VkDepthBiasRepresentationInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT => {
                const nn: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceMemoryReportCallbackDataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerCustomBorderColorCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineLibraryCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentBarrierNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainPresentBarrierCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlLayerInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeUsageInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersGetInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV => {
                const nn: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTileShadingCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkPerTileBeginInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM => {
                const nn: *const vk.VkPerTileEndInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM => {
                const nn: *const vk.VkDispatchTileInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV => {
                const nn: *const vk.VkQueryLowLatencySupportNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT => {
                const nn: *const vk.VkDescriptorAddressInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT => {
                const nn: *const vk.VkDescriptorGetInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkBufferCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageViewCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkSamplerCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT => {
                const nn: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT => {
                const nn: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMotionInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCopyCommandTransformInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT => {
                const nn: *const vk.VkImageCompressionControlEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT => {
                const nn: *const vk.VkImageCompressionPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFaultFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT => {
                const nn: *const vk.VkDeviceFaultCountsEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT => {
                const nn: *const vk.VkDeviceFaultInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputBindingDescription2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputAttributeDescription2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDrmPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceAddressBindingCallbackDataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkMemoryGetRemoteAddressInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT => {
                const nn: *const vk.VkPipelinePropertiesIdentifierEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT => {
                const nn: *const vk.VkFrameBoundaryEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT => {
                const nn: *const vk.VkSubpassResolvePerformanceQueryEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT => {
                const nn: *const vk.VkMultisampledRenderToSingleSampledInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorWriteCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT => {
                const nn: *const vk.VkMicromapVersionInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapToMemoryInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMemoryToMicromapInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkMicromapCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildSizesInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT => {
                const nn: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageViewSlicedCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE => {
                const nn: *const vk.VkDescriptorSetBindingReferenceVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE => {
                const nn: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeBeginInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeSubmitInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV => {
                const nn: *const vk.VkComputePipelineIndirectBufferInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkPipelineIndirectDeviceAddressInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometrySpheresDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM => {
                const nn: *const vk.VkImageViewSampleWeightCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT => {
                const nn: *const vk.VkExternalMemoryAcquireUnmodifiedEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT => {
                const nn: *const vk.VkRenderPassCreationControlEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingInfoLUNARG = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingListLUNARG = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorViewCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindTensorMemoryInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM => {
                const nn: *const vk.VkWriteDescriptorSetTensorARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM => {
                const nn: *const vk.VkTensorFormatPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM => {
                const nn: *const vk.VkTensorDescriptionARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkTensorMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM => {
                const nn: *const vk.VkTensorMemoryBarrierARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM => {
                const nn: *const vk.VkDeviceTensorMemoryRequirementsARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM => {
                const nn: *const vk.VkCopyTensorInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_COPY_ARM => {
                const nn: *const vk.VkTensorCopyARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM => {
                const nn: *const vk.VkTensorDependencyInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfoTensorARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceExternalTensorInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkExternalTensorPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkExternalMemoryTensorCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM => {
                const nn: *const vk.VkDescriptorGetTensorInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorViewCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM => {
                const nn: *const vk.VkFrameBoundaryTensorsARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT => {
                const nn: *const vk.VkShaderModuleIdentifierEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowExecuteInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD => {
                const nn: *const vk.VkAntiLagDataAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD => {
                const nn: *const vk.VkAntiLagPresentationInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentWait2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR => {
                const nn: *const vk.VkPresentWait2InfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR => {
                const nn: *const vk.VkPipelineBinaryKeyKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR => {
                const nn: *const vk.VkReleaseCapturedPipelineDataInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryDataInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR => {
                const nn: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryHandlesInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM => {
                const nn: *const vk.VkTilePropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC => {
                const nn: *const vk.VkAmigoProfilingSubmitInfoSEC = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR => {
                const nn: *const vk.VkSurfacePresentModeKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfacePresentScalingCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR => {
                const nn: *const vk.VkSurfacePresentModeCompatibilityKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentFenceInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModesCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModeInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentScalingCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR => {
                const nn: *const vk.VkReleaseSwapchainImagesInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV => {
                const nn: *const vk.VkConvertCooperativeVectorMatrixInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT => {
                const nn: *const vk.VkMutableDescriptorTypeCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT => {
                const nn: *const vk.VkLayerSettingsCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV => {
                const nn: *const vk.VkLatencySleepModeInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV => {
                const nn: *const vk.VkLatencySleepInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkSetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkGetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV => {
                const nn: *const vk.VkLatencyTimingsFrameReportNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV => {
                const nn: *const vk.VkOutOfBandQueueTypeInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainLatencyCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV => {
                const nn: *const vk.VkLatencySurfaceCapabilitiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineResourceInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDataGraphFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM => {
                const nn: *const vk.VkDataGraphPipelinePropertyQueryResultARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineDispatchInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphProcessingEngineCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR => {
                const nn: *const vk.VkVideoInlineQueryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerCubicWeightsCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM => {
                const nn: *const vk.VkBlitImageCubicWeightsInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT => {
                const nn: *const vk.VkAttachmentFeedbackLoopInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT => {
                const nn: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR => {
                const nn: *const vk.VkCalibratedTimestampInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT => {
                const nn: *const vk.VkSetDescriptorBufferOffsetsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT => {
                const nn: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM => {
                const nn: *const vk.VkTileMemoryRequirementsQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM => {
                const nn: *const vk.VkTileMemoryBindInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM => {
                const nn: *const vk.VkTileMemorySizeInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV => {
                const nn: *const vk.VkDisplaySurfaceStereoCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV => {
                const nn: *const vk.VkDisplayModeStereoPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatQuantizationMapPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueDeviceCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV => {
                const nn: *const vk.VkExternalComputeQueueDataParamsNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureInputInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureCommandsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureInstancesInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkBuildPartitionedAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureFlagsNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetPipelineEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetShaderEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetPipelineInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsPipelineInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsShaderInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR => {
                const nn: *const vk.VkMemoryBarrierAccessFlags3KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA => {
                const nn: *const vk.VkImageAlignmentControlCreateInfoMESA = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceFormatPackFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE => {
                const nn: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT => {
                const nn: *const vk.VkRenderingEndInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            else => {
                log.warn(@src(), "Unknown struct sType: {d}", .{base_struct.sType});
                current = base_struct.pNext;
            },
        }
    }
    return size;
}
pub fn check_result(result: vk.VkResult) !void {
    switch (result) {
        vk.VK_SUCCESS => return,
        vk.VK_NOT_READY => {
            log.err(@src(), "Vulkan error: VK_NOT_READY (A fence or query has not yet completed)", .{});
            return error.VK_NOT_READY;
        },
        vk.VK_TIMEOUT => {
            log.err(@src(), "Vulkan error: VK_TIMEOUT (A wait operation has not completed in the specified time)", .{});
            return error.VK_TIMEOUT;
        },
        vk.VK_EVENT_SET => {
            log.err(@src(), "Vulkan error: VK_EVENT_SET (An event is signaled)", .{});
            return error.VK_EVENT_SET;
        },
        vk.VK_EVENT_RESET => {
            log.err(@src(), "Vulkan error: VK_EVENT_RESET (An event is unsignaled)", .{});
            return error.VK_EVENT_RESET;
        },
        vk.VK_INCOMPLETE => {
            log.err(@src(), "Vulkan error: VK_INCOMPLETE (A return array was too small for the result)", .{});
            return error.VK_INCOMPLETE;
        },
        vk.VK_ERROR_OUT_OF_HOST_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_HOST_MEMORY (A host memory allocation has failed)", .{});
            return error.VK_ERROR_OUT_OF_HOST_MEMORY;
        },
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DEVICE_MEMORY (A device memory allocation has failed)", .{});
            return error.VK_ERROR_OUT_OF_DEVICE_MEMORY;
        },
        vk.VK_ERROR_INITIALIZATION_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_INITIALIZATION_FAILED (Initialization of an object has failed)", .{});
            return error.VK_ERROR_INITIALIZATION_FAILED;
        },
        vk.VK_ERROR_DEVICE_LOST => {
            log.err(@src(), "Vulkan error: VK_ERROR_DEVICE_LOST (The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;)", .{});
            return error.VK_ERROR_DEVICE_LOST;
        },
        vk.VK_ERROR_MEMORY_MAP_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_MEMORY_MAP_FAILED (Mapping of a memory object has failed)", .{});
            return error.VK_ERROR_MEMORY_MAP_FAILED;
        },
        vk.VK_ERROR_LAYER_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_LAYER_NOT_PRESENT (Layer specified does not exist)", .{});
            return error.VK_ERROR_LAYER_NOT_PRESENT;
        },
        vk.VK_ERROR_EXTENSION_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_EXTENSION_NOT_PRESENT (Extension specified does not exist)", .{});
            return error.VK_ERROR_EXTENSION_NOT_PRESENT;
        },
        vk.VK_ERROR_FEATURE_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FEATURE_NOT_PRESENT (Requested feature is not available on this device)", .{});
            return error.VK_ERROR_FEATURE_NOT_PRESENT;
        },
        vk.VK_ERROR_INCOMPATIBLE_DRIVER => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DRIVER (Unable to find a Vulkan driver)", .{});
            return error.VK_ERROR_INCOMPATIBLE_DRIVER;
        },
        vk.VK_ERROR_TOO_MANY_OBJECTS => {
            log.err(@src(), "Vulkan error: VK_ERROR_TOO_MANY_OBJECTS (Too many objects of the type have already been created)", .{});
            return error.VK_ERROR_TOO_MANY_OBJECTS;
        },
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_FORMAT_NOT_SUPPORTED (Requested format is not supported on this device)", .{});
            return error.VK_ERROR_FORMAT_NOT_SUPPORTED;
        },
        vk.VK_ERROR_FRAGMENTED_POOL => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTED_POOL (A requested pool allocation has failed due to fragmentation of the pool's memory)", .{});
            return error.VK_ERROR_FRAGMENTED_POOL;
        },
        vk.VK_ERROR_UNKNOWN => {
            log.err(@src(), "Vulkan error: VK_ERROR_UNKNOWN (An unknown error has occurred, due to an implementation or application bug)", .{});
            return error.VK_ERROR_UNKNOWN;
        },
        vk.VK_ERROR_SURFACE_LOST_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_SURFACE_LOST_KHR (VK_KHR_surface)", .{});
            return error.VK_ERROR_SURFACE_LOST_KHR;
        },
        vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR (VK_KHR_surface)", .{});
            return error.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;
        },
        vk.VK_SUBOPTIMAL_KHR => {
            log.err(@src(), "Vulkan error: VK_SUBOPTIMAL_KHR (VK_KHR_swapchain)", .{});
            return error.VK_SUBOPTIMAL_KHR;
        },
        vk.VK_ERROR_OUT_OF_DATE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR (VK_KHR_swapchain)", .{});
            return error.VK_ERROR_OUT_OF_DATE_KHR;
        },
        vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR (VK_KHR_display_swapchain)", .{});
            return error.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR;
        },
        vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR (VK_KHR_video_queue)", .{});
            return error.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_OUT_OF_POOL_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY (VK_KHR_maintenance1)", .{});
            return error.VK_ERROR_OUT_OF_POOL_MEMORY;
        },
        vk.VK_ERROR_INVALID_EXTERNAL_HANDLE => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE (VK_KHR_external_memory)", .{});
            return error.VK_ERROR_INVALID_EXTERNAL_HANDLE;
        },
        vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT (VK_EXT_image_drm_format_modifier)", .{});
            return error.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT;
        },
        vk.VK_ERROR_FRAGMENTATION => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTATION (VK_EXT_descriptor_indexing)", .{});
            return error.VK_ERROR_FRAGMENTATION;
        },
        vk.VK_ERROR_NOT_PERMITTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_PERMITTED (VK_EXT_global_priority)", .{});
            return error.VK_ERROR_NOT_PERMITTED;
        },
        vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS (VK_EXT_buffer_device_address)", .{});
            return error.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
        },
        vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT (VK_EXT_full_screen_exclusive)", .{});
            return error.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT;
        },
        vk.VK_THREAD_IDLE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_IDLE_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_THREAD_IDLE_KHR;
        },
        vk.VK_THREAD_DONE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_DONE_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_THREAD_DONE_KHR;
        },
        vk.VK_OPERATION_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_DEFERRED_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_OPERATION_DEFERRED_KHR;
        },
        vk.VK_OPERATION_NOT_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_NOT_DEFERRED_KHR (VK_KHR_deferred_host_operations)", .{});
            return error.VK_OPERATION_NOT_DEFERRED_KHR;
        },
        vk.VK_PIPELINE_COMPILE_REQUIRED => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_COMPILE_REQUIRED (VK_EXT_pipeline_creation_cache_control)", .{});
            return error.VK_PIPELINE_COMPILE_REQUIRED;
        },
        vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR (VK_KHR_video_encode_queue)", .{});
            return error.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR;
        },
        vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_COMPRESSION_EXHAUSTED_EXT (VK_EXT_image_compression_control)", .{});
            return error.VK_ERROR_COMPRESSION_EXHAUSTED_EXT;
        },
        vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT => {
            log.err(@src(), "Vulkan error: VK_INCOMPATIBLE_SHADER_BINARY_EXT (VK_EXT_shader_object)", .{});
            return error.VK_INCOMPATIBLE_SHADER_BINARY_EXT;
        },
        vk.VK_PIPELINE_BINARY_MISSING_KHR => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_BINARY_MISSING_KHR (VK_KHR_pipeline_binary)", .{});
            return error.VK_PIPELINE_BINARY_MISSING_KHR;
        },
        vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_ENOUGH_SPACE_KHR (VK_KHR_pipeline_binary)", .{});
            return error.VK_ERROR_NOT_ENOUGH_SPACE_KHR;
        },
        else => {
            log.err(@src(), "Vulkan error: UNKNOWN {}", .{result});
            return error.UNKNOWN;
        },
    }
}
pub const Extensions = struct {
    instance: packed struct(u25) {
        VK_KHR_surface: bool = false,
        VK_KHR_display: bool = false,
        VK_EXT_debug_report: bool = false,
        VK_KHR_get_physical_device_properties2: bool = false,
        VK_EXT_validation_flags: bool = false,
        VK_KHR_device_group_creation: bool = false,
        VK_KHR_external_memory_capabilities: bool = false,
        VK_KHR_external_semaphore_capabilities: bool = false,
        VK_EXT_direct_mode_display: bool = false,
        VK_EXT_display_surface_counter: bool = false,
        VK_EXT_swapchain_colorspace: bool = false,
        VK_KHR_external_fence_capabilities: bool = false,
        VK_KHR_get_surface_capabilities2: bool = false,
        VK_KHR_get_display_properties2: bool = false,
        VK_EXT_debug_utils: bool = false,
        VK_EXT_metal_surface: bool = false,
        VK_KHR_surface_protected_capabilities: bool = false,
        VK_EXT_validation_features: bool = false,
        VK_EXT_headless_surface: bool = false,
        VK_EXT_surface_maintenance1: bool = false,
        VK_EXT_acquire_drm_display: bool = false,
        VK_EXT_directfb_surface: bool = false,
        VK_KHR_portability_enumeration: bool = false,
        VK_KHR_surface_maintenance1: bool = false,
        VK_EXT_layer_settings: bool = false,
    } = .{},
    device: packed struct(u257) {
        VK_KHR_swapchain: bool = false,
        VK_KHR_display_swapchain: bool = false,
        VK_EXT_depth_range_unrestricted: bool = false,
        VK_IMG_filter_cubic: bool = false,
        VK_EXT_debug_marker: bool = false,
        VK_KHR_video_queue: bool = false,
        VK_KHR_video_decode_queue: bool = false,
        VK_EXT_transform_feedback: bool = false,
        VK_KHR_video_encode_h264: bool = false,
        VK_KHR_video_encode_h265: bool = false,
        VK_KHR_video_decode_h264: bool = false,
        VK_KHR_dynamic_rendering: bool = false,
        VK_KHR_multiview: bool = false,
        VK_IMG_format_pvrtc: bool = false,
        VK_KHR_device_group: bool = false,
        VK_KHR_shader_draw_parameters: bool = false,
        VK_EXT_shader_subgroup_ballot: bool = false,
        VK_EXT_shader_subgroup_vote: bool = false,
        VK_EXT_texture_compression_astc_hdr: bool = false,
        VK_EXT_astc_decode_mode: bool = false,
        VK_EXT_pipeline_robustness: bool = false,
        VK_KHR_maintenance1: bool = false,
        VK_KHR_external_memory: bool = false,
        VK_KHR_external_memory_fd: bool = false,
        VK_KHR_external_semaphore: bool = false,
        VK_KHR_external_semaphore_fd: bool = false,
        VK_KHR_push_descriptor: bool = false,
        VK_EXT_conditional_rendering: bool = false,
        VK_KHR_shader_float16_int8: bool = false,
        VK_KHR_16bit_storage: bool = false,
        VK_KHR_incremental_present: bool = false,
        VK_KHR_descriptor_update_template: bool = false,
        VK_EXT_display_control: bool = false,
        VK_EXT_discard_rectangles: bool = false,
        VK_EXT_conservative_rasterization: bool = false,
        VK_EXT_depth_clip_enable: bool = false,
        VK_EXT_hdr_metadata: bool = false,
        VK_KHR_imageless_framebuffer: bool = false,
        VK_KHR_create_renderpass2: bool = false,
        VK_IMG_relaxed_line_rasterization: bool = false,
        VK_KHR_shared_presentable_image: bool = false,
        VK_KHR_external_fence: bool = false,
        VK_KHR_external_fence_fd: bool = false,
        VK_KHR_maintenance2: bool = false,
        VK_KHR_variable_pointers: bool = false,
        VK_EXT_external_memory_dma_buf: bool = false,
        VK_EXT_queue_family_foreign: bool = false,
        VK_KHR_dedicated_allocation: bool = false,
        VK_EXT_sampler_filter_minmax: bool = false,
        VK_KHR_storage_buffer_storage_class: bool = false,
        VK_EXT_inline_uniform_block: bool = false,
        VK_EXT_shader_stencil_export: bool = false,
        VK_KHR_shader_bfloat16: bool = false,
        VK_EXT_sample_locations: bool = false,
        VK_KHR_relaxed_block_layout: bool = false,
        VK_KHR_get_memory_requirements2: bool = false,
        VK_KHR_image_format_list: bool = false,
        VK_EXT_blend_operation_advanced: bool = false,
        VK_KHR_acceleration_structure: bool = false,
        VK_KHR_ray_tracing_pipeline: bool = false,
        VK_KHR_ray_query: bool = false,
        VK_EXT_post_depth_coverage: bool = false,
        VK_KHR_sampler_ycbcr_conversion: bool = false,
        VK_KHR_bind_memory2: bool = false,
        VK_EXT_image_drm_format_modifier: bool = false,
        VK_EXT_validation_cache: bool = false,
        VK_EXT_descriptor_indexing: bool = false,
        VK_EXT_shader_viewport_index_layer: bool = false,
        VK_KHR_maintenance3: bool = false,
        VK_KHR_draw_indirect_count: bool = false,
        VK_EXT_filter_cubic: bool = false,
        VK_QCOM_render_pass_shader_resolve: bool = false,
        VK_EXT_global_priority: bool = false,
        VK_KHR_shader_subgroup_extended_types: bool = false,
        VK_KHR_8bit_storage: bool = false,
        VK_EXT_external_memory_host: bool = false,
        VK_KHR_shader_atomic_int64: bool = false,
        VK_KHR_shader_clock: bool = false,
        VK_EXT_calibrated_timestamps: bool = false,
        VK_KHR_video_decode_h265: bool = false,
        VK_KHR_global_priority: bool = false,
        VK_EXT_vertex_attribute_divisor: bool = false,
        VK_EXT_pipeline_creation_feedback: bool = false,
        VK_KHR_driver_properties: bool = false,
        VK_KHR_shader_float_controls: bool = false,
        VK_KHR_depth_stencil_resolve: bool = false,
        VK_KHR_swapchain_mutable_format: bool = false,
        VK_KHR_timeline_semaphore: bool = false,
        VK_INTEL_shader_integer_functions2: bool = false,
        VK_INTEL_performance_query: bool = false,
        VK_KHR_vulkan_memory_model: bool = false,
        VK_EXT_pci_bus_info: bool = false,
        VK_KHR_shader_terminate_invocation: bool = false,
        VK_EXT_fragment_density_map: bool = false,
        VK_EXT_scalar_block_layout: bool = false,
        VK_EXT_subgroup_size_control: bool = false,
        VK_KHR_fragment_shading_rate: bool = false,
        VK_KHR_dynamic_rendering_local_read: bool = false,
        VK_EXT_shader_image_atomic_int64: bool = false,
        VK_KHR_shader_quad_control: bool = false,
        VK_KHR_spirv_1_4: bool = false,
        VK_EXT_memory_budget: bool = false,
        VK_EXT_memory_priority: bool = false,
        VK_KHR_separate_depth_stencil_layouts: bool = false,
        VK_EXT_buffer_device_address: bool = false,
        VK_EXT_tooling_info: bool = false,
        VK_EXT_separate_stencil_usage: bool = false,
        VK_KHR_present_wait: bool = false,
        VK_EXT_fragment_shader_interlock: bool = false,
        VK_EXT_ycbcr_image_arrays: bool = false,
        VK_KHR_uniform_buffer_standard_layout: bool = false,
        VK_EXT_provoking_vertex: bool = false,
        VK_EXT_full_screen_exclusive: bool = false,
        VK_KHR_buffer_device_address: bool = false,
        VK_EXT_line_rasterization: bool = false,
        VK_EXT_shader_atomic_float: bool = false,
        VK_EXT_host_query_reset: bool = false,
        VK_EXT_index_type_uint8: bool = false,
        VK_EXT_extended_dynamic_state: bool = false,
        VK_KHR_deferred_host_operations: bool = false,
        VK_KHR_pipeline_executable_properties: bool = false,
        VK_EXT_host_image_copy: bool = false,
        VK_KHR_map_memory2: bool = false,
        VK_EXT_map_memory_placed: bool = false,
        VK_EXT_shader_atomic_float2: bool = false,
        VK_EXT_swapchain_maintenance1: bool = false,
        VK_EXT_shader_demote_to_helper_invocation: bool = false,
        VK_KHR_shader_integer_dot_product: bool = false,
        VK_EXT_texel_buffer_alignment: bool = false,
        VK_QCOM_render_pass_transform: bool = false,
        VK_EXT_depth_bias_control: bool = false,
        VK_EXT_device_memory_report: bool = false,
        VK_EXT_robustness2: bool = false,
        VK_EXT_custom_border_color: bool = false,
        VK_KHR_pipeline_library: bool = false,
        VK_KHR_shader_non_semantic_info: bool = false,
        VK_KHR_present_id: bool = false,
        VK_EXT_private_data: bool = false,
        VK_EXT_pipeline_creation_cache_control: bool = false,
        VK_KHR_video_encode_queue: bool = false,
        VK_QCOM_render_pass_store_ops: bool = false,
        VK_QCOM_tile_shading: bool = false,
        VK_EXT_metal_objects: bool = false,
        VK_KHR_synchronization2: bool = false,
        VK_EXT_descriptor_buffer: bool = false,
        VK_EXT_graphics_pipeline_library: bool = false,
        VK_KHR_fragment_shader_barycentric: bool = false,
        VK_KHR_shader_subgroup_uniform_control_flow: bool = false,
        VK_KHR_zero_initialize_workgroup_memory: bool = false,
        VK_EXT_mesh_shader: bool = false,
        VK_EXT_ycbcr_2plane_444_formats: bool = false,
        VK_EXT_fragment_density_map2: bool = false,
        VK_QCOM_rotated_copy_commands: bool = false,
        VK_EXT_image_robustness: bool = false,
        VK_KHR_workgroup_memory_explicit_layout: bool = false,
        VK_KHR_copy_commands2: bool = false,
        VK_EXT_image_compression_control: bool = false,
        VK_EXT_attachment_feedback_loop_layout: bool = false,
        VK_EXT_4444_formats: bool = false,
        VK_EXT_device_fault: bool = false,
        VK_EXT_rgba10x6_formats: bool = false,
        VK_VALVE_mutable_descriptor_type: bool = false,
        VK_EXT_vertex_input_dynamic_state: bool = false,
        VK_EXT_physical_device_drm: bool = false,
        VK_EXT_device_address_binding_report: bool = false,
        VK_EXT_depth_clip_control: bool = false,
        VK_EXT_primitive_topology_list_restart: bool = false,
        VK_KHR_format_feature_flags2: bool = false,
        VK_EXT_present_mode_fifo_latest_ready: bool = false,
        VK_EXT_pipeline_properties: bool = false,
        VK_EXT_frame_boundary: bool = false,
        VK_EXT_multisampled_render_to_single_sampled: bool = false,
        VK_EXT_extended_dynamic_state2: bool = false,
        VK_EXT_color_write_enable: bool = false,
        VK_EXT_primitives_generated_query: bool = false,
        VK_KHR_ray_tracing_maintenance1: bool = false,
        VK_EXT_global_priority_query: bool = false,
        VK_EXT_image_view_min_lod: bool = false,
        VK_EXT_multi_draw: bool = false,
        VK_EXT_image_2d_view_of_3d: bool = false,
        VK_EXT_shader_tile_image: bool = false,
        VK_EXT_opacity_micromap: bool = false,
        VK_EXT_load_store_op_none: bool = false,
        VK_EXT_border_color_swizzle: bool = false,
        VK_EXT_pageable_device_local_memory: bool = false,
        VK_KHR_maintenance4: bool = false,
        VK_KHR_shader_subgroup_rotate: bool = false,
        VK_EXT_image_sliced_view_of_3d: bool = false,
        VK_VALVE_descriptor_set_host_mapping: bool = false,
        VK_EXT_depth_clamp_zero_one: bool = false,
        VK_EXT_non_seamless_cube_map: bool = false,
        VK_QCOM_fragment_density_map_offset: bool = false,
        VK_KHR_shader_maximal_reconvergence: bool = false,
        VK_EXT_image_compression_control_swapchain: bool = false,
        VK_QCOM_image_processing: bool = false,
        VK_EXT_nested_command_buffer: bool = false,
        VK_EXT_external_memory_acquire_unmodified: bool = false,
        VK_EXT_extended_dynamic_state3: bool = false,
        VK_EXT_subpass_merge_feedback: bool = false,
        VK_EXT_shader_module_identifier: bool = false,
        VK_EXT_rasterization_order_attachment_access: bool = false,
        VK_EXT_legacy_dithering: bool = false,
        VK_EXT_pipeline_protected_access: bool = false,
        VK_KHR_maintenance5: bool = false,
        VK_KHR_present_id2: bool = false,
        VK_KHR_present_wait2: bool = false,
        VK_KHR_ray_tracing_position_fetch: bool = false,
        VK_EXT_shader_object: bool = false,
        VK_KHR_pipeline_binary: bool = false,
        VK_QCOM_tile_properties: bool = false,
        VK_KHR_swapchain_maintenance1: bool = false,
        VK_QCOM_multiview_per_view_viewports: bool = false,
        VK_EXT_mutable_descriptor_type: bool = false,
        VK_EXT_legacy_vertex_attributes: bool = false,
        VK_EXT_pipeline_library_group_handles: bool = false,
        VK_EXT_dynamic_rendering_unused_attachments: bool = false,
        VK_KHR_cooperative_matrix: bool = false,
        VK_QCOM_multiview_per_view_render_areas: bool = false,
        VK_KHR_compute_shader_derivatives: bool = false,
        VK_KHR_video_decode_av1: bool = false,
        VK_KHR_video_encode_av1: bool = false,
        VK_KHR_video_decode_vp9: bool = false,
        VK_KHR_video_maintenance1: bool = false,
        VK_QCOM_image_processing2: bool = false,
        VK_QCOM_filter_cubic_weights: bool = false,
        VK_QCOM_ycbcr_degamma: bool = false,
        VK_QCOM_filter_cubic_clamp: bool = false,
        VK_EXT_attachment_feedback_loop_dynamic_state: bool = false,
        VK_KHR_vertex_attribute_divisor: bool = false,
        VK_KHR_load_store_op_none: bool = false,
        VK_KHR_unified_image_layouts: bool = false,
        VK_KHR_shader_float_controls2: bool = false,
        VK_KHR_index_type_uint8: bool = false,
        VK_KHR_line_rasterization: bool = false,
        VK_KHR_calibrated_timestamps: bool = false,
        VK_KHR_shader_expect_assume: bool = false,
        VK_KHR_maintenance6: bool = false,
        VK_QCOM_tile_memory_heap: bool = false,
        VK_KHR_video_encode_intra_refresh: bool = false,
        VK_KHR_video_encode_quantization_map: bool = false,
        VK_KHR_shader_relaxed_extended_instruction: bool = false,
        VK_KHR_maintenance7: bool = false,
        VK_EXT_shader_replicated_composites: bool = false,
        VK_EXT_shader_float8: bool = false,
        VK_EXT_device_generated_commands: bool = false,
        VK_KHR_maintenance8: bool = false,
        VK_EXT_depth_clamp_control: bool = false,
        VK_KHR_maintenance9: bool = false,
        VK_KHR_video_maintenance2: bool = false,
        VK_EXT_external_memory_metal: bool = false,
        VK_KHR_depth_clamp_zero_one: bool = false,
        VK_EXT_vertex_attribute_robustness: bool = false,
        VK_VALVE_fragment_density_map_layered: bool = false,
        VK_KHR_robustness2: bool = false,
        VK_EXT_fragment_density_map_offset: bool = false,
        VK_EXT_zero_initialize_device_memory: bool = false,
        VK_KHR_present_mode_fifo_latest_ready: bool = false,
    } = .{},

    const Self = @This();

    pub fn init(
        tmp_alloc: Allocator,
        api_version: u32,
        instance_extensions: []const [*c]const u8,
        device_extensions: []const [*c]const u8,
    ) !Self {
        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        var self: Self = .{};
        if (vk.VK_API_VERSION_1_1 <= api_version) {
            self.instance.VK_KHR_get_physical_device_properties2 = true;
            self.instance.VK_KHR_device_group_creation = true;
            self.instance.VK_KHR_external_memory_capabilities = true;
            self.instance.VK_KHR_external_semaphore_capabilities = true;
            self.instance.VK_KHR_external_fence_capabilities = true;
            self.device.VK_KHR_multiview = true;
            self.device.VK_KHR_device_group = true;
            self.device.VK_KHR_shader_draw_parameters = true;
            self.device.VK_KHR_maintenance1 = true;
            self.device.VK_KHR_external_memory = true;
            self.device.VK_KHR_external_semaphore = true;
            self.device.VK_KHR_16bit_storage = true;
            self.device.VK_KHR_descriptor_update_template = true;
            self.device.VK_KHR_external_fence = true;
            self.device.VK_KHR_maintenance2 = true;
            self.device.VK_KHR_variable_pointers = true;
            self.device.VK_KHR_dedicated_allocation = true;
            self.device.VK_KHR_storage_buffer_storage_class = true;
            self.device.VK_KHR_relaxed_block_layout = true;
            self.device.VK_KHR_get_memory_requirements2 = true;
            self.device.VK_KHR_sampler_ycbcr_conversion = true;
            self.device.VK_KHR_bind_memory2 = true;
            self.device.VK_KHR_maintenance3 = true;
        }
        if (vk.VK_API_VERSION_1_2 <= api_version) {
            self.device.VK_KHR_shader_float16_int8 = true;
            self.device.VK_KHR_imageless_framebuffer = true;
            self.device.VK_KHR_create_renderpass2 = true;
            self.device.VK_EXT_sampler_filter_minmax = true;
            self.device.VK_KHR_image_format_list = true;
            self.device.VK_EXT_descriptor_indexing = true;
            self.device.VK_EXT_shader_viewport_index_layer = true;
            self.device.VK_KHR_draw_indirect_count = true;
            self.device.VK_KHR_shader_subgroup_extended_types = true;
            self.device.VK_KHR_8bit_storage = true;
            self.device.VK_KHR_shader_atomic_int64 = true;
            self.device.VK_KHR_driver_properties = true;
            self.device.VK_KHR_shader_float_controls = true;
            self.device.VK_KHR_depth_stencil_resolve = true;
            self.device.VK_KHR_timeline_semaphore = true;
            self.device.VK_KHR_vulkan_memory_model = true;
            self.device.VK_EXT_scalar_block_layout = true;
            self.device.VK_KHR_spirv_1_4 = true;
            self.device.VK_KHR_separate_depth_stencil_layouts = true;
            self.device.VK_EXT_separate_stencil_usage = true;
            self.device.VK_KHR_uniform_buffer_standard_layout = true;
            self.device.VK_KHR_buffer_device_address = true;
            self.device.VK_EXT_host_query_reset = true;
        }
        if (vk.VK_API_VERSION_1_3 <= api_version) {
            self.device.VK_KHR_dynamic_rendering = true;
            self.device.VK_EXT_texture_compression_astc_hdr = true;
            self.device.VK_EXT_inline_uniform_block = true;
            self.device.VK_EXT_pipeline_creation_feedback = true;
            self.device.VK_KHR_shader_terminate_invocation = true;
            self.device.VK_EXT_subgroup_size_control = true;
            self.device.VK_EXT_tooling_info = true;
            self.device.VK_EXT_extended_dynamic_state = true;
            self.device.VK_EXT_shader_demote_to_helper_invocation = true;
            self.device.VK_KHR_shader_integer_dot_product = true;
            self.device.VK_EXT_texel_buffer_alignment = true;
            self.device.VK_KHR_shader_non_semantic_info = true;
            self.device.VK_EXT_private_data = true;
            self.device.VK_EXT_pipeline_creation_cache_control = true;
            self.device.VK_KHR_synchronization2 = true;
            self.device.VK_KHR_zero_initialize_workgroup_memory = true;
            self.device.VK_EXT_ycbcr_2plane_444_formats = true;
            self.device.VK_EXT_image_robustness = true;
            self.device.VK_KHR_copy_commands2 = true;
            self.device.VK_EXT_4444_formats = true;
            self.device.VK_KHR_format_feature_flags2 = true;
            self.device.VK_EXT_extended_dynamic_state2 = true;
            self.device.VK_KHR_maintenance4 = true;
        }
        if (vk.VK_API_VERSION_1_4 <= api_version) {
            self.device.VK_EXT_pipeline_robustness = true;
            self.device.VK_KHR_push_descriptor = true;
            self.device.VK_KHR_global_priority = true;
            self.device.VK_KHR_dynamic_rendering_local_read = true;
            self.device.VK_EXT_host_image_copy = true;
            self.device.VK_KHR_map_memory2 = true;
            self.device.VK_KHR_shader_subgroup_rotate = true;
            self.device.VK_EXT_pipeline_protected_access = true;
            self.device.VK_KHR_maintenance5 = true;
            self.device.VK_KHR_vertex_attribute_divisor = true;
            self.device.VK_KHR_load_store_op_none = true;
            self.device.VK_KHR_shader_float_controls2 = true;
            self.device.VK_KHR_index_type_uint8 = true;
            self.device.VK_KHR_line_rasterization = true;
            self.device.VK_KHR_shader_expect_assume = true;
            self.device.VK_KHR_maintenance6 = true;
        }
        // Instance extensions
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface")) {
                self.instance.VK_KHR_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_report")) {
                self.instance.VK_EXT_debug_report = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_physical_device_properties2")) {
                self.instance.VK_KHR_get_physical_device_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_flags")) {
                self.instance.VK_EXT_validation_flags = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group_creation")) {
                self.instance.VK_KHR_device_group_creation = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_memory_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_semaphore_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_direct_mode_display") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_direct_mode_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_surface_counter") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_display_surface_counter = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_colorspace") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_swapchain_colorspace = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_fence_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_surface_capabilities2") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_get_surface_capabilities2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_display_properties2") and (self.instance.VK_KHR_display)) {
                self.instance.VK_KHR_get_display_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_utils")) {
                self.instance.VK_EXT_debug_utils = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_metal_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_protected_capabilities") and (vk.VK_API_VERSION_1_1 <= api_version and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_protected_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_features")) {
                self.instance.VK_EXT_validation_features = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_headless_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_headless_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_surface_maintenance1") and (self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_EXT_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_acquire_drm_display") and (self.instance.VK_EXT_direct_mode_display)) {
                self.instance.VK_EXT_acquire_drm_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_directfb_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_directfb_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_portability_enumeration")) {
                self.instance.VK_KHR_portability_enumeration = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_maintenance1") and (self.instance.VK_KHR_surface or self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_layer_settings")) {
                self.instance.VK_EXT_layer_settings = true;
                break;
            }
        }
        // Device extensions
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain") and (self.instance.VK_KHR_surface)) {
                self.device.VK_KHR_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display_swapchain") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_display)) {
                self.device.VK_KHR_display_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_range_unrestricted")) {
                self.device.VK_EXT_depth_range_unrestricted = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_filter_cubic")) {
                self.device.VK_IMG_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_marker") and (self.instance.VK_EXT_debug_report)) {
                self.device.VK_EXT_debug_marker = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_queue") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_video_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_decode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_transform_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_transform_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h264") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h265") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h264") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_multiview") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_multiview = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_format_pvrtc")) {
                self.device.VK_IMG_format_pvrtc = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group") and (self.instance.VK_KHR_device_group_creation)) {
                self.device.VK_KHR_device_group = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_draw_parameters")) {
                self.device.VK_KHR_shader_draw_parameters = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_ballot")) {
                self.device.VK_EXT_shader_subgroup_ballot = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_vote")) {
                self.device.VK_EXT_shader_subgroup_vote = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texture_compression_astc_hdr") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texture_compression_astc_hdr = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_astc_decode_mode") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_astc_decode_mode = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance1")) {
                self.device.VK_KHR_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory") and (self.instance.VK_KHR_external_memory_capabilities or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_fd") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore") and (self.instance.VK_KHR_external_semaphore_capabilities)) {
                self.device.VK_KHR_external_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_fd") and (self.device.VK_KHR_external_semaphore or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_semaphore_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_push_descriptor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_push_descriptor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conditional_rendering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conditional_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float16_int8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float16_int8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_16bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_16bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_incremental_present") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_incremental_present = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_descriptor_update_template")) {
                self.device.VK_KHR_descriptor_update_template = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_control") and (self.instance.VK_EXT_display_surface_counter and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_display_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_discard_rectangles") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_discard_rectangles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conservative_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conservative_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_hdr_metadata") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_hdr_metadata = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_imageless_framebuffer") and ((((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_imageless_framebuffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_create_renderpass2") and ((self.device.VK_KHR_multiview and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_create_renderpass2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_relaxed_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_IMG_relaxed_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shared_presentable_image") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_surface_capabilities2 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_KHR_shared_presentable_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence") and (self.instance.VK_KHR_external_fence_capabilities)) {
                self.device.VK_KHR_external_fence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_fd") and (self.device.VK_KHR_external_fence or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_fence_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance2")) {
                self.device.VK_KHR_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_variable_pointers") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_variable_pointers = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_dma_buf") and (self.device.VK_KHR_external_memory_fd)) {
                self.device.VK_EXT_external_memory_dma_buf = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_queue_family_foreign") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_queue_family_foreign = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dedicated_allocation") and (self.device.VK_KHR_get_memory_requirements2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_dedicated_allocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sampler_filter_minmax") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sampler_filter_minmax = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_storage_buffer_storage_class")) {
                self.device.VK_KHR_storage_buffer_storage_class = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_inline_uniform_block") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance1) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_inline_uniform_block = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_stencil_export")) {
                self.device.VK_EXT_shader_stencil_export = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_bfloat16") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_bfloat16 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sample_locations") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sample_locations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_relaxed_block_layout")) {
                self.device.VK_KHR_relaxed_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_memory_requirements2")) {
                self.device.VK_KHR_get_memory_requirements2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_image_format_list")) {
                self.device.VK_KHR_image_format_list = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_blend_operation_advanced") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_blend_operation_advanced = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_acceleration_structure") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_EXT_descriptor_indexing and self.device.VK_KHR_buffer_device_address) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_deferred_host_operations)) {
                self.device.VK_KHR_acceleration_structure = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_pipeline") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_pipeline = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_query") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_post_depth_coverage")) {
                self.device.VK_EXT_post_depth_coverage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_sampler_ycbcr_conversion") and ((self.device.VK_KHR_maintenance1 and self.device.VK_KHR_bind_memory2 and self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_sampler_ycbcr_conversion = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_bind_memory2")) {
                self.device.VK_KHR_bind_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_drm_format_modifier") and ((((self.device.VK_KHR_bind_memory2 and self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_sampler_ycbcr_conversion) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_image_drm_format_modifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_cache")) {
                self.device.VK_EXT_validation_cache = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_indexing") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance3) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_descriptor_indexing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_viewport_index_layer")) {
                self.device.VK_EXT_shader_viewport_index_layer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_draw_indirect_count")) {
                self.device.VK_KHR_draw_indirect_count = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_filter_cubic")) {
                self.device.VK_EXT_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_shader_resolve")) {
                self.device.VK_QCOM_render_pass_shader_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority")) {
                self.device.VK_EXT_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_extended_types") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_extended_types = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_8bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_8bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_host") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_host = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_clock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_clock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h265") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_global_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_feedback")) {
                self.device.VK_EXT_pipeline_creation_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_driver_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_driver_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float_controls = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_stencil_resolve") and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_depth_stencil_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_mutable_format") and (self.device.VK_KHR_swapchain and (self.device.VK_KHR_maintenance2 or vk.VK_API_VERSION_1_1 <= api_version) and (self.device.VK_KHR_image_format_list or vk.VK_API_VERSION_1_2 <= api_version))) {
                self.device.VK_KHR_swapchain_mutable_format = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_timeline_semaphore") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_timeline_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_shader_integer_functions2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_INTEL_shader_integer_functions2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_performance_query")) {
                self.device.VK_INTEL_performance_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vulkan_memory_model") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vulkan_memory_model = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pci_bus_info") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pci_bus_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_terminate_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_terminate_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_density_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_scalar_block_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_scalar_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subgroup_size_control") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subgroup_size_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shading_rate") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_fragment_shading_rate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering_local_read") and (self.device.VK_KHR_dynamic_rendering or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering_local_read = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_image_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_image_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_quad_control") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_vulkan_memory_model) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_shader_maximal_reconvergence)) {
                self.device.VK_KHR_shader_quad_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_spirv_1_4") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_spirv_1_4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_budget") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_budget = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_separate_depth_stencil_layouts") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_separate_depth_stencil_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_buffer_device_address") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_tooling_info")) {
                self.device.VK_EXT_tooling_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_separate_stencil_usage")) {
                self.device.VK_EXT_separate_stencil_usage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait") and (self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id)) {
                self.device.VK_KHR_present_wait = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_shader_interlock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_shader_interlock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_image_arrays") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_image_arrays = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_uniform_buffer_standard_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_uniform_buffer_standard_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_provoking_vertex") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_provoking_vertex = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_full_screen_exclusive") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_full_screen_exclusive = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_buffer_device_address") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_device_group) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_atomic_float = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_query_reset") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_host_query_reset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_deferred_host_operations")) {
                self.device.VK_KHR_deferred_host_operations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_executable_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_pipeline_executable_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_image_copy") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_copy_commands2 and self.device.VK_KHR_format_feature_flags2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_host_image_copy = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_map_memory2")) {
                self.device.VK_KHR_map_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_map_memory_placed") and (self.device.VK_KHR_map_memory2 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_EXT_map_memory_placed = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float2") and (self.device.VK_EXT_shader_atomic_float)) {
                self.device.VK_EXT_shader_atomic_float2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_maintenance1") and (self.device.VK_KHR_swapchain and self.instance.VK_EXT_surface_maintenance1 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_demote_to_helper_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_demote_to_helper_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_integer_dot_product") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_integer_dot_product = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texel_buffer_alignment") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texel_buffer_alignment = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_transform")) {
                self.device.VK_QCOM_render_pass_transform = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_bias_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_bias_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_memory_report") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_memory_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_custom_border_color") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_custom_border_color = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_library")) {
                self.device.VK_KHR_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_non_semantic_info")) {
                self.device.VK_KHR_shader_non_semantic_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_present_id = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_private_data") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_private_data = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_cache_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_creation_cache_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_store_ops")) {
                self.device.VK_QCOM_render_pass_store_ops = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_shading") and (self.device.VK_QCOM_tile_properties or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_QCOM_tile_shading = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_objects")) {
                self.device.VK_EXT_metal_objects = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_synchronization2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_synchronization2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_buffer") and (((((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_buffer_device_address and self.device.VK_EXT_descriptor_indexing) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_descriptor_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_graphics_pipeline_library") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_graphics_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shader_barycentric") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_fragment_shader_barycentric = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_uniform_control_flow") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_uniform_control_flow = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_zero_initialize_workgroup_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_zero_initialize_workgroup_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mesh_shader") and (self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_mesh_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_2plane_444_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_2plane_444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map2") and (self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_EXT_fragment_density_map2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_rotated_copy_commands") and (self.device.VK_KHR_copy_commands2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_rotated_copy_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_workgroup_memory_explicit_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_workgroup_memory_explicit_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_copy_commands2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_copy_commands2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_compression_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_attachment_feedback_loop_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_4444_formats") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_4444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_fault") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_fault = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rgba10x6_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rgba10x6_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3)) {
                self.device.VK_VALVE_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_input_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_input_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_physical_device_drm") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_physical_device_drm = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_address_binding_report") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_EXT_debug_utils)) {
                self.device.VK_EXT_device_address_binding_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitive_topology_list_restart") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_primitive_topology_list_restart = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_format_feature_flags2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_format_feature_flags2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_frame_boundary")) {
                self.device.VK_EXT_frame_boundary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multisampled_render_to_single_sampled") and ((self.device.VK_KHR_create_renderpass2 and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_multisampled_render_to_single_sampled = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_color_write_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_color_write_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitives_generated_query") and (self.device.VK_EXT_transform_feedback)) {
                self.device.VK_EXT_primitives_generated_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_maintenance1") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority_query") and (self.device.VK_EXT_global_priority and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_global_priority_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_view_min_lod") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_view_min_lod = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multi_draw") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_multi_draw = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_2d_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_2d_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_tile_image") and (vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_tile_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_opacity_micromap") and (self.device.VK_KHR_acceleration_structure and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_EXT_opacity_micromap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_load_store_op_none")) {
                self.device.VK_EXT_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_border_color_swizzle") and (self.device.VK_EXT_custom_border_color)) {
                self.device.VK_EXT_border_color_swizzle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pageable_device_local_memory") and (self.device.VK_EXT_memory_priority)) {
                self.device.VK_EXT_pageable_device_local_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance4") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_rotate")) {
                self.device.VK_KHR_shader_subgroup_rotate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_sliced_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_sliced_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_descriptor_set_host_mapping") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_VALVE_descriptor_set_host_mapping = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_non_seamless_cube_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_non_seamless_cube_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_QCOM_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_maximal_reconvergence") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_maximal_reconvergence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control_swapchain") and (self.device.VK_EXT_image_compression_control)) {
                self.device.VK_EXT_image_compression_control_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing") and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_image_processing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_nested_command_buffer") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_nested_command_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_acquire_unmodified") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_acquire_unmodified = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subpass_merge_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subpass_merge_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_module_identifier") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_pipeline_creation_cache_control) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_module_identifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rasterization_order_attachment_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rasterization_order_attachment_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_dithering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_legacy_dithering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_protected_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_protected_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance5") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_maintenance5 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_id2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id2)) {
                self.device.VK_KHR_present_wait2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_position_fetch") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_position_fetch = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_object") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_object = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_binary") and (self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_KHR_pipeline_binary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_maintenance1") and (self.device.VK_KHR_swapchain or self.instance.VK_KHR_surface_maintenance1 or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_KHR_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_viewports") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_multiview_per_view_viewports = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_vertex_attributes") and (self.device.VK_EXT_vertex_input_dynamic_state)) {
                self.device.VK_EXT_legacy_vertex_attributes = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_library_group_handles") and (self.device.VK_KHR_ray_tracing_pipeline and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_pipeline_library_group_handles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_dynamic_rendering_unused_attachments") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_dynamic_rendering_unused_attachments = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_cooperative_matrix") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_cooperative_matrix = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_render_areas")) {
                self.device.VK_QCOM_multiview_per_view_render_areas = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_compute_shader_derivatives") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_compute_shader_derivatives = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_av1") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_av1") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_vp9") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_vp9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance1") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing2") and (self.device.VK_QCOM_image_processing)) {
                self.device.VK_QCOM_image_processing2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_weights") and (self.device.VK_EXT_filter_cubic)) {
                self.device.VK_QCOM_filter_cubic_weights = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_ycbcr_degamma")) {
                self.device.VK_QCOM_ycbcr_degamma = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_clamp") and ((self.device.VK_EXT_filter_cubic) and (vk.VK_API_VERSION_1_2 <= api_version or self.device.VK_EXT_sampler_filter_minmax))) {
                self.device.VK_QCOM_filter_cubic_clamp = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_dynamic_state") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_attachment_feedback_loop_layout)) {
                self.device.VK_EXT_attachment_feedback_loop_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_load_store_op_none")) {
                self.device.VK_KHR_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_unified_image_layouts")) {
                self.device.VK_KHR_unified_image_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls2") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_shader_float_controls2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_expect_assume") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_expect_assume = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance6") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance6 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_memory_heap") and ((self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_memory_heap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_intra_refresh") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_intra_refresh = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_quantization_map") and (self.device.VK_KHR_video_encode_queue and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_quantization_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_relaxed_extended_instruction")) {
                self.device.VK_KHR_shader_relaxed_extended_instruction = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance7") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance7 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_replicated_composites")) {
                self.device.VK_EXT_shader_replicated_composites = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_float8")) {
                self.device.VK_EXT_shader_float8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_generated_commands") and (((self.device.VK_KHR_buffer_device_address or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_maintenance5) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_device_generated_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance8") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance9") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance2") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_metal") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_metal = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_fragment_density_map_layered") and ((self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_VALVE_fragment_density_map_layered = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version) and (vk.VK_API_VERSION_1_3 <= api_version or self.device.VK_KHR_dynamic_rendering))) {
                self.device.VK_EXT_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_zero_initialize_device_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_zero_initialize_device_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        return self;
    }
};

pub fn check_VkBaseOutStructure(extensions: *const Extensions, item: *const vk.VkBaseOutStructure) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBaseInStructure(extensions: *const Extensions, item: *const vk.VkBaseInStructure) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkOffset2D(extensions: *const Extensions, item: *const vk.VkOffset2D) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkOffset3D(extensions: *const Extensions, item: *const vk.VkOffset3D) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExtent2D(extensions: *const Extensions, item: *const vk.VkExtent2D) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExtent3D(extensions: *const Extensions, item: *const vk.VkExtent3D) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkViewport(extensions: *const Extensions, item: *const vk.VkViewport) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRect2D(extensions: *const Extensions, item: *const vk.VkRect2D) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClearRect(extensions: *const Extensions, item: *const vk.VkClearRect) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkComponentMapping(extensions: *const Extensions, item: *const vk.VkComponentMapping) bool {
    return (check_enum_VkComponentSwizzle(extensions, &item.r) and
        check_enum_VkComponentSwizzle(extensions, &item.g) and
        check_enum_VkComponentSwizzle(extensions, &item.b) and
        check_enum_VkComponentSwizzle(extensions, &item.a));
}

pub fn check_VkPhysicalDeviceProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties) bool {
    return (check_enum_VkPhysicalDeviceType(extensions, &item.deviceType));
}

pub fn check_VkExtensionProperties(extensions: *const Extensions, item: *const vk.VkExtensionProperties) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkLayerProperties(extensions: *const Extensions, item: *const vk.VkLayerProperties) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkApplicationInfo(extensions: *const Extensions, item: *const vk.VkApplicationInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAllocationCallbacks(extensions: *const Extensions, item: *const vk.VkAllocationCallbacks) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceQueueCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDeviceQueueCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkInstanceCreateInfo(extensions: *const Extensions, item: *const vk.VkInstanceCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkInstanceCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkQueueFamilyProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties) bool {
    return (check_bitmask_VkQueueFlagBits(extensions, &item.queueFlags));
}

pub fn check_VkPhysicalDeviceMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryRequirements(extensions: *const Extensions, item: *const vk.VkMemoryRequirements) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSparseImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties) bool {
    return (check_bitmask_VkImageAspectFlagBits(extensions, &item.aspectMask) and
        check_bitmask_VkSparseImageFormatFlagBits(extensions, &item.flags));
}

pub fn check_VkSparseImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryType(extensions: *const Extensions, item: *const vk.VkMemoryType) bool {
    return (check_bitmask_VkMemoryPropertyFlagBits(extensions, &item.propertyFlags));
}

pub fn check_VkMemoryHeap(extensions: *const Extensions, item: *const vk.VkMemoryHeap) bool {
    return (check_bitmask_VkMemoryHeapFlagBits(extensions, &item.flags));
}

pub fn check_VkMappedMemoryRange(extensions: *const Extensions, item: *const vk.VkMappedMemoryRange) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFormatProperties(extensions: *const Extensions, item: *const vk.VkFormatProperties) bool {
    return (check_bitmask_VkFormatFeatureFlagBits(extensions, &item.linearTilingFeatures) and
        check_bitmask_VkFormatFeatureFlagBits(extensions, &item.optimalTilingFeatures) and
        check_bitmask_VkFormatFeatureFlagBits(extensions, &item.bufferFeatures));
}

pub fn check_VkImageFormatProperties(extensions: *const Extensions, item: *const vk.VkImageFormatProperties) bool {
    return (check_bitmask_VkSampleCountFlagBits(extensions, &item.sampleCounts));
}

pub fn check_VkDescriptorBufferInfo(extensions: *const Extensions, item: *const vk.VkDescriptorBufferInfo) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDescriptorImageInfo(extensions: *const Extensions, item: *const vk.VkDescriptorImageInfo) bool {
    return (check_enum_VkImageLayout(extensions, &item.imageLayout));
}

pub fn check_VkWriteDescriptorSet(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSet) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDescriptorType(extensions, &item.descriptorType));
}

pub fn check_VkCopyDescriptorSet(extensions: *const Extensions, item: *const vk.VkCopyDescriptorSet) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferUsageFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2CreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferUsageFlags2CreateInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2CreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkBufferCreateFlagBits(extensions, &item.flags) and
        check_bitmask_VkBufferUsageFlagBits(extensions, &item.usage) and
        check_enum_VkSharingMode(extensions, &item.sharingMode));
}

pub fn check_VkBufferViewCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferViewCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkImageSubresource(extensions: *const Extensions, item: *const vk.VkImageSubresource) bool {
    return (check_bitmask_VkImageAspectFlagBits(extensions, &item.aspectMask));
}

pub fn check_VkImageSubresourceLayers(extensions: *const Extensions, item: *const vk.VkImageSubresourceLayers) bool {
    return (check_bitmask_VkImageAspectFlagBits(extensions, &item.aspectMask));
}

pub fn check_VkImageSubresourceRange(extensions: *const Extensions, item: *const vk.VkImageSubresourceRange) bool {
    return (check_bitmask_VkImageAspectFlagBits(extensions, &item.aspectMask));
}

pub fn check_VkMemoryBarrier(extensions: *const Extensions, item: *const vk.VkMemoryBarrier) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkAccessFlagBits(extensions, &item.srcAccessMask) and
        check_bitmask_VkAccessFlagBits(extensions, &item.dstAccessMask));
}

pub fn check_VkBufferMemoryBarrier(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkAccessFlagBits(extensions, &item.srcAccessMask) and
        check_bitmask_VkAccessFlagBits(extensions, &item.dstAccessMask));
}

pub fn check_VkImageMemoryBarrier(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkAccessFlagBits(extensions, &item.srcAccessMask) and
        check_bitmask_VkAccessFlagBits(extensions, &item.dstAccessMask) and
        check_enum_VkImageLayout(extensions, &item.oldLayout) and
        check_enum_VkImageLayout(extensions, &item.newLayout));
}

pub fn check_VkImageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageCreateFlagBits(extensions, &item.flags) and
        check_enum_VkImageType(extensions, &item.imageType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.samples) and
        check_enum_VkImageTiling(extensions, &item.tiling) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.usage) and
        check_enum_VkSharingMode(extensions, &item.sharingMode) and
        check_enum_VkImageLayout(extensions, &item.initialLayout));
}

pub fn check_VkSubresourceLayout(extensions: *const Extensions, item: *const vk.VkSubresourceLayout) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageViewCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageViewCreateFlagBits(extensions, &item.flags) and
        check_enum_VkImageViewType(extensions, &item.viewType) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkBufferCopy(extensions: *const Extensions, item: *const vk.VkBufferCopy) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSparseMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseMemoryBind) bool {
    return (check_bitmask_VkSparseMemoryBindFlagBits(extensions, &item.flags));
}

pub fn check_VkSparseImageMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBind) bool {
    return (check_bitmask_VkSparseMemoryBindFlagBits(extensions, &item.flags));
}

pub fn check_VkSparseBufferMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseBufferMemoryBindInfo) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSparseImageOpaqueMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageOpaqueMemoryBindInfo) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSparseImageMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBindInfo) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindSparseInfo(extensions: *const Extensions, item: *const vk.VkBindSparseInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageCopy(extensions: *const Extensions, item: *const vk.VkImageCopy) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageBlit(extensions: *const Extensions, item: *const vk.VkImageBlit) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferImageCopy(extensions: *const Extensions, item: *const vk.VkBufferImageCopy) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyMemoryIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkCopyMemoryIndirectCommandNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyMemoryToImageIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageIndirectCommandNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageResolve(extensions: *const Extensions, item: *const vk.VkImageResolve) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkShaderModuleCreateInfo(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorSetLayoutBinding(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBinding) bool {
    return (check_enum_VkDescriptorType(extensions, &item.descriptorType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stageFlags));
}

pub fn check_VkDescriptorSetLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDescriptorSetLayoutCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkDescriptorPoolSize(extensions: *const Extensions, item: *const vk.VkDescriptorPoolSize) bool {
    return (check_enum_VkDescriptorType(extensions, &item.type));
}

pub fn check_VkDescriptorPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDescriptorPoolCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkDescriptorSetAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetAllocateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSpecializationMapEntry(extensions: *const Extensions, item: *const vk.VkSpecializationMapEntry) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSpecializationInfo(extensions: *const Extensions, item: *const vk.VkSpecializationInfo) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineShaderStageCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineShaderStageCreateFlagBits(extensions, &item.flags) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stage));
}

pub fn check_VkComputePipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkComputePipelineCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkComputePipelineIndirectBufferInfoNV(extensions: *const Extensions, item: *const vk.VkComputePipelineIndirectBufferInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineCreateFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2CreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineCreateFlags2CreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2CreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVertexInputBindingDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription) bool {
    return (check_enum_VkVertexInputRate(extensions, &item.inputRate));
}

pub fn check_VkVertexInputAttributeDescription(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription) bool {
    return (check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkPipelineVertexInputStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineInputAssemblyStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineInputAssemblyStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPrimitiveTopology(extensions, &item.topology));
}

pub fn check_VkPipelineTessellationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineViewportStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineViewportStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineRasterizationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPolygonMode(extensions, &item.polygonMode) and
        check_bitmask_VkCullModeFlagBits(extensions, &item.cullMode) and
        check_enum_VkFrontFace(extensions, &item.frontFace));
}

pub fn check_VkPipelineMultisampleStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineMultisampleStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.rasterizationSamples));
}

pub fn check_VkPipelineColorBlendAttachmentState(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAttachmentState) bool {
    return (check_enum_VkBlendFactor(extensions, &item.srcColorBlendFactor) and
        check_enum_VkBlendFactor(extensions, &item.dstColorBlendFactor) and
        check_enum_VkBlendOp(extensions, &item.colorBlendOp) and
        check_enum_VkBlendFactor(extensions, &item.srcAlphaBlendFactor) and
        check_enum_VkBlendFactor(extensions, &item.dstAlphaBlendFactor) and
        check_enum_VkBlendOp(extensions, &item.alphaBlendOp) and
        check_bitmask_VkColorComponentFlagBits(extensions, &item.colorWriteMask));
}

pub fn check_VkPipelineColorBlendStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineColorBlendStateCreateFlagBits(extensions, &item.flags) and
        check_enum_VkLogicOp(extensions, &item.logicOp));
}

pub fn check_VkPipelineDynamicStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDynamicStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDynamicState(extensions, &item.pDynamicStates));
}

pub fn check_VkStencilOpState(extensions: *const Extensions, item: *const vk.VkStencilOpState) bool {
    return (check_enum_VkStencilOp(extensions, &item.failOp) and
        check_enum_VkStencilOp(extensions, &item.passOp) and
        check_enum_VkStencilOp(extensions, &item.depthFailOp) and
        check_enum_VkCompareOp(extensions, &item.compareOp));
}

pub fn check_VkPipelineDepthStencilStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineDepthStencilStateCreateFlagBits(extensions, &item.flags) and
        check_enum_VkCompareOp(extensions, &item.depthCompareOp));
}

pub fn check_VkGraphicsPipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkPipelineCacheCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineCacheCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkPipelineCacheHeaderVersionOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionOne) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineCacheStageValidationIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheStageValidationIndexEntry) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineCacheSafetyCriticalIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheSafetyCriticalIndexEntry) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineCacheHeaderVersionSafetyCriticalOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionSafetyCriticalOne) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPushConstantRange(extensions: *const Extensions, item: *const vk.VkPushConstantRange) bool {
    return (check_bitmask_VkShaderStageFlagBits(extensions, &item.stageFlags));
}

pub fn check_VkPipelineBinaryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineBinaryHandlesInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryHandlesInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineBinaryDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineBinaryKeysAndDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeysAndDataKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineBinaryKeyKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeyKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineBinaryInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkReleaseCapturedPipelineDataInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseCapturedPipelineDataInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineBinaryDataInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineLayoutCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkSamplerCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSamplerCreateFlagBits(extensions, &item.flags) and
        check_enum_VkFilter(extensions, &item.magFilter) and
        check_enum_VkFilter(extensions, &item.minFilter) and
        check_enum_VkSamplerMipmapMode(extensions, &item.mipmapMode) and
        check_enum_VkSamplerAddressMode(extensions, &item.addressModeU) and
        check_enum_VkSamplerAddressMode(extensions, &item.addressModeV) and
        check_enum_VkSamplerAddressMode(extensions, &item.addressModeW) and
        check_enum_VkCompareOp(extensions, &item.compareOp) and
        check_enum_VkBorderColor(extensions, &item.borderColor));
}

pub fn check_VkCommandPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkCommandPoolCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkCommandBufferAllocateInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferAllocateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCommandBufferLevel(extensions, &item.level));
}

pub fn check_VkCommandBufferInheritanceInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkQueryControlFlagBits(extensions, &item.queryFlags) and
        check_bitmask_VkQueryPipelineStatisticFlagBits(extensions, &item.pipelineStatistics));
}

pub fn check_VkCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferBeginInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkCommandBufferUsageFlagBits(extensions, &item.flags));
}

pub fn check_VkRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassBeginInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkClearDepthStencilValue(extensions: *const Extensions, item: *const vk.VkClearDepthStencilValue) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClearAttachment(extensions: *const Extensions, item: *const vk.VkClearAttachment) bool {
    return (check_bitmask_VkImageAspectFlagBits(extensions, &item.aspectMask));
}

pub fn check_VkAttachmentDescription(extensions: *const Extensions, item: *const vk.VkAttachmentDescription) bool {
    return (check_bitmask_VkAttachmentDescriptionFlagBits(extensions, &item.flags) and
        check_enum_VkFormat(extensions, &item.format) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.samples) and
        check_enum_VkAttachmentLoadOp(extensions, &item.loadOp) and
        check_enum_VkAttachmentStoreOp(extensions, &item.storeOp) and
        check_enum_VkAttachmentLoadOp(extensions, &item.stencilLoadOp) and
        check_enum_VkAttachmentStoreOp(extensions, &item.stencilStoreOp) and
        check_enum_VkImageLayout(extensions, &item.initialLayout) and
        check_enum_VkImageLayout(extensions, &item.finalLayout));
}

pub fn check_VkAttachmentReference(extensions: *const Extensions, item: *const vk.VkAttachmentReference) bool {
    return (check_enum_VkImageLayout(extensions, &item.layout));
}

pub fn check_VkSubpassDescription(extensions: *const Extensions, item: *const vk.VkSubpassDescription) bool {
    return (check_bitmask_VkSubpassDescriptionFlagBits(extensions, &item.flags) and
        check_enum_VkPipelineBindPoint(extensions, &item.pipelineBindPoint));
}

pub fn check_VkSubpassDependency(extensions: *const Extensions, item: *const vk.VkSubpassDependency) bool {
    return (check_bitmask_VkPipelineStageFlagBits(extensions, &item.srcStageMask) and
        check_bitmask_VkPipelineStageFlagBits(extensions, &item.dstStageMask) and
        check_bitmask_VkAccessFlagBits(extensions, &item.srcAccessMask) and
        check_bitmask_VkAccessFlagBits(extensions, &item.dstAccessMask) and
        check_bitmask_VkDependencyFlagBits(extensions, &item.dependencyFlags));
}

pub fn check_VkRenderPassCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkRenderPassCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkEventCreateInfo(extensions: *const Extensions, item: *const vk.VkEventCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkEventCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkFenceCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFenceCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkPhysicalDeviceFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSparseProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseProperties) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceLimits(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLimits) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkQueryPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkQueryPoolCreateFlagBits(extensions, &item.flags) and
        check_enum_VkQueryType(extensions, &item.queryType) and
        check_bitmask_VkQueryPipelineStatisticFlagBits(extensions, &item.pipelineStatistics));
}

pub fn check_VkFramebufferCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFramebufferCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkDrawIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndirectCommand) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDrawIndexedIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndexedIndirectCommand) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDispatchIndirectCommand(extensions: *const Extensions, item: *const vk.VkDispatchIndirectCommand) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMultiDrawInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMultiDrawIndexedInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawIndexedInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubmitInfo(extensions: *const Extensions, item: *const vk.VkSubmitInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineStageFlagBits(extensions, &item.pWaitDstStageMask));
}

pub fn check_VkDisplayPropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPropertiesKHR) bool {
    return (check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.supportedTransforms));
}

pub fn check_VkDisplayPlanePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlanePropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDisplayModeParametersKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeParametersKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDisplayModePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayModePropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDisplayModeCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayPlaneCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilitiesKHR) bool {
    return (check_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions, &item.supportedAlpha));
}

pub fn check_VkDisplaySurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.transform) and
        check_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions, &item.alphaMode));
}

pub fn check_VkDisplaySurfaceStereoCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceStereoCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDisplaySurfaceStereoTypeNV(extensions, &item.stereoType));
}

pub fn check_VkDisplayPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayPresentInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesKHR) bool {
    return (check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.supportedTransforms) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.currentTransform) and
        check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, &item.supportedCompositeAlpha) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.supportedUsageFlags));
}

pub fn check_VkAndroidSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAndroidSurfaceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkViSurfaceCreateInfoNN(extensions: *const Extensions, item: *const vk.VkViSurfaceCreateInfoNN) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkWaylandSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkWin32SurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32SurfaceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkXlibSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXlibSurfaceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkXcbSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXcbSurfaceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDirectFBSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDirectFBSurfaceCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImagePipeSurfaceCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImagePipeSurfaceCreateInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkStreamDescriptorSurfaceCreateInfoGGP(extensions: *const Extensions, item: *const vk.VkStreamDescriptorSurfaceCreateInfoGGP) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkScreenSurfaceCreateInfoQNX(extensions: *const Extensions, item: *const vk.VkScreenSurfaceCreateInfoQNX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceFormatKHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormatKHR) bool {
    return (check_enum_VkFormat(extensions, &item.format) and
        check_enum_VkColorSpaceKHR(extensions, &item.colorSpace));
}

pub fn check_VkSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSwapchainCreateFlagBitsKHR(extensions, &item.flags) and
        check_enum_VkFormat(extensions, &item.imageFormat) and
        check_enum_VkColorSpaceKHR(extensions, &item.imageColorSpace) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.imageUsage) and
        check_enum_VkSharingMode(extensions, &item.imageSharingMode) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.preTransform) and
        check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, &item.compositeAlpha) and
        check_enum_VkPresentModeKHR(extensions, &item.presentMode));
}

pub fn check_VkPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkPresentInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkResult(extensions, &item.pResults));
}

pub fn check_VkDebugReportCallbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugReportCallbackCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDebugReportFlagBitsEXT(extensions, &item.flags));
}

pub fn check_VkValidationFlagsEXT(extensions: *const Extensions, item: *const vk.VkValidationFlagsEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkValidationCheckEXT(extensions, &item.pDisabledValidationChecks));
}

pub fn check_VkValidationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkValidationFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkValidationFeatureEnableEXT(extensions, &item.pEnabledValidationFeatures) and
        check_enum_VkValidationFeatureDisableEXT(extensions, &item.pDisabledValidationFeatures));
}

pub fn check_VkLayerSettingsCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingsCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkLayerSettingEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingEXT) bool {
    return (check_enum_VkLayerSettingTypeEXT(extensions, &item.type));
}

pub fn check_VkApplicationParametersEXT(extensions: *const Extensions, item: *const vk.VkApplicationParametersEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineRasterizationStateRasterizationOrderAMD(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkRasterizationOrderAMD(extensions, &item.rasterizationOrder));
}

pub fn check_VkDebugMarkerObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectNameInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDebugReportObjectTypeEXT(extensions, &item.objectType));
}

pub fn check_VkDebugMarkerObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectTagInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDebugReportObjectTypeEXT(extensions, &item.objectType));
}

pub fn check_VkDebugMarkerMarkerInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerMarkerInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDedicatedAllocationImageCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDedicatedAllocationImageCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDedicatedAllocationBufferCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDedicatedAllocationBufferCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDedicatedAllocationMemoryAllocateInfoNV(extensions: *const Extensions, item: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalImageFormatPropertiesNV(extensions: *const Extensions, item: *const vk.VkExternalImageFormatPropertiesNV) bool {
    return (check_bitmask_VkExternalMemoryFeatureFlagBitsNV(extensions, &item.externalMemoryFeatures) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions, &item.exportFromImportedHandleTypes) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions, &item.compatibleHandleTypes));
}

pub fn check_VkExternalMemoryImageCreateInfoNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions, &item.handleTypes));
}

pub fn check_VkExportMemoryAllocateInfoNV(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions, &item.handleTypes));
}

pub fn check_VkImportMemoryWin32HandleInfoNV(extensions: *const Extensions, item: *const vk.VkImportMemoryWin32HandleInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions, &item.handleType));
}

pub fn check_VkExportMemoryWin32HandleInfoNV(extensions: *const Extensions, item: *const vk.VkExportMemoryWin32HandleInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExportMemorySciBufInfoNV(extensions: *const Extensions, item: *const vk.VkExportMemorySciBufInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportMemorySciBufInfoNV(extensions: *const Extensions, item: *const vk.VkImportMemorySciBufInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkMemoryGetSciBufInfoNV(extensions: *const Extensions, item: *const vk.VkMemoryGetSciBufInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkMemorySciBufPropertiesNV(extensions: *const Extensions, item: *const vk.VkMemorySciBufPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalMemorySciBufFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemorySciBufFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalSciBufFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSciBufFeaturesNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkWin32KeyedMutexAcquireReleaseInfoNV(extensions: *const Extensions, item: *const vk.VkWin32KeyedMutexAcquireReleaseInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDevicePrivateDataCreateInfo(extensions: *const Extensions, item: *const vk.VkDevicePrivateDataCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDevicePrivateDataCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDevicePrivateDataCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPrivateDataSlotCreateInfo(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPrivateDataSlotCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePrivateDataFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrivateDataFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePrivateDataFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrivateDataFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkStridedDeviceAddressNV(extensions: *const Extensions, item: *const vk.VkStridedDeviceAddressNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClusterAccelerationStructureMoveObjectsInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureMoveObjectsInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClusterAccelerationStructureGetTemplateIndicesInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGetTemplateIndicesInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClusterAccelerationStructureBuildTriangleClusterInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureBuildTriangleClusterInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClusterAccelerationStructureInstantiateClusterInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureInstantiateClusterInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkClusterAccelerationStructureClustersBottomLevelInputNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkClusterAccelerationStructureTriangleClusterInputNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.vertexFormat));
}

pub fn check_VkClusterAccelerationStructureMoveObjectsInputNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkClusterAccelerationStructureTypeNV(extensions, &item.type));
}

pub fn check_VkClusterAccelerationStructureInputInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureInputInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions, &item.flags) and
        check_enum_VkClusterAccelerationStructureOpTypeNV(extensions, &item.opType) and
        check_enum_VkClusterAccelerationStructureOpModeNV(extensions, &item.opMode));
}

pub fn check_VkClusterAccelerationStructureCommandsInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureCommandsInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkClusterAccelerationStructureAddressResolutionFlagBitsNV(extensions, &item.addressResolutionFlags));
}

pub fn check_VkPhysicalDeviceMultiDrawPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkGraphicsShaderGroupCreateInfoNV(extensions: *const Extensions, item: *const vk.VkGraphicsShaderGroupCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkGraphicsPipelineShaderGroupsCreateInfoNV(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindShaderGroupIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindShaderGroupIndirectCommandNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindIndexBufferIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindIndexBufferIndirectCommandNV) bool {
    return (check_enum_VkIndexType(extensions, &item.indexType));
}

pub fn check_VkBindVertexBufferIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindVertexBufferIndirectCommandNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSetStateFlagsIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkSetStateFlagsIndirectCommandNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkIndirectCommandsStreamNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsStreamNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkIndirectCommandsLayoutTokenNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutTokenNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkIndirectCommandsTokenTypeNV(extensions, &item.tokenType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.pushconstantShaderStageFlags) and
        check_bitmask_VkIndirectStateFlagBitsNV(extensions, &item.indirectStateFlags) and
        check_enum_VkIndexType(extensions, &item.pIndexTypes));
}

pub fn check_VkIndirectCommandsLayoutCreateInfoNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkIndirectCommandsLayoutUsageFlagBitsNV(extensions, &item.flags) and
        check_enum_VkPipelineBindPoint(extensions, &item.pipelineBindPoint));
}

pub fn check_VkGeneratedCommandsInfoNV(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineBindPoint(extensions, &item.pipelineBindPoint));
}

pub fn check_VkGeneratedCommandsMemoryRequirementsInfoNV(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineBindPoint(extensions, &item.pipelineBindPoint));
}

pub fn check_VkPipelineIndirectDeviceAddressInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineIndirectDeviceAddressInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineBindPoint(extensions, &item.pipelineBindPoint));
}

pub fn check_VkBindPipelineIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindPipelineIndirectCommandNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceFeatures2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFeatures2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceProperties2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkFormatProperties2(extensions: *const Extensions, item: *const vk.VkFormatProperties2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkFormatProperties2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkImageFormatProperties2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkImageFormatProperties2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageFormatInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_enum_VkImageType(extensions, &item.type) and
        check_enum_VkImageTiling(extensions, &item.tiling) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.usage) and
        check_bitmask_VkImageCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkPhysicalDeviceImageFormatInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageFormatInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkQueueFamilyProperties2(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkQueueFamilyProperties2KHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMemoryProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMemoryProperties2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSparseImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSparseImageFormatProperties2KHR(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSparseImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_enum_VkImageType(extensions, &item.type) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.samples) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.usage) and
        check_enum_VkImageTiling(extensions, &item.tiling));
}

pub fn check_VkPhysicalDeviceSparseImageFormatInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePushDescriptorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePushDescriptorProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePushDescriptorPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePushDescriptorPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkConformanceVersion(extensions: *const Extensions, item: *const vk.VkConformanceVersion) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkConformanceVersionKHR(extensions: *const Extensions, item: *const vk.VkConformanceVersionKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDriverProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDriverProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDriverId(extensions, &item.driverID));
}

pub fn check_VkPhysicalDeviceDriverPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDriverPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPresentRegionsKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionsKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPresentRegionKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRectLayerKHR(extensions: *const Extensions, item: *const vk.VkRectLayerKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceVariablePointersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointersFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVariablePointersFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointersFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceVariablePointerFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointerFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceVariablePointerFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointerFeatures) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExternalMemoryProperties(extensions: *const Extensions, item: *const vk.VkExternalMemoryProperties) bool {
    return (check_bitmask_VkExternalMemoryFeatureFlagBits(extensions, &item.externalMemoryFeatures) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.exportFromImportedHandleTypes) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.compatibleHandleTypes));
}

pub fn check_VkExternalMemoryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceExternalImageFormatInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalImageFormatInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkPhysicalDeviceExternalImageFormatInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalImageFormatInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExternalImageFormatProperties(extensions: *const Extensions, item: *const vk.VkExternalImageFormatProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalImageFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalImageFormatPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceExternalBufferInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalBufferInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkBufferCreateFlagBits(extensions, &item.flags) and
        check_bitmask_VkBufferUsageFlagBits(extensions, &item.usage) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkPhysicalDeviceExternalBufferInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalBufferInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExternalBufferProperties(extensions: *const Extensions, item: *const vk.VkExternalBufferProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalBufferPropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalBufferPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceIDProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIDProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceIDPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIDPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExternalMemoryImageCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleTypes));
}

pub fn check_VkExternalMemoryImageCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExternalMemoryBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryBufferCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleTypes));
}

pub fn check_VkExternalMemoryBufferCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExternalMemoryBufferCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExportMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleTypes));
}

pub fn check_VkExportMemoryAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkExportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportMemoryWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportMemoryZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryZirconHandleInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkMemoryZirconHandlePropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryZirconHandlePropertiesFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryGetZirconHandleInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkMemoryWin32HandlePropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryWin32HandlePropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkImportMemoryFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryFdInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkMemoryFdPropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryFdPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetFdInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32KeyedMutexAcquireReleaseInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportMemoryMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryMetalHandleInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkMemoryMetalHandlePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryMetalHandlePropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryGetMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryGetMetalHandleInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkPhysicalDeviceExternalSemaphoreInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSemaphoreInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkPhysicalDeviceExternalSemaphoreInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSemaphoreInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExternalSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.exportFromImportedHandleTypes) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.compatibleHandleTypes) and
        check_bitmask_VkExternalSemaphoreFeatureFlagBits(extensions, &item.externalSemaphoreFeatures));
}

pub fn check_VkExternalSemaphorePropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalSemaphorePropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExportSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkExportSemaphoreCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleTypes));
}

pub fn check_VkExportSemaphoreCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportSemaphoreCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSemaphoreImportFlagBits(extensions, &item.flags) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkExportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportSemaphoreWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkD3D12FenceSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkD3D12FenceSubmitInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSemaphoreGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkImportSemaphoreFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreFdInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSemaphoreImportFlagBits(extensions, &item.flags) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkSemaphoreGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetFdInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkImportSemaphoreZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportSemaphoreZirconHandleInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSemaphoreImportFlagBits(extensions, &item.flags) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkSemaphoreGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkSemaphoreGetZirconHandleInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkPhysicalDeviceExternalFenceInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFenceInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkPhysicalDeviceExternalFenceInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFenceInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExternalFenceProperties(extensions: *const Extensions, item: *const vk.VkExternalFenceProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.exportFromImportedHandleTypes) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.compatibleHandleTypes) and
        check_bitmask_VkExternalFenceFeatureFlagBits(extensions, &item.externalFenceFeatures));
}

pub fn check_VkExternalFencePropertiesKHR(extensions: *const Extensions, item: *const vk.VkExternalFencePropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkExportFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkExportFenceCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleTypes));
}

pub fn check_VkExportFenceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkExportFenceCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFenceImportFlagBits(extensions, &item.flags) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkExportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportFenceWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFenceGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetWin32HandleInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkImportFenceFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceFdInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFenceImportFlagBits(extensions, &item.flags) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkFenceGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetFdInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkExportFenceSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkExportFenceSciSyncInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportFenceSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkImportFenceSciSyncInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkFenceGetSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkFenceGetSciSyncInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkExportSemaphoreSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkExportSemaphoreSciSyncInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportSemaphoreSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkImportSemaphoreSciSyncInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkSemaphoreGetSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkSemaphoreGetSciSyncInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkSciSyncAttributesInfoNV(extensions: *const Extensions, item: *const vk.VkSciSyncAttributesInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkSciSyncClientTypeNV(extensions, &item.clientType) and
        check_enum_VkSciSyncPrimitiveTypeNV(extensions, &item.primitiveType));
}

pub fn check_VkPhysicalDeviceExternalSciSyncFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSciSyncFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalSciSync2FeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSciSync2FeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSemaphoreSciSyncPoolCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSemaphoreSciSyncPoolCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSemaphoreSciSyncCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSemaphoreSciSyncCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMultiviewFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMultiviewFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMultiviewProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMultiviewPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassMultiviewCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassMultiviewCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassMultiviewCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassMultiviewCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSurfaceCapabilities2EXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2EXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.supportedTransforms) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.currentTransform) and
        check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions, &item.supportedCompositeAlpha) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.supportedUsageFlags) and
        check_bitmask_VkSurfaceCounterFlagBitsEXT(extensions, &item.supportedSurfaceCounters));
}

pub fn check_VkDisplayPowerInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDisplayPowerStateEXT(extensions, &item.powerState));
}

pub fn check_VkDeviceEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDeviceEventTypeEXT(extensions, &item.deviceEvent));
}

pub fn check_VkDisplayEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDisplayEventTypeEXT(extensions, &item.displayEvent));
}

pub fn check_VkSwapchainCounterCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainCounterCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSurfaceCounterFlagBitsEXT(extensions, &item.surfaceCounters));
}

pub fn check_VkPhysicalDeviceGroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGroupProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceGroupPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGroupPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryAllocateFlagsInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagsInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkMemoryAllocateFlagBits(extensions, &item.flags));
}

pub fn check_VkMemoryAllocateFlagsInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagsInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindBufferMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindBufferMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindBufferMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryDeviceGroupInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindBufferMemoryDeviceGroupInfoKHR(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryDeviceGroupInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindImageMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindImageMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemoryInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindImageMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryDeviceGroupInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindImageMemoryDeviceGroupInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemoryDeviceGroupInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceGroupRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupRenderPassBeginInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceGroupRenderPassBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupRenderPassBeginInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceGroupCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupCommandBufferBeginInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceGroupCommandBufferBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupCommandBufferBeginInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceGroupSubmitInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupSubmitInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceGroupSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupSubmitInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceGroupBindSparseInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupBindSparseInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceGroupBindSparseInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupBindSparseInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceGroupPresentCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, &item.modes));
}

pub fn check_VkImageSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageSwapchainCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindImageMemorySwapchainInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemorySwapchainInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAcquireNextImageInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireNextImageInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceGroupPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, &item.mode));
}

pub fn check_VkDeviceGroupDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupDeviceCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceGroupDeviceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupDeviceCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceGroupSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupSwapchainCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions, &item.modes));
}

pub fn check_VkDescriptorUpdateTemplateEntry(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateEntry) bool {
    return (check_enum_VkDescriptorType(extensions, &item.descriptorType));
}

pub fn check_VkDescriptorUpdateTemplateEntryKHR(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateEntryKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDescriptorUpdateTemplateCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDescriptorUpdateTemplateType(extensions, &item.templateType) and
        check_enum_VkPipelineBindPoint(extensions, &item.pipelineBindPoint));
}

pub fn check_VkDescriptorUpdateTemplateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkXYColorEXT(extensions: *const Extensions, item: *const vk.VkXYColorEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePresentIdFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentIdFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPresentIdKHR(extensions: *const Extensions, item: *const vk.VkPresentIdKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePresentId2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentId2FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPresentId2KHR(extensions: *const Extensions, item: *const vk.VkPresentId2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPresentWait2InfoKHR(extensions: *const Extensions, item: *const vk.VkPresentWait2InfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePresentWaitFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePresentWait2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkHdrMetadataEXT(extensions: *const Extensions, item: *const vk.VkHdrMetadataEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkHdrVividDynamicMetadataHUAWEI(extensions: *const Extensions, item: *const vk.VkHdrVividDynamicMetadataHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayNativeHdrSurfaceCapabilitiesAMD(extensions: *const Extensions, item: *const vk.VkDisplayNativeHdrSurfaceCapabilitiesAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSwapchainDisplayNativeHdrCreateInfoAMD(extensions: *const Extensions, item: *const vk.VkSwapchainDisplayNativeHdrCreateInfoAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRefreshCycleDurationGOOGLE(extensions: *const Extensions, item: *const vk.VkRefreshCycleDurationGOOGLE) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPastPresentationTimingGOOGLE(extensions: *const Extensions, item: *const vk.VkPastPresentationTimingGOOGLE) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPresentTimesInfoGOOGLE(extensions: *const Extensions, item: *const vk.VkPresentTimesInfoGOOGLE) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPresentTimeGOOGLE(extensions: *const Extensions, item: *const vk.VkPresentTimeGOOGLE) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkIOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkIOSSurfaceCreateInfoMVK) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMacOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkMacOSSurfaceCreateInfoMVK) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMetalSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMetalSurfaceCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkViewportWScalingNV(extensions: *const Extensions, item: *const vk.VkViewportWScalingNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineViewportWScalingStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportWScalingStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkViewportSwizzleNV(extensions: *const Extensions, item: *const vk.VkViewportSwizzleNV) bool {
    return (check_enum_VkViewportCoordinateSwizzleNV(extensions, &item.x) and
        check_enum_VkViewportCoordinateSwizzleNV(extensions, &item.y) and
        check_enum_VkViewportCoordinateSwizzleNV(extensions, &item.z) and
        check_enum_VkViewportCoordinateSwizzleNV(extensions, &item.w));
}

pub fn check_VkPipelineViewportSwizzleStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDiscardRectanglePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineDiscardRectangleStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDiscardRectangleModeEXT(extensions, &item.discardRectangleMode));
}

pub fn check_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkInputAttachmentAspectReference(extensions: *const Extensions, item: *const vk.VkInputAttachmentAspectReference) bool {
    return (check_bitmask_VkImageAspectFlagBits(extensions, &item.aspectMask));
}

pub fn check_VkInputAttachmentAspectReferenceKHR(extensions: *const Extensions, item: *const vk.VkInputAttachmentAspectReferenceKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassInputAttachmentAspectCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassInputAttachmentAspectCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassInputAttachmentAspectCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassInputAttachmentAspectCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSurfaceInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSurfaceInfo2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceFormat2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormat2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayProperties2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayPlaneProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneProperties2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayModeProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayModeProperties2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayModeStereoPropertiesNV(extensions: *const Extensions, item: *const vk.VkDisplayModeStereoPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayPlaneInfo2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneInfo2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDisplayPlaneCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilities2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSharedPresentSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSharedPresentSurfaceCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.sharedPresentSupportedUsageFlags));
}

pub fn check_VkPhysicalDevice16BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice16BitStorageFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevice16BitStorageFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevice16BitStorageFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.supportedStages) and
        check_bitmask_VkSubgroupFeatureFlagBits(extensions, &item.supportedOperations));
}

pub fn check_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkBufferMemoryRequirementsInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkBufferMemoryRequirementsInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceBufferMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceBufferMemoryRequirements) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceBufferMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkDeviceBufferMemoryRequirementsKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageMemoryRequirementsInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkImageMemoryRequirementsInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageSparseMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageSparseMemoryRequirementsInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageSparseMemoryRequirementsInfo2KHR(extensions: *const Extensions, item: *const vk.VkImageSparseMemoryRequirementsInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceImageMemoryRequirements) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageAspectFlagBits(extensions, &item.planeAspect));
}

pub fn check_VkDeviceImageMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkDeviceImageMemoryRequirementsKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkMemoryRequirements2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryRequirements2KHR(extensions: *const Extensions, item: *const vk.VkMemoryRequirements2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSparseImageMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSparseImageMemoryRequirements2KHR(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePointClippingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePointClippingProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPointClippingBehavior(extensions, &item.pointClippingBehavior));
}

pub fn check_VkPhysicalDevicePointClippingPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePointClippingPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryDedicatedRequirements(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedRequirements) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryDedicatedRequirementsKHR(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedRequirementsKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryDedicatedAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryDedicatedAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageViewUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewUsageCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.usage));
}

pub fn check_VkImageViewSlicedCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewSlicedCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageViewUsageCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageViewUsageCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineTessellationDomainOriginStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkTessellationDomainOrigin(extensions, &item.domainOrigin));
}

pub fn check_VkPipelineTessellationDomainOriginStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSamplerYcbcrConversionInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerYcbcrConversionInfoKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSamplerYcbcrConversionCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_enum_VkSamplerYcbcrModelConversion(extensions, &item.ycbcrModel) and
        check_enum_VkSamplerYcbcrRange(extensions, &item.ycbcrRange) and
        check_enum_VkChromaLocation(extensions, &item.xChromaOffset) and
        check_enum_VkChromaLocation(extensions, &item.yChromaOffset) and
        check_enum_VkFilter(extensions, &item.chromaFilter));
}

pub fn check_VkSamplerYcbcrConversionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindImagePlaneMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImagePlaneMemoryInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageAspectFlagBits(extensions, &item.planeAspect));
}

pub fn check_VkBindImagePlaneMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImagePlaneMemoryInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImagePlaneMemoryRequirementsInfo(extensions: *const Extensions, item: *const vk.VkImagePlaneMemoryRequirementsInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageAspectFlagBits(extensions, &item.planeAspect));
}

pub fn check_VkImagePlaneMemoryRequirementsInfoKHR(extensions: *const Extensions, item: *const vk.VkImagePlaneMemoryRequirementsInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSamplerYcbcrConversionImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionImageFormatProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerYcbcrConversionImageFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionImageFormatPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkTextureLODGatherFormatPropertiesAMD(extensions: *const Extensions, item: *const vk.VkTextureLODGatherFormatPropertiesAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkConditionalRenderingBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingBeginInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkConditionalRenderingFlagBitsEXT(extensions, &item.flags));
}

pub fn check_VkProtectedSubmitInfo(extensions: *const Extensions, item: *const vk.VkProtectedSubmitInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceProtectedMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceProtectedMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceQueueInfo2(extensions: *const Extensions, item: *const vk.VkDeviceQueueInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDeviceQueueCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkPipelineCoverageToColorStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageToColorStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSamplerFilterMinmaxProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSampleLocationEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSampleLocationsInfoEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationsInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.sampleLocationsPerPixel));
}

pub fn check_VkAttachmentSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkAttachmentSampleLocationsEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubpassSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkSubpassSampleLocationsEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassSampleLocationsBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSampleLocationsBeginInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineSampleLocationsStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSampleLocationsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.sampleLocationSampleCounts));
}

pub fn check_VkMultisamplePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMultisamplePropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerReductionModeCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerReductionModeCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkSamplerReductionMode(extensions, &item.reductionMode));
}

pub fn check_VkSamplerReductionModeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerReductionModeCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineColorBlendAdvancedStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkBlendOverlapEXT(extensions, &item.blendOverlap));
}

pub fn check_VkPhysicalDeviceInlineUniformBlockFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceInlineUniformBlockProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkWriteDescriptorSetInlineUniformBlock(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetInlineUniformBlock) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkWriteDescriptorSetInlineUniformBlockEXT(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetInlineUniformBlockEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDescriptorPoolInlineUniformBlockCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineCoverageModulationStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageModulationStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCoverageModulationModeNV(extensions, &item.coverageModulationMode));
}

pub fn check_VkImageFormatListCreateInfo(extensions: *const Extensions, item: *const vk.VkImageFormatListCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.pViewFormats));
}

pub fn check_VkImageFormatListCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageFormatListCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkShaderModuleValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleValidationCacheCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance3Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance3Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance3PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance3PropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance4Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance4FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance4Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance4PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4PropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance5Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance5FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance5Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance5PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5PropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance6Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance6FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance6Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance6PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6PropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance7PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLayeredApiPropertiesListKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLayeredApiPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPhysicalDeviceLayeredApiKHR(extensions, &item.layeredAPI));
}

pub fn check_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMaintenance9PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDefaultVertexAttributeValueKHR(extensions, &item.defaultVertexAttributeValue));
}

pub fn check_VkQueueFamilyOwnershipTransferPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderingAreaInfo(extensions: *const Extensions, item: *const vk.VkRenderingAreaInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.pColorAttachmentFormats) and
        check_enum_VkFormat(extensions, &item.depthAttachmentFormat) and
        check_enum_VkFormat(extensions, &item.stencilAttachmentFormat));
}

pub fn check_VkRenderingAreaInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAreaInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDescriptorSetLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutSupport) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorSetLayoutSupportKHR(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutSupportKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderDrawParametersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderDrawParameterFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDrawParameterFeatures) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderFloat16Int8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat16Int8Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat16Int8FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceFloat16Int8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloat16Int8FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceFloatControlsProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloatControlsProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkShaderFloatControlsIndependence(extensions, &item.denormBehaviorIndependence) and
        check_enum_VkShaderFloatControlsIndependence(extensions, &item.roundingModeIndependence));
}

pub fn check_VkPhysicalDeviceFloatControlsPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloatControlsPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceHostQueryResetFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostQueryResetFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceHostQueryResetFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostQueryResetFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkNativeBufferUsage2ANDROID(extensions: *const Extensions, item: *const vk.VkNativeBufferUsage2ANDROID) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkNativeBufferANDROID(extensions: *const Extensions, item: *const vk.VkNativeBufferANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSwapchainImageCreateInfoANDROID(extensions: *const Extensions, item: *const vk.VkSwapchainImageCreateInfoANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSwapchainImageUsageFlagBitsANDROID(extensions, &item.usage));
}

pub fn check_VkPhysicalDevicePresentationPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentationPropertiesANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkShaderResourceUsageAMD(extensions: *const Extensions, item: *const vk.VkShaderResourceUsageAMD) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkShaderStatisticsInfoAMD(extensions: *const Extensions, item: *const vk.VkShaderStatisticsInfoAMD) bool {
    return (check_bitmask_VkShaderStageFlagBits(extensions, &item.shaderStageMask));
}

pub fn check_VkDeviceQueueGlobalPriorityCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkQueueGlobalPriority(extensions, &item.globalPriority));
}

pub fn check_VkDeviceQueueGlobalPriorityCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceQueueGlobalPriorityCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkQueueFamilyGlobalPriorityProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkQueueGlobalPriority(extensions, &item.priorities));
}

pub fn check_VkQueueFamilyGlobalPriorityPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkQueueFamilyGlobalPriorityPropertiesEXT(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDebugUtilsObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectNameInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkObjectType(extensions, &item.objectType));
}

pub fn check_VkDebugUtilsObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectTagInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkObjectType(extensions, &item.objectType));
}

pub fn check_VkDebugUtilsLabelEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsLabelEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDebugUtilsMessengerCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDebugUtilsMessageSeverityFlagBitsEXT(extensions, &item.messageSeverity) and
        check_bitmask_VkDebugUtilsMessageTypeFlagBitsEXT(extensions, &item.messageType));
}

pub fn check_VkDebugUtilsMessengerCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCallbackDataEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceDeviceMemoryReportCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceMemoryReportCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportCallbackDataEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDeviceMemoryReportEventTypeEXT(extensions, &item.type) and
        check_enum_VkObjectType(extensions, &item.objectType));
}

pub fn check_VkImportMemoryHostPointerInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryHostPointerInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkMemoryHostPointerPropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryHostPointerPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCalibratedTimestampInfoKHR(extensions: *const Extensions, item: *const vk.VkCalibratedTimestampInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkTimeDomainKHR(extensions, &item.timeDomain));
}

pub fn check_VkCalibratedTimestampInfoEXT(extensions: *const Extensions, item: *const vk.VkCalibratedTimestampInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderCorePropertiesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderCoreProperties2AMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderCorePropertiesFlagBitsAMD(extensions, &item.shaderCoreFeatures));
}

pub fn check_VkPipelineRasterizationConservativeStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkConservativeRasterizationModeEXT(extensions, &item.conservativeRasterizationMode));
}

pub fn check_VkPhysicalDeviceDescriptorIndexingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDescriptorIndexingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDescriptorSetLayoutBindingFlagsCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDescriptorBindingFlagBits(extensions, &item.pBindingFlags));
}

pub fn check_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDescriptorSetVariableDescriptorCountAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDescriptorSetVariableDescriptorCountLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAttachmentDescription2(extensions: *const Extensions, item: *const vk.VkAttachmentDescription2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkAttachmentDescriptionFlagBits(extensions, &item.flags) and
        check_enum_VkFormat(extensions, &item.format) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.samples) and
        check_enum_VkAttachmentLoadOp(extensions, &item.loadOp) and
        check_enum_VkAttachmentStoreOp(extensions, &item.storeOp) and
        check_enum_VkAttachmentLoadOp(extensions, &item.stencilLoadOp) and
        check_enum_VkAttachmentStoreOp(extensions, &item.stencilStoreOp) and
        check_enum_VkImageLayout(extensions, &item.initialLayout) and
        check_enum_VkImageLayout(extensions, &item.finalLayout));
}

pub fn check_VkAttachmentDescription2KHR(extensions: *const Extensions, item: *const vk.VkAttachmentDescription2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAttachmentReference2(extensions: *const Extensions, item: *const vk.VkAttachmentReference2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.layout) and
        check_bitmask_VkImageAspectFlagBits(extensions, &item.aspectMask));
}

pub fn check_VkAttachmentReference2KHR(extensions: *const Extensions, item: *const vk.VkAttachmentReference2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubpassDescription2(extensions: *const Extensions, item: *const vk.VkSubpassDescription2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSubpassDescriptionFlagBits(extensions, &item.flags) and
        check_enum_VkPipelineBindPoint(extensions, &item.pipelineBindPoint));
}

pub fn check_VkSubpassDescription2KHR(extensions: *const Extensions, item: *const vk.VkSubpassDescription2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubpassDependency2(extensions: *const Extensions, item: *const vk.VkSubpassDependency2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineStageFlagBits(extensions, &item.srcStageMask) and
        check_bitmask_VkPipelineStageFlagBits(extensions, &item.dstStageMask) and
        check_bitmask_VkAccessFlagBits(extensions, &item.srcAccessMask) and
        check_bitmask_VkAccessFlagBits(extensions, &item.dstAccessMask) and
        check_bitmask_VkDependencyFlagBits(extensions, &item.dependencyFlags));
}

pub fn check_VkSubpassDependency2KHR(extensions: *const Extensions, item: *const vk.VkSubpassDependency2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassCreateInfo2(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkRenderPassCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkRenderPassCreateInfo2KHR(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubpassBeginInfo(extensions: *const Extensions, item: *const vk.VkSubpassBeginInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkSubpassContents(extensions, &item.contents));
}

pub fn check_VkSubpassBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkSubpassBeginInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubpassEndInfo(extensions: *const Extensions, item: *const vk.VkSubpassEndInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSubpassEndInfoKHR(extensions: *const Extensions, item: *const vk.VkSubpassEndInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceTimelineSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTimelineSemaphorePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphorePropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSemaphoreTypeCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreTypeCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkSemaphoreType(extensions, &item.semaphoreType));
}

pub fn check_VkSemaphoreTypeCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreTypeCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkTimelineSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkTimelineSemaphoreSubmitInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTimelineSemaphoreSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkTimelineSemaphoreSubmitInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSemaphoreWaitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSemaphoreWaitFlagBits(extensions, &item.flags));
}

pub fn check_VkSemaphoreWaitInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSemaphoreSignalInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSignalInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSemaphoreSignalInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreSignalInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVertexInputBindingDivisorDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescription) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVertexInputBindingDivisorDescriptionKHR(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescriptionKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVertexInputBindingDivisorDescriptionEXT(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescriptionEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineVertexInputDivisorStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineVertexInputDivisorStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineVertexInputDivisorStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePCIBusInfoPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkImportAndroidHardwareBufferInfoANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAndroidHardwareBufferUsageANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferUsageANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAndroidHardwareBufferPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferPropertiesANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryGetAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkMemoryGetAndroidHardwareBufferInfoANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAndroidHardwareBufferFormatPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatPropertiesANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_bitmask_VkFormatFeatureFlagBits(extensions, &item.formatFeatures) and
        check_enum_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel) and
        check_enum_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange) and
        check_enum_VkChromaLocation(extensions, &item.suggestedXChromaOffset) and
        check_enum_VkChromaLocation(extensions, &item.suggestedYChromaOffset));
}

pub fn check_VkCommandBufferInheritanceConditionalRenderingInfoEXT(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalFormatANDROID(extensions: *const Extensions, item: *const vk.VkExternalFormatANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevice8BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice8BitStorageFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevice8BitStorageFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevice8BitStorageFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderAtomicInt64Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicInt64Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkQueueFamilyCheckpointPropertiesNV(extensions: *const Extensions, item: *const vk.VkQueueFamilyCheckpointPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineStageFlagBits(extensions, &item.checkpointExecutionStageMask));
}

pub fn check_VkCheckpointDataNV(extensions: *const Extensions, item: *const vk.VkCheckpointDataNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineStageFlagBits(extensions, &item.stage));
}

pub fn check_VkPhysicalDeviceDepthStencilResolveProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthStencilResolveProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkResolveModeFlagBits(extensions, &item.supportedDepthResolveModes) and
        check_bitmask_VkResolveModeFlagBits(extensions, &item.supportedStencilResolveModes));
}

pub fn check_VkPhysicalDeviceDepthStencilResolvePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthStencilResolvePropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubpassDescriptionDepthStencilResolve(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionDepthStencilResolve) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkResolveModeFlagBits(extensions, &item.depthResolveMode) and
        check_bitmask_VkResolveModeFlagBits(extensions, &item.stencilResolveMode));
}

pub fn check_VkSubpassDescriptionDepthStencilResolveKHR(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionDepthStencilResolveKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageViewASTCDecodeModeEXT(extensions: *const Extensions, item: *const vk.VkImageViewASTCDecodeModeEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.decodeMode));
}

pub fn check_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTransformFeedbackPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineRasterizationStateStreamCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExclusiveScissorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineViewportExclusiveScissorStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCornerSampledImageFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderImageFootprintFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkQueueFlagBits(extensions, &item.supportedQueues));
}

pub fn check_VkPhysicalDeviceMemoryDecompressionFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMemoryDecompressionPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkShadingRatePaletteNV(extensions: *const Extensions, item: *const vk.VkShadingRatePaletteNV) bool {
    return (check_enum_VkShadingRatePaletteEntryNV(extensions, &item.pShadingRatePaletteEntries));
}

pub fn check_VkPipelineViewportShadingRateImageStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShadingRateImageFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShadingRateImagePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCoarseSampleLocationNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleLocationNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCoarseSampleOrderCustomNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleOrderCustomNV) bool {
    return (check_enum_VkShadingRatePaletteEntryNV(extensions, &item.shadingRate));
}

pub fn check_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCoarseSampleOrderTypeNV(extensions, &item.sampleOrderType));
}

pub fn check_VkPhysicalDeviceMeshShaderFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMeshShaderPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDrawMeshTasksIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkDrawMeshTasksIndirectCommandNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMeshShaderPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDrawMeshTasksIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawMeshTasksIndirectCommandEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRayTracingShaderGroupCreateInfoNV(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkRayTracingShaderGroupTypeKHR(extensions, &item.type));
}

pub fn check_VkRayTracingShaderGroupCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkRayTracingShaderGroupTypeKHR(extensions, &item.type));
}

pub fn check_VkRayTracingPipelineCreateInfoNV(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkRayTracingPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkGeometryTrianglesNV(extensions: *const Extensions, item: *const vk.VkGeometryTrianglesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.vertexFormat) and
        check_enum_VkIndexType(extensions, &item.indexType));
}

pub fn check_VkGeometryAABBNV(extensions: *const Extensions, item: *const vk.VkGeometryAABBNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkGeometryDataNV(extensions: *const Extensions, item: *const vk.VkGeometryDataNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkGeometryNV(extensions: *const Extensions, item: *const vk.VkGeometryNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkGeometryTypeKHR(extensions, &item.geometryType) and
        check_bitmask_VkGeometryFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkAccelerationStructureInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureCreateInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindAccelerationStructureMemoryInfoNV(extensions: *const Extensions, item: *const vk.VkBindAccelerationStructureMemoryInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkWriteDescriptorSetAccelerationStructureKHR(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetAccelerationStructureKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkWriteDescriptorSetAccelerationStructureNV(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetAccelerationStructureNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureMemoryRequirementsInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkAccelerationStructureMemoryRequirementsTypeNV(extensions, &item.type));
}

pub fn check_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceAccelerationStructurePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkStridedDeviceAddressRegionKHR(extensions: *const Extensions, item: *const vk.VkStridedDeviceAddressRegionKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkTraceRaysIndirectCommandKHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommandKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkTraceRaysIndirectCommand2KHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommand2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDrmFormatModifierPropertiesListEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesListEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesEXT) bool {
    return (check_bitmask_VkFormatFeatureFlagBits(extensions, &item.drmFormatModifierTilingFeatures));
}

pub fn check_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkSharingMode(extensions, &item.sharingMode));
}

pub fn check_VkImageDrmFormatModifierListCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierListCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageDrmFormatModifierExplicitCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageStencilUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageStencilUsageCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.stencilUsage));
}

pub fn check_VkImageStencilUsageCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageStencilUsageCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceMemoryOverallocationCreateInfoAMD(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkMemoryOverallocationBehaviorAMD(extensions, &item.overallocationBehavior));
}

pub fn check_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(extensions: *const Extensions, item: *const vk.VkSubpassFragmentDensityMapOffsetEndInfoQCOM) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSurfaceProtectedCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceProtectedCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineRasterizationDepthClipStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMemoryBudgetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryPriorityAllocateInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryPriorityAllocateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceBufferDeviceAddressFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceBufferAddressFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferAddressFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferDeviceAddressInfo(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferDeviceAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferDeviceAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferOpaqueCaptureAddressCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferOpaqueCaptureAddressCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferOpaqueCaptureAddressCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkBufferOpaqueCaptureAddressCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferDeviceAddressCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageViewImageFormatInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageViewType(extensions, &item.imageViewType));
}

pub fn check_VkFilterCubicImageViewImageFormatPropertiesEXT(extensions: *const Extensions, item: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImagelessFramebufferFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImagelessFramebufferFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkFramebufferAttachmentsCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentsCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFramebufferAttachmentsCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentsCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkFramebufferAttachmentImageInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentImageInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageCreateFlagBits(extensions, &item.flags) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.usage) and
        check_enum_VkFormat(extensions, &item.pViewFormats));
}

pub fn check_VkFramebufferAttachmentImageInfoKHR(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentImageInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassAttachmentBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassAttachmentBeginInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassAttachmentBeginInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderPassAttachmentBeginInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceCooperativeMatrixFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCooperativeMatrixPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.cooperativeMatrixSupportedStages));
}

pub fn check_VkCooperativeMatrixPropertiesNV(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageViewHandleInfoNVX(extensions: *const Extensions, item: *const vk.VkImageViewHandleInfoNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDescriptorType(extensions, &item.descriptorType));
}

pub fn check_VkImageViewAddressPropertiesNVX(extensions: *const Extensions, item: *const vk.VkImageViewAddressPropertiesNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPresentFrameTokenGGP(extensions: *const Extensions, item: *const vk.VkPresentFrameTokenGGP) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineCreationFeedback(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedback) bool {
    return (check_bitmask_VkPipelineCreationFeedbackFlagBits(extensions, &item.flags));
}

pub fn check_VkPipelineCreationFeedbackEXT(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineCreationFeedbackCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineCreationFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSurfaceFullScreenExclusiveInfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFullScreenExclusiveEXT(extensions, &item.fullScreenExclusive));
}

pub fn check_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveWin32InfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceCapabilitiesFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesFullScreenExclusiveEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePresentBarrierFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceCapabilitiesPresentBarrierNV(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentBarrierNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSwapchainPresentBarrierCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSwapchainPresentBarrierCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePerformanceQueryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPerformanceCounterKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPerformanceCounterUnitKHR(extensions, &item.unit) and
        check_enum_VkPerformanceCounterScopeKHR(extensions, &item.scope) and
        check_enum_VkPerformanceCounterStorageKHR(extensions, &item.storage));
}

pub fn check_VkPerformanceCounterDescriptionKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPerformanceCounterDescriptionFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkQueryPoolPerformanceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAcquireProfilingLockInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkAcquireProfilingLockFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkPerformanceQuerySubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQuerySubmitInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPerformanceQueryReservationInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQueryReservationInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkHeadlessSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkHeadlessSurfaceCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCoverageReductionModeFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineCoverageReductionStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageReductionStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCoverageReductionModeNV(extensions, &item.coverageReductionMode));
}

pub fn check_VkFramebufferMixedSamplesCombinationNV(extensions: *const Extensions, item: *const vk.VkFramebufferMixedSamplesCombinationNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCoverageReductionModeNV(extensions, &item.coverageReductionMode) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.rasterizationSamples) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.depthStencilSamples) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.colorSamples));
}

pub fn check_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPerformanceValueINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueINTEL) bool {
    return (check_enum_VkPerformanceValueTypeINTEL(extensions, &item.type));
}

pub fn check_VkInitializePerformanceApiInfoINTEL(extensions: *const Extensions, item: *const vk.VkInitializePerformanceApiInfoINTEL) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkQueryPoolPerformanceQueryCreateInfoINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkQueryPoolSamplingModeINTEL(extensions, &item.performanceCountersSampling));
}

pub fn check_VkQueryPoolCreateInfoINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateInfoINTEL) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPerformanceMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceMarkerInfoINTEL) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPerformanceStreamMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceStreamMarkerInfoINTEL) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPerformanceOverrideInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideInfoINTEL) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPerformanceOverrideTypeINTEL(extensions, &item.type));
}

pub fn check_VkPerformanceConfigurationAcquireInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationAcquireInfoINTEL) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPerformanceConfigurationTypeINTEL(extensions, &item.type));
}

pub fn check_VkPhysicalDeviceShaderClockFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceIndexTypeUint8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceIndexTypeUint8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8FeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAttachmentReferenceStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentReferenceStencilLayout) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.stencilLayout));
}

pub fn check_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAttachmentReferenceStencilLayoutKHR(extensions: *const Extensions, item: *const vk.VkAttachmentReferenceStencilLayoutKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAttachmentDescriptionStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionStencilLayout) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.stencilInitialLayout) and
        check_enum_VkImageLayout(extensions, &item.stencilFinalLayout));
}

pub fn check_VkAttachmentDescriptionStencilLayoutKHR(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionStencilLayoutKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineExecutablePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutablePropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stages));
}

pub fn check_VkPipelineExecutableInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineExecutableStatisticKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineExecutableStatisticFormatKHR(extensions, &item.format));
}

pub fn check_VkPipelineExecutableInternalRepresentationKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInternalRepresentationKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTexelBufferAlignmentProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.requiredSubgroupSizeStages));
}

pub fn check_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkShaderRequiredSubgroupSizeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderRequiredSubgroupSizeCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubpassShadingPipelineCreateInfoHUAWEI(extensions: *const Extensions, item: *const vk.VkSubpassShadingPipelineCreateInfoHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryOpaqueCaptureAddressAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryOpaqueCaptureAddressAllocateInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceMemoryOpaqueCaptureAddressInfo(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceMemoryOpaqueCaptureAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLineRasterizationFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLineRasterizationPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceLineRasterizationPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineRasterizationLineStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkLineRasterizationMode(extensions, &item.lineRasterizationMode));
}

pub fn check_VkPipelineRasterizationLineStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineRasterizationLineStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceVulkan11Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVulkan11Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.subgroupSupportedStages) and
        check_bitmask_VkSubgroupFeatureFlagBits(extensions, &item.subgroupSupportedOperations) and
        check_enum_VkPointClippingBehavior(extensions, &item.pointClippingBehavior));
}

pub fn check_VkPhysicalDeviceVulkan12Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVulkan12Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDriverId(extensions, &item.driverID) and
        check_enum_VkShaderFloatControlsIndependence(extensions, &item.denormBehaviorIndependence) and
        check_enum_VkShaderFloatControlsIndependence(extensions, &item.roundingModeIndependence) and
        check_bitmask_VkResolveModeFlagBits(extensions, &item.supportedDepthResolveModes) and
        check_bitmask_VkResolveModeFlagBits(extensions, &item.supportedStencilResolveModes) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.framebufferIntegerColorSampleCounts));
}

pub fn check_VkPhysicalDeviceVulkan13Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVulkan13Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.requiredSubgroupSizeStages));
}

pub fn check_VkPhysicalDeviceVulkan14Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVulkan14Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessStorageBuffers) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessUniformBuffers) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessVertexInputs) and
        check_enum_VkPipelineRobustnessImageBehavior(extensions, &item.defaultRobustnessImages) and
        check_enum_VkImageLayout(extensions, &item.pCopySrcLayouts) and
        check_enum_VkImageLayout(extensions, &item.pCopyDstLayouts));
}

pub fn check_VkPipelineCompilerControlCreateInfoAMD(extensions: *const Extensions, item: *const vk.VkPipelineCompilerControlCreateInfoAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineCompilerControlFlagBitsAMD(extensions, &item.compilerControlFlags));
}

pub fn check_VkPhysicalDeviceCoherentMemoryFeaturesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFaultData(extensions: *const Extensions, item: *const vk.VkFaultData) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFaultLevel(extensions, &item.faultLevel) and
        check_enum_VkFaultType(extensions, &item.faultType));
}

pub fn check_VkFaultCallbackInfo(extensions: *const Extensions, item: *const vk.VkFaultCallbackInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceToolProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceToolProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkToolPurposeFlagBits(extensions, &item.purposes));
}

pub fn check_VkPhysicalDeviceToolPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceToolPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSamplerCustomBorderColorCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCustomBorderColorCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkPhysicalDeviceCustomBorderColorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerBorderColorComponentMappingCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureGeometryTrianglesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.vertexFormat) and
        check_enum_VkIndexType(extensions, &item.indexType));
}

pub fn check_VkAccelerationStructureGeometryAabbsDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryAabbsDataKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureGeometryInstancesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryInstancesDataKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureGeometryLinearSweptSpheresDataNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.vertexFormat) and
        check_enum_VkFormat(extensions, &item.radiusFormat) and
        check_enum_VkIndexType(extensions, &item.indexType) and
        check_enum_VkRayTracingLssIndexingModeNV(extensions, &item.indexingMode) and
        check_enum_VkRayTracingLssPrimitiveEndCapsModeNV(extensions, &item.endCapsMode));
}

pub fn check_VkAccelerationStructureGeometrySpheresDataNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometrySpheresDataNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.vertexFormat) and
        check_enum_VkFormat(extensions, &item.radiusFormat) and
        check_enum_VkIndexType(extensions, &item.indexType));
}

pub fn check_VkAccelerationStructureGeometryKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkGeometryTypeKHR(extensions, &item.geometryType) and
        check_bitmask_VkGeometryFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkAccelerationStructureBuildGeometryInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildGeometryInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkAccelerationStructureTypeKHR(extensions, &item.type) and
        check_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions, &item.flags) and
        check_enum_VkBuildAccelerationStructureModeKHR(extensions, &item.mode));
}

pub fn check_VkAccelerationStructureBuildRangeInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildRangeInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAccelerationStructureCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkAccelerationStructureCreateFlagBitsKHR(extensions, &item.createFlags) and
        check_enum_VkAccelerationStructureTypeKHR(extensions, &item.type));
}

pub fn check_VkAabbPositionsKHR(extensions: *const Extensions, item: *const vk.VkAabbPositionsKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAabbPositionsNV(extensions: *const Extensions, item: *const vk.VkAabbPositionsNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkTransformMatrixKHR(extensions: *const Extensions, item: *const vk.VkTransformMatrixKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkTransformMatrixNV(extensions: *const Extensions, item: *const vk.VkTransformMatrixNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAccelerationStructureInstanceKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureInstanceKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAccelerationStructureInstanceNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureInstanceNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAccelerationStructureDeviceAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureDeviceAddressInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureVersionInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureVersionInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCopyAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCopyAccelerationStructureModeKHR(extensions, &item.mode));
}

pub fn check_VkCopyAccelerationStructureToMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCopyAccelerationStructureModeKHR(extensions, &item.mode));
}

pub fn check_VkCopyMemoryToAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCopyAccelerationStructureModeKHR(extensions, &item.mode));
}

pub fn check_VkRayTracingPipelineInterfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineLibraryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineLibraryCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRefreshObjectKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectKHR) bool {
    return (check_enum_VkObjectType(extensions, &item.objectType) and
        check_bitmask_VkRefreshObjectFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkRefreshObjectListKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectListKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkColorBlendEquationEXT(extensions: *const Extensions, item: *const vk.VkColorBlendEquationEXT) bool {
    return (check_enum_VkBlendFactor(extensions, &item.srcColorBlendFactor) and
        check_enum_VkBlendFactor(extensions, &item.dstColorBlendFactor) and
        check_enum_VkBlendOp(extensions, &item.colorBlendOp) and
        check_enum_VkBlendFactor(extensions, &item.srcAlphaBlendFactor) and
        check_enum_VkBlendFactor(extensions, &item.dstAlphaBlendFactor) and
        check_enum_VkBlendOp(extensions, &item.alphaBlendOp));
}

pub fn check_VkColorBlendAdvancedEXT(extensions: *const Extensions, item: *const vk.VkColorBlendAdvancedEXT) bool {
    return (check_enum_VkBlendOp(extensions, &item.advancedBlendOp) and
        check_enum_VkBlendOverlapEXT(extensions, &item.blendOverlap));
}

pub fn check_VkRenderPassTransformBeginInfoQCOM(extensions: *const Extensions, item: *const vk.VkRenderPassTransformBeginInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.transform));
}

pub fn check_VkCopyCommandTransformInfoQCOM(extensions: *const Extensions, item: *const vk.VkCopyCommandTransformInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.transform));
}

pub fn check_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions, &item.transform));
}

pub fn check_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBuildPartitionedAccelerationStructureIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBuildPartitionedAccelerationStructureIndirectCommandNV) bool {
    return (check_enum_VkPartitionedAccelerationStructureOpTypeNV(extensions, &item.opType));
}

pub fn check_VkPartitionedAccelerationStructureFlagsNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureFlagsNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPartitionedAccelerationStructureWriteInstanceDataNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureWriteInstanceDataNV) bool {
    return (check_bitmask_VkPartitionedAccelerationStructureInstanceFlagBitsNV(extensions, &item.instanceFlags));
}

pub fn check_VkPartitionedAccelerationStructureUpdateInstanceDataNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureUpdateInstanceDataNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureWritePartitionTranslationDataNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkWriteDescriptorSetPartitionedAccelerationStructureNV(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPartitionedAccelerationStructureInstancesInputNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureInstancesInputNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkBuildPartitionedAccelerationStructureInfoNV(extensions: *const Extensions, item: *const vk.VkBuildPartitionedAccelerationStructureInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceDiagnosticsConfigCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDeviceDiagnosticsConfigFlagBitsNV(extensions, &item.flags));
}

pub fn check_VkPipelineOfflineCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineOfflineCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineMatchControl(extensions, &item.matchControl));
}

pub fn check_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRobustness2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRobustness2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2FeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceRobustness2PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRobustness2PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2PropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceImageRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageRobustnessFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageRobustnessFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePortabilitySubsetPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevice4444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferCopy2(extensions: *const Extensions, item: *const vk.VkBufferCopy2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferCopy2KHR(extensions: *const Extensions, item: *const vk.VkBufferCopy2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageCopy2(extensions: *const Extensions, item: *const vk.VkImageCopy2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageCopy2KHR(extensions: *const Extensions, item: *const vk.VkImageCopy2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageBlit2(extensions: *const Extensions, item: *const vk.VkImageBlit2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageBlit2KHR(extensions: *const Extensions, item: *const vk.VkImageBlit2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferImageCopy2(extensions: *const Extensions, item: *const vk.VkBufferImageCopy2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferImageCopy2KHR(extensions: *const Extensions, item: *const vk.VkBufferImageCopy2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageResolve2(extensions: *const Extensions, item: *const vk.VkImageResolve2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageResolve2KHR(extensions: *const Extensions, item: *const vk.VkImageResolve2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCopyBufferInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyBufferInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.srcImageLayout) and
        check_enum_VkImageLayout(extensions, &item.dstImageLayout));
}

pub fn check_VkCopyImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyImageInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBlitImageInfo2(extensions: *const Extensions, item: *const vk.VkBlitImageInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.srcImageLayout) and
        check_enum_VkImageLayout(extensions, &item.dstImageLayout) and
        check_enum_VkFilter(extensions, &item.filter));
}

pub fn check_VkBlitImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkBlitImageInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyBufferToImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferToImageInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.dstImageLayout));
}

pub fn check_VkCopyBufferToImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyBufferToImageInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyImageToBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageToBufferInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.srcImageLayout));
}

pub fn check_VkCopyImageToBufferInfo2KHR(extensions: *const Extensions, item: *const vk.VkCopyImageToBufferInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkResolveImageInfo2(extensions: *const Extensions, item: *const vk.VkResolveImageInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.srcImageLayout) and
        check_enum_VkImageLayout(extensions, &item.dstImageLayout));
}

pub fn check_VkResolveImageInfo2KHR(extensions: *const Extensions, item: *const vk.VkResolveImageInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateAttachmentInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineFragmentShadingRateStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFragmentShadingRateCombinerOpKHR(extensions, &item.combinerOps));
}

pub fn check_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.maxFragmentShadingRateRasterizationSamples));
}

pub fn check_VkPhysicalDeviceFragmentShadingRateKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.sampleCounts));
}

pub fn check_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.maxFragmentShadingRateInvocationCount));
}

pub fn check_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFragmentShadingRateTypeNV(extensions, &item.shadingRateType) and
        check_enum_VkFragmentShadingRateNV(extensions, &item.shadingRate) and
        check_enum_VkFragmentShadingRateCombinerOpKHR(extensions, &item.combinerOps));
}

pub fn check_VkAccelerationStructureBuildSizesInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildSizesInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMutableDescriptorTypeListEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeListEXT) bool {
    return (check_enum_VkDescriptorType(extensions, &item.pDescriptorTypes));
}

pub fn check_VkMutableDescriptorTypeListVALVE(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeListVALVE) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMutableDescriptorTypeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMutableDescriptorTypeCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeCreateInfoVALVE) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions, &item.supportedIndirectCommandsInputModes) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.supportedIndirectCommandsShaderStages) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.supportedIndirectCommandsShaderStagesPipelineBinding) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.supportedIndirectCommandsShaderStagesShaderBinding));
}

pub fn check_VkGeneratedCommandsPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsPipelineInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkGeneratedCommandsShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsShaderInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkGeneratedCommandsMemoryRequirementsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkIndirectExecutionSetPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetPipelineInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkIndirectExecutionSetShaderLayoutInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkIndirectExecutionSetShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkIndirectExecutionSetCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkIndirectExecutionSetInfoTypeEXT(extensions, &item.type));
}

pub fn check_VkGeneratedCommandsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.shaderStages));
}

pub fn check_VkWriteIndirectExecutionSetPipelineEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetPipelineEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkWriteIndirectExecutionSetShaderEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetShaderEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkIndirectCommandsLayoutCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkIndirectCommandsLayoutUsageFlagBitsEXT(extensions, &item.flags) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.shaderStages));
}

pub fn check_VkIndirectCommandsLayoutTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutTokenEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkIndirectCommandsTokenTypeEXT(extensions, &item.type));
}

pub fn check_VkDrawIndirectCountIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawIndirectCountIndirectCommandEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkIndirectCommandsVertexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsVertexBufferTokenEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindVertexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindVertexBufferIndirectCommandEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkIndirectCommandsIndexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsIndexBufferTokenEXT) bool {
    return (check_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions, &item.mode));
}

pub fn check_VkBindIndexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindIndexBufferIndirectCommandEXT) bool {
    return (check_enum_VkIndexType(extensions, &item.indexType));
}

pub fn check_VkIndirectCommandsPushConstantTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsPushConstantTokenEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkIndirectCommandsExecutionSetTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsExecutionSetTokenEXT) bool {
    return (check_enum_VkIndirectExecutionSetInfoTypeEXT(extensions, &item.type) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.shaderStages));
}

pub fn check_VkPipelineViewportDepthClipControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineViewportDepthClampControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDepthClampModeEXT(extensions, &item.depthClampMode));
}

pub fn check_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVertexInputBindingDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription2EXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkVertexInputRate(extensions, &item.inputRate));
}

pub fn check_VkVertexInputAttributeDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription2EXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineColorWriteCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorWriteCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkMemoryBarrier2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkMemoryBarrier2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.oldLayout) and
        check_enum_VkImageLayout(extensions, &item.newLayout));
}

pub fn check_VkImageMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBufferMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferMemoryBarrier2KHR(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryBarrierAccessFlags3KHR(extensions: *const Extensions, item: *const vk.VkMemoryBarrierAccessFlags3KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDependencyInfo(extensions: *const Extensions, item: *const vk.VkDependencyInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDependencyFlagBits(extensions, &item.dependencyFlags));
}

pub fn check_VkDependencyInfoKHR(extensions: *const Extensions, item: *const vk.VkDependencyInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSubmitInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSemaphoreSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreSubmitInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCommandBufferSubmitInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferSubmitInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCommandBufferSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkCommandBufferSubmitInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubmitInfo2(extensions: *const Extensions, item: *const vk.VkSubmitInfo2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSubmitFlagBits(extensions, &item.flags));
}

pub fn check_VkSubmitInfo2KHR(extensions: *const Extensions, item: *const vk.VkSubmitInfo2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkQueueFamilyCheckpointProperties2NV(extensions: *const Extensions, item: *const vk.VkQueueFamilyCheckpointProperties2NV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCheckpointData2NV(extensions: *const Extensions, item: *const vk.VkCheckpointData2NV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSynchronization2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSynchronization2Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSynchronization2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSynchronization2FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceHostImageCopyFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceHostImageCopyFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceHostImageCopyProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.pCopySrcLayouts) and
        check_enum_VkImageLayout(extensions, &item.pCopyDstLayouts));
}

pub fn check_VkPhysicalDeviceHostImageCopyPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryToImageCopy(extensions: *const Extensions, item: *const vk.VkMemoryToImageCopy) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryToImageCopyEXT(extensions: *const Extensions, item: *const vk.VkMemoryToImageCopyEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageToMemoryCopy(extensions: *const Extensions, item: *const vk.VkImageToMemoryCopy) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageToMemoryCopyEXT(extensions: *const Extensions, item: *const vk.VkImageToMemoryCopyEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyMemoryToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkHostImageCopyFlagBits(extensions, &item.flags) and
        check_enum_VkImageLayout(extensions, &item.dstImageLayout));
}

pub fn check_VkCopyMemoryToImageInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyImageToMemoryInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToMemoryInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkHostImageCopyFlagBits(extensions, &item.flags) and
        check_enum_VkImageLayout(extensions, &item.srcImageLayout));
}

pub fn check_VkCopyImageToMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyImageToMemoryInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCopyImageToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToImageInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkHostImageCopyFlagBits(extensions, &item.flags) and
        check_enum_VkImageLayout(extensions, &item.srcImageLayout) and
        check_enum_VkImageLayout(extensions, &item.dstImageLayout));
}

pub fn check_VkCopyImageToImageInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyImageToImageInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkHostImageLayoutTransitionInfo(extensions: *const Extensions, item: *const vk.VkHostImageLayoutTransitionInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.oldLayout) and
        check_enum_VkImageLayout(extensions, &item.newLayout));
}

pub fn check_VkHostImageLayoutTransitionInfoEXT(extensions: *const Extensions, item: *const vk.VkHostImageLayoutTransitionInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubresourceHostMemcpySize(extensions: *const Extensions, item: *const vk.VkSubresourceHostMemcpySize) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSubresourceHostMemcpySizeEXT(extensions: *const Extensions, item: *const vk.VkSubresourceHostMemcpySizeEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkHostImageCopyDevicePerformanceQuery(extensions: *const Extensions, item: *const vk.VkHostImageCopyDevicePerformanceQuery) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkHostImageCopyDevicePerformanceQueryEXT(extensions: *const Extensions, item: *const vk.VkHostImageCopyDevicePerformanceQueryEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceVulkanSC10Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Properties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelinePoolSize(extensions: *const Extensions, item: *const vk.VkPipelinePoolSize) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceObjectReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceObjectReservationCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCommandPoolMemoryReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryReservationCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCommandPoolMemoryConsumption(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryConsumption) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVulkanSC10Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceCapabilitiesPresentId2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentId2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceCapabilitiesPresentWait2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentWait2KHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSubpassResolvePerformanceQueryEXT(extensions: *const Extensions, item: *const vk.VkSubpassResolvePerformanceQueryEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMultisampledRenderToSingleSampledInfoEXT(extensions: *const Extensions, item: *const vk.VkMultisampledRenderToSingleSampledInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.rasterizationSamples));
}

pub fn check_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkQueueFamilyVideoPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyVideoPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions, &item.videoCodecOperations));
}

pub fn check_VkQueueFamilyQueryResultStatusPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoProfileListInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileListInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVideoFormatInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoFormatInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.imageUsage));
}

pub fn check_VkVideoFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_bitmask_VkImageCreateFlagBits(extensions, &item.imageCreateFlags) and
        check_enum_VkImageType(extensions, &item.imageType) and
        check_enum_VkImageTiling(extensions, &item.imageTiling) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.imageUsageFlags));
}

pub fn check_VkVideoEncodeQuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QuantizationMapCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QuantizationMapCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoFormatQuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatQuantizationMapPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoFormatH265QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatH265QuantizationMapPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions, &item.compatibleCtbSizes));
}

pub fn check_VkVideoFormatAV1QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatAV1QuantizationMapPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions, &item.compatibleSuperblockSizes));
}

pub fn check_VkVideoProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions, &item.videoCodecOperation) and
        check_bitmask_VkVideoChromaSubsamplingFlagBitsKHR(extensions, &item.chromaSubsampling) and
        check_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions, &item.lumaBitDepth) and
        check_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions, &item.chromaBitDepth));
}

pub fn check_VkVideoCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoCapabilityFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoSessionMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionMemoryRequirementsKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindVideoSessionMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindVideoSessionMemoryInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoPictureResourceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoPictureResourceInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoReferenceSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceSlotInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoDecodeCapabilityFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoDecodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoDecodeUsageFlagBitsKHR(extensions, &item.videoUsageHints));
}

pub fn check_VkVideoDecodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoInlineQueryInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoInlineQueryInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264ProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoDecodeH264PictureLayoutFlagBitsKHR(extensions, &item.pictureLayout));
}

pub fn check_VkVideoDecodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264CapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersAddInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH264InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264InlineSessionParametersInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264DpbSlotInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265ProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265CapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersAddInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH265InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265InlineSessionParametersInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265PictureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265DpbSlotInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeVP9ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9ProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeVP9CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9CapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeVP9PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9PictureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1ProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1CapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1SessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeAV1InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1InlineSessionParametersInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1PictureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoDecodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1DpbSlotInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoSessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoSessionCreateFlagBitsKHR(extensions, &item.flags) and
        check_enum_VkFormat(extensions, &item.pictureFormat) and
        check_enum_VkFormat(extensions, &item.referencePictureFormat));
}

pub fn check_VkVideoSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoSessionParametersCreateFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoSessionParametersUpdateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersUpdateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeSessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersGetInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeSessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoBeginCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoBeginCodingInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEndCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEndCodingInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoCodingControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoCodingControlFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoEncodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeUsageFlagBitsKHR(extensions, &item.videoUsageHints) and
        check_bitmask_VkVideoEncodeContentFlagBitsKHR(extensions, &item.videoContentHints) and
        check_enum_VkVideoEncodeTuningModeKHR(extensions, &item.tuningMode));
}

pub fn check_VkVideoEncodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoEncodeQuantizationMapInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions, &item.encodeFeedbackFlags));
}

pub fn check_VkVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeQualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, &item.preferredRateControlMode));
}

pub fn check_VkVideoEncodeRateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, &item.rateControlMode));
}

pub fn check_VkVideoEncodeRateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlLayerInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeCapabilityFlagBitsKHR(extensions, &item.flags) and
        check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions, &item.rateControlModes) and
        check_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions, &item.supportedEncodeFeedbackFlags));
}

pub fn check_VkVideoEncodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeH264CapabilityFlagBitsKHR(extensions, &item.flags) and
        check_bitmask_VkVideoEncodeH264StdFlagBitsKHR(extensions, &item.stdSyntaxFlags));
}

pub fn check_VkVideoEncodeH264QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QualityLevelPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions, &item.preferredRateControlFlags));
}

pub fn check_VkVideoEncodeH264SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersAddInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersGetInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersFeedbackInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264DpbSlotInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264PictureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264ProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264NaluSliceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264NaluSliceInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoEncodeH264QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QpKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVideoEncodeH264FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264FrameSizeKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVideoEncodeH264GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264GopRemainingFrameInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH264RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlLayerInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeH265CapabilityFlagBitsKHR(extensions, &item.flags) and
        check_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions, &item.ctbSizes) and
        check_bitmask_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(extensions, &item.transformBlockSizes) and
        check_bitmask_VkVideoEncodeH265StdFlagBitsKHR(extensions, &item.stdSyntaxFlags));
}

pub fn check_VkVideoEncodeH265QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QualityLevelPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions, &item.preferredRateControlFlags));
}

pub fn check_VkVideoEncodeH265SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersAddInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersGetInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersFeedbackInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265PictureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265NaluSliceSegmentInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265NaluSliceSegmentInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoEncodeH265QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QpKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVideoEncodeH265FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265FrameSizeKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVideoEncodeH265GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265GopRemainingFrameInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlLayerInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265ProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265DpbSlotInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeAV1CapabilityFlagBitsKHR(extensions, &item.flags) and
        check_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions, &item.superblockSizes) and
        check_bitmask_VkVideoEncodeAV1StdFlagBitsKHR(extensions, &item.stdSyntaxFlags));
}

pub fn check_VkVideoEncodeAV1QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QualityLevelPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions, &item.preferredRateControlFlags));
}

pub fn check_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionParametersCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1DpbSlotInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PictureInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkVideoEncodeAV1PredictionModeKHR(extensions, &item.predictionMode) and
        check_enum_VkVideoEncodeAV1RateControlGroupKHR(extensions, &item.rateControlGroup));
}

pub fn check_VkVideoEncodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1ProfileInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions, &item.flags));
}

pub fn check_VkVideoEncodeAV1QIndexKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QIndexKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVideoEncodeAV1FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1FrameSizeKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkVideoEncodeAV1GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1GopRemainingFrameInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoEncodeAV1RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlLayerInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCommandBufferInheritanceViewportScissorInfoNV(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceProvokingVertexPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkProvokingVertexModeEXT(extensions, &item.provokingVertexMode));
}

pub fn check_VkVideoEncodeIntraRefreshCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions, &item.intraRefreshModes));
}

pub fn check_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions, &item.intraRefreshMode));
}

pub fn check_VkVideoEncodeIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkVideoReferenceIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceIntraRefreshInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCuModuleCreateInfoNVX(extensions: *const Extensions, item: *const vk.VkCuModuleCreateInfoNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCuModuleTexturingModeCreateInfoNVX(extensions: *const Extensions, item: *const vk.VkCuModuleTexturingModeCreateInfoNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCuFunctionCreateInfoNVX(extensions: *const Extensions, item: *const vk.VkCuFunctionCreateInfoNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCuLaunchInfoNVX(extensions: *const Extensions, item: *const vk.VkCuLaunchInfoNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDescriptorBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorAddressInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkDescriptorBufferBindingInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkBufferUsageFlagBits(extensions, &item.usage));
}

pub fn check_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorGetInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorGetInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDescriptorType(extensions, &item.type));
}

pub fn check_VkBufferCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferCaptureDescriptorDataInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageCaptureDescriptorDataInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageViewCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewCaptureDescriptorDataInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCaptureDescriptorDataInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDrmPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDrmPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingValidationFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureGeometryMotionTrianglesDataNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureMotionInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSRTDataNV(extensions: *const Extensions, item: *const vk.VkSRTDataNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAccelerationStructureSRTMotionInstanceNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureSRTMotionInstanceNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAccelerationStructureMatrixMotionInstanceNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMatrixMotionInstanceNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAccelerationStructureMotionInstanceNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInstanceNV) bool {
    return (check_enum_VkAccelerationStructureMotionInstanceTypeNV(extensions, &item.type));
}

pub fn check_VkMemoryGetRemoteAddressInfoNV(extensions: *const Extensions, item: *const vk.VkMemoryGetRemoteAddressInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkImportMemoryBufferCollectionFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryBufferCollectionFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferCollectionImageCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionImageCreateInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferCollectionBufferCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionBufferCreateInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferCollectionCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionCreateInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBufferCollectionPropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionPropertiesFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFormatFeatureFlagBits(extensions, &item.formatFeatures) and
        check_enum_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel) and
        check_enum_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange) and
        check_enum_VkChromaLocation(extensions, &item.suggestedXChromaOffset) and
        check_enum_VkChromaLocation(extensions, &item.suggestedYChromaOffset));
}

pub fn check_VkBufferConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferConstraintsInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFormatFeatureFlagBits(extensions, &item.requiredFormatFeatures));
}

pub fn check_VkSysmemColorSpaceFUCHSIA(extensions: *const Extensions, item: *const vk.VkSysmemColorSpaceFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageFormatConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFormatFeatureFlagBits(extensions, &item.requiredFormatFeatures));
}

pub fn check_VkImageConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageConstraintsInfoFlagBitsFUCHSIA(extensions, &item.flags));
}

pub fn check_VkBufferCollectionConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionConstraintsInfoFUCHSIA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCudaModuleCreateInfoNV(extensions: *const Extensions, item: *const vk.VkCudaModuleCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCudaFunctionCreateInfoNV(extensions: *const Extensions, item: *const vk.VkCudaFunctionCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCudaLaunchInfoNV(extensions: *const Extensions, item: *const vk.VkCudaLaunchInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFormatProperties3(extensions: *const Extensions, item: *const vk.VkFormatProperties3) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFormatProperties3KHR(extensions: *const Extensions, item: *const vk.VkFormatProperties3KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDrmFormatModifierPropertiesList2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesList2EXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDrmFormatModifierProperties2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierProperties2EXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAndroidHardwareBufferFormatProperties2ANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatProperties2ANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_enum_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel) and
        check_enum_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange) and
        check_enum_VkChromaLocation(extensions, &item.suggestedXChromaOffset) and
        check_enum_VkChromaLocation(extensions, &item.suggestedYChromaOffset));
}

pub fn check_VkPipelineRenderingCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRenderingCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.pColorAttachmentFormats) and
        check_enum_VkFormat(extensions, &item.depthAttachmentFormat) and
        check_enum_VkFormat(extensions, &item.stencilAttachmentFormat));
}

pub fn check_VkPipelineRenderingCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineRenderingCreateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderingInfo(extensions: *const Extensions, item: *const vk.VkRenderingInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkRenderingFlagBits(extensions, &item.flags));
}

pub fn check_VkRenderingInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderingEndInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderingEndInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderingAttachmentInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.imageLayout) and
        check_bitmask_VkResolveModeFlagBits(extensions, &item.resolveMode) and
        check_enum_VkImageLayout(extensions, &item.resolveImageLayout) and
        check_enum_VkAttachmentLoadOp(extensions, &item.loadOp) and
        check_enum_VkAttachmentStoreOp(extensions, &item.storeOp));
}

pub fn check_VkRenderingAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderingFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.imageLayout));
}

pub fn check_VkRenderingFragmentDensityMapAttachmentInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkImageLayout(extensions, &item.imageLayout));
}

pub fn check_VkPhysicalDeviceDynamicRenderingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDynamicRenderingFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkCommandBufferInheritanceRenderingInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderingInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkRenderingFlagBits(extensions, &item.flags) and
        check_enum_VkFormat(extensions, &item.pColorAttachmentFormats) and
        check_enum_VkFormat(extensions, &item.depthAttachmentFormat) and
        check_enum_VkFormat(extensions, &item.stencilAttachmentFormat) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.rasterizationSamples));
}

pub fn check_VkCommandBufferInheritanceRenderingInfoKHR(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderingInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAttachmentSampleCountInfoAMD(extensions: *const Extensions, item: *const vk.VkAttachmentSampleCountInfoAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.pColorAttachmentSamples) and
        check_bitmask_VkSampleCountFlagBits(extensions, &item.depthStencilAttachmentSamples));
}

pub fn check_VkAttachmentSampleCountInfoNV(extensions: *const Extensions, item: *const vk.VkAttachmentSampleCountInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMultiviewPerViewAttributesInfoNVX(extensions: *const Extensions, item: *const vk.VkMultiviewPerViewAttributesInfoNVX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewMinLodFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageViewMinLodCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewMinLodCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDevicePipelineBinaryInternalCacheControlKHR(extensions: *const Extensions, item: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineBinaryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkGraphicsPipelineLibraryCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkGraphicsPipelineLibraryFlagBitsEXT(extensions, &item.flags));
}

pub fn check_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorSetBindingReferenceVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetBindingReferenceVALVE) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorSetLayoutHostMappingInfoVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkShaderModuleIdentifierEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleIdentifierEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageCompressionControlEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionControlEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageCompressionFlagBitsEXT(extensions, &item.flags) and
        check_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions, &item.pFixedRateFlags));
}

pub fn check_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageCompressionPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageCompressionFlagBitsEXT(extensions, &item.imageCompressionFlags) and
        check_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions, &item.imageCompressionFixedRateFlags));
}

pub fn check_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageSubresource2(extensions: *const Extensions, item: *const vk.VkImageSubresource2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageSubresource2KHR(extensions: *const Extensions, item: *const vk.VkImageSubresource2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageSubresource2EXT(extensions: *const Extensions, item: *const vk.VkImageSubresource2EXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubresourceLayout2(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSubresourceLayout2KHR(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2KHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSubresourceLayout2EXT(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2EXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassCreationControlEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationControlEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassCreationFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderPassCreationFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassSubpassFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackInfoEXT) bool {
    return (check_enum_VkSubpassMergeStatusEXT(extensions, &item.subpassMergeStatus));
}

pub fn check_VkRenderPassSubpassFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMicromapBuildInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkMicromapTypeEXT(extensions, &item.type) and
        check_bitmask_VkBuildMicromapFlagBitsEXT(extensions, &item.flags) and
        check_enum_VkBuildMicromapModeEXT(extensions, &item.mode));
}

pub fn check_VkMicromapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkMicromapCreateFlagBitsEXT(extensions, &item.createFlags) and
        check_enum_VkMicromapTypeEXT(extensions, &item.type));
}

pub fn check_VkMicromapVersionInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapVersionInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCopyMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCopyMicromapModeEXT(extensions, &item.mode));
}

pub fn check_VkCopyMicromapToMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapToMemoryInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCopyMicromapModeEXT(extensions, &item.mode));
}

pub fn check_VkCopyMemoryToMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMemoryToMicromapInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCopyMicromapModeEXT(extensions, &item.mode));
}

pub fn check_VkMicromapBuildSizesInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildSizesInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMicromapUsageEXT(extensions: *const Extensions, item: *const vk.VkMicromapUsageEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMicromapTriangleEXT(extensions: *const Extensions, item: *const vk.VkMicromapTriangleEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceOpacityMicromapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureTrianglesOpacityMicromapEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkIndexType(extensions, &item.indexType));
}

pub fn check_VkPhysicalDeviceDisplacementMicromapFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDisplacementMicromapFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDisplacementMicromapPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDisplacementMicromapPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAccelerationStructureTrianglesDisplacementMicromapNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTrianglesDisplacementMicromapNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.displacementBiasAndScaleFormat) and
        check_enum_VkFormat(extensions, &item.displacementVectorFormat) and
        check_enum_VkIndexType(extensions, &item.indexType));
}

pub fn check_VkPipelinePropertiesIdentifierEXT(extensions: *const Extensions, item: *const vk.VkPipelinePropertiesIdentifierEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalMemoryAcquireUnmodifiedEXT(extensions: *const Extensions, item: *const vk.VkExternalMemoryAcquireUnmodifiedEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExportMetalObjectCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExportMetalObjectTypeFlagBitsEXT(extensions, &item.exportObjectType));
}

pub fn check_VkExportMetalObjectsInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectsInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExportMetalDeviceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalDeviceInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExportMetalCommandQueueInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalCommandQueueInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalBufferInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalBufferInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalTextureInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageAspectFlagBits(extensions, &item.plane));
}

pub fn check_VkImportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalTextureInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageAspectFlagBits(extensions, &item.plane));
}

pub fn check_VkExportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalIOSurfaceInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalIOSurfaceInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalSharedEventInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalSharedEventInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPipelineRobustnessCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessCreateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.storageBuffers) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.uniformBuffers) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.vertexInputs) and
        check_enum_VkPipelineRobustnessImageBehavior(extensions, &item.images));
}

pub fn check_VkPipelineRobustnessCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePipelineRobustnessProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessProperties) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessStorageBuffers) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessUniformBuffers) and
        check_enum_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessVertexInputs) and
        check_enum_VkPipelineRobustnessImageBehavior(extensions, &item.defaultRobustnessImages));
}

pub fn check_VkPhysicalDevicePipelineRobustnessPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessPropertiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkImageViewSampleWeightCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkImageViewSampleWeightCreateInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageProcessingFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageProcessingPropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTilePropertiesFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTilePropertiesQCOM(extensions: *const Extensions, item: *const vk.VkTilePropertiesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTileMemoryBindInfoQCOM(extensions: *const Extensions, item: *const vk.VkTileMemoryBindInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceAmigoProfilingFeaturesSEC(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAmigoProfilingSubmitInfoSEC(extensions: *const Extensions, item: *const vk.VkAmigoProfilingSubmitInfoSEC) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkAttachmentFeedbackLoopInfoEXT(extensions: *const Extensions, item: *const vk.VkAttachmentFeedbackLoopInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceAddressBindingCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingCallbackDataEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkDeviceAddressBindingFlagBitsEXT(extensions, &item.flags) and
        check_enum_VkDeviceAddressBindingTypeEXT(extensions, &item.bindingType));
}

pub fn check_VkPhysicalDeviceOpticalFlowFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceOpticalFlowPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkOpticalFlowGridSizeFlagBitsNV(extensions, &item.supportedOutputGridSizes) and
        check_bitmask_VkOpticalFlowGridSizeFlagBitsNV(extensions, &item.supportedHintGridSizes));
}

pub fn check_VkOpticalFlowImageFormatInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowImageFormatInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkOpticalFlowUsageFlagBitsNV(extensions, &item.usage));
}

pub fn check_VkOpticalFlowImageFormatPropertiesNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowImageFormatPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkOpticalFlowSessionCreateInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.imageFormat) and
        check_enum_VkFormat(extensions, &item.flowVectorFormat) and
        check_enum_VkFormat(extensions, &item.costFormat) and
        check_bitmask_VkOpticalFlowGridSizeFlagBitsNV(extensions, &item.outputGridSize) and
        check_bitmask_VkOpticalFlowGridSizeFlagBitsNV(extensions, &item.hintGridSize) and
        check_enum_VkOpticalFlowPerformanceLevelNV(extensions, &item.performanceLevel) and
        check_bitmask_VkOpticalFlowSessionCreateFlagBitsNV(extensions, &item.flags));
}

pub fn check_VkOpticalFlowSessionCreatePrivateDataInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkOpticalFlowExecuteInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowExecuteInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkOpticalFlowExecuteFlagBitsNV(extensions, &item.flags));
}

pub fn check_VkPhysicalDeviceFaultFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFaultFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceFaultAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressInfoEXT) bool {
    return (check_enum_VkDeviceFaultAddressTypeEXT(extensions, &item.addressType));
}

pub fn check_VkDeviceFaultVendorInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDeviceFaultCountsEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultCountsEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceFaultInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionOneEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDepthBiasInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDepthBiasRepresentationInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDepthBiasRepresentationEXT(extensions, &item.depthBiasRepresentation));
}

pub fn check_VkDecompressMemoryRegionNV(extensions: *const Extensions, item: *const vk.VkDecompressMemoryRegionNV) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFrameBoundaryEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkFrameBoundaryFlagBitsEXT(extensions, &item.flags));
}

pub fn check_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfacePresentModeKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPresentModeKHR(extensions, &item.presentMode));
}

pub fn check_VkSurfacePresentModeEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSurfacePresentScalingCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentScalingCapabilitiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPresentScalingFlagBitsKHR(extensions, &item.supportedPresentScaling) and
        check_bitmask_VkPresentGravityFlagBitsKHR(extensions, &item.supportedPresentGravityX) and
        check_bitmask_VkPresentGravityFlagBitsKHR(extensions, &item.supportedPresentGravityY));
}

pub fn check_VkSurfacePresentScalingCapabilitiesEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentScalingCapabilitiesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSurfacePresentModeCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeCompatibilityKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPresentModeKHR(extensions, &item.pPresentModes));
}

pub fn check_VkSurfacePresentModeCompatibilityEXT(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeCompatibilityEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSwapchainPresentFenceInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentFenceInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSwapchainPresentFenceInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentFenceInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSwapchainPresentModesCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModesCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSwapchainPresentModesCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModesCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSwapchainPresentModeInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModeInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPresentModeKHR(extensions, &item.pPresentModes));
}

pub fn check_VkSwapchainPresentModeInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModeInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSwapchainPresentScalingCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentScalingCreateInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPresentScalingFlagBitsKHR(extensions, &item.scalingBehavior) and
        check_bitmask_VkPresentGravityFlagBitsKHR(extensions, &item.presentGravityX) and
        check_bitmask_VkPresentGravityFlagBitsKHR(extensions, &item.presentGravityY));
}

pub fn check_VkSwapchainPresentScalingCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainPresentScalingCreateInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkReleaseSwapchainImagesInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseSwapchainImagesInfoKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkReleaseSwapchainImagesInfoEXT(extensions: *const Extensions, item: *const vk.VkReleaseSwapchainImagesInfoEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkRayTracingInvocationReorderModeNV(extensions, &item.rayTracingInvocationReorderReorderingHint));
}

pub fn check_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkImageUsageFlagBits(extensions, &item.extendedSparseImageUsageFlags) and
        check_bitmask_VkBufferUsageFlagBits(extensions, &item.extendedSparseBufferUsageFlags));
}

pub fn check_VkDirectDriverLoadingInfoLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingInfoLUNARG) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDirectDriverLoadingListLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingListLUNARG) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDirectDriverLoadingModeLUNARG(extensions, &item.mode));
}

pub fn check_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceImageSubresourceInfo(extensions: *const Extensions, item: *const vk.VkDeviceImageSubresourceInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceImageSubresourceInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceImageSubresourceInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderCorePropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCorePropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(extensions: *const Extensions, item: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkQueryLowLatencySupportNV(extensions: *const Extensions, item: *const vk.VkQueryLowLatencySupportNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryMapInfo(extensions: *const Extensions, item: *const vk.VkMemoryMapInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkMemoryMapFlagBits(extensions, &item.flags));
}

pub fn check_VkMemoryMapInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryMapInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkMemoryUnmapInfo(extensions: *const Extensions, item: *const vk.VkMemoryUnmapInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkMemoryUnmapFlagBits(extensions, &item.flags));
}

pub fn check_VkMemoryUnmapInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryUnmapInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderObjectPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkShaderCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderCreateFlagBitsEXT(extensions, &item.flags) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stage) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.nextStage) and
        check_enum_VkShaderCodeTypeEXT(extensions, &item.codeType));
}

pub fn check_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderTileImagePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImportScreenBufferInfoQNX(extensions: *const Extensions, item: *const vk.VkImportScreenBufferInfoQNX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkScreenBufferPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferPropertiesQNX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkScreenBufferFormatPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferFormatPropertiesQNX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format) and
        check_bitmask_VkFormatFeatureFlagBits(extensions, &item.formatFeatures) and
        check_enum_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel) and
        check_enum_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange) and
        check_enum_VkChromaLocation(extensions, &item.suggestedXChromaOffset) and
        check_enum_VkChromaLocation(extensions, &item.suggestedYChromaOffset));
}

pub fn check_VkExternalFormatQNX(extensions: *const Extensions, item: *const vk.VkExternalFormatQNX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkComponentTypeKHR(extensions, &item.AType) and
        check_enum_VkComponentTypeKHR(extensions, &item.BType) and
        check_enum_VkComponentTypeKHR(extensions, &item.CType) and
        check_enum_VkComponentTypeKHR(extensions, &item.ResultType) and
        check_enum_VkScopeKHR(extensions, &item.scope));
}

pub fn check_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.cooperativeMatrixSupportedStages));
}

pub fn check_VkPhysicalDeviceShaderEnqueuePropertiesAMDX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderEnqueuePropertiesAMDX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderEnqueueFeaturesAMDX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderEnqueueFeaturesAMDX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExecutionGraphPipelineCreateInfoAMDX(extensions: *const Extensions, item: *const vk.VkExecutionGraphPipelineCreateInfoAMDX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkPipelineCreateFlagBits(extensions, &item.flags));
}

pub fn check_VkPipelineShaderStageNodeCreateInfoAMDX(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageNodeCreateInfoAMDX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExecutionGraphPipelineScratchSizeAMDX(extensions: *const Extensions, item: *const vk.VkExecutionGraphPipelineScratchSizeAMDX) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDispatchGraphInfoAMDX(extensions: *const Extensions, item: *const vk.VkDispatchGraphInfoAMDX) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkDispatchGraphCountInfoAMDX(extensions: *const Extensions, item: *const vk.VkDispatchGraphCountInfoAMDX) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceAntiLagFeaturesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkAntiLagDataAMD(extensions: *const Extensions, item: *const vk.VkAntiLagDataAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkAntiLagModeAMD(extensions, &item.mode));
}

pub fn check_VkAntiLagPresentationInfoAMD(extensions: *const Extensions, item: *const vk.VkAntiLagPresentationInfoAMD) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkAntiLagStageAMD(extensions, &item.stage));
}

pub fn check_VkBindMemoryStatus(extensions: *const Extensions, item: *const vk.VkBindMemoryStatus) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkResult(extensions, &item.pResult));
}

pub fn check_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTileMemorySizeInfoQCOM(extensions: *const Extensions, item: *const vk.VkTileMemorySizeInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTileMemoryRequirementsQCOM(extensions: *const Extensions, item: *const vk.VkTileMemoryRequirementsQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindMemoryStatusKHR(extensions: *const Extensions, item: *const vk.VkBindMemoryStatusKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkBindDescriptorSetsInfo(extensions: *const Extensions, item: *const vk.VkBindDescriptorSetsInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stageFlags));
}

pub fn check_VkBindDescriptorSetsInfoKHR(extensions: *const Extensions, item: *const vk.VkBindDescriptorSetsInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPushConstantsInfo(extensions: *const Extensions, item: *const vk.VkPushConstantsInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stageFlags));
}

pub fn check_VkPushConstantsInfoKHR(extensions: *const Extensions, item: *const vk.VkPushConstantsInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPushDescriptorSetInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stageFlags));
}

pub fn check_VkPushDescriptorSetInfoKHR(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPushDescriptorSetWithTemplateInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetWithTemplateInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPushDescriptorSetWithTemplateInfoKHR(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetWithTemplateInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkSetDescriptorBufferOffsetsInfoEXT(extensions: *const Extensions, item: *const vk.VkSetDescriptorBufferOffsetsInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stageFlags));
}

pub fn check_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(extensions: *const Extensions, item: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.stageFlags));
}

pub fn check_VkPhysicalDeviceCubicClampFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCubicWeightsFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerCubicWeightsCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkSamplerCubicWeightsCreateInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCubicFilterWeightsQCOM(extensions, &item.cubicWeights));
}

pub fn check_VkBlitImageCubicWeightsInfoQCOM(extensions: *const Extensions, item: *const vk.VkBlitImageCubicWeightsInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkCubicFilterWeightsQCOM(extensions, &item.cubicWeights));
}

pub fn check_VkPhysicalDeviceImageProcessing2FeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageProcessing2PropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSamplerBlockMatchWindowCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkBlockMatchWindowCompareModeQCOM(extensions, &item.windowCompareMode));
}

pub fn check_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceLayeredDriverPropertiesMSFT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkLayeredDriverUnderlyingApiMSFT(extensions, &item.underlyingAPI));
}

pub fn check_VkPhysicalDevicePerStageDescriptorSetFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkChromaLocation(extensions, &item.externalFormatResolveChromaOffsetX) and
        check_enum_VkChromaLocation(extensions, &item.externalFormatResolveChromaOffsetY));
}

pub fn check_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatResolvePropertiesANDROID) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.colorAttachmentFormat));
}

pub fn check_VkLatencySleepModeInfoNV(extensions: *const Extensions, item: *const vk.VkLatencySleepModeInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkLatencySleepInfoNV(extensions: *const Extensions, item: *const vk.VkLatencySleepInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSetLatencyMarkerInfoNV(extensions: *const Extensions, item: *const vk.VkSetLatencyMarkerInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkLatencyMarkerNV(extensions, &item.marker));
}

pub fn check_VkGetLatencyMarkerInfoNV(extensions: *const Extensions, item: *const vk.VkGetLatencyMarkerInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkLatencyTimingsFrameReportNV(extensions: *const Extensions, item: *const vk.VkLatencyTimingsFrameReportNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkOutOfBandQueueTypeInfoNV(extensions: *const Extensions, item: *const vk.VkOutOfBandQueueTypeInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkOutOfBandQueueTypeNV(extensions, &item.queueType));
}

pub fn check_VkLatencySubmissionPresentIdNV(extensions: *const Extensions, item: *const vk.VkLatencySubmissionPresentIdNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSwapchainLatencyCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSwapchainLatencyCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkLatencySurfaceCapabilitiesNV(extensions: *const Extensions, item: *const vk.VkLatencySurfaceCapabilitiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPresentModeKHR(extensions, &item.pPresentModes));
}

pub fn check_VkPhysicalDeviceCudaKernelLaunchFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCudaKernelLaunchFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCudaKernelLaunchPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCudaKernelLaunchPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceQueueShaderCoreControlCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSchedulingControlsFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceSchedulingControlsPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRenderPassStripedFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRenderPassStripedPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassStripeInfoARM(extensions: *const Extensions, item: *const vk.VkRenderPassStripeInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassStripeBeginInfoARM(extensions: *const Extensions, item: *const vk.VkRenderPassStripeBeginInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassStripeSubmitInfoARM(extensions: *const Extensions, item: *const vk.VkRenderPassStripeSubmitInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderExpectAssumeFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderFloatControls2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloatControls2Features) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderFloatControls2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloatControls2FeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderingAttachmentLocationInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentLocationInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderingAttachmentLocationInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentLocationInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkRenderingInputAttachmentIndexInfo(extensions: *const Extensions, item: *const vk.VkRenderingInputAttachmentIndexInfo) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderingInputAttachmentIndexInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingInputAttachmentIndexInfoKHR) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryMapPlacedInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryMapPlacedInfoEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceRawAccessChainsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkImageAlignmentControlCreateInfoMESA(extensions: *const Extensions, item: *const vk.VkImageAlignmentControlCreateInfoMESA) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDepthClampRangeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampRangeEXT) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceCooperativeMatrix2FeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCooperativeMatrix2PropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCooperativeMatrixFlexibleDimensionsPropertiesNV(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkComponentTypeKHR(extensions, &item.AType) and
        check_enum_VkComponentTypeKHR(extensions, &item.BType) and
        check_enum_VkComponentTypeKHR(extensions, &item.CType) and
        check_enum_VkComponentTypeKHR(extensions, &item.ResultType) and
        check_enum_VkScopeKHR(extensions, &item.scope));
}

pub fn check_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHdrVividFeaturesHUAWEI) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceCooperativeVectorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCooperativeVectorPropertiesNV(extensions: *const Extensions, item: *const vk.VkCooperativeVectorPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkComponentTypeKHR(extensions, &item.inputType) and
        check_enum_VkComponentTypeKHR(extensions, &item.inputInterpretation) and
        check_enum_VkComponentTypeKHR(extensions, &item.matrixInterpretation) and
        check_enum_VkComponentTypeKHR(extensions, &item.biasInterpretation) and
        check_enum_VkComponentTypeKHR(extensions, &item.resultType));
}

pub fn check_VkPhysicalDeviceCooperativeVectorPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.cooperativeVectorSupportedStages));
}

pub fn check_VkConvertCooperativeVectorMatrixInfoNV(extensions: *const Extensions, item: *const vk.VkConvertCooperativeVectorMatrixInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkComponentTypeKHR(extensions, &item.srcComponentType) and
        check_enum_VkComponentTypeKHR(extensions, &item.dstComponentType) and
        check_enum_VkCooperativeVectorMatrixLayoutNV(extensions, &item.srcLayout) and
        check_enum_VkCooperativeVectorMatrixLayoutNV(extensions, &item.dstLayout));
}

pub fn check_VkPhysicalDeviceTileShadingFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTileShadingPropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkRenderPassTileShadingCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkRenderPassTileShadingCreateInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkTileShadingRenderPassFlagBitsQCOM(extensions, &item.flags));
}

pub fn check_VkPerTileBeginInfoQCOM(extensions: *const Extensions, item: *const vk.VkPerTileBeginInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPerTileEndInfoQCOM(extensions: *const Extensions, item: *const vk.VkPerTileEndInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDispatchTileInfoQCOM(extensions: *const Extensions, item: *const vk.VkDispatchTileInfoQCOM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSetPresentConfigNV(extensions: *const Extensions, item: *const vk.VkSetPresentConfigNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePresentMeteringFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentMeteringFeaturesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalComputeQueueDeviceCreateInfoNV(extensions: *const Extensions, item: *const vk.VkExternalComputeQueueDeviceCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalComputeQueueCreateInfoNV(extensions: *const Extensions, item: *const vk.VkExternalComputeQueueCreateInfoNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalComputeQueueDataParamsNV(extensions: *const Extensions, item: *const vk.VkExternalComputeQueueDataParamsNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalComputeQueuePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceFormatPackFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFormatPackFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTensorDescriptionARM(extensions: *const Extensions, item: *const vk.VkTensorDescriptionARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkTensorTilingARM(extensions, &item.tiling) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkTensorCreateInfoARM(extensions: *const Extensions, item: *const vk.VkTensorCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkSharingMode(extensions, &item.sharingMode));
}

pub fn check_VkTensorViewCreateInfoARM(extensions: *const Extensions, item: *const vk.VkTensorViewCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkFormat(extensions, &item.format));
}

pub fn check_VkTensorMemoryRequirementsInfoARM(extensions: *const Extensions, item: *const vk.VkTensorMemoryRequirementsInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkBindTensorMemoryInfoARM(extensions: *const Extensions, item: *const vk.VkBindTensorMemoryInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkWriteDescriptorSetTensorARM(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetTensorARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTensorFormatPropertiesARM(extensions: *const Extensions, item: *const vk.VkTensorFormatPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTensorPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTensorPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkShaderStageFlagBits(extensions, &item.shaderTensorSupportedStages));
}

pub fn check_VkTensorMemoryBarrierARM(extensions: *const Extensions, item: *const vk.VkTensorMemoryBarrierARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTensorDependencyInfoARM(extensions: *const Extensions, item: *const vk.VkTensorDependencyInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceTensorFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTensorFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDeviceTensorMemoryRequirementsARM(extensions: *const Extensions, item: *const vk.VkDeviceTensorMemoryRequirementsARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkCopyTensorInfoARM(extensions: *const Extensions, item: *const vk.VkCopyTensorInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTensorCopyARM(extensions: *const Extensions, item: *const vk.VkTensorCopyARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkMemoryDedicatedAllocateInfoTensorARM(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfoTensorARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDescriptorBufferTensorPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDescriptorBufferTensorFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTensorCaptureDescriptorDataInfoARM(extensions: *const Extensions, item: *const vk.VkTensorCaptureDescriptorDataInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkTensorViewCaptureDescriptorDataInfoARM(extensions: *const Extensions, item: *const vk.VkTensorViewCaptureDescriptorDataInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDescriptorGetTensorInfoARM(extensions: *const Extensions, item: *const vk.VkDescriptorGetTensorInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkFrameBoundaryTensorsARM(extensions: *const Extensions, item: *const vk.VkFrameBoundaryTensorsARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceExternalTensorInfoARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalTensorInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleType));
}

pub fn check_VkExternalTensorPropertiesARM(extensions: *const Extensions, item: *const vk.VkExternalTensorPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkExternalMemoryTensorCreateInfoARM(extensions: *const Extensions, item: *const vk.VkExternalMemoryTensorCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.handleTypes));
}

pub fn check_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkOHSurfaceCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkOHSurfaceCreateInfoOHOS) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkSurfaceCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkSurfaceCreateInfoOHOS) bool {
    _ = extensions;
    _ = item;
    return true;
}

pub fn check_VkPhysicalDeviceDataGraphFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphFeaturesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineConstantARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineConstantARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineResourceInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineResourceInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineCompilerControlCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineShaderModuleCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineSessionCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineSessionBindPointRequirementsInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineSessionBindPointRequirementARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDataGraphPipelineSessionBindPointARM(extensions, &item.bindPoint) and
        check_enum_VkDataGraphPipelineSessionBindPointTypeARM(extensions, &item.bindPointType));
}

pub fn check_VkDataGraphPipelineSessionMemoryRequirementsInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDataGraphPipelineSessionBindPointARM(extensions, &item.bindPoint));
}

pub fn check_VkBindDataGraphPipelineSessionMemoryInfoARM(extensions: *const Extensions, item: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDataGraphPipelineSessionBindPointARM(extensions, &item.bindPoint));
}

pub fn check_VkDataGraphPipelineInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelinePropertyQueryResultARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelinePropertyQueryResultARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkDataGraphPipelinePropertyARM(extensions, &item.property));
}

pub fn check_VkDataGraphPipelineIdentifierCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkDataGraphPipelineDispatchInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineDispatchInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceDataGraphProcessingEngineARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphProcessingEngineARM) bool {
    return (check_enum_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions, &item.type));
}

pub fn check_VkPhysicalDeviceDataGraphOperationSupportARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphOperationSupportARM) bool {
    return (check_enum_VkPhysicalDeviceDataGraphOperationTypeARM(extensions, &item.operationType));
}

pub fn check_VkQueueFamilyDataGraphPropertiesARM(extensions: *const Extensions, item: *const vk.VkQueueFamilyDataGraphPropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_enum_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions, &item.engineType));
}

pub fn check_VkQueueFamilyDataGraphProcessingEnginePropertiesARM(extensions: *const Extensions, item: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType) and
        check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions, &item.foreignSemaphoreHandleTypes) and
        check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions, &item.foreignMemoryHandleTypes));
}

pub fn check_VkDataGraphProcessingEngineCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphProcessingEngineCreateInfoARM) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC) bool {
    return (check_enum_VkStructureType(extensions, &item.sType));
}

pub fn check_enum_VkImageLayout(extensions: *const Extensions, item: *const vk.VkImageLayout) bool {
    const min = @min(
        vk.VK_IMAGE_LAYOUT_UNDEFINED,
        vk.VK_IMAGE_LAYOUT_GENERAL,
        vk.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_PREINITIALIZED,
    );
    const max = @max(
        vk.VK_IMAGE_LAYOUT_UNDEFINED,
        vk.VK_IMAGE_LAYOUT_GENERAL,
        vk.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        vk.VK_IMAGE_LAYOUT_PREINITIALIZED,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == vk.VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == vk.VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT)
        return true;
    return false;
}

pub fn check_enum_VkAttachmentLoadOp(extensions: *const Extensions, item: *const vk.VkAttachmentLoadOp) bool {
    const min = @min(
        vk.VK_ATTACHMENT_LOAD_OP_LOAD,
        vk.VK_ATTACHMENT_LOAD_OP_CLEAR,
        vk.VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    );
    const max = @max(
        vk.VK_ATTACHMENT_LOAD_OP_LOAD,
        vk.VK_ATTACHMENT_LOAD_OP_CLEAR,
        vk.VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_load_store_op_none and item.* == vk.VK_ATTACHMENT_LOAD_OP_NONE_EXT)
        return true;
    if (extensions.device.VK_KHR_load_store_op_none and item.* == vk.VK_ATTACHMENT_LOAD_OP_NONE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkAttachmentStoreOp(extensions: *const Extensions, item: *const vk.VkAttachmentStoreOp) bool {
    const min = @min(
        vk.VK_ATTACHMENT_STORE_OP_STORE,
        vk.VK_ATTACHMENT_STORE_OP_DONT_CARE,
    );
    const max = @max(
        vk.VK_ATTACHMENT_STORE_OP_STORE,
        vk.VK_ATTACHMENT_STORE_OP_DONT_CARE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_KHR)
        return true;
    if (extensions.device.VK_QCOM_render_pass_store_ops and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_QCOM)
        return true;
    if (extensions.device.VK_EXT_load_store_op_none and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_EXT)
        return true;
    if (extensions.device.VK_KHR_load_store_op_none and item.* == vk.VK_ATTACHMENT_STORE_OP_NONE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkImageType(extensions: *const Extensions, item: *const vk.VkImageType) bool {
    const min = @min(
        vk.VK_IMAGE_TYPE_1D,
        vk.VK_IMAGE_TYPE_2D,
        vk.VK_IMAGE_TYPE_3D,
    );
    const max = @max(
        vk.VK_IMAGE_TYPE_1D,
        vk.VK_IMAGE_TYPE_2D,
        vk.VK_IMAGE_TYPE_3D,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkImageTiling(extensions: *const Extensions, item: *const vk.VkImageTiling) bool {
    const min = @min(
        vk.VK_IMAGE_TILING_OPTIMAL,
        vk.VK_IMAGE_TILING_LINEAR,
    );
    const max = @max(
        vk.VK_IMAGE_TILING_OPTIMAL,
        vk.VK_IMAGE_TILING_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT)
        return true;
    return false;
}

pub fn check_enum_VkImageViewType(extensions: *const Extensions, item: *const vk.VkImageViewType) bool {
    const min = @min(
        vk.VK_IMAGE_VIEW_TYPE_1D,
        vk.VK_IMAGE_VIEW_TYPE_2D,
        vk.VK_IMAGE_VIEW_TYPE_3D,
        vk.VK_IMAGE_VIEW_TYPE_CUBE,
        vk.VK_IMAGE_VIEW_TYPE_1D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_2D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    );
    const max = @max(
        vk.VK_IMAGE_VIEW_TYPE_1D,
        vk.VK_IMAGE_VIEW_TYPE_2D,
        vk.VK_IMAGE_VIEW_TYPE_3D,
        vk.VK_IMAGE_VIEW_TYPE_CUBE,
        vk.VK_IMAGE_VIEW_TYPE_1D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_2D_ARRAY,
        vk.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCommandBufferLevel(extensions: *const Extensions, item: *const vk.VkCommandBufferLevel) bool {
    const min = @min(
        vk.VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        vk.VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    );
    const max = @max(
        vk.VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        vk.VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkComponentSwizzle(extensions: *const Extensions, item: *const vk.VkComponentSwizzle) bool {
    const min = @min(
        vk.VK_COMPONENT_SWIZZLE_IDENTITY,
        vk.VK_COMPONENT_SWIZZLE_ZERO,
        vk.VK_COMPONENT_SWIZZLE_ONE,
        vk.VK_COMPONENT_SWIZZLE_R,
        vk.VK_COMPONENT_SWIZZLE_G,
        vk.VK_COMPONENT_SWIZZLE_B,
        vk.VK_COMPONENT_SWIZZLE_A,
    );
    const max = @max(
        vk.VK_COMPONENT_SWIZZLE_IDENTITY,
        vk.VK_COMPONENT_SWIZZLE_ZERO,
        vk.VK_COMPONENT_SWIZZLE_ONE,
        vk.VK_COMPONENT_SWIZZLE_R,
        vk.VK_COMPONENT_SWIZZLE_G,
        vk.VK_COMPONENT_SWIZZLE_B,
        vk.VK_COMPONENT_SWIZZLE_A,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDescriptorType(extensions: *const Extensions, item: *const vk.VkDescriptorType) bool {
    const min = @min(
        vk.VK_DESCRIPTOR_TYPE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    );
    const max = @max(
        vk.VK_DESCRIPTOR_TYPE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        vk.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
        vk.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
        vk.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_DESCRIPTOR_TYPE_MUTABLE_VALVE)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_DESCRIPTOR_TYPE_MUTABLE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkQueryType(extensions: *const Extensions, item: *const vk.VkQueryType) bool {
    const min = @min(
        vk.VK_QUERY_TYPE_OCCLUSION,
        vk.VK_QUERY_TYPE_PIPELINE_STATISTICS,
        vk.VK_QUERY_TYPE_TIMESTAMP,
    );
    const max = @max(
        vk.VK_QUERY_TYPE_OCCLUSION,
        vk.VK_QUERY_TYPE_PIPELINE_STATISTICS,
        vk.VK_QUERY_TYPE_TIMESTAMP,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == vk.VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkBorderColor(extensions: *const Extensions, item: *const vk.VkBorderColor) bool {
    const min = @min(
        vk.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_INT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
        vk.VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    );
    const max = @max(
        vk.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_INT_OPAQUE_BLACK,
        vk.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
        vk.VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_BORDER_COLOR_FLOAT_CUSTOM_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_BORDER_COLOR_INT_CUSTOM_EXT)
        return true;
    return false;
}

pub fn check_enum_VkPipelineBindPoint(extensions: *const Extensions, item: *const vk.VkPipelineBindPoint) bool {
    const min = @min(
        vk.VK_PIPELINE_BIND_POINT_GRAPHICS,
        vk.VK_PIPELINE_BIND_POINT_COMPUTE,
    );
    const max = @max(
        vk.VK_PIPELINE_BIND_POINT_GRAPHICS,
        vk.VK_PIPELINE_BIND_POINT_COMPUTE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR)
        return true;
    return false;
}

pub fn check_enum_VkPipelineCacheHeaderVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersion) bool {
    const min = vk.VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
    const max = vk.VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPipelineCacheCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance8)
        valid_bits |= vk.VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPrimitiveTopology(extensions: *const Extensions, item: *const vk.VkPrimitiveTopology) bool {
    const min = @min(
        vk.VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    );
    const max = @max(
        vk.VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
        vk.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSharingMode(extensions: *const Extensions, item: *const vk.VkSharingMode) bool {
    const min = @min(
        vk.VK_SHARING_MODE_EXCLUSIVE,
        vk.VK_SHARING_MODE_CONCURRENT,
    );
    const max = @max(
        vk.VK_SHARING_MODE_EXCLUSIVE,
        vk.VK_SHARING_MODE_CONCURRENT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkIndexType(extensions: *const Extensions, item: *const vk.VkIndexType) bool {
    const min = @min(
        vk.VK_INDEX_TYPE_UINT16,
        vk.VK_INDEX_TYPE_UINT32,
    );
    const max = @max(
        vk.VK_INDEX_TYPE_UINT16,
        vk.VK_INDEX_TYPE_UINT32,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_INDEX_TYPE_NONE_KHR)
        return true;
    if (extensions.device.VK_EXT_index_type_uint8 and item.* == vk.VK_INDEX_TYPE_UINT8_EXT)
        return true;
    if (extensions.device.VK_KHR_index_type_uint8 and item.* == vk.VK_INDEX_TYPE_UINT8_KHR)
        return true;
    return false;
}

pub fn check_enum_VkFilter(extensions: *const Extensions, item: *const vk.VkFilter) bool {
    const min = @min(
        vk.VK_FILTER_NEAREST,
        vk.VK_FILTER_LINEAR,
    );
    const max = @max(
        vk.VK_FILTER_NEAREST,
        vk.VK_FILTER_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_IMG_filter_cubic and item.* == vk.VK_FILTER_CUBIC_IMG)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_FILTER_CUBIC_EXT)
        return true;
    return false;
}

pub fn check_enum_VkSamplerMipmapMode(extensions: *const Extensions, item: *const vk.VkSamplerMipmapMode) bool {
    const min = @min(
        vk.VK_SAMPLER_MIPMAP_MODE_NEAREST,
        vk.VK_SAMPLER_MIPMAP_MODE_LINEAR,
    );
    const max = @max(
        vk.VK_SAMPLER_MIPMAP_MODE_NEAREST,
        vk.VK_SAMPLER_MIPMAP_MODE_LINEAR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSamplerAddressMode(extensions: *const Extensions, item: *const vk.VkSamplerAddressMode) bool {
    const min = @min(
        vk.VK_SAMPLER_ADDRESS_MODE_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    );
    const max = @max(
        vk.VK_SAMPLER_ADDRESS_MODE_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
        vk.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCompareOp(extensions: *const Extensions, item: *const vk.VkCompareOp) bool {
    const min = @min(
        vk.VK_COMPARE_OP_NEVER,
        vk.VK_COMPARE_OP_LESS,
        vk.VK_COMPARE_OP_EQUAL,
        vk.VK_COMPARE_OP_LESS_OR_EQUAL,
        vk.VK_COMPARE_OP_GREATER,
        vk.VK_COMPARE_OP_NOT_EQUAL,
        vk.VK_COMPARE_OP_GREATER_OR_EQUAL,
        vk.VK_COMPARE_OP_ALWAYS,
    );
    const max = @max(
        vk.VK_COMPARE_OP_NEVER,
        vk.VK_COMPARE_OP_LESS,
        vk.VK_COMPARE_OP_EQUAL,
        vk.VK_COMPARE_OP_LESS_OR_EQUAL,
        vk.VK_COMPARE_OP_GREATER,
        vk.VK_COMPARE_OP_NOT_EQUAL,
        vk.VK_COMPARE_OP_GREATER_OR_EQUAL,
        vk.VK_COMPARE_OP_ALWAYS,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPolygonMode(extensions: *const Extensions, item: *const vk.VkPolygonMode) bool {
    const min = @min(
        vk.VK_POLYGON_MODE_FILL,
        vk.VK_POLYGON_MODE_LINE,
        vk.VK_POLYGON_MODE_POINT,
    );
    const max = @max(
        vk.VK_POLYGON_MODE_FILL,
        vk.VK_POLYGON_MODE_LINE,
        vk.VK_POLYGON_MODE_POINT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFrontFace(extensions: *const Extensions, item: *const vk.VkFrontFace) bool {
    const min = @min(
        vk.VK_FRONT_FACE_COUNTER_CLOCKWISE,
        vk.VK_FRONT_FACE_CLOCKWISE,
    );
    const max = @max(
        vk.VK_FRONT_FACE_COUNTER_CLOCKWISE,
        vk.VK_FRONT_FACE_CLOCKWISE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBlendFactor(extensions: *const Extensions, item: *const vk.VkBlendFactor) bool {
    const min = @min(
        vk.VK_BLEND_FACTOR_ZERO,
        vk.VK_BLEND_FACTOR_ONE,
        vk.VK_BLEND_FACTOR_SRC_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
        vk.VK_BLEND_FACTOR_DST_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
        vk.VK_BLEND_FACTOR_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_DST_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
        vk.VK_BLEND_FACTOR_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
        vk.VK_BLEND_FACTOR_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_SRC1_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    );
    const max = @max(
        vk.VK_BLEND_FACTOR_ZERO,
        vk.VK_BLEND_FACTOR_ONE,
        vk.VK_BLEND_FACTOR_SRC_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
        vk.VK_BLEND_FACTOR_DST_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
        vk.VK_BLEND_FACTOR_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        vk.VK_BLEND_FACTOR_DST_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
        vk.VK_BLEND_FACTOR_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
        vk.VK_BLEND_FACTOR_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
        vk.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
        vk.VK_BLEND_FACTOR_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
        vk.VK_BLEND_FACTOR_SRC1_ALPHA,
        vk.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBlendOp(extensions: *const Extensions, item: *const vk.VkBlendOp) bool {
    const min = @min(
        vk.VK_BLEND_OP_ADD,
        vk.VK_BLEND_OP_SUBTRACT,
        vk.VK_BLEND_OP_REVERSE_SUBTRACT,
        vk.VK_BLEND_OP_MIN,
        vk.VK_BLEND_OP_MAX,
    );
    const max = @max(
        vk.VK_BLEND_OP_ADD,
        vk.VK_BLEND_OP_SUBTRACT,
        vk.VK_BLEND_OP_REVERSE_SUBTRACT,
        vk.VK_BLEND_OP_MIN,
        vk.VK_BLEND_OP_MAX,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_ZERO_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SRC_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DST_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_XOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MULTIPLY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SCREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_OVERLAY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DARKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LIGHTEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_COLORDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_COLORBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HARDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_SOFTLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_DIFFERENCE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_EXCLUSION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_RGB_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_VIVIDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_LINEARLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PINLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HARDMIX_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_HUE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_SATURATION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_COLOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_HSL_LUMINOSITY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_PLUS_DARKER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MINUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_MINUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_CONTRAST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_INVERT_OVG_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_RED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_GREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_BLEND_OP_BLUE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkStencilOp(extensions: *const Extensions, item: *const vk.VkStencilOp) bool {
    const min = @min(
        vk.VK_STENCIL_OP_KEEP,
        vk.VK_STENCIL_OP_ZERO,
        vk.VK_STENCIL_OP_REPLACE,
        vk.VK_STENCIL_OP_INCREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_DECREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_INVERT,
        vk.VK_STENCIL_OP_INCREMENT_AND_WRAP,
        vk.VK_STENCIL_OP_DECREMENT_AND_WRAP,
    );
    const max = @max(
        vk.VK_STENCIL_OP_KEEP,
        vk.VK_STENCIL_OP_ZERO,
        vk.VK_STENCIL_OP_REPLACE,
        vk.VK_STENCIL_OP_INCREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_DECREMENT_AND_CLAMP,
        vk.VK_STENCIL_OP_INVERT,
        vk.VK_STENCIL_OP_INCREMENT_AND_WRAP,
        vk.VK_STENCIL_OP_DECREMENT_AND_WRAP,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLogicOp(extensions: *const Extensions, item: *const vk.VkLogicOp) bool {
    const min = @min(
        vk.VK_LOGIC_OP_CLEAR,
        vk.VK_LOGIC_OP_AND,
        vk.VK_LOGIC_OP_AND_REVERSE,
        vk.VK_LOGIC_OP_COPY,
        vk.VK_LOGIC_OP_AND_INVERTED,
        vk.VK_LOGIC_OP_NO_OP,
        vk.VK_LOGIC_OP_XOR,
        vk.VK_LOGIC_OP_OR,
        vk.VK_LOGIC_OP_NOR,
        vk.VK_LOGIC_OP_EQUIVALENT,
        vk.VK_LOGIC_OP_INVERT,
        vk.VK_LOGIC_OP_OR_REVERSE,
        vk.VK_LOGIC_OP_COPY_INVERTED,
        vk.VK_LOGIC_OP_OR_INVERTED,
        vk.VK_LOGIC_OP_NAND,
        vk.VK_LOGIC_OP_SET,
    );
    const max = @max(
        vk.VK_LOGIC_OP_CLEAR,
        vk.VK_LOGIC_OP_AND,
        vk.VK_LOGIC_OP_AND_REVERSE,
        vk.VK_LOGIC_OP_COPY,
        vk.VK_LOGIC_OP_AND_INVERTED,
        vk.VK_LOGIC_OP_NO_OP,
        vk.VK_LOGIC_OP_XOR,
        vk.VK_LOGIC_OP_OR,
        vk.VK_LOGIC_OP_NOR,
        vk.VK_LOGIC_OP_EQUIVALENT,
        vk.VK_LOGIC_OP_INVERT,
        vk.VK_LOGIC_OP_OR_REVERSE,
        vk.VK_LOGIC_OP_COPY_INVERTED,
        vk.VK_LOGIC_OP_OR_INVERTED,
        vk.VK_LOGIC_OP_NAND,
        vk.VK_LOGIC_OP_SET,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkInternalAllocationType(extensions: *const Extensions, item: *const vk.VkInternalAllocationType) bool {
    const min = vk.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
    const max = vk.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSystemAllocationScope(extensions: *const Extensions, item: *const vk.VkSystemAllocationScope) bool {
    const min = @min(
        vk.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    );
    const max = @max(
        vk.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
        vk.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPhysicalDeviceType(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceType) bool {
    const min = @min(
        vk.VK_PHYSICAL_DEVICE_TYPE_OTHER,
        vk.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_CPU,
    );
    const max = @max(
        vk.VK_PHYSICAL_DEVICE_TYPE_OTHER,
        vk.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
        vk.VK_PHYSICAL_DEVICE_TYPE_CPU,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkVertexInputRate(extensions: *const Extensions, item: *const vk.VkVertexInputRate) bool {
    const min = @min(
        vk.VK_VERTEX_INPUT_RATE_VERTEX,
        vk.VK_VERTEX_INPUT_RATE_INSTANCE,
    );
    const max = @max(
        vk.VK_VERTEX_INPUT_RATE_VERTEX,
        vk.VK_VERTEX_INPUT_RATE_INSTANCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFormat(extensions: *const Extensions, item: *const vk.VkFormat) bool {
    const min = @min(
        vk.VK_FORMAT_UNDEFINED,
        vk.VK_FORMAT_R4G4_UNORM_PACK8,
        vk.VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        vk.VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        vk.VK_FORMAT_R5G6B5_UNORM_PACK16,
        vk.VK_FORMAT_B5G6R5_UNORM_PACK16,
        vk.VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        vk.VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        vk.VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        vk.VK_FORMAT_R8_UNORM,
        vk.VK_FORMAT_R8_SNORM,
        vk.VK_FORMAT_R8_USCALED,
        vk.VK_FORMAT_R8_SSCALED,
        vk.VK_FORMAT_R8_UINT,
        vk.VK_FORMAT_R8_SINT,
        vk.VK_FORMAT_R8_SRGB,
        vk.VK_FORMAT_R8G8_UNORM,
        vk.VK_FORMAT_R8G8_SNORM,
        vk.VK_FORMAT_R8G8_USCALED,
        vk.VK_FORMAT_R8G8_SSCALED,
        vk.VK_FORMAT_R8G8_UINT,
        vk.VK_FORMAT_R8G8_SINT,
        vk.VK_FORMAT_R8G8_SRGB,
        vk.VK_FORMAT_R8G8B8_UNORM,
        vk.VK_FORMAT_R8G8B8_SNORM,
        vk.VK_FORMAT_R8G8B8_USCALED,
        vk.VK_FORMAT_R8G8B8_SSCALED,
        vk.VK_FORMAT_R8G8B8_UINT,
        vk.VK_FORMAT_R8G8B8_SINT,
        vk.VK_FORMAT_R8G8B8_SRGB,
        vk.VK_FORMAT_B8G8R8_UNORM,
        vk.VK_FORMAT_B8G8R8_SNORM,
        vk.VK_FORMAT_B8G8R8_USCALED,
        vk.VK_FORMAT_B8G8R8_SSCALED,
        vk.VK_FORMAT_B8G8R8_UINT,
        vk.VK_FORMAT_B8G8R8_SINT,
        vk.VK_FORMAT_B8G8R8_SRGB,
        vk.VK_FORMAT_R8G8B8A8_UNORM,
        vk.VK_FORMAT_R8G8B8A8_SNORM,
        vk.VK_FORMAT_R8G8B8A8_USCALED,
        vk.VK_FORMAT_R8G8B8A8_SSCALED,
        vk.VK_FORMAT_R8G8B8A8_UINT,
        vk.VK_FORMAT_R8G8B8A8_SINT,
        vk.VK_FORMAT_R8G8B8A8_SRGB,
        vk.VK_FORMAT_B8G8R8A8_UNORM,
        vk.VK_FORMAT_B8G8R8A8_SNORM,
        vk.VK_FORMAT_B8G8R8A8_USCALED,
        vk.VK_FORMAT_B8G8R8A8_SSCALED,
        vk.VK_FORMAT_B8G8R8A8_UINT,
        vk.VK_FORMAT_B8G8R8A8_SINT,
        vk.VK_FORMAT_B8G8R8A8_SRGB,
        vk.VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_UINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UINT_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SINT_PACK32,
        vk.VK_FORMAT_R16_UNORM,
        vk.VK_FORMAT_R16_SNORM,
        vk.VK_FORMAT_R16_USCALED,
        vk.VK_FORMAT_R16_SSCALED,
        vk.VK_FORMAT_R16_UINT,
        vk.VK_FORMAT_R16_SINT,
        vk.VK_FORMAT_R16_SFLOAT,
        vk.VK_FORMAT_R16G16_UNORM,
        vk.VK_FORMAT_R16G16_SNORM,
        vk.VK_FORMAT_R16G16_USCALED,
        vk.VK_FORMAT_R16G16_SSCALED,
        vk.VK_FORMAT_R16G16_UINT,
        vk.VK_FORMAT_R16G16_SINT,
        vk.VK_FORMAT_R16G16_SFLOAT,
        vk.VK_FORMAT_R16G16B16_UNORM,
        vk.VK_FORMAT_R16G16B16_SNORM,
        vk.VK_FORMAT_R16G16B16_USCALED,
        vk.VK_FORMAT_R16G16B16_SSCALED,
        vk.VK_FORMAT_R16G16B16_UINT,
        vk.VK_FORMAT_R16G16B16_SINT,
        vk.VK_FORMAT_R16G16B16_SFLOAT,
        vk.VK_FORMAT_R16G16B16A16_UNORM,
        vk.VK_FORMAT_R16G16B16A16_SNORM,
        vk.VK_FORMAT_R16G16B16A16_USCALED,
        vk.VK_FORMAT_R16G16B16A16_SSCALED,
        vk.VK_FORMAT_R16G16B16A16_UINT,
        vk.VK_FORMAT_R16G16B16A16_SINT,
        vk.VK_FORMAT_R16G16B16A16_SFLOAT,
        vk.VK_FORMAT_R32_UINT,
        vk.VK_FORMAT_R32_SINT,
        vk.VK_FORMAT_R32_SFLOAT,
        vk.VK_FORMAT_R32G32_UINT,
        vk.VK_FORMAT_R32G32_SINT,
        vk.VK_FORMAT_R32G32_SFLOAT,
        vk.VK_FORMAT_R32G32B32_UINT,
        vk.VK_FORMAT_R32G32B32_SINT,
        vk.VK_FORMAT_R32G32B32_SFLOAT,
        vk.VK_FORMAT_R32G32B32A32_UINT,
        vk.VK_FORMAT_R32G32B32A32_SINT,
        vk.VK_FORMAT_R32G32B32A32_SFLOAT,
        vk.VK_FORMAT_R64_UINT,
        vk.VK_FORMAT_R64_SINT,
        vk.VK_FORMAT_R64_SFLOAT,
        vk.VK_FORMAT_R64G64_UINT,
        vk.VK_FORMAT_R64G64_SINT,
        vk.VK_FORMAT_R64G64_SFLOAT,
        vk.VK_FORMAT_R64G64B64_UINT,
        vk.VK_FORMAT_R64G64B64_SINT,
        vk.VK_FORMAT_R64G64B64_SFLOAT,
        vk.VK_FORMAT_R64G64B64A64_UINT,
        vk.VK_FORMAT_R64G64B64A64_SINT,
        vk.VK_FORMAT_R64G64B64A64_SFLOAT,
        vk.VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        vk.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
        vk.VK_FORMAT_D16_UNORM,
        vk.VK_FORMAT_X8_D24_UNORM_PACK32,
        vk.VK_FORMAT_D32_SFLOAT,
        vk.VK_FORMAT_S8_UINT,
        vk.VK_FORMAT_D16_UNORM_S8_UINT,
        vk.VK_FORMAT_D24_UNORM_S8_UINT,
        vk.VK_FORMAT_D32_SFLOAT_S8_UINT,
        vk.VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
        vk.VK_FORMAT_BC2_UNORM_BLOCK,
        vk.VK_FORMAT_BC2_SRGB_BLOCK,
        vk.VK_FORMAT_BC3_UNORM_BLOCK,
        vk.VK_FORMAT_BC3_SRGB_BLOCK,
        vk.VK_FORMAT_BC4_UNORM_BLOCK,
        vk.VK_FORMAT_BC4_SNORM_BLOCK,
        vk.VK_FORMAT_BC5_UNORM_BLOCK,
        vk.VK_FORMAT_BC5_SNORM_BLOCK,
        vk.VK_FORMAT_BC6H_UFLOAT_BLOCK,
        vk.VK_FORMAT_BC6H_SFLOAT_BLOCK,
        vk.VK_FORMAT_BC7_UNORM_BLOCK,
        vk.VK_FORMAT_BC7_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
        vk.VK_FORMAT_EAC_R11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11_SNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    );
    const max = @max(
        vk.VK_FORMAT_UNDEFINED,
        vk.VK_FORMAT_R4G4_UNORM_PACK8,
        vk.VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        vk.VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        vk.VK_FORMAT_R5G6B5_UNORM_PACK16,
        vk.VK_FORMAT_B5G6R5_UNORM_PACK16,
        vk.VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        vk.VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        vk.VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        vk.VK_FORMAT_R8_UNORM,
        vk.VK_FORMAT_R8_SNORM,
        vk.VK_FORMAT_R8_USCALED,
        vk.VK_FORMAT_R8_SSCALED,
        vk.VK_FORMAT_R8_UINT,
        vk.VK_FORMAT_R8_SINT,
        vk.VK_FORMAT_R8_SRGB,
        vk.VK_FORMAT_R8G8_UNORM,
        vk.VK_FORMAT_R8G8_SNORM,
        vk.VK_FORMAT_R8G8_USCALED,
        vk.VK_FORMAT_R8G8_SSCALED,
        vk.VK_FORMAT_R8G8_UINT,
        vk.VK_FORMAT_R8G8_SINT,
        vk.VK_FORMAT_R8G8_SRGB,
        vk.VK_FORMAT_R8G8B8_UNORM,
        vk.VK_FORMAT_R8G8B8_SNORM,
        vk.VK_FORMAT_R8G8B8_USCALED,
        vk.VK_FORMAT_R8G8B8_SSCALED,
        vk.VK_FORMAT_R8G8B8_UINT,
        vk.VK_FORMAT_R8G8B8_SINT,
        vk.VK_FORMAT_R8G8B8_SRGB,
        vk.VK_FORMAT_B8G8R8_UNORM,
        vk.VK_FORMAT_B8G8R8_SNORM,
        vk.VK_FORMAT_B8G8R8_USCALED,
        vk.VK_FORMAT_B8G8R8_SSCALED,
        vk.VK_FORMAT_B8G8R8_UINT,
        vk.VK_FORMAT_B8G8R8_SINT,
        vk.VK_FORMAT_B8G8R8_SRGB,
        vk.VK_FORMAT_R8G8B8A8_UNORM,
        vk.VK_FORMAT_R8G8B8A8_SNORM,
        vk.VK_FORMAT_R8G8B8A8_USCALED,
        vk.VK_FORMAT_R8G8B8A8_SSCALED,
        vk.VK_FORMAT_R8G8B8A8_UINT,
        vk.VK_FORMAT_R8G8B8A8_SINT,
        vk.VK_FORMAT_R8G8B8A8_SRGB,
        vk.VK_FORMAT_B8G8R8A8_UNORM,
        vk.VK_FORMAT_B8G8R8A8_SNORM,
        vk.VK_FORMAT_B8G8R8A8_USCALED,
        vk.VK_FORMAT_B8G8R8A8_SSCALED,
        vk.VK_FORMAT_B8G8R8A8_UINT,
        vk.VK_FORMAT_B8G8R8A8_SINT,
        vk.VK_FORMAT_B8G8R8A8_SRGB,
        vk.VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        vk.VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        vk.VK_FORMAT_A8B8G8R8_UINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SINT_PACK32,
        vk.VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        vk.VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        vk.VK_FORMAT_A2R10G10B10_UINT_PACK32,
        vk.VK_FORMAT_A2R10G10B10_SINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        vk.VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        vk.VK_FORMAT_A2B10G10R10_UINT_PACK32,
        vk.VK_FORMAT_A2B10G10R10_SINT_PACK32,
        vk.VK_FORMAT_R16_UNORM,
        vk.VK_FORMAT_R16_SNORM,
        vk.VK_FORMAT_R16_USCALED,
        vk.VK_FORMAT_R16_SSCALED,
        vk.VK_FORMAT_R16_UINT,
        vk.VK_FORMAT_R16_SINT,
        vk.VK_FORMAT_R16_SFLOAT,
        vk.VK_FORMAT_R16G16_UNORM,
        vk.VK_FORMAT_R16G16_SNORM,
        vk.VK_FORMAT_R16G16_USCALED,
        vk.VK_FORMAT_R16G16_SSCALED,
        vk.VK_FORMAT_R16G16_UINT,
        vk.VK_FORMAT_R16G16_SINT,
        vk.VK_FORMAT_R16G16_SFLOAT,
        vk.VK_FORMAT_R16G16B16_UNORM,
        vk.VK_FORMAT_R16G16B16_SNORM,
        vk.VK_FORMAT_R16G16B16_USCALED,
        vk.VK_FORMAT_R16G16B16_SSCALED,
        vk.VK_FORMAT_R16G16B16_UINT,
        vk.VK_FORMAT_R16G16B16_SINT,
        vk.VK_FORMAT_R16G16B16_SFLOAT,
        vk.VK_FORMAT_R16G16B16A16_UNORM,
        vk.VK_FORMAT_R16G16B16A16_SNORM,
        vk.VK_FORMAT_R16G16B16A16_USCALED,
        vk.VK_FORMAT_R16G16B16A16_SSCALED,
        vk.VK_FORMAT_R16G16B16A16_UINT,
        vk.VK_FORMAT_R16G16B16A16_SINT,
        vk.VK_FORMAT_R16G16B16A16_SFLOAT,
        vk.VK_FORMAT_R32_UINT,
        vk.VK_FORMAT_R32_SINT,
        vk.VK_FORMAT_R32_SFLOAT,
        vk.VK_FORMAT_R32G32_UINT,
        vk.VK_FORMAT_R32G32_SINT,
        vk.VK_FORMAT_R32G32_SFLOAT,
        vk.VK_FORMAT_R32G32B32_UINT,
        vk.VK_FORMAT_R32G32B32_SINT,
        vk.VK_FORMAT_R32G32B32_SFLOAT,
        vk.VK_FORMAT_R32G32B32A32_UINT,
        vk.VK_FORMAT_R32G32B32A32_SINT,
        vk.VK_FORMAT_R32G32B32A32_SFLOAT,
        vk.VK_FORMAT_R64_UINT,
        vk.VK_FORMAT_R64_SINT,
        vk.VK_FORMAT_R64_SFLOAT,
        vk.VK_FORMAT_R64G64_UINT,
        vk.VK_FORMAT_R64G64_SINT,
        vk.VK_FORMAT_R64G64_SFLOAT,
        vk.VK_FORMAT_R64G64B64_UINT,
        vk.VK_FORMAT_R64G64B64_SINT,
        vk.VK_FORMAT_R64G64B64_SFLOAT,
        vk.VK_FORMAT_R64G64B64A64_UINT,
        vk.VK_FORMAT_R64G64B64A64_SINT,
        vk.VK_FORMAT_R64G64B64A64_SFLOAT,
        vk.VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        vk.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
        vk.VK_FORMAT_D16_UNORM,
        vk.VK_FORMAT_X8_D24_UNORM_PACK32,
        vk.VK_FORMAT_D32_SFLOAT,
        vk.VK_FORMAT_S8_UINT,
        vk.VK_FORMAT_D16_UNORM_S8_UINT,
        vk.VK_FORMAT_D24_UNORM_S8_UINT,
        vk.VK_FORMAT_D32_SFLOAT_S8_UINT,
        vk.VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        vk.VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
        vk.VK_FORMAT_BC2_UNORM_BLOCK,
        vk.VK_FORMAT_BC2_SRGB_BLOCK,
        vk.VK_FORMAT_BC3_UNORM_BLOCK,
        vk.VK_FORMAT_BC3_SRGB_BLOCK,
        vk.VK_FORMAT_BC4_UNORM_BLOCK,
        vk.VK_FORMAT_BC4_SNORM_BLOCK,
        vk.VK_FORMAT_BC5_UNORM_BLOCK,
        vk.VK_FORMAT_BC5_SNORM_BLOCK,
        vk.VK_FORMAT_BC6H_UFLOAT_BLOCK,
        vk.VK_FORMAT_BC6H_SFLOAT_BLOCK,
        vk.VK_FORMAT_BC7_UNORM_BLOCK,
        vk.VK_FORMAT_BC7_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        vk.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
        vk.VK_FORMAT_EAC_R11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11_SNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        vk.VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        vk.VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == vk.VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8B8G8R8_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B8G8R8G8_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16B16G16R16_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_B16G16R16G16_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_FORMAT_A8_UNORM_KHR)
        return true;
    return false;
}

pub fn check_enum_VkStructureType(extensions: *const Extensions, item: *const vk.VkStructureType) bool {
    const min = @min(
        vk.VK_STRUCTURE_TYPE_APPLICATION_INFO,
        vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SUBMIT_INFO,
        vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
        vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    );
    const max = @max(
        vk.VK_STRUCTURE_TYPE_APPLICATION_INFO,
        vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SUBMIT_INFO,
        vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
        vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
        vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER,
        vk.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
        vk.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_physical_device_properties2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_EXT_validation_flags and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT)
        return true;
    if (extensions.instance.VK_KHR_device_group_creation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_device_group_creation and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_memory_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_EXT_display_surface_counter and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_external_fence_capabilities and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_metal_surface and item.* == vk.VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_protected_capabilities and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
        return true;
    if (extensions.instance.VK_EXT_validation_features and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT)
        return true;
    if (extensions.instance.VK_EXT_headless_surface and item.* == vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT)
        return true;
    if (extensions.instance.VK_EXT_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT)
        return true;
    if (extensions.instance.VK_EXT_directfb_surface and item.* == vk.VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR)
        return true;
    if (extensions.instance.VK_EXT_layer_settings and item.* == vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_multiview and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_texture_compression_astc_hdr and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_push_descriptor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_float16_int8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float16_int8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_16bit_storage and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_incremental_present and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_hdr_metadata and item.* == vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_imageless_framebuffer and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_create_renderpass2 and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR)
        return true;
    if (extensions.device.VK_IMG_relaxed_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_variable_pointers and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_variable_pointers and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dedicated_allocation and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_dedicated_allocation and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT)
        return true;
    if (extensions.device.VK_EXT_inline_uniform_block and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR)
        return true;
    if (extensions.device.VK_KHR_get_memory_requirements2 and item.* == vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR)
        return true;
    if (extensions.device.VK_KHR_image_format_list and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_bind_memory2 and item.* == vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_bind_memory2 and item.* == vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance3 and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_extended_types and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_8bit_storage and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_atomic_int64 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_clock and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_feedback and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_depth_stencil_resolve and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_depth_stencil_resolve and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR)
        return true;
    if (extensions.device.VK_INTEL_shader_integer_functions2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL)
        return true;
    if (extensions.device.VK_KHR_vulkan_memory_model and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_pci_bus_info and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_terminate_invocation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_scalar_block_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_subgroup_size_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_dynamic_rendering_local_read and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_image_atomic_int64 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_quad_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_memory_budget and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR)
        return true;
    if (extensions.device.VK_KHR_separate_depth_stencil_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_tooling_info and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_separate_stencil_usage and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_present_wait and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_shader_interlock and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_image_arrays and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_uniform_buffer_standard_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_query_reset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_index_type_uint8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_host_image_copy and item.* == vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT)
        return true;
    if (extensions.device.VK_KHR_map_memory2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_map_memory2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_demote_to_helper_invocation and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_integer_dot_product and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_integer_dot_product and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_texel_buffer_alignment and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_texel_buffer_alignment and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_EXT_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_ID_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_synchronization2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_uniform_control_flow and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_zero_initialize_workgroup_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_QCOM_rotated_copy_commands and item.* == vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_image_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_workgroup_memory_explicit_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_commands2 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_rgba10x6_formats and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_physical_device_drm and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitive_topology_list_restart and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_format_feature_flags2 and item.* == vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR)
        return true;
    if (extensions.device.VK_EXT_present_mode_fifo_latest_ready and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_global_priority_query and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority_query and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_2d_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pageable_device_local_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance4 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_rotate and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_zero_one and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_non_seamless_cube_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_shader_maximal_reconvergence and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control_swapchain and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_acquire_unmodified and item.* == vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_dithering and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_protected_access and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance5 and item.* == vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_viewports and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_library_group_handles and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_dynamic_rendering_unused_attachments and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_vertex_attribute_divisor and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_index_type_uint8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_calibrated_timestamps and item.* == vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_expect_assume and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_relaxed_extended_instruction and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_replicated_composites and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == vk.VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_depth_clamp_zero_one and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_robustness and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSubpassContents(extensions: *const Extensions, item: *const vk.VkSubpassContents) bool {
    const min = @min(
        vk.VK_SUBPASS_CONTENTS_INLINE,
        vk.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    );
    const max = @max(
        vk.VK_SUBPASS_CONTENTS_INLINE,
        vk.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == vk.VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == vk.VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR)
        return true;
    return false;
}

pub fn check_enum_VkResult(extensions: *const Extensions, item: *const vk.VkResult) bool {
    const min = @min(
        vk.VK_SUCCESS,
        vk.VK_NOT_READY,
        vk.VK_TIMEOUT,
        vk.VK_EVENT_SET,
        vk.VK_EVENT_RESET,
        vk.VK_INCOMPLETE,
        vk.VK_ERROR_OUT_OF_HOST_MEMORY,
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY,
        vk.VK_ERROR_INITIALIZATION_FAILED,
        vk.VK_ERROR_DEVICE_LOST,
        vk.VK_ERROR_MEMORY_MAP_FAILED,
        vk.VK_ERROR_LAYER_NOT_PRESENT,
        vk.VK_ERROR_EXTENSION_NOT_PRESENT,
        vk.VK_ERROR_FEATURE_NOT_PRESENT,
        vk.VK_ERROR_INCOMPATIBLE_DRIVER,
        vk.VK_ERROR_TOO_MANY_OBJECTS,
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED,
        vk.VK_ERROR_FRAGMENTED_POOL,
        vk.VK_ERROR_UNKNOWN,
    );
    const max = @max(
        vk.VK_SUCCESS,
        vk.VK_NOT_READY,
        vk.VK_TIMEOUT,
        vk.VK_EVENT_SET,
        vk.VK_EVENT_RESET,
        vk.VK_INCOMPLETE,
        vk.VK_ERROR_OUT_OF_HOST_MEMORY,
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY,
        vk.VK_ERROR_INITIALIZATION_FAILED,
        vk.VK_ERROR_DEVICE_LOST,
        vk.VK_ERROR_MEMORY_MAP_FAILED,
        vk.VK_ERROR_LAYER_NOT_PRESENT,
        vk.VK_ERROR_EXTENSION_NOT_PRESENT,
        vk.VK_ERROR_FEATURE_NOT_PRESENT,
        vk.VK_ERROR_INCOMPATIBLE_DRIVER,
        vk.VK_ERROR_TOO_MANY_OBJECTS,
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED,
        vk.VK_ERROR_FRAGMENTED_POOL,
        vk.VK_ERROR_UNKNOWN,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_ERROR_SURFACE_LOST_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_SUBOPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_ERROR_OUT_OF_DATE_KHR)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance1 and item.* == vk.VK_ERROR_OUT_OF_POOL_MEMORY_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory and item.* == vk.VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_indexing and item.* == vk.VK_ERROR_FRAGMENTATION_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_ERROR_NOT_PERMITTED_EXT)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_ERROR_NOT_PERMITTED_KHR)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == vk.VK_ERROR_INVALID_DEVICE_ADDRESS_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT)
        return true;
    if (extensions.device.VK_KHR_buffer_device_address and item.* == vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_THREAD_IDLE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_THREAD_DONE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OPERATION_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OPERATION_NOT_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_PIPELINE_COMPILE_REQUIRED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control and item.* == vk.VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_PIPELINE_BINARY_MISSING_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkDynamicState(extensions: *const Extensions, item: *const vk.VkDynamicState) bool {
    const min = @min(
        vk.VK_DYNAMIC_STATE_VIEWPORT,
        vk.VK_DYNAMIC_STATE_SCISSOR,
        vk.VK_DYNAMIC_STATE_LINE_WIDTH,
        vk.VK_DYNAMIC_STATE_DEPTH_BIAS,
        vk.VK_DYNAMIC_STATE_BLEND_CONSTANTS,
        vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS,
        vk.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    );
    const max = @max(
        vk.VK_DYNAMIC_STATE_VIEWPORT,
        vk.VK_DYNAMIC_STATE_SCISSOR,
        vk.VK_DYNAMIC_STATE_LINE_WIDTH,
        vk.VK_DYNAMIC_STATE_DEPTH_BIAS,
        vk.VK_DYNAMIC_STATE_BLEND_CONSTANTS,
        vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS,
        vk.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
        vk.VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == vk.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == vk.VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == vk.VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_CULL_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_FRONT_FACE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_STENCIL_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_VERTEX_INPUT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_LOGIC_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == vk.VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == vk.VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_POLYGON_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == vk.VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == vk.VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_DYNAMIC_STATE_LINE_STIPPLE_KHR)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == vk.VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT)
        return true;
    return false;
}

pub fn check_enum_VkDescriptorUpdateTemplateType(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateType) bool {
    const min = vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    const max = vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_push_descriptor and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR)
        return true;
    return false;
}

pub fn check_enum_VkObjectType(extensions: *const Extensions, item: *const vk.VkObjectType) bool {
    const min = @min(
        vk.VK_OBJECT_TYPE_UNKNOWN,
        vk.VK_OBJECT_TYPE_INSTANCE,
        vk.VK_OBJECT_TYPE_PHYSICAL_DEVICE,
        vk.VK_OBJECT_TYPE_DEVICE,
        vk.VK_OBJECT_TYPE_QUEUE,
        vk.VK_OBJECT_TYPE_SEMAPHORE,
        vk.VK_OBJECT_TYPE_COMMAND_BUFFER,
        vk.VK_OBJECT_TYPE_FENCE,
        vk.VK_OBJECT_TYPE_DEVICE_MEMORY,
        vk.VK_OBJECT_TYPE_BUFFER,
        vk.VK_OBJECT_TYPE_IMAGE,
        vk.VK_OBJECT_TYPE_EVENT,
        vk.VK_OBJECT_TYPE_QUERY_POOL,
        vk.VK_OBJECT_TYPE_BUFFER_VIEW,
        vk.VK_OBJECT_TYPE_IMAGE_VIEW,
        vk.VK_OBJECT_TYPE_SHADER_MODULE,
        vk.VK_OBJECT_TYPE_PIPELINE_CACHE,
        vk.VK_OBJECT_TYPE_PIPELINE_LAYOUT,
        vk.VK_OBJECT_TYPE_RENDER_PASS,
        vk.VK_OBJECT_TYPE_PIPELINE,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
        vk.VK_OBJECT_TYPE_SAMPLER,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_POOL,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET,
        vk.VK_OBJECT_TYPE_FRAMEBUFFER,
        vk.VK_OBJECT_TYPE_COMMAND_POOL,
    );
    const max = @max(
        vk.VK_OBJECT_TYPE_UNKNOWN,
        vk.VK_OBJECT_TYPE_INSTANCE,
        vk.VK_OBJECT_TYPE_PHYSICAL_DEVICE,
        vk.VK_OBJECT_TYPE_DEVICE,
        vk.VK_OBJECT_TYPE_QUEUE,
        vk.VK_OBJECT_TYPE_SEMAPHORE,
        vk.VK_OBJECT_TYPE_COMMAND_BUFFER,
        vk.VK_OBJECT_TYPE_FENCE,
        vk.VK_OBJECT_TYPE_DEVICE_MEMORY,
        vk.VK_OBJECT_TYPE_BUFFER,
        vk.VK_OBJECT_TYPE_IMAGE,
        vk.VK_OBJECT_TYPE_EVENT,
        vk.VK_OBJECT_TYPE_QUERY_POOL,
        vk.VK_OBJECT_TYPE_BUFFER_VIEW,
        vk.VK_OBJECT_TYPE_IMAGE_VIEW,
        vk.VK_OBJECT_TYPE_SHADER_MODULE,
        vk.VK_OBJECT_TYPE_PIPELINE_CACHE,
        vk.VK_OBJECT_TYPE_PIPELINE_LAYOUT,
        vk.VK_OBJECT_TYPE_RENDER_PASS,
        vk.VK_OBJECT_TYPE_PIPELINE,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
        vk.VK_OBJECT_TYPE_SAMPLER,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_POOL,
        vk.VK_OBJECT_TYPE_DESCRIPTOR_SET,
        vk.VK_OBJECT_TYPE_FRAMEBUFFER,
        vk.VK_OBJECT_TYPE_COMMAND_POOL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == vk.VK_OBJECT_TYPE_SURFACE_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_OBJECT_TYPE_DISPLAY_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == vk.VK_OBJECT_TYPE_DISPLAY_MODE_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == vk.VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == vk.VK_OBJECT_TYPE_SWAPCHAIN_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_OBJECT_TYPE_VIDEO_SESSION_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == vk.VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == vk.VK_OBJECT_TYPE_VALIDATION_CACHE_EXT)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == vk.VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == vk.VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR)
        return true;
    if (extensions.device.VK_EXT_private_data and item.* == vk.VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == vk.VK_OBJECT_TYPE_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == vk.VK_OBJECT_TYPE_SHADER_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == vk.VK_OBJECT_TYPE_PIPELINE_BINARY_KHR)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == vk.VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT)
        return true;
    return false;
}

pub fn check_enum_VkRayTracingInvocationReorderModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingInvocationReorderModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
        vk.VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRayTracingLssIndexingModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssIndexingModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
        vk.VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRayTracingLssPrimitiveEndCapsModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssPrimitiveEndCapsModeNV) bool {
    const min = @min(
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
    );
    const max = @max(
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
        vk.VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDirectDriverLoadingModeLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingModeLUNARG) bool {
    const min = @min(
        vk.VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
        vk.VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
    );
    const max = @max(
        vk.VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
        vk.VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAntiLagModeAMD(extensions: *const Extensions, item: *const vk.VkAntiLagModeAMD) bool {
    const min = @min(
        vk.VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
        vk.VK_ANTI_LAG_MODE_ON_AMD,
        vk.VK_ANTI_LAG_MODE_OFF_AMD,
    );
    const max = @max(
        vk.VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
        vk.VK_ANTI_LAG_MODE_ON_AMD,
        vk.VK_ANTI_LAG_MODE_OFF_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAntiLagStageAMD(extensions: *const Extensions, item: *const vk.VkAntiLagStageAMD) bool {
    const min = @min(
        vk.VK_ANTI_LAG_STAGE_INPUT_AMD,
        vk.VK_ANTI_LAG_STAGE_PRESENT_AMD,
    );
    const max = @max(
        vk.VK_ANTI_LAG_STAGE_INPUT_AMD,
        vk.VK_ANTI_LAG_STAGE_PRESENT_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkQueueFlagBits(extensions: *const Extensions, item: *const vk.VkQueueFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUEUE_GRAPHICS_BIT |
        vk.VK_QUEUE_COMPUTE_BIT |
        vk.VK_QUEUE_TRANSFER_BIT |
        vk.VK_QUEUE_SPARSE_BINDING_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_QUEUE_VIDEO_DECODE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_QUEUE_VIDEO_ENCODE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCullModeFlagBits(extensions: *const Extensions, item: *const vk.VkCullModeFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CULL_MODE_NONE |
        vk.VK_CULL_MODE_FRONT_BIT |
        vk.VK_CULL_MODE_BACK_BIT |
        vk.VK_CULL_MODE_FRONT_AND_BACK;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkRenderPassCreateFlagBits(extensions: *const Extensions, item: *const vk.VkRenderPassCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_QCOM_render_pass_transform)
        valid_bits |= vk.VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceQueueCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryPropertyFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryPropertyFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
        vk.VK_MEMORY_PROPERTY_HOST_CACHED_BIT |
        vk.VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryHeapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryHeapFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_MEMORY_HEAP_DEVICE_LOCAL_BIT;
    if (extensions.instance.VK_KHR_device_group_creation)
        valid_bits |= vk.VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAccessFlagBits(extensions: *const Extensions, item: *const vk.VkAccessFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_ACCESS_INDIRECT_COMMAND_READ_BIT |
        vk.VK_ACCESS_INDEX_READ_BIT |
        vk.VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT |
        vk.VK_ACCESS_UNIFORM_READ_BIT |
        vk.VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_SHADER_READ_BIT |
        vk.VK_ACCESS_SHADER_WRITE_BIT |
        vk.VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_TRANSFER_READ_BIT |
        vk.VK_ACCESS_TRANSFER_WRITE_BIT |
        vk.VK_ACCESS_HOST_READ_BIT |
        vk.VK_ACCESS_HOST_WRITE_BIT |
        vk.VK_ACCESS_MEMORY_READ_BIT |
        vk.VK_ACCESS_MEMORY_WRITE_BIT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT;
    if (extensions.device.VK_EXT_blend_operation_advanced)
        valid_bits |= vk.VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_NONE_KHR;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBufferUsageFlagBits(extensions: *const Extensions, item: *const vk.VkBufferUsageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUFFER_USAGE_TRANSFER_SRC_BIT |
        vk.VK_BUFFER_USAGE_TRANSFER_DST_BIT |
        vk.VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_INDEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR;
    if (extensions.device.VK_EXT_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBufferUsageFlagBits2(extensions: *const Extensions, item: *const vk.VkBufferUsageFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT |
        vk.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT |
        vk.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT |
        vk.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBufferCreateFlagBits(extensions: *const Extensions, item: *const vk.VkBufferCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUFFER_CREATE_SPARSE_BINDING_BIT |
        vk.VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT |
        vk.VK_BUFFER_CREATE_SPARSE_ALIASED_BIT;
    if (extensions.device.VK_EXT_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkShaderStageFlagBits(extensions: *const Extensions, item: *const vk.VkShaderStageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SHADER_STAGE_VERTEX_BIT |
        vk.VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT |
        vk.VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT |
        vk.VK_SHADER_STAGE_GEOMETRY_BIT |
        vk.VK_SHADER_STAGE_FRAGMENT_BIT |
        vk.VK_SHADER_STAGE_COMPUTE_BIT |
        vk.VK_SHADER_STAGE_ALL_GRAPHICS |
        vk.VK_SHADER_STAGE_ALL;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_RAYGEN_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_MISS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_SHADER_STAGE_CALLABLE_BIT_KHR;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_SHADER_STAGE_TASK_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_SHADER_STAGE_MESH_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageUsageFlagBits(extensions: *const Extensions, item: *const vk.VkImageUsageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_USAGE_TRANSFER_SRC_BIT |
        vk.VK_IMAGE_USAGE_TRANSFER_DST_BIT |
        vk.VK_IMAGE_USAGE_SAMPLED_BIT |
        vk.VK_IMAGE_USAGE_STORAGE_BIT |
        vk.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT |
        vk.VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_memory_heap)
        valid_bits |= vk.VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageCreateFlagBits(extensions: *const Extensions, item: *const vk.VkImageCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_CREATE_SPARSE_BINDING_BIT |
        vk.VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT |
        vk.VK_IMAGE_CREATE_SPARSE_ALIASED_BIT |
        vk.VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT |
        vk.VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance2)
        valid_bits |= vk.VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance2)
        valid_bits |= vk.VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR;
    if (extensions.device.VK_EXT_sample_locations)
        valid_bits |= vk.VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_CREATE_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_bind_memory2)
        valid_bits |= vk.VK_IMAGE_CREATE_ALIAS_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled)
        valid_bits |= vk.VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_image_2d_view_of_3d)
        valid_bits |= vk.VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT;
    if (extensions.device.VK_QCOM_fragment_density_map_offset)
        valid_bits |= vk.VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map_offset)
        valid_bits |= vk.VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageViewCreateFlagBits(extensions: *const Extensions, item: *const vk.VkImageViewCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map2)
        valid_bits |= vk.VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSamplerCreateFlagBits(extensions: *const Extensions, item: *const vk.VkSamplerCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    if (extensions.device.VK_EXT_non_seamless_cube_map)
        valid_bits |= vk.VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT |
        vk.VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT |
        vk.VK_PIPELINE_CREATE_DERIVATIVE_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PIPELINE_CREATE_DISPATCH_BASE_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_executable_properties)
        valid_bits |= vk.VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_executable_properties)
        valid_bits |= vk.VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_LIBRARY_BIT_KHR;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_cache_control)
        valid_bits |= vk.VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_protected_access)
        valid_bits |= vk.VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_protected_access)
        valid_bits |= vk.VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCreateFlagBits2(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT |
        vk.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT |
        vk.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT |
        vk.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT |
        vk.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT |
        vk.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT |
        vk.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT |
        vk.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT |
        vk.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance5)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM;
    if (extensions.device.VK_KHR_pipeline_binary)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineShaderStageCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_subgroup_size_control)
        valid_bits |= vk.VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    if (extensions.device.VK_EXT_subgroup_size_control)
        valid_bits |= vk.VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkColorComponentFlagBits(extensions: *const Extensions, item: *const vk.VkColorComponentFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COLOR_COMPONENT_R_BIT |
        vk.VK_COLOR_COMPONENT_G_BIT |
        vk.VK_COLOR_COMPONENT_B_BIT |
        vk.VK_COLOR_COMPONENT_A_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFenceCreateFlagBits(extensions: *const Extensions, item: *const vk.VkFenceCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_FENCE_CREATE_SIGNALED_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSemaphoreCreateFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFormatFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT |
        vk.VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_BLIT_SRC_BIT |
        vk.VK_FORMAT_FEATURE_BLIT_DST_BIT |
        vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT;
    if (extensions.device.VK_IMG_filter_cubic)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance1)
        valid_bits |= vk.VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_EXT_sampler_filter_minmax)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_EXT_filter_cubic)
        valid_bits |= vk.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryControlFlagBits(extensions: *const Extensions, item: *const vk.VkQueryControlFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_QUERY_CONTROL_PRECISE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryResultFlagBits(extensions: *const Extensions, item: *const vk.VkQueryResultFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUERY_RESULT_64_BIT |
        vk.VK_QUERY_RESULT_WAIT_BIT |
        vk.VK_QUERY_RESULT_WITH_AVAILABILITY_BIT |
        vk.VK_QUERY_RESULT_PARTIAL_BIT;
    if (extensions.device.VK_KHR_video_queue)
        valid_bits |= vk.VK_QUERY_RESULT_WITH_STATUS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandBufferUsageFlagBits(extensions: *const Extensions, item: *const vk.VkCommandBufferUsageFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT |
        vk.VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT |
        vk.VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryPipelineStatisticFlagBits(extensions: *const Extensions, item: *const vk.VkQueryPipelineStatisticFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT |
        vk.VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryMapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryMapFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_map_memory_placed)
        valid_bits |= vk.VK_MEMORY_MAP_PLACED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageAspectFlagBits(extensions: *const Extensions, item: *const vk.VkImageAspectFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_IMAGE_ASPECT_COLOR_BIT |
        vk.VK_IMAGE_ASPECT_DEPTH_BIT |
        vk.VK_IMAGE_ASPECT_STENCIL_BIT |
        vk.VK_IMAGE_ASPECT_METADATA_BIT;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_0_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_1_BIT_KHR;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion)
        valid_bits |= vk.VK_IMAGE_ASPECT_PLANE_2_BIT_KHR;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
    if (extensions.device.VK_EXT_image_drm_format_modifier)
        valid_bits |= vk.VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance4)
        valid_bits |= vk.VK_IMAGE_ASPECT_NONE_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSparseImageFormatFlagBits(extensions: *const Extensions, item: *const vk.VkSparseImageFormatFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT |
        vk.VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT |
        vk.VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSparseMemoryBindFlagBits(extensions: *const Extensions, item: *const vk.VkSparseMemoryBindFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SPARSE_MEMORY_BIND_METADATA_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineStageFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineStageFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT |
        vk.VK_PIPELINE_STAGE_VERTEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_VERTEX_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
        vk.VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_HOST_BIT |
        vk.VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT |
        vk.VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    if (extensions.device.VK_EXT_transform_feedback)
        valid_bits |= vk.VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT;
    if (extensions.device.VK_EXT_conditional_rendering)
        valid_bits |= vk.VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_pipeline)
        valid_bits |= vk.VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_NONE_KHR;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_mesh_shader)
        valid_bits |= vk.VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_POOL_CREATE_TRANSIENT_BIT |
        vk.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandPoolResetFlagBits(extensions: *const Extensions, item: *const vk.VkCommandPoolResetFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCommandBufferResetFlagBits(extensions: *const Extensions, item: *const vk.VkCommandBufferResetFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSampleCountFlagBits(extensions: *const Extensions, item: *const vk.VkSampleCountFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SAMPLE_COUNT_1_BIT |
        vk.VK_SAMPLE_COUNT_2_BIT |
        vk.VK_SAMPLE_COUNT_4_BIT |
        vk.VK_SAMPLE_COUNT_8_BIT |
        vk.VK_SAMPLE_COUNT_16_BIT |
        vk.VK_SAMPLE_COUNT_32_BIT |
        vk.VK_SAMPLE_COUNT_64_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAttachmentDescriptionFlagBits(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkStencilFaceFlagBits(extensions: *const Extensions, item: *const vk.VkStencilFaceFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_STENCIL_FACE_FRONT_BIT |
        vk.VK_STENCIL_FACE_BACK_BIT |
        vk.VK_STENCIL_FACE_FRONT_AND_BACK;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDescriptorPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT;
    if (extensions.device.VK_VALVE_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE;
    if (extensions.device.VK_EXT_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDependencyFlagBits(extensions: *const Extensions, item: *const vk.VkDependencyFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DEPENDENCY_BY_REGION_BIT;
    if (extensions.device.VK_KHR_multiview)
        valid_bits |= vk.VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout)
        valid_bits |= vk.VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance8)
        valid_bits |= vk.VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR;
    if (extensions.device.VK_KHR_maintenance9)
        valid_bits |= vk.VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkSemaphoreType(extensions: *const Extensions, item: *const vk.VkSemaphoreType) bool {
    const min = @min(
        vk.VK_SEMAPHORE_TYPE_BINARY,
        vk.VK_SEMAPHORE_TYPE_TIMELINE,
    );
    const max = @max(
        vk.VK_SEMAPHORE_TYPE_BINARY,
        vk.VK_SEMAPHORE_TYPE_TIMELINE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_SEMAPHORE_TYPE_BINARY_KHR)
        return true;
    if (extensions.device.VK_KHR_timeline_semaphore and item.* == vk.VK_SEMAPHORE_TYPE_TIMELINE_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkSemaphoreWaitFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SEMAPHORE_WAIT_ANY_BIT;
    if (extensions.device.VK_KHR_timeline_semaphore)
        valid_bits |= vk.VK_SEMAPHORE_WAIT_ANY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPresentModeKHR(extensions: *const Extensions, item: *const vk.VkPresentModeKHR) bool {
    const min = @min(
        vk.VK_PRESENT_MODE_IMMEDIATE_KHR,
        vk.VK_PRESENT_MODE_MAILBOX_KHR,
        vk.VK_PRESENT_MODE_FIFO_KHR,
        vk.VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    );
    const max = @max(
        vk.VK_PRESENT_MODE_IMMEDIATE_KHR,
        vk.VK_PRESENT_MODE_MAILBOX_KHR,
        vk.VK_PRESENT_MODE_FIFO_KHR,
        vk.VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == vk.VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR)
        return true;
    if (extensions.device.VK_EXT_present_mode_fifo_latest_ready and item.* == vk.VK_PRESENT_MODE_FIFO_LATEST_READY_EXT)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == vk.VK_PRESENT_MODE_FIFO_LATEST_READY_KHR)
        return true;
    return false;
}

pub fn check_enum_VkColorSpaceKHR(extensions: *const Extensions, item: *const vk.VkColorSpaceKHR) bool {
    const min = vk.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    const max = vk.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT709_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT709_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_BT2020_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_HDR10_ST2084_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_DOLBYVISION_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_HDR10_HLG_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_PASS_THROUGH_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == vk.VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT)
        return true;
    return false;
}

pub fn check_bitmask_VkDisplayPlaneAlphaFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneAlphaFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR |
        vk.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkCompositeAlphaFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkCompositeAlphaFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR |
        vk.VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSurfaceTransformFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkSurfaceTransformFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR |
        vk.VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDisplaySurfaceStereoTypeNV(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceStereoTypeNV) bool {
    const min = @min(
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
    );
    const max = @max(
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
        vk.VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkSwapchainImageUsageFlagBitsANDROID(extensions: *const Extensions, item: *const vk.VkSwapchainImageUsageFlagBitsANDROID) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkTimeDomainKHR(extensions: *const Extensions, item: *const vk.VkTimeDomainKHR) bool {
    const min = @min(
        vk.VK_TIME_DOMAIN_DEVICE_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
        vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
    );
    const max = @max(
        vk.VK_TIME_DOMAIN_DEVICE_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
        vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
        vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_DEVICE_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT)
        return true;
    if (extensions.device.VK_EXT_calibrated_timestamps and item.* == vk.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT)
        return true;
    return false;
}

pub fn check_bitmask_VkDebugReportFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugReportFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEBUG_REPORT_INFORMATION_BIT_EXT |
        vk.VK_DEBUG_REPORT_WARNING_BIT_EXT |
        vk.VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |
        vk.VK_DEBUG_REPORT_ERROR_BIT_EXT |
        vk.VK_DEBUG_REPORT_DEBUG_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDebugReportObjectTypeEXT(extensions: *const Extensions, item: *const vk.VkDebugReportObjectTypeEXT) bool {
    const min = @min(
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    );
    const max = @max(
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
        vk.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT)
        return true;
    if (extensions.device.VK_KHR_descriptor_update_template and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT)
        return true;
    return false;
}

pub fn check_enum_VkDeviceMemoryReportEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportEventTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
        vk.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRasterizationOrderAMD(extensions: *const Extensions, item: *const vk.VkRasterizationOrderAMD) bool {
    const min = @min(
        vk.VK_RASTERIZATION_ORDER_STRICT_AMD,
        vk.VK_RASTERIZATION_ORDER_RELAXED_AMD,
    );
    const max = @max(
        vk.VK_RASTERIZATION_ORDER_STRICT_AMD,
        vk.VK_RASTERIZATION_ORDER_RELAXED_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkExternalMemoryHandleTypeFlagBitsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalMemoryFeatureFlagBitsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV |
        vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkClusterAccelerationStructureIndexFormatFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureIndexFormatFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkClusterAccelerationStructureTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureTypeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkClusterAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpTypeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkClusterAccelerationStructureOpModeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpModeNV) bool {
    const min = @min(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    );
    const max = @max(
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkClusterAccelerationStructureClusterFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureClusterFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkClusterAccelerationStructureGeometryFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGeometryFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkClusterAccelerationStructureAddressResolutionFlagBitsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureAddressResolutionFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV |
        vk.VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkValidationCheckEXT(extensions: *const Extensions, item: *const vk.VkValidationCheckEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_CHECK_ALL_EXT,
        vk.VK_VALIDATION_CHECK_SHADERS_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_CHECK_ALL_EXT,
        vk.VK_VALIDATION_CHECK_SHADERS_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkValidationFeatureEnableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureEnableEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
        vk.VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkValidationFeatureDisableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureDisableEXT) bool {
    const min = @min(
        vk.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
    );
    const max = @max(
        vk.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
        vk.VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLayerSettingTypeEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingTypeEXT) bool {
    const min = @min(
        vk.VK_LAYER_SETTING_TYPE_BOOL32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_STRING_EXT,
    );
    const max = @max(
        vk.VK_LAYER_SETTING_TYPE_BOOL32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_INT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_UINT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
        vk.VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
        vk.VK_LAYER_SETTING_TYPE_STRING_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkSubgroupFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkSubgroupFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SUBGROUP_FEATURE_BASIC_BIT |
        vk.VK_SUBGROUP_FEATURE_VOTE_BIT |
        vk.VK_SUBGROUP_FEATURE_ARITHMETIC_BIT |
        vk.VK_SUBGROUP_FEATURE_BALLOT_BIT |
        vk.VK_SUBGROUP_FEATURE_SHUFFLE_BIT |
        vk.VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT |
        vk.VK_SUBGROUP_FEATURE_CLUSTERED_BIT |
        vk.VK_SUBGROUP_FEATURE_QUAD_BIT;
    if (extensions.device.VK_KHR_shader_subgroup_rotate)
        valid_bits |= vk.VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR;
    if (extensions.device.VK_KHR_shader_subgroup_rotate)
        valid_bits |= vk.VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkIndirectCommandsLayoutUsageFlagBitsNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkIndirectStateFlagBitsNV(extensions: *const Extensions, item: *const vk.VkIndirectStateFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkIndirectCommandsTokenTypeNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeNV) bool {
    const min = @min(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    );
    const max = @max(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV)
        return true;
    return false;
}

pub fn check_bitmask_VkPrivateDataSlotCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDescriptorSetLayoutCreateFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_push_descriptor)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT;
    if (extensions.device.VK_VALVE_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE;
    if (extensions.device.VK_EXT_mutable_descriptor_type)
        valid_bits |= vk.VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalMemoryHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
        vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR;
    if (extensions.device.VK_EXT_external_memory_dma_buf)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_host)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_host)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT;
    if (extensions.device.VK_EXT_external_memory_metal)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalMemoryFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT |
        vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_memory_capabilities)
        valid_bits |= vk.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalSemaphoreHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalSemaphoreFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_semaphore_capabilities)
        valid_bits |= vk.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSemaphoreImportFlagBits(extensions: *const Extensions, item: *const vk.VkSemaphoreImportFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
    if (extensions.device.VK_KHR_external_semaphore)
        valid_bits |= vk.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalFenceHandleTypeFlagBits(extensions: *const Extensions, item: *const vk.VkExternalFenceHandleTypeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
        vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkExternalFenceFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkExternalFenceFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT |
        vk.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR;
    if (extensions.instance.VK_KHR_external_fence_capabilities)
        valid_bits |= vk.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFenceImportFlagBits(extensions: *const Extensions, item: *const vk.VkFenceImportFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_FENCE_IMPORT_TEMPORARY_BIT;
    if (extensions.device.VK_KHR_external_fence)
        valid_bits |= vk.VK_FENCE_IMPORT_TEMPORARY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSurfaceCounterFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCounterFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_SURFACE_COUNTER_VBLANK_BIT_EXT |
        vk.VK_SURFACE_COUNTER_VBLANK_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDisplayPowerStateEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerStateEXT) bool {
    const min = @min(
        vk.VK_DISPLAY_POWER_STATE_OFF_EXT,
        vk.VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
        vk.VK_DISPLAY_POWER_STATE_ON_EXT,
    );
    const max = @max(
        vk.VK_DISPLAY_POWER_STATE_OFF_EXT,
        vk.VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
        vk.VK_DISPLAY_POWER_STATE_ON_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDeviceEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventTypeEXT) bool {
    const min = vk.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
    const max = vk.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDisplayEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventTypeEXT) bool {
    const min = vk.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
    const max = vk.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPeerMemoryFeatureFlagBits(extensions: *const Extensions, item: *const vk.VkPeerMemoryFeatureFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT |
        vk.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT |
        vk.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT |
        vk.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMemoryAllocateFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;
    if (extensions.device.VK_KHR_buffer_device_address)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_zero_initialize_device_memory)
        valid_bits |= vk.VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceGroupPresentModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR |
        vk.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSwapchainCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_swapchain)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR;
    if (extensions.device.VK_KHR_device_group)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain_mutable_format)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR;
    if (extensions.device.VK_EXT_swapchain_maintenance1)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT;
    if (extensions.device.VK_KHR_present_id2)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR;
    if (extensions.device.VK_KHR_present_wait2)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR;
    if (extensions.device.VK_KHR_swapchain_maintenance1)
        valid_bits |= vk.VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkViewportCoordinateSwizzleNV(extensions: *const Extensions, item: *const vk.VkViewportCoordinateSwizzleNV) bool {
    const min = @min(
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    );
    const max = @max(
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
        vk.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDiscardRectangleModeEXT(extensions: *const Extensions, item: *const vk.VkDiscardRectangleModeEXT) bool {
    const min = @min(
        vk.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
        vk.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    );
    const max = @max(
        vk.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
        vk.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkSubpassDescriptionFlagBits(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_QCOM_render_pass_shader_resolve)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM;
    if (extensions.device.VK_QCOM_render_pass_shader_resolve)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPointClippingBehavior(extensions: *const Extensions, item: *const vk.VkPointClippingBehavior) bool {
    const min = @min(
        vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
        vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    );
    const max = @max(
        vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
        vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSamplerReductionMode(extensions: *const Extensions, item: *const vk.VkSamplerReductionMode) bool {
    const min = @min(
        vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
        vk.VK_SAMPLER_REDUCTION_MODE_MIN,
        vk.VK_SAMPLER_REDUCTION_MODE_MAX,
    );
    const max = @max(
        vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
        vk.VK_SAMPLER_REDUCTION_MODE_MIN,
        vk.VK_SAMPLER_REDUCTION_MODE_MAX,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_MIN_EXT)
        return true;
    if (extensions.device.VK_EXT_sampler_filter_minmax and item.* == vk.VK_SAMPLER_REDUCTION_MODE_MAX_EXT)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == vk.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM)
        return true;
    return false;
}

pub fn check_enum_VkTessellationDomainOrigin(extensions: *const Extensions, item: *const vk.VkTessellationDomainOrigin) bool {
    const min = @min(
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    );
    const max = @max(
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
        vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance2 and item.* == vk.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSamplerYcbcrModelConversion(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrModelConversion) bool {
    const min = @min(
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    );
    const max = @max(
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
        vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR)
        return true;
    return false;
}

pub fn check_enum_VkSamplerYcbcrRange(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrRange) bool {
    const min = @min(
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    );
    const max = @max(
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
        vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR)
        return true;
    return false;
}

pub fn check_enum_VkChromaLocation(extensions: *const Extensions, item: *const vk.VkChromaLocation) bool {
    const min = @min(
        vk.VK_CHROMA_LOCATION_COSITED_EVEN,
        vk.VK_CHROMA_LOCATION_MIDPOINT,
    );
    const max = @max(
        vk.VK_CHROMA_LOCATION_COSITED_EVEN,
        vk.VK_CHROMA_LOCATION_MIDPOINT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_CHROMA_LOCATION_COSITED_EVEN_KHR)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == vk.VK_CHROMA_LOCATION_MIDPOINT_KHR)
        return true;
    return false;
}

pub fn check_enum_VkBlendOverlapEXT(extensions: *const Extensions, item: *const vk.VkBlendOverlapEXT) bool {
    const min = @min(
        vk.VK_BLEND_OVERLAP_UNCORRELATED_EXT,
        vk.VK_BLEND_OVERLAP_DISJOINT_EXT,
        vk.VK_BLEND_OVERLAP_CONJOINT_EXT,
    );
    const max = @max(
        vk.VK_BLEND_OVERLAP_UNCORRELATED_EXT,
        vk.VK_BLEND_OVERLAP_DISJOINT_EXT,
        vk.VK_BLEND_OVERLAP_CONJOINT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCoverageModulationModeNV(extensions: *const Extensions, item: *const vk.VkCoverageModulationModeNV) bool {
    const min = @min(
        vk.VK_COVERAGE_MODULATION_MODE_NONE_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGB_NV,
        vk.VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    );
    const max = @max(
        vk.VK_COVERAGE_MODULATION_MODE_NONE_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGB_NV,
        vk.VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
        vk.VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCoverageReductionModeNV(extensions: *const Extensions, item: *const vk.VkCoverageReductionModeNV) bool {
    const min = @min(
        vk.VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
        vk.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
    );
    const max = @max(
        vk.VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
        vk.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkValidationCacheHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheHeaderVersionEXT) bool {
    const min = vk.VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
    const max = vk.VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkShaderInfoTypeAMD(extensions: *const Extensions, item: *const vk.VkShaderInfoTypeAMD) bool {
    const min = @min(
        vk.VK_SHADER_INFO_TYPE_STATISTICS_AMD,
        vk.VK_SHADER_INFO_TYPE_BINARY_AMD,
        vk.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    );
    const max = @max(
        vk.VK_SHADER_INFO_TYPE_STATISTICS_AMD,
        vk.VK_SHADER_INFO_TYPE_BINARY_AMD,
        vk.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkQueueGlobalPriority(extensions: *const Extensions, item: *const vk.VkQueueGlobalPriority) bool {
    const min = @min(
        vk.VK_QUEUE_GLOBAL_PRIORITY_LOW,
        vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
        vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH,
        vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    );
    const max = @max(
        vk.VK_QUEUE_GLOBAL_PRIORITY_LOW,
        vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
        vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH,
        vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT)
        return true;
    if (extensions.device.VK_EXT_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR)
        return true;
    if (extensions.device.VK_KHR_global_priority and item.* == vk.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkDebugUtilsMessageSeverityFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageSeverityFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDebugUtilsMessageTypeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageTypeFlagBitsEXT) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
        vk.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    if (extensions.device.VK_EXT_device_address_binding_report)
        valid_bits |= vk.VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkConservativeRasterizationModeEXT(extensions: *const Extensions, item: *const vk.VkConservativeRasterizationModeEXT) bool {
    const min = @min(
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    );
    const max = @max(
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
        vk.VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkDescriptorBindingFlagBits(extensions: *const Extensions, item: *const vk.VkDescriptorBindingFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT |
        vk.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT |
        vk.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT |
        vk.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_indexing)
        valid_bits |= vk.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkVendorId(extensions: *const Extensions, item: *const vk.VkVendorId) bool {
    const min = @min(
        vk.VK_VENDOR_ID_KHRONOS,
        vk.VK_VENDOR_ID_VIV,
        vk.VK_VENDOR_ID_VSI,
        vk.VK_VENDOR_ID_KAZAN,
        vk.VK_VENDOR_ID_CODEPLAY,
        vk.VK_VENDOR_ID_MESA,
        vk.VK_VENDOR_ID_POCL,
        vk.VK_VENDOR_ID_MOBILEYE,
    );
    const max = @max(
        vk.VK_VENDOR_ID_KHRONOS,
        vk.VK_VENDOR_ID_VIV,
        vk.VK_VENDOR_ID_VSI,
        vk.VK_VENDOR_ID_KAZAN,
        vk.VK_VENDOR_ID_CODEPLAY,
        vk.VK_VENDOR_ID_MESA,
        vk.VK_VENDOR_ID_POCL,
        vk.VK_VENDOR_ID_MOBILEYE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDriverId(extensions: *const Extensions, item: *const vk.VkDriverId) bool {
    const min = @min(
        vk.VK_DRIVER_ID_AMD_PROPRIETARY,
        vk.VK_DRIVER_ID_AMD_OPEN_SOURCE,
        vk.VK_DRIVER_ID_MESA_RADV,
        vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY,
        vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
        vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
        vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
        vk.VK_DRIVER_ID_ARM_PROPRIETARY,
        vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
        vk.VK_DRIVER_ID_GGP_PROPRIETARY,
        vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_LLVMPIPE,
        vk.VK_DRIVER_ID_MOLTENVK,
        vk.VK_DRIVER_ID_COREAVI_PROPRIETARY,
        vk.VK_DRIVER_ID_JUICE_PROPRIETARY,
        vk.VK_DRIVER_ID_VERISILICON_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_TURNIP,
        vk.VK_DRIVER_ID_MESA_V3DV,
        vk.VK_DRIVER_ID_MESA_PANVK,
        vk.VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_VENUS,
        vk.VK_DRIVER_ID_MESA_DOZEN,
        vk.VK_DRIVER_ID_MESA_NVK,
        vk.VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_MESA_HONEYKRISP,
        vk.VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
    );
    const max = @max(
        vk.VK_DRIVER_ID_AMD_PROPRIETARY,
        vk.VK_DRIVER_ID_AMD_OPEN_SOURCE,
        vk.VK_DRIVER_ID_MESA_RADV,
        vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY,
        vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
        vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
        vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
        vk.VK_DRIVER_ID_ARM_PROPRIETARY,
        vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
        vk.VK_DRIVER_ID_GGP_PROPRIETARY,
        vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_LLVMPIPE,
        vk.VK_DRIVER_ID_MOLTENVK,
        vk.VK_DRIVER_ID_COREAVI_PROPRIETARY,
        vk.VK_DRIVER_ID_JUICE_PROPRIETARY,
        vk.VK_DRIVER_ID_VERISILICON_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_TURNIP,
        vk.VK_DRIVER_ID_MESA_V3DV,
        vk.VK_DRIVER_ID_MESA_PANVK,
        vk.VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
        vk.VK_DRIVER_ID_MESA_VENUS,
        vk.VK_DRIVER_ID_MESA_DOZEN,
        vk.VK_DRIVER_ID_MESA_NVK,
        vk.VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
        vk.VK_DRIVER_ID_MESA_HONEYKRISP,
        vk.VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_AMD_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_MESA_RADV_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_ARM_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_GGP_PROPRIETARY_KHR)
        return true;
    if (extensions.device.VK_KHR_driver_properties and item.* == vk.VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkConditionalRenderingFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkResolveModeFlagBits(extensions: *const Extensions, item: *const vk.VkResolveModeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_RESOLVE_MODE_NONE |
        vk.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT |
        vk.VK_RESOLVE_MODE_AVERAGE_BIT |
        vk.VK_RESOLVE_MODE_MIN_BIT |
        vk.VK_RESOLVE_MODE_MAX_BIT;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_NONE_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_AVERAGE_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_MIN_BIT_KHR;
    if (extensions.device.VK_KHR_depth_stencil_resolve)
        valid_bits |= vk.VK_RESOLVE_MODE_MAX_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkShadingRatePaletteEntryNV(extensions: *const Extensions, item: *const vk.VkShadingRatePaletteEntryNV) bool {
    const min = @min(
        vk.VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    );
    const max = @max(
        vk.VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkCoarseSampleOrderTypeNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleOrderTypeNV) bool {
    const min = @min(
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    );
    const max = @max(
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
        vk.VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkGeometryInstanceFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkGeometryInstanceFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkGeometryFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkGeometryFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_GEOMETRY_OPAQUE_BIT_KHR |
        vk.VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkBuildAccelerationStructureFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR |
        vk.VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch)
        valid_bits |= vk.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAccelerationStructureCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkCopyAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureModeKHR) bool {
    const min = @min(
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    );
    const max = @max(
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
        vk.VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBuildAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureModeKHR) bool {
    const min = @min(
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
    );
    const max = @max(
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
        vk.VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTypeKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
        vk.VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkGeometryTypeKHR(extensions: *const Extensions, item: *const vk.VkGeometryTypeKHR) bool {
    const min = @min(
        vk.VK_GEOMETRY_TYPE_TRIANGLES_KHR,
        vk.VK_GEOMETRY_TYPE_AABBS_KHR,
        vk.VK_GEOMETRY_TYPE_INSTANCES_KHR,
    );
    const max = @max(
        vk.VK_GEOMETRY_TYPE_TRIANGLES_KHR,
        vk.VK_GEOMETRY_TYPE_AABBS_KHR,
        vk.VK_GEOMETRY_TYPE_INSTANCES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureMemoryRequirementsTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMemoryRequirementsTypeNV) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
        vk.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureBuildTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildTypeKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkRayTracingShaderGroupTypeKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupTypeKHR) bool {
    const min = @min(
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
    );
    const max = @max(
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
        vk.VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCompatibilityKHR) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
        vk.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkShaderGroupShaderKHR(extensions: *const Extensions, item: *const vk.VkShaderGroupShaderKHR) bool {
    const min = @min(
        vk.VK_SHADER_GROUP_SHADER_GENERAL_KHR,
        vk.VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
    );
    const max = @max(
        vk.VK_SHADER_GROUP_SHADER_GENERAL_KHR,
        vk.VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
        vk.VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkMemoryOverallocationBehaviorAMD(extensions: *const Extensions, item: *const vk.VkMemoryOverallocationBehaviorAMD) bool {
    const min = @min(
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    );
    const max = @max(
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
        vk.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkFramebufferCreateFlagBits(extensions: *const Extensions, item: *const vk.VkFramebufferCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_imageless_framebuffer)
        valid_bits |= vk.VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkQueryPoolCreateFlagBits(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_maintenance9)
        valid_bits |= vk.VK_QUERY_POOL_CREATE_RESET_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceDiagnosticsConfigFlagBitsNV(extensions: *const Extensions, item: *const vk.VkDeviceDiagnosticsConfigFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV |
        vk.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCreationFeedbackFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT |
        vk.VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT |
        vk.VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT;
    if (extensions.device.VK_EXT_pipeline_creation_feedback)
        valid_bits |= vk.VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkFullScreenExclusiveEXT) bool {
    const min = @min(
        vk.VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
    );
    const max = @max(
        vk.VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
        vk.VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceCounterScopeKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterScopeKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_QUERY_SCOPE_RENDER_PASS_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
        vk.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
        vk.VK_QUERY_SCOPE_RENDER_PASS_KHR,
        vk.VK_QUERY_SCOPE_COMMAND_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkMemoryDecompressionMethodFlagBitsNV(extensions: *const Extensions, item: *const vk.VkMemoryDecompressionMethodFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPerformanceCounterUnitKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterUnitKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
        vk.VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceCounterStorageKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterStorageKHR) bool {
    const min = @min(
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
    );
    const max = @max(
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
        vk.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPerformanceCounterDescriptionFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR |
        vk.VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkAcquireProfilingLockFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkShaderCorePropertiesFlagBitsAMD(extensions: *const Extensions, item: *const vk.VkShaderCorePropertiesFlagBitsAMD) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkRefreshObjectFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPerformanceConfigurationTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationTypeINTEL) bool {
    const min = vk.VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
    const max = vk.VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkQueryPoolSamplingModeINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolSamplingModeINTEL) bool {
    const min = vk.VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
    const max = vk.VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceOverrideTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
        vk.VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceParameterTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceParameterTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
        vk.VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
        vk.VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPerformanceValueTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueTypeINTEL) bool {
    const min = @min(
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
    );
    const max = @max(
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
        vk.VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkShaderFloatControlsIndependence(extensions: *const Extensions, item: *const vk.VkShaderFloatControlsIndependence) bool {
    const min = @min(
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
    );
    const max = @max(
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
        vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_float_controls and item.* == vk.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR)
        return true;
    return false;
}

pub fn check_enum_VkPipelineExecutableStatisticFormatKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticFormatKHR) bool {
    const min = @min(
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
    );
    const max = @max(
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
        vk.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLineRasterizationMode(extensions: *const Extensions, item: *const vk.VkLineRasterizationMode) bool {
    const min = @min(
        vk.VK_LINE_RASTERIZATION_MODE_DEFAULT,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
        vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
    );
    const max = @max(
        vk.VK_LINE_RASTERIZATION_MODE_DEFAULT,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
        vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM,
        vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT)
        return true;
    if (extensions.device.VK_EXT_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR)
        return true;
    if (extensions.device.VK_KHR_line_rasterization and item.* == vk.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkShaderModuleCreateFlagBits(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateFlagBits) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineCompilerControlFlagBitsAMD(extensions: *const Extensions, item: *const vk.VkPipelineCompilerControlFlagBitsAMD) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkFaultLevel(extensions: *const Extensions, item: *const vk.VkFaultLevel) bool {
    const min = @min(
        vk.VK_FAULT_LEVEL_UNASSIGNED,
        vk.VK_FAULT_LEVEL_CRITICAL,
        vk.VK_FAULT_LEVEL_RECOVERABLE,
        vk.VK_FAULT_LEVEL_WARNING,
    );
    const max = @max(
        vk.VK_FAULT_LEVEL_UNASSIGNED,
        vk.VK_FAULT_LEVEL_CRITICAL,
        vk.VK_FAULT_LEVEL_RECOVERABLE,
        vk.VK_FAULT_LEVEL_WARNING,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFaultType(extensions: *const Extensions, item: *const vk.VkFaultType) bool {
    const min = @min(
        vk.VK_FAULT_TYPE_INVALID,
        vk.VK_FAULT_TYPE_UNASSIGNED,
        vk.VK_FAULT_TYPE_IMPLEMENTATION,
        vk.VK_FAULT_TYPE_SYSTEM,
        vk.VK_FAULT_TYPE_PHYSICAL_DEVICE,
        vk.VK_FAULT_TYPE_COMMAND_BUFFER_FULL,
        vk.VK_FAULT_TYPE_INVALID_API_USAGE,
    );
    const max = @max(
        vk.VK_FAULT_TYPE_INVALID,
        vk.VK_FAULT_TYPE_UNASSIGNED,
        vk.VK_FAULT_TYPE_IMPLEMENTATION,
        vk.VK_FAULT_TYPE_SYSTEM,
        vk.VK_FAULT_TYPE_PHYSICAL_DEVICE,
        vk.VK_FAULT_TYPE_COMMAND_BUFFER_FULL,
        vk.VK_FAULT_TYPE_INVALID_API_USAGE,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFaultQueryBehavior(extensions: *const Extensions, item: *const vk.VkFaultQueryBehavior) bool {
    const min = vk.VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS;
    const max = vk.VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkToolPurposeFlagBits(extensions: *const Extensions, item: *const vk.VkToolPurposeFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_TOOL_PURPOSE_VALIDATION_BIT |
        vk.VK_TOOL_PURPOSE_PROFILING_BIT |
        vk.VK_TOOL_PURPOSE_TRACING_BIT |
        vk.VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT |
        vk.VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_VALIDATION_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_PROFILING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_TRACING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT;
    if (extensions.device.VK_EXT_tooling_info)
        valid_bits |= vk.VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPipelineMatchControl(extensions: *const Extensions, item: *const vk.VkPipelineMatchControl) bool {
    const min = vk.VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH;
    const max = vk.VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFragmentShadingRateCombinerOpKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateCombinerOpKHR) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
        vk.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFragmentShadingRateNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateNV) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
        vk.VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
        vk.VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkFragmentShadingRateTypeNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateTypeNV) bool {
    const min = @min(
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
    );
    const max = @max(
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
        vk.VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSubpassMergeStatusEXT(extensions: *const Extensions, item: *const vk.VkSubpassMergeStatusEXT) bool {
    const min = @min(
        vk.VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
    );
    const max = @max(
        vk.VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
        vk.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkAccessFlagBits2(extensions: *const Extensions, item: *const vk.VkAccessFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_ACCESS_2_NONE |
        vk.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT |
        vk.VK_ACCESS_2_INDEX_READ_BIT |
        vk.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT |
        vk.VK_ACCESS_2_UNIFORM_READ_BIT |
        vk.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_SHADER_READ_BIT |
        vk.VK_ACCESS_2_SHADER_WRITE_BIT |
        vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
        vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT |
        vk.VK_ACCESS_2_TRANSFER_READ_BIT |
        vk.VK_ACCESS_2_TRANSFER_WRITE_BIT |
        vk.VK_ACCESS_2_HOST_READ_BIT |
        vk.VK_ACCESS_2_HOST_WRITE_BIT |
        vk.VK_ACCESS_2_MEMORY_READ_BIT |
        vk.VK_ACCESS_2_MEMORY_WRITE_BIT |
        vk.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT |
        vk.VK_ACCESS_2_SHADER_STORAGE_READ_BIT |
        vk.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM;
    if (extensions.device.VK_QCOM_tile_shading)
        valid_bits |= vk.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_NONE_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INDEX_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_UNIFORM_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFER_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_HOST_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_HOST_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_MEMORY_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_MEMORY_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    if (extensions.device.VK_EXT_descriptor_buffer)
        valid_bits |= vk.VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1)
        valid_bits |= vk.VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_ACCESS_2_MICROMAP_READ_BIT_EXT;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineStageFlagBits2(extensions: *const Extensions, item: *const vk.VkPipelineStageFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_PIPELINE_STAGE_2_NONE |
        vk.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT |
        vk.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_2_TRANSFER_BIT |
        vk.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT |
        vk.VK_PIPELINE_STAGE_2_HOST_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT |
        vk.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT |
        vk.VK_PIPELINE_STAGE_2_COPY_BIT |
        vk.VK_PIPELINE_STAGE_2_RESOLVE_BIT |
        vk.VK_PIPELINE_STAGE_2_BLIT_BIT |
        vk.VK_PIPELINE_STAGE_2_CLEAR_BIT |
        vk.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT |
        vk.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_NONE_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_HOST_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COPY_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_BLIT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
    if (extensions.device.VK_EXT_opacity_micromap)
        valid_bits |= vk.VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkSubmitFlagBits(extensions: *const Extensions, item: *const vk.VkSubmitFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SUBMIT_PROTECTED_BIT;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_SUBMIT_PROTECTED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkEventCreateFlagBits(extensions: *const Extensions, item: *const vk.VkEventCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_synchronization2)
        valid_bits |= vk.VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineLayoutCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_graphics_pipeline_library)
        valid_bits |= vk.VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkSciSyncClientTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncClientTypeNV) bool {
    const min = @min(
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV,
    );
    const max = @max(
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV,
        vk.VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkSciSyncPrimitiveTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncPrimitiveTypeNV) bool {
    const min = @min(
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV,
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV,
    );
    const max = @max(
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV,
        vk.VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkProvokingVertexModeEXT(extensions: *const Extensions, item: *const vk.VkProvokingVertexModeEXT) bool {
    const min = @min(
        vk.VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
        vk.VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
    );
    const max = @max(
        vk.VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
        vk.VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPipelineCacheValidationVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheValidationVersion) bool {
    const min = vk.VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE;
    const max = vk.VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkAccelerationStructureMotionInstanceTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInstanceTypeNV) bool {
    const min = @min(
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
    );
    const max = @max(
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
        vk.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPipelineColorBlendStateCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPipelineDepthStencilStateCreateFlagBits(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access)
        valid_bits |= vk.VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkGraphicsPipelineLibraryFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT |
        vk.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkDeviceAddressBindingFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDeviceAddressBindingTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
        vk.VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkFrameBoundaryFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPresentScalingFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPresentScalingFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR |
        vk.VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT |
        vk.VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR |
        vk.VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT |
        vk.VK_PRESENT_SCALING_STRETCH_BIT_KHR |
        vk.VK_PRESENT_SCALING_STRETCH_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPresentGravityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkPresentGravityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PRESENT_GRAVITY_MIN_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_MIN_BIT_EXT |
        vk.VK_PRESENT_GRAVITY_MAX_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_MAX_BIT_EXT |
        vk.VK_PRESENT_GRAVITY_CENTERED_BIT_KHR |
        vk.VK_PRESENT_GRAVITY_CENTERED_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkPhysicalDeviceSchedulingControlsFlagBitsARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoCodecOperationFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodecOperationFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_CODEC_OPERATION_NONE_KHR;
    if (extensions.device.VK_KHR_video_encode_h264)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_h265)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_h264)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_h265)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_av1)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_av1)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_vp9)
        valid_bits |= vk.VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoChromaSubsamplingFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoChromaSubsamplingFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR |
        vk.VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoComponentBitDepthFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoComponentBitDepthFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR |
        vk.VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR |
        vk.VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoSessionCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR;
    if (extensions.device.VK_KHR_video_maintenance1)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_maintenance2)
        valid_bits |= vk.VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoSessionParametersCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoDecodeH264PictureLayoutFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureLayoutFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR |
        vk.VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoCodingControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkQueryResultStatusKHR(extensions: *const Extensions, item: *const vk.VkQueryResultStatusKHR) bool {
    const min = @min(
        vk.VK_QUERY_RESULT_STATUS_ERROR_KHR,
        vk.VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
        vk.VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
    );
    const max = @max(
        vk.VK_QUERY_RESULT_STATUS_ERROR_KHR,
        vk.VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
        vk.VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == vk.VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR)
        return true;
    return false;
}

pub fn check_bitmask_VkVideoDecodeUsageFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_USAGE_DEFAULT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR |
        vk.VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoDecodeCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilityFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR |
        vk.VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFlagBitsKHR) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeUsageFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR |
        vk.VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeContentFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeContentFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkVideoEncodeTuningModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeTuningModeKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
        vk.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkVideoEncodeCapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR |
        vk.VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeFeedbackFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFeedbackFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR |
        vk.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeRateControlModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR |
        vk.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeIntraRefreshModeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshModeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH264CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH264StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH264RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkHostImageCopyFlagBits(extensions: *const Extensions, item: *const vk.VkHostImageCopyFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_HOST_IMAGE_COPY_MEMCPY_BIT |
        vk.VK_HOST_IMAGE_COPY_MEMCPY;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_HOST_IMAGE_COPY_MEMCPY_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPartitionedAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureOpTypeNV) bool {
    const min = @min(
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
    );
    const max = @max(
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkPartitionedAccelerationStructureInstanceFlagBitsNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureInstanceFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV |
        vk.VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageFormatConstraintsFlagBitsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsFlagBitsFUCHSIA) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageConstraintsInfoFlagBitsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFlagBitsFUCHSIA) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA |
        vk.VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkFormatFeatureFlagBits2(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlagBits2) bool {
    var valid_bits: u64 = 0 |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT |
        vk.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT |
        vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT |
        vk.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT |
        vk.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT |
        vk.VK_FORMAT_FEATURE_2_BLIT_DST_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT |
        vk.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT |
        vk.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT |
        vk.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT |
        vk.VK_FORMAT_FEATURE_2_DISJOINT_BIT |
        vk.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT |
        vk.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT |
        vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_decode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_acceleration_structure)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_EXT_fragment_density_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT;
    if (extensions.device.VK_KHR_fragment_shading_rate)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_EXT_host_image_copy)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_queue)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR;
    if (extensions.device.VK_KHR_format_feature_flags2)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM;
    if (extensions.device.VK_QCOM_image_processing)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkRenderingFlagBits(extensions: *const Extensions, item: *const vk.VkRenderingFlagBits) bool {
    var valid_bits: u32 = 0 |
        vk.VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT |
        vk.VK_RENDERING_SUSPENDING_BIT |
        vk.VK_RENDERING_RESUMING_BIT;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_SUSPENDING_BIT_KHR;
    if (extensions.device.VK_KHR_dynamic_rendering)
        valid_bits |= vk.VK_RENDERING_RESUMING_BIT_KHR;
    if (extensions.device.VK_EXT_nested_command_buffer)
        valid_bits |= vk.VK_RENDERING_CONTENTS_INLINE_BIT_EXT;
    if (extensions.device.VK_EXT_legacy_dithering)
        valid_bits |= vk.VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT;
    if (extensions.device.VK_KHR_maintenance7)
        valid_bits |= vk.VK_RENDERING_CONTENTS_INLINE_BIT_KHR;
    if (extensions.device.VK_VALVE_fragment_density_map_layered)
        valid_bits |= vk.VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_quantization_map)
        valid_bits |= vk.VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265CtbSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CtbSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR |
        vk.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1CapabilityFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilityFlagBitsKHR) bool {
    var valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR;
    if (extensions.device.VK_KHR_video_encode_intra_refresh)
        valid_bits |= vk.VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1StdFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1StdFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1RateControlFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR |
        vk.VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkVideoEncodeAV1PredictionModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PredictionModeKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR,
        vk.VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkVideoEncodeAV1RateControlGroupKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlGroupKHR) bool {
    const min = @min(
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    );
    const max = @max(
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
        vk.VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkExportMetalObjectTypeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectTypeFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT |
        vk.VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkInstanceCreateFlagBits(extensions: *const Extensions, item: *const vk.VkInstanceCreateFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.instance.VK_KHR_portability_enumeration)
        valid_bits |= vk.VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageCompressionFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_COMPRESSION_DEFAULT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT |
        vk.VK_IMAGE_COMPRESSION_DISABLED_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkImageCompressionFixedRateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFixedRateFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT |
        vk.VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPipelineRobustnessBufferBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessBufferBehavior) bool {
    const min = @min(
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
    );
    const max = @max(
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT)
        return true;
    return false;
}

pub fn check_enum_VkPipelineRobustnessImageBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessImageBehavior) bool {
    const min = @min(
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
    );
    const max = @max(
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
        vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_robustness and item.* == vk.VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT)
        return true;
    return false;
}

pub fn check_bitmask_VkOpticalFlowGridSizeFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowGridSizeFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV |
        vk.VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkOpticalFlowUsageFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowUsageFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV |
        vk.VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_COST_BIT_NV |
        vk.VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkOpticalFlowPerformanceLevelNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowPerformanceLevelNV) bool {
    const min = @min(
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
    );
    const max = @max(
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
        vk.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOpticalFlowSessionBindingPointNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionBindingPointNV) bool {
    const min = @min(
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
    );
    const max = @max(
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
        vk.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkOpticalFlowSessionCreateFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreateFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV |
        vk.VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkOpticalFlowExecuteFlagBitsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowExecuteFlagBitsNV) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkMicromapTypeEXT(extensions: *const Extensions, item: *const vk.VkMicromapTypeEXT) bool {
    const min = vk.VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT;
    const max = vk.VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkBuildMicromapFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT |
        vk.VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT |
        vk.VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkMicromapCreateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkCopyMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapModeEXT) bool {
    const min = @min(
        vk.VK_COPY_MICROMAP_MODE_CLONE_EXT,
        vk.VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_COMPACT_EXT,
    );
    const max = @max(
        vk.VK_COPY_MICROMAP_MODE_CLONE_EXT,
        vk.VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
        vk.VK_COPY_MICROMAP_MODE_COMPACT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBuildMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapModeEXT) bool {
    const min = vk.VK_BUILD_MICROMAP_MODE_BUILD_EXT;
    const max = vk.VK_BUILD_MICROMAP_MODE_BUILD_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOpacityMicromapFormatEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapFormatEXT) bool {
    const min = @min(
        vk.VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
        vk.VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
    );
    const max = @max(
        vk.VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
        vk.VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOpacityMicromapSpecialIndexEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapSpecialIndexEXT) bool {
    const min = @min(
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
    );
    const max = @max(
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
        vk.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDepthBiasRepresentationEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationEXT) bool {
    const min = @min(
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
    );
    const max = @max(
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
        vk.VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDeviceFaultAddressTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressTypeEXT) bool {
    const min = @min(
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
    );
    const max = @max(
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
        vk.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDeviceFaultVendorBinaryHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionEXT) bool {
    const min = vk.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT;
    const max = vk.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkIndirectCommandsLayoutUsageFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT |
        vk.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkIndirectExecutionSetInfoTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetInfoTypeEXT) bool {
    const min = @min(
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
    );
    const max = @max(
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
        vk.VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkIndirectCommandsInputModeFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsInputModeFlagBitsEXT) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT |
        vk.VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkIndirectCommandsTokenTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeEXT) bool {
    const min = @min(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    );
    const max = @max(
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
        vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == vk.VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT)
        return true;
    return false;
}

pub fn check_enum_VkDisplacementMicromapFormatNV(extensions: *const Extensions, item: *const vk.VkDisplacementMicromapFormatNV) bool {
    const min = @min(
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV,
    );
    const max = @max(
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV,
        vk.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkShaderCreateFlagBitsEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateFlagBitsEXT) bool {
    var valid_bits: u32 = 0 |
        vk.VK_SHADER_CREATE_LINK_STAGE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_shader_object)
        valid_bits |= vk.VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    if (extensions.device.VK_EXT_device_generated_commands)
        valid_bits |= vk.VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkShaderCodeTypeEXT(extensions: *const Extensions, item: *const vk.VkShaderCodeTypeEXT) bool {
    const min = @min(
        vk.VK_SHADER_CODE_TYPE_BINARY_EXT,
        vk.VK_SHADER_CODE_TYPE_SPIRV_EXT,
    );
    const max = @max(
        vk.VK_SHADER_CODE_TYPE_BINARY_EXT,
        vk.VK_SHADER_CODE_TYPE_SPIRV_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkScopeKHR(extensions: *const Extensions, item: *const vk.VkScopeKHR) bool {
    const min = @min(
        vk.VK_SCOPE_DEVICE_KHR,
        vk.VK_SCOPE_WORKGROUP_KHR,
        vk.VK_SCOPE_SUBGROUP_KHR,
        vk.VK_SCOPE_QUEUE_FAMILY_KHR,
    );
    const max = @max(
        vk.VK_SCOPE_DEVICE_KHR,
        vk.VK_SCOPE_WORKGROUP_KHR,
        vk.VK_SCOPE_SUBGROUP_KHR,
        vk.VK_SCOPE_QUEUE_FAMILY_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkComponentTypeKHR(extensions: *const Extensions, item: *const vk.VkComponentTypeKHR) bool {
    const min = @min(
        vk.VK_COMPONENT_TYPE_FLOAT16_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT32_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT64_KHR,
        vk.VK_COMPONENT_TYPE_SINT8_KHR,
        vk.VK_COMPONENT_TYPE_SINT16_KHR,
        vk.VK_COMPONENT_TYPE_SINT32_KHR,
        vk.VK_COMPONENT_TYPE_SINT64_KHR,
        vk.VK_COMPONENT_TYPE_UINT8_KHR,
        vk.VK_COMPONENT_TYPE_UINT16_KHR,
        vk.VK_COMPONENT_TYPE_UINT32_KHR,
        vk.VK_COMPONENT_TYPE_UINT64_KHR,
    );
    const max = @max(
        vk.VK_COMPONENT_TYPE_FLOAT16_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT32_KHR,
        vk.VK_COMPONENT_TYPE_FLOAT64_KHR,
        vk.VK_COMPONENT_TYPE_SINT8_KHR,
        vk.VK_COMPONENT_TYPE_SINT16_KHR,
        vk.VK_COMPONENT_TYPE_SINT32_KHR,
        vk.VK_COMPONENT_TYPE_SINT64_KHR,
        vk.VK_COMPONENT_TYPE_UINT8_KHR,
        vk.VK_COMPONENT_TYPE_UINT16_KHR,
        vk.VK_COMPONENT_TYPE_UINT32_KHR,
        vk.VK_COMPONENT_TYPE_UINT64_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == vk.VK_COMPONENT_TYPE_BFLOAT16_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == vk.VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT)
        return true;
    return false;
}

pub fn check_enum_VkCubicFilterWeightsQCOM(extensions: *const Extensions, item: *const vk.VkCubicFilterWeightsQCOM) bool {
    const min = @min(
        vk.VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
    );
    const max = @max(
        vk.VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
        vk.VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkBlockMatchWindowCompareModeQCOM(extensions: *const Extensions, item: *const vk.VkBlockMatchWindowCompareModeQCOM) bool {
    const min = @min(
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
    );
    const max = @max(
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
        vk.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPhysicalDeviceLayeredApiKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiKHR) bool {
    const min = @min(
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
    );
    const max = @max(
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
        vk.VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLayeredDriverUnderlyingApiMSFT(extensions: *const Extensions, item: *const vk.VkLayeredDriverUnderlyingApiMSFT) bool {
    const min = @min(
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
    );
    const max = @max(
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
        vk.VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkLatencyMarkerNV(extensions: *const Extensions, item: *const vk.VkLatencyMarkerNV) bool {
    const min = @min(
        vk.VK_LATENCY_MARKER_SIMULATION_START_NV,
        vk.VK_LATENCY_MARKER_SIMULATION_END_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_PRESENT_END_NV,
        vk.VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
        vk.VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
    );
    const max = @max(
        vk.VK_LATENCY_MARKER_SIMULATION_START_NV,
        vk.VK_LATENCY_MARKER_SIMULATION_END_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_PRESENT_END_NV,
        vk.VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
        vk.VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
        vk.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkOutOfBandQueueTypeNV(extensions: *const Extensions, item: *const vk.VkOutOfBandQueueTypeNV) bool {
    const min = @min(
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
    );
    const max = @max(
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
        vk.VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkMemoryUnmapFlagBits(extensions: *const Extensions, item: *const vk.VkMemoryUnmapFlagBits) bool {
    var valid_bits: u32 = 0;
    if (extensions.device.VK_EXT_map_memory_placed)
        valid_bits |= vk.VK_MEMORY_UNMAP_RESERVE_BIT_EXT;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkWaylandSurfaceCreateFlagBitsKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateFlagBitsKHR) bool {
    _ = extensions;
    const valid_bits: u32 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDepthClampModeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampModeEXT) bool {
    const min = @min(
        vk.VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
        vk.VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
    );
    const max = @max(
        vk.VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
        vk.VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkAccessFlagBits3KHR(extensions: *const Extensions, item: *const vk.VkAccessFlagBits3KHR) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_ACCESS_3_NONE_KHR;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkTileShadingRenderPassFlagBitsQCOM(extensions: *const Extensions, item: *const vk.VkTileShadingRenderPassFlagBitsQCOM) bool {
    _ = extensions;
    const valid_bits: u32 = 0 |
        vk.VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM |
        vk.VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkCooperativeVectorMatrixLayoutNV(extensions: *const Extensions, item: *const vk.VkCooperativeVectorMatrixLayoutNV) bool {
    const min = @min(
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
    );
    const max = @max(
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
        vk.VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkTensorCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM |
        vk.VK_TENSOR_CREATE_PROTECTED_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_bitmask_VkTensorUsageFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorUsageFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_TENSOR_USAGE_SHADER_BIT_ARM |
        vk.VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM |
        vk.VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM |
        vk.VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkTensorTilingARM(extensions: *const Extensions, item: *const vk.VkTensorTilingARM) bool {
    const min = @min(
        vk.VK_TENSOR_TILING_OPTIMAL_ARM,
        vk.VK_TENSOR_TILING_LINEAR_ARM,
    );
    const max = @max(
        vk.VK_TENSOR_TILING_OPTIMAL_ARM,
        vk.VK_TENSOR_TILING_LINEAR_ARM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkTensorViewCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkTensorViewCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDefaultVertexAttributeValueKHR(extensions: *const Extensions, item: *const vk.VkDefaultVertexAttributeValueKHR) bool {
    const min = @min(
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR,
    );
    const max = @max(
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
        vk.VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkDataGraphPipelineSessionCreateFlagBitsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionCreateFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0 |
        vk.VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkDataGraphPipelineSessionBindPointARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointARM) bool {
    const min = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM;
    const max = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDataGraphPipelineSessionBindPointTypeARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointTypeARM) bool {
    const min = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM;
    const max = vk.VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkDataGraphPipelinePropertyARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelinePropertyARM) bool {
    const min = @min(
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM,
    );
    const max = @max(
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
        vk.VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM,
    );
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_bitmask_VkDataGraphPipelineDispatchFlagBitsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineDispatchFlagBitsARM) bool {
    _ = extensions;
    const valid_bits: u64 = 0;
    return (item.* & ~valid_bits) == 0;
}

pub fn check_enum_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphProcessingEngineTypeARM) bool {
    const min = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM;
    const max = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}

pub fn check_enum_VkPhysicalDeviceDataGraphOperationTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphOperationTypeARM) bool {
    const min = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM;
    const max = vk.VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM;
    if (min <= item.* and item.* <= max)
        return true;
    _ = extensions;
    return false;
}
