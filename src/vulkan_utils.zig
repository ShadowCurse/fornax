// Copyright (c) 2025 Egor Lazarchuk
// SPDX-License-Identifier: MIT
//
// This file is auto generated by gen/vulkan_utils_gen.zig

const std = @import("std");
const vk = @import("volk");
const log = @import("log.zig");

const Allocator = std.mem.Allocator;
pub fn struct_size(@"struct": anytype) usize {
    var size: usize = 0;
    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    const fields = @typeInfo(t).@"struct".fields;
    inline for (fields) |field| {
        switch (field.type) {
            [*c]const u8 => {},
            [*c]const u32 => {
                if (@hasField(t, "codeSize"))
                    size += @field(@"struct", "codeSize");
            },
            [*c]const vk.VkDescriptorSetLayoutBinding => {
                const len = @field(@"struct", "bindingCount");
                size += @sizeOf(vk.VkDescriptorSetLayoutBinding) * len;
                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkDescriptorSetLayout => {
                const len = if (@hasField(t, "descriptorSetCount"))
                    @field(@"struct", "descriptorSetCount")
                else if (@hasField(t, "setLayoutCount"))
                    @field(@"struct", "setLayoutCount");
                size += @sizeOf(*anyopaque) * len;
            },
            [*c]const vk.VkPushConstantRange => {
                const len = @field(@"struct", "pushConstantRangeCount");
                size += @sizeOf(vk.VkPushConstantRange) * len;
                var elements: []const vk.VkPushConstantRange = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkAttachmentDescription => {
                const len = @field(@"struct", "attachmentCount");
                size += @sizeOf(vk.VkAttachmentDescription) * len;
                var elements: []const vk.VkAttachmentDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkSubpassDescription => {
                const len = @field(@"struct", "subpassCount");
                size += @sizeOf(vk.VkSubpassDescription) * len;
                var elements: []const vk.VkSubpassDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkAttachmentReference => {
                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
                    @field(@"struct", "inputAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
                    @field(@"struct", "colorAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
                    if (@field(@"struct", field.name) != null)
                        break :blk @field(@"struct", "colorAttachmentCount")
                    else
                        break :blk 0;
                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
                    @intFromBool(@field(@"struct", field.name) != null)
                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
                    @field(@"struct", "preserveAttachmentCount")
                else
                    @panic("Cannot find length for the VkAttachmentReference array");

                if (len != 0) {
                    size += @sizeOf(vk.VkAttachmentReference) * len;
                    var elements: []const vk.VkAttachmentReference = undefined;
                    elements.ptr = @field(@"struct", field.name);
                    elements.len = len;
                    for (elements) |*binding| size += struct_size(binding);
                }
            },
            [*c]const vk.VkSubpassDependency => {
                const len = @field(@"struct", "dependencyCount");
                size += @sizeOf(vk.VkSubpassDependency) * len;
                var elements: []const vk.VkSubpassDependency = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkPipelineShaderStageCreateInfo => {
                const len = @field(@"struct", "stageCount");
                size += @sizeOf(vk.VkPipelineShaderStageCreateInfo) * len;
                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkSpecializationMapEntry => {
                const len = @field(@"struct", "mapEntryCount");
                size += @sizeOf(vk.VkSpecializationMapEntry) * len;
                var elements: []const vk.VkSpecializationMapEntry = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding| size += struct_size(binding);
            },
            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
            [*c]const vk.VkPipelineTessellationStateCreateInfo,
            [*c]const vk.VkPipelineViewportStateCreateInfo,
            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
            [*c]const vk.VkPipelineDynamicStateCreateInfo,
            [*c]const vk.VkSpecializationInfo,
            [*c]const vk.VkViewport,
            [*c]const vk.VkRect2D,
            => {
                const element_type = @typeInfo(field.type).pointer.child;
                const element: ?*const element_type = @field(@"struct", field.name);
                if (element) |e| size += struct_size(e);
            },
            else => size += @sizeOf(field.type),
        }
    }
    return size;
}

pub fn print_struct(@"struct": anytype) void {
    print_struct_inner("", @"struct", 0);
}

fn print_offset_output(offset: u32, comptime format: []const u8, args: anytype) void {
    for (0..offset) |_| log.output("    ", .{});
    log.output(format, args);
}

fn print_offset_struct(offset: u32, field_name: []const u8, @"struct": anytype) void {
    for (0..offset) |_| log.output("    ", .{});
    print_struct_inner(
        field_name,
        @"struct",
        offset,
    );
}

fn print_offset_slice(
    offset: u32,
    field_name: []const u8,
    type_name: []const u8,
    comptime T: type,
    elements: []const T,
) void {
    print_offset_output(offset, "{s}: []{s} = [\n", .{ field_name, type_name });
    defer print_offset_output(offset, "]\n", .{});
    for (elements) |*binding| {
        for (0..offset + 1) |_| log.output("    ", .{});
        print_struct_inner(&.{}, binding, offset + 1);
    }
}

fn print_struct_inner(name: []const u8, @"struct": anytype, base_offset: u32) void {
    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    const type_name = @typeName(t)["cimport.struct_".len..];
    log.output("{s}: {s} = .{{\n", .{ name, type_name });
    const fields = @typeInfo(t).@"struct".fields;
    const fields_base_offset = base_offset + 1;
    inline for (fields) |field| {
        switch (field.type) {
            i16, i32, u32, u64, usize, vk.VkStructureType => {
                print_offset_output(fields_base_offset, "{s}: {s} = {d},\n", .{
                    field.name,
                    @typeName(field.type),
                    @field(@"struct", field.name),
                });
            },
            f32, f64 => {
                print_offset_output(
                    fields_base_offset,
                    "{s}: {d},\n",
                    .{ field.name, @field(@"struct", field.name) },
                );
            },
            vk.VkOffset2D,
            vk.VkExtent2D,
            vk.VkOffset3D,
            vk.VkExtent3D,
            vk.VkPhysicalDeviceFeatures,
            => print_offset_struct(
                fields_base_offset,
                field.name,
                &@field(@"struct", field.name),
            ),
            ?*anyopaque,
            ?*const anyopaque,
            vk.VkBuffer,
            vk.VkImage,
            vk.VkInstance,
            vk.VkPhysicalDevice,
            vk.VkDevice,
            vk.VkQueue,
            vk.VkSemaphore,
            vk.VkCommandBuffer,
            vk.VkFence,
            vk.VkDeviceMemory,
            vk.VkEvent,
            vk.VkQueryPool,
            vk.VkBufferView,
            vk.VkImageView,
            vk.VkShaderModule,
            vk.VkPipelineCache,
            vk.VkPipelineLayout,
            vk.VkPipeline,
            vk.VkRenderPass,
            vk.VkDescriptorSetLayout,
            vk.VkSampler,
            vk.VkDescriptorSet,
            vk.VkDescriptorPool,
            vk.VkFramebuffer,
            vk.VkCommandPool,
            => print_offset_output(
                fields_base_offset,
                "{s}: {?},\n",
                .{ field.name, @field(@"struct", field.name) },
            ),
            [*c]const u8 => print_offset_output(
                fields_base_offset,
                "{s}: {s},\n",
                .{ field.name, @field(@"struct", field.name) },
            ),
            [*c]const u32 => {
                if (@hasField(t, "codeSize")) {
                    const len = @field(@"struct", "codeSize") / @sizeOf(u32);
                    print_offset_output(
                        fields_base_offset,
                        "{s}: {d} instructions,\n",
                        .{ field.name, len },
                    );
                }
            },
            [*c]const vk.VkDescriptorSetLayoutBinding => {
                const len = @field(@"struct", "bindingCount");
                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkDescriptorSetLayoutBinding,
                    elements,
                );
            },
            [*c]const vk.VkDescriptorSetLayout => {
                const len = if (@hasField(t, "descriptorSetCount"))
                    @field(@"struct", "descriptorSetCount")
                else if (@hasField(t, "setLayoutCount"))
                    @field(@"struct", "setLayoutCount");
                var elements: []const *anyopaque = undefined;
                elements.ptr = @ptrCast(@field(@"struct", field.name));
                elements.len = len;
                print_offset_output(
                    fields_base_offset,
                    "{s}: {any},\n",
                    .{ field.name, elements },
                );
            },
            [*c]const vk.VkPushConstantRange => {
                const len = @field(@"struct", "pushConstantRangeCount");
                var elements: []const vk.VkPushConstantRange = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkPushConstantRange,
                    elements,
                );
            },
            [*c]const vk.VkAttachmentDescription => {
                const len = @field(@"struct", "attachmentCount");
                var elements: []const vk.VkAttachmentDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkAttachmentDescription,
                    elements,
                );
            },
            [*c]const vk.VkSubpassDescription => {
                const len = @field(@"struct", "subpassCount");
                var elements: []const vk.VkSubpassDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSubpassDescription,
                    elements,
                );
            },
            [*c]const vk.VkAttachmentReference => {
                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
                    @field(@"struct", "inputAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
                    @field(@"struct", "colorAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
                    if (@field(@"struct", field.name) != null)
                        break :blk @field(@"struct", "colorAttachmentCount")
                    else
                        break :blk 0;
                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
                    @intFromBool(@field(@"struct", field.name) != null)
                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
                    @field(@"struct", "preserveAttachmentCount")
                else
                    @panic("Cannot find length for the VkAttachmentReference array");

                if (len != 0) {
                    var elements: []const vk.VkAttachmentReference = undefined;
                    elements.ptr = @field(@"struct", field.name);
                    elements.len = len;
                    print_offset_slice(
                        fields_base_offset,
                        field.name,
                        type_name,
                        vk.VkAttachmentReference,
                        elements,
                    );
                }
            },
            [*c]const vk.VkSubpassDependency => {
                const len = @field(@"struct", "dependencyCount");
                var elements: []const vk.VkSubpassDependency = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSubpassDependency,
                    elements,
                );
            },
            [*c]const vk.VkPipelineShaderStageCreateInfo => {
                const len = @field(@"struct", "stageCount");
                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkPipelineShaderStageCreateInfo,
                    elements,
                );
            },
            [*c]const vk.VkSpecializationMapEntry => {
                const len = @field(@"struct", "mapEntryCount");
                var elements: []const vk.VkSpecializationMapEntry = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                print_offset_slice(
                    fields_base_offset,
                    field.name,
                    type_name,
                    vk.VkSpecializationMapEntry,
                    elements,
                );
            },
            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
            [*c]const vk.VkPipelineTessellationStateCreateInfo,
            [*c]const vk.VkPipelineViewportStateCreateInfo,
            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
            [*c]const vk.VkPipelineDynamicStateCreateInfo,
            [*c]const vk.VkSpecializationInfo,
            [*c]const vk.VkViewport,
            [*c]const vk.VkRect2D,
            => {
                const element_type = @typeInfo(field.type).pointer.child;
                const element: ?*const element_type = @field(@"struct", field.name);
                if (element) |e|
                    print_offset_struct(fields_base_offset, field.name, e)
                else
                    print_offset_output(
                        fields_base_offset,
                        "{s}: {?},\n",
                        .{ field.name, element },
                    );
            },
            else => log.warn(
                @src(),
                "Cannot format field {s} of type {s}",
                .{ field.name, @typeName(field.type) },
            ),
        }
    }
    for (0..base_offset) |_|
        log.output("    ", .{});
    log.output("}},\n", .{});
}

pub fn print_chain(chain: anytype) void {
    var current: ?*const anyopaque = chain;
    while (current) |c| {
        const base_struct: *const vk.VkBaseInStructure = @ptrCast(@alignCast(c));
        switch (base_struct.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_INFO => {
                const nn: *const vk.VkApplicationInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO => {
                const nn: *const vk.VkInstanceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO => {
                const nn: *const vk.VkSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE => {
                const nn: *const vk.VkMappedMemoryRange = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO => {
                const nn: *const vk.VkBindSparseInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO => {
                const nn: *const vk.VkFenceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO => {
                const nn: *const vk.VkEventCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO => {
                const nn: *const vk.VkQueryPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkBufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO => {
                const nn: *const vk.VkBufferViewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkImageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO => {
                const nn: *const vk.VkImageViewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO => {
                const nn: *const vk.VkShaderModuleCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO => {
                const nn: *const vk.VkPipelineCacheCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineInputAssemblyStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineViewportStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineMultisampleStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDepthStencilStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineColorBlendStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDynamicStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkGraphicsPipelineCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkComputePipelineCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkPipelineLayoutCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO => {
                const nn: *const vk.VkSamplerCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET => {
                const nn: *const vk.VkWriteDescriptorSet = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET => {
                const nn: *const vk.VkCopyDescriptorSet = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO => {
                const nn: *const vk.VkFramebufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO => {
                const nn: *const vk.VkRenderPassCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO => {
                const nn: *const vk.VkCommandPoolCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO => {
                const nn: *const vk.VkCommandBufferAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER => {
                const nn: *const vk.VkBufferMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER => {
                const nn: *const vk.VkImageMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER => {
                const nn: *const vk.VkMemoryBarrier = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO => {
                const nn: *const vk.VkBindBufferMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO => {
                const nn: *const vk.VkBindImageMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice16BitStorageFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS => {
                const nn: *const vk.VkMemoryDedicatedRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO => {
                const nn: *const vk.VkMemoryAllocateFlagsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupRenderPassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO => {
                const nn: *const vk.VkDeviceGroupSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO => {
                const nn: *const vk.VkDeviceGroupBindSparseInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindBufferMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindImageMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceGroupProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceGroupDeviceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkBufferMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageSparseMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkMemoryRequirements2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkSparseImageMemoryRequirements2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 => {
                const nn: *const vk.VkPhysicalDeviceFeatures2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkImageFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceImageFormatInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 => {
                const nn: *const vk.VkQueueFamilyProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceMemoryProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkSparseImageFormatProperties2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceSparseImageFormatInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePointClippingProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO => {
                const nn: *const vk.VkRenderPassInputAttachmentAspectCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageViewUsageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO => {
                const nn: *const vk.VkRenderPassMultiviewCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVariablePointersFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO => {
                const nn: *const vk.VkProtectedSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 => {
                const nn: *const vk.VkDeviceQueueInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO => {
                const nn: *const vk.VkBindImagePlaneMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO => {
                const nn: *const vk.VkImagePlaneMemoryRequirementsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkSamplerYcbcrConversionImageFormatProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO => {
                const nn: *const vk.VkDescriptorUpdateTemplateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalImageFormatInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkExternalImageFormatProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalBufferInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES => {
                const nn: *const vk.VkExternalBufferProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceIDProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryBufferCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryImageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkExportMemoryAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalFenceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES => {
                const nn: *const vk.VkExternalFenceProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO => {
                const nn: *const vk.VkExportFenceCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkExportSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalSemaphoreInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkExternalSemaphoreProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance3Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetLayoutSupport = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO => {
                const nn: *const vk.VkImageFormatListCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 => {
                const nn: *const vk.VkAttachmentDescription2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 => {
                const nn: *const vk.VkAttachmentReference2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 => {
                const nn: *const vk.VkSubpassDescription2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 => {
                const nn: *const vk.VkSubpassDependency2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 => {
                const nn: *const vk.VkRenderPassCreateInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO => {
                const nn: *const vk.VkSubpassBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO => {
                const nn: *const vk.VkSubpassEndInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice8BitStorageFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDriverProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicInt64Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat16Int8Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceFloatControlsProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDepthStencilResolveProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE => {
                const nn: *const vk.VkSubpassDescriptionDepthStencilResolve = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageStencilUsageCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO => {
                const nn: *const vk.VkSamplerReductionModeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentsCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassAttachmentBeginInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentReferenceStencilLayout = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentDescriptionStencilLayout = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostQueryResetFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreTypeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkTimelineSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO => {
                const nn: *const vk.VkSemaphoreWaitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO => {
                const nn: *const vk.VkSemaphoreSignalInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO => {
                const nn: *const vk.VkBufferDeviceAddressInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO => {
                const nn: *const vk.VkBufferOpaqueCaptureAddressCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO => {
                const nn: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreationFeedbackCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceToolProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePrivateDataFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO => {
                const nn: *const vk.VkDevicePrivateDataCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO => {
                const nn: *const vk.VkPrivateDataSlotCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkBufferMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkImageMemoryBarrier2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO => {
                const nn: *const vk.VkDependencyInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2 => {
                const nn: *const vk.VkSubmitInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO => {
                const nn: *const vk.VkCommandBufferSubmitInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSynchronization2Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImageRobustnessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyBufferInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyBufferToImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyImageToBufferInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 => {
                const nn: *const vk.VkBlitImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 => {
                const nn: *const vk.VkResolveImageInfo2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2 => {
                const nn: *const vk.VkBufferCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2 => {
                const nn: *const vk.VkImageCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2 => {
                const nn: *const vk.VkImageBlit2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 => {
                const nn: *const vk.VkBufferImageCopy2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 => {
                const nn: *const vk.VkImageResolve2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK => {
                const nn: *const vk.VkWriteDescriptorSetInlineUniformBlock = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INFO => {
                const nn: *const vk.VkRenderingInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO => {
                const nn: *const vk.VkRenderingAttachmentInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO => {
                const nn: *const vk.VkPipelineRenderingCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceRenderingInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 => {
                const nn: *const vk.VkFormatProperties3 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceBufferMemoryRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceImageMemoryRequirements = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueGlobalPriorityCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES => {
                const nn: *const vk.VkQueueFamilyGlobalPriorityProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloatControls2Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationLineStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputDivisorStateCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceIndexTypeUint8Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO => {
                const nn: *const vk.VkMemoryMapInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO => {
                const nn: *const vk.VkMemoryUnmapInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO => {
                const nn: *const vk.VkRenderingAreaInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO => {
                const nn: *const vk.VkDeviceImageSubresourceInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 => {
                const nn: *const vk.VkSubresourceLayout2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 => {
                const nn: *const vk.VkImageSubresource2 = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreateFlags2CreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkBufferUsageFlags2CreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePushDescriptorProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO => {
                const nn: *const vk.VkRenderingAttachmentLocationInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO => {
                const nn: *const vk.VkRenderingInputAttachmentIndexInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Features = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Properties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS => {
                const nn: *const vk.VkBindMemoryStatus = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO => {
                const nn: *const vk.VkBindDescriptorSetsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO => {
                const nn: *const vk.VkPushConstantsInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO => {
                const nn: *const vk.VkPushDescriptorSetInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO => {
                const nn: *const vk.VkPushDescriptorSetWithTemplateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO => {
                const nn: *const vk.VkPipelineRobustnessCreateInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyFeatures = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyProperties = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY => {
                const nn: *const vk.VkMemoryToImageCopy = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY => {
                const nn: *const vk.VkImageToMemoryCopy = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO => {
                const nn: *const vk.VkCopyImageToMemoryInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyMemoryToImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO => {
                const nn: *const vk.VkHostImageLayoutTransitionInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyImageToImageInfo = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE => {
                const nn: *const vk.VkSubresourceHostMemcpySize = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY => {
                const nn: *const vk.VkHostImageCopyDevicePerformanceQuery = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR => {
                const nn: *const vk.VkPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR => {
                const nn: *const vk.VkDeviceGroupPresentCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkImageSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR => {
                const nn: *const vk.VkBindImageMemorySwapchainInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR => {
                const nn: *const vk.VkAcquireNextImageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplayModeCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplaySurfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDisplayPresentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugReportCallbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD => {
                const nn: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectNameInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectTagInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerMarkerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR => {
                const nn: *const vk.VkVideoProfileInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR => {
                const nn: *const vk.VkVideoPictureResourceInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR => {
                const nn: *const vk.VkVideoSessionMemoryRequirementsKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR => {
                const nn: *const vk.VkBindVideoSessionMemoryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersUpdateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoBeginCodingInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoEndCodingInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoCodingControlInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceSlotInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyVideoPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR => {
                const nn: *const vk.VkVideoProfileListInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoFormatInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoDecodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeUsageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationImageCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationBufferCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuFunctionCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX => {
                const nn: *const vk.VkCuLaunchInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleTexturingModeCreateInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX => {
                const nn: *const vk.VkImageViewHandleInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX => {
                const nn: *const vk.VkImageViewAddressPropertiesNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD => {
                const nn: *const vk.VkTextureLODGatherFormatPropertiesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalMemoryImageCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkExportMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT => {
                const nn: *const vk.VkValidationFlagsEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT => {
                const nn: *const vk.VkImageViewASTCDecodeModeEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR => {
                const nn: *const vk.VkImportMemoryFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR => {
                const nn: *const vk.VkMemoryFdPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR => {
                const nn: *const vk.VkMemoryGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR => {
                const nn: *const vk.VkImportSemaphoreFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkSemaphoreGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT => {
                const nn: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT => {
                const nn: *const vk.VkConditionalRenderingBeginInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR => {
                const nn: *const vk.VkPresentRegionsKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportWScalingStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT => {
                const nn: *const vk.VkSurfaceCapabilities2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT => {
                const nn: *const vk.VkDisplayPowerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT => {
                const nn: *const vk.VkDeviceEventInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT => {
                const nn: *const vk.VkDisplayEventInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT => {
                const nn: *const vk.VkSwapchainCounterCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX => {
                const nn: *const vk.VkMultiviewPerViewAttributesInfoNVX = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT => {
                const nn: *const vk.VkHdrMetadataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG => {
                const nn: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR => {
                const nn: *const vk.VkSharedPresentSurfaceCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR => {
                const nn: *const vk.VkImportFenceFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkFenceGetFdInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolPerformanceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR => {
                const nn: *const vk.VkPerformanceQuerySubmitInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR => {
                const nn: *const vk.VkAcquireProfilingLockInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR => {
                const nn: *const vk.VkPerformanceCounterKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR => {
                const nn: *const vk.VkPerformanceCounterDescriptionKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR => {
                const nn: *const vk.VkPhysicalDeviceSurfaceInfo2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilities2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR => {
                const nn: *const vk.VkSurfaceFormat2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayModeProperties2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR => {
                const nn: *const vk.VkDisplayPlaneInfo2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneCapabilities2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectNameInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectTagInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT => {
                const nn: *const vk.VkDebugUtilsLabelEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD => {
                const nn: *const vk.VkAttachmentSampleCountInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT => {
                const nn: *const vk.VkSampleLocationsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT => {
                const nn: *const vk.VkRenderPassSampleLocationsBeginInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT => {
                const nn: *const vk.VkMultisamplePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageToColorStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildGeometryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureDeviceAddressInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryAabbsDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryInstancesDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureVersionInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildSizesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageModulationStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesListEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierListCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesList2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderModuleValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_NV => {
                const nn: *const vk.VkGeometryNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV => {
                const nn: *const vk.VkGeometryTrianglesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV => {
                const nn: *const vk.VkGeometryAABBNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV => {
                const nn: *const vk.VkBindAccelerationStructureMemoryInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT => {
                const nn: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT => {
                const nn: *const vk.VkImportMemoryHostPointerInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT => {
                const nn: *const vk.VkMemoryHostPointerPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD => {
                const nn: *const vk.VkPipelineCompilerControlCreateInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD => {
                const nn: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV => {
                const nn: *const vk.VkCheckpointDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointProperties2NV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV => {
                const nn: *const vk.VkCheckpointData2NV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL => {
                const nn: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL => {
                const nn: *const vk.VkInitializePerformanceApiInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceMarkerInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceStreamMarkerInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceOverrideInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceConfigurationAcquireInfoINTEL = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT => {
                const nn: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT => {
                const nn: *const vk.VkMemoryPriorityAllocateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfaceProtectedCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT => {
                const nn: *const vk.VkBufferDeviceAddressCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT => {
                const nn: *const vk.VkValidationFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageReductionStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV => {
                const nn: *const vk.VkFramebufferMixedSamplesCombinationNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT => {
                const nn: *const vk.VkHeadlessSurfaceCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR => {
                const nn: *const vk.VkPipelineInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR => {
                const nn: *const vk.VkPipelineExecutablePropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR => {
                const nn: *const vk.VkPipelineExecutableInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR => {
                const nn: *const vk.VkPipelineExecutableStatisticKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR => {
                const nn: *const vk.VkPipelineExecutableInternalRepresentationKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT => {
                const nn: *const vk.VkMemoryMapPlacedInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV => {
                const nn: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTransformBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT => {
                const nn: *const vk.VkDepthBiasInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT => {
                const nn: *const vk.VkDepthBiasRepresentationInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT => {
                const nn: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceMemoryReportCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerCustomBorderColorCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineLibraryCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentBarrierNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainPresentBarrierCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlLayerInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeUsageInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersGetInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV => {
                const nn: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTileShadingCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkPerTileBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM => {
                const nn: *const vk.VkPerTileEndInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM => {
                const nn: *const vk.VkDispatchTileInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV => {
                const nn: *const vk.VkQueryLowLatencySupportNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT => {
                const nn: *const vk.VkDescriptorAddressInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT => {
                const nn: *const vk.VkDescriptorGetInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkBufferCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageViewCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkSamplerCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT => {
                const nn: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT => {
                const nn: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMotionInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCopyCommandTransformInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT => {
                const nn: *const vk.VkImageCompressionControlEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT => {
                const nn: *const vk.VkImageCompressionPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFaultFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT => {
                const nn: *const vk.VkDeviceFaultCountsEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT => {
                const nn: *const vk.VkDeviceFaultInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputBindingDescription2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputAttributeDescription2EXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDrmPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceAddressBindingCallbackDataEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkMemoryGetRemoteAddressInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT => {
                const nn: *const vk.VkPipelinePropertiesIdentifierEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT => {
                const nn: *const vk.VkFrameBoundaryEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT => {
                const nn: *const vk.VkSubpassResolvePerformanceQueryEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT => {
                const nn: *const vk.VkMultisampledRenderToSingleSampledInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorWriteCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT => {
                const nn: *const vk.VkMicromapVersionInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapToMemoryInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMemoryToMicromapInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkMicromapCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildSizesInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT => {
                const nn: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageViewSlicedCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE => {
                const nn: *const vk.VkDescriptorSetBindingReferenceVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE => {
                const nn: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeBeginInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeSubmitInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV => {
                const nn: *const vk.VkComputePipelineIndirectBufferInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkPipelineIndirectDeviceAddressInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometrySpheresDataNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM => {
                const nn: *const vk.VkImageViewSampleWeightCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT => {
                const nn: *const vk.VkExternalMemoryAcquireUnmodifiedEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT => {
                const nn: *const vk.VkRenderPassCreationControlEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingInfoLUNARG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingListLUNARG = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorViewCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindTensorMemoryInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM => {
                const nn: *const vk.VkWriteDescriptorSetTensorARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM => {
                const nn: *const vk.VkTensorFormatPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM => {
                const nn: *const vk.VkTensorDescriptionARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkTensorMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM => {
                const nn: *const vk.VkTensorMemoryBarrierARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM => {
                const nn: *const vk.VkDeviceTensorMemoryRequirementsARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM => {
                const nn: *const vk.VkCopyTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_COPY_ARM => {
                const nn: *const vk.VkTensorCopyARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM => {
                const nn: *const vk.VkTensorDependencyInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfoTensorARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceExternalTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkExternalTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkExternalMemoryTensorCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM => {
                const nn: *const vk.VkDescriptorGetTensorInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorViewCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM => {
                const nn: *const vk.VkFrameBoundaryTensorsARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT => {
                const nn: *const vk.VkShaderModuleIdentifierEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowExecuteInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD => {
                const nn: *const vk.VkAntiLagDataAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD => {
                const nn: *const vk.VkAntiLagPresentationInfoAMD = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentWait2KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR => {
                const nn: *const vk.VkPresentWait2InfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR => {
                const nn: *const vk.VkPipelineBinaryKeyKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR => {
                const nn: *const vk.VkReleaseCapturedPipelineDataInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryDataInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR => {
                const nn: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryHandlesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM => {
                const nn: *const vk.VkTilePropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC => {
                const nn: *const vk.VkAmigoProfilingSubmitInfoSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR => {
                const nn: *const vk.VkSurfacePresentModeKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfacePresentScalingCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR => {
                const nn: *const vk.VkSurfacePresentModeCompatibilityKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentFenceInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModesCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModeInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentScalingCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR => {
                const nn: *const vk.VkReleaseSwapchainImagesInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV => {
                const nn: *const vk.VkConvertCooperativeVectorMatrixInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT => {
                const nn: *const vk.VkMutableDescriptorTypeCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT => {
                const nn: *const vk.VkLayerSettingsCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV => {
                const nn: *const vk.VkLatencySleepModeInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV => {
                const nn: *const vk.VkLatencySleepInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkSetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkGetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV => {
                const nn: *const vk.VkLatencyTimingsFrameReportNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV => {
                const nn: *const vk.VkOutOfBandQueueTypeInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainLatencyCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV => {
                const nn: *const vk.VkLatencySurfaceCapabilitiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineResourceInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDataGraphFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM => {
                const nn: *const vk.VkDataGraphPipelinePropertyQueryResultARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineDispatchInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphProcessingEngineCreateInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphPropertiesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR => {
                const nn: *const vk.VkVideoInlineQueryInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerCubicWeightsCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM => {
                const nn: *const vk.VkBlitImageCubicWeightsInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT => {
                const nn: *const vk.VkAttachmentFeedbackLoopInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT => {
                const nn: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR => {
                const nn: *const vk.VkCalibratedTimestampInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT => {
                const nn: *const vk.VkSetDescriptorBufferOffsetsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT => {
                const nn: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM => {
                const nn: *const vk.VkTileMemoryRequirementsQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM => {
                const nn: *const vk.VkTileMemoryBindInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM => {
                const nn: *const vk.VkTileMemorySizeInfoQCOM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV => {
                const nn: *const vk.VkDisplaySurfaceStereoCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV => {
                const nn: *const vk.VkDisplayModeStereoPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatQuantizationMapPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueDeviceCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV => {
                const nn: *const vk.VkExternalComputeQueueDataParamsNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureInputInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureCommandsInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureInstancesInputNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkBuildPartitionedAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureFlagsNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetPipelineEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetShaderEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetPipelineInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsPipelineInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsShaderInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR => {
                const nn: *const vk.VkMemoryBarrierAccessFlags3KHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA => {
                const nn: *const vk.VkImageAlignmentControlCreateInfoMESA = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceFormatPackFeaturesARM = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE => {
                const nn: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT => {
                const nn: *const vk.VkRenderingEndInfoEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = @ptrCast(@alignCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            else => {
                log.warn(@src(), "Unknown struct sType: {d}", .{base_struct.sType});
                current = base_struct.pNext;
            },
        }
    }
}
pub fn chain_size(chain: anytype) usize {
    var size: usize = 0;
    var current: ?*const anyopaque = chain;
    while (current) |c| {
        const base_struct: *const vk.VkBaseInStructure = @ptrCast(@alignCast(c));
        switch (base_struct.sType) {
            vk.VK_STRUCTURE_TYPE_APPLICATION_INFO => {
                const nn: *const vk.VkApplicationInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO => {
                const nn: *const vk.VkInstanceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO => {
                const nn: *const vk.VkSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE => {
                const nn: *const vk.VkMappedMemoryRange = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO => {
                const nn: *const vk.VkBindSparseInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO => {
                const nn: *const vk.VkFenceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO => {
                const nn: *const vk.VkEventCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO => {
                const nn: *const vk.VkQueryPoolCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkBufferCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO => {
                const nn: *const vk.VkBufferViewCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkImageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO => {
                const nn: *const vk.VkImageViewCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO => {
                const nn: *const vk.VkShaderModuleCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO => {
                const nn: *const vk.VkPipelineCacheCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineInputAssemblyStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineViewportStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineMultisampleStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDepthStencilStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineColorBlendStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineDynamicStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkGraphicsPipelineCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO => {
                const nn: *const vk.VkComputePipelineCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkPipelineLayoutCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO => {
                const nn: *const vk.VkSamplerCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET => {
                const nn: *const vk.VkWriteDescriptorSet = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET => {
                const nn: *const vk.VkCopyDescriptorSet = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO => {
                const nn: *const vk.VkFramebufferCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO => {
                const nn: *const vk.VkRenderPassCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO => {
                const nn: *const vk.VkCommandPoolCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO => {
                const nn: *const vk.VkCommandBufferAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER => {
                const nn: *const vk.VkBufferMemoryBarrier = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER => {
                const nn: *const vk.VkImageMemoryBarrier = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER => {
                const nn: *const vk.VkMemoryBarrier = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO => {
                const nn: *const vk.VkBindBufferMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO => {
                const nn: *const vk.VkBindImageMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice16BitStorageFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS => {
                const nn: *const vk.VkMemoryDedicatedRequirements = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO => {
                const nn: *const vk.VkMemoryAllocateFlagsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupRenderPassBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO => {
                const nn: *const vk.VkDeviceGroupCommandBufferBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO => {
                const nn: *const vk.VkDeviceGroupSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO => {
                const nn: *const vk.VkDeviceGroupBindSparseInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindBufferMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO => {
                const nn: *const vk.VkBindImageMemoryDeviceGroupInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceGroupProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO => {
                const nn: *const vk.VkDeviceGroupDeviceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkBufferMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 => {
                const nn: *const vk.VkImageSparseMemoryRequirementsInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkMemoryRequirements2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 => {
                const nn: *const vk.VkSparseImageMemoryRequirements2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 => {
                const nn: *const vk.VkPhysicalDeviceFeatures2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkFormatProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkImageFormatProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceImageFormatInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 => {
                const nn: *const vk.VkQueueFamilyProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 => {
                const nn: *const vk.VkPhysicalDeviceMemoryProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 => {
                const nn: *const vk.VkSparseImageFormatProperties2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 => {
                const nn: *const vk.VkPhysicalDeviceSparseImageFormatInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePointClippingProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO => {
                const nn: *const vk.VkRenderPassInputAttachmentAspectCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageViewUsageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO => {
                const nn: *const vk.VkRenderPassMultiviewCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVariablePointersFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO => {
                const nn: *const vk.VkProtectedSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceProtectedMemoryProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 => {
                const nn: *const vk.VkDeviceQueueInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO => {
                const nn: *const vk.VkSamplerYcbcrConversionInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO => {
                const nn: *const vk.VkBindImagePlaneMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO => {
                const nn: *const vk.VkImagePlaneMemoryRequirementsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkSamplerYcbcrConversionImageFormatProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO => {
                const nn: *const vk.VkDescriptorUpdateTemplateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalImageFormatInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES => {
                const nn: *const vk.VkExternalImageFormatProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalBufferInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES => {
                const nn: *const vk.VkExternalBufferProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceIDProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryBufferCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO => {
                const nn: *const vk.VkExternalMemoryImageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO => {
                const nn: *const vk.VkExportMemoryAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalFenceInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES => {
                const nn: *const vk.VkExternalFenceProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO => {
                const nn: *const vk.VkExportFenceCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO => {
                const nn: *const vk.VkExportSemaphoreCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO => {
                const nn: *const vk.VkPhysicalDeviceExternalSemaphoreInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkExternalSemaphoreProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance3Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetLayoutSupport = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan11Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan12Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO => {
                const nn: *const vk.VkImageFormatListCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 => {
                const nn: *const vk.VkAttachmentDescription2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 => {
                const nn: *const vk.VkAttachmentReference2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 => {
                const nn: *const vk.VkSubpassDescription2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 => {
                const nn: *const vk.VkSubpassDependency2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 => {
                const nn: *const vk.VkRenderPassCreateInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO => {
                const nn: *const vk.VkSubpassBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_END_INFO => {
                const nn: *const vk.VkSubpassEndInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice8BitStorageFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDriverProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicInt64Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat16Int8Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceFloatControlsProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO => {
                const nn: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT => {
                const nn: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceDepthStencilResolveProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE => {
                const nn: *const vk.VkSubpassDescriptionDepthStencilResolve = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO => {
                const nn: *const vk.VkImageStencilUsageCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO => {
                const nn: *const vk.VkSamplerReductionModeCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentsCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO => {
                const nn: *const vk.VkFramebufferAttachmentImageInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO => {
                const nn: *const vk.VkRenderPassAttachmentBeginInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentReferenceStencilLayout = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT => {
                const nn: *const vk.VkAttachmentDescriptionStencilLayout = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostQueryResetFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO => {
                const nn: *const vk.VkSemaphoreTypeCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkTimelineSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO => {
                const nn: *const vk.VkSemaphoreWaitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO => {
                const nn: *const vk.VkSemaphoreSignalInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO => {
                const nn: *const vk.VkBufferDeviceAddressInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO => {
                const nn: *const vk.VkBufferOpaqueCaptureAddressCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO => {
                const nn: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO => {
                const nn: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan13Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreationFeedbackCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceToolProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePrivateDataFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO => {
                const nn: *const vk.VkDevicePrivateDataCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO => {
                const nn: *const vk.VkPrivateDataSlotCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkMemoryBarrier2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkBufferMemoryBarrier2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 => {
                const nn: *const vk.VkImageMemoryBarrier2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPENDENCY_INFO => {
                const nn: *const vk.VkDependencyInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBMIT_INFO_2 => {
                const nn: *const vk.VkSubmitInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO => {
                const nn: *const vk.VkSemaphoreSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO => {
                const nn: *const vk.VkCommandBufferSubmitInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSynchronization2Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceImageRobustnessFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyBufferInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 => {
                const nn: *const vk.VkCopyBufferToImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 => {
                const nn: *const vk.VkCopyImageToBufferInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 => {
                const nn: *const vk.VkBlitImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 => {
                const nn: *const vk.VkResolveImageInfo2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_COPY_2 => {
                const nn: *const vk.VkBufferCopy2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COPY_2 => {
                const nn: *const vk.VkImageCopy2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_BLIT_2 => {
                const nn: *const vk.VkImageBlit2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 => {
                const nn: *const vk.VkBufferImageCopy2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 => {
                const nn: *const vk.VkImageResolve2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO => {
                const nn: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK => {
                const nn: *const vk.VkWriteDescriptorSetInlineUniformBlock = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO => {
                const nn: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INFO => {
                const nn: *const vk.VkRenderingInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO => {
                const nn: *const vk.VkRenderingAttachmentInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO => {
                const nn: *const vk.VkPipelineRenderingCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO => {
                const nn: *const vk.VkCommandBufferInheritanceRenderingInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 => {
                const nn: *const vk.VkFormatProperties3 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceBufferMemoryRequirements = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS => {
                const nn: *const vk.VkDeviceImageMemoryRequirements = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVulkan14Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO => {
                const nn: *const vk.VkDeviceQueueGlobalPriorityCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES => {
                const nn: *const vk.VkQueueFamilyGlobalPriorityProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloatControls2Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineRasterizationLineStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO => {
                const nn: *const vk.VkPipelineVertexInputDivisorStateCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceIndexTypeUint8Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO => {
                const nn: *const vk.VkMemoryMapInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO => {
                const nn: *const vk.VkMemoryUnmapInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO => {
                const nn: *const vk.VkRenderingAreaInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO => {
                const nn: *const vk.VkDeviceImageSubresourceInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 => {
                const nn: *const vk.VkSubresourceLayout2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 => {
                const nn: *const vk.VkImageSubresource2 = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkPipelineCreateFlags2CreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO => {
                const nn: *const vk.VkBufferUsageFlags2CreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePushDescriptorProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO => {
                const nn: *const vk.VkRenderingAttachmentLocationInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO => {
                const nn: *const vk.VkRenderingInputAttachmentIndexInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Features = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceMaintenance6Properties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS => {
                const nn: *const vk.VkBindMemoryStatus = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO => {
                const nn: *const vk.VkBindDescriptorSetsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO => {
                const nn: *const vk.VkPushConstantsInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO => {
                const nn: *const vk.VkPushDescriptorSetInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO => {
                const nn: *const vk.VkPushDescriptorSetWithTemplateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO => {
                const nn: *const vk.VkPipelineRobustnessCreateInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyFeatures = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES => {
                const nn: *const vk.VkPhysicalDeviceHostImageCopyProperties = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY => {
                const nn: *const vk.VkMemoryToImageCopy = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY => {
                const nn: *const vk.VkImageToMemoryCopy = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO => {
                const nn: *const vk.VkCopyImageToMemoryInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyMemoryToImageInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO => {
                const nn: *const vk.VkHostImageLayoutTransitionInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO => {
                const nn: *const vk.VkCopyImageToImageInfo = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE => {
                const nn: *const vk.VkSubresourceHostMemcpySize = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY => {
                const nn: *const vk.VkHostImageCopyDevicePerformanceQuery = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR => {
                const nn: *const vk.VkPresentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR => {
                const nn: *const vk.VkDeviceGroupPresentCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkImageSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR => {
                const nn: *const vk.VkBindImageMemorySwapchainInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR => {
                const nn: *const vk.VkAcquireNextImageInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupPresentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR => {
                const nn: *const vk.VkDeviceGroupSwapchainCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplayModeCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkDisplaySurfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR => {
                const nn: *const vk.VkDisplayPresentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugReportCallbackCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD => {
                const nn: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectNameInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerObjectTagInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT => {
                const nn: *const vk.VkDebugMarkerMarkerInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR => {
                const nn: *const vk.VkVideoProfileInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR => {
                const nn: *const vk.VkVideoPictureResourceInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR => {
                const nn: *const vk.VkVideoSessionMemoryRequirementsKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR => {
                const nn: *const vk.VkBindVideoSessionMemoryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR => {
                const nn: *const vk.VkVideoSessionParametersUpdateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoBeginCodingInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR => {
                const nn: *const vk.VkVideoEndCodingInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoCodingControlInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceSlotInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyVideoPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR => {
                const nn: *const vk.VkVideoProfileListInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoFormatInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoDecodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoDecodeUsageInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationImageCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationBufferCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleCreateInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuFunctionCreateInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX => {
                const nn: *const vk.VkCuLaunchInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX => {
                const nn: *const vk.VkCuModuleTexturingModeCreateInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX => {
                const nn: *const vk.VkImageViewHandleInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX => {
                const nn: *const vk.VkImageViewAddressPropertiesNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD => {
                const nn: *const vk.VkTextureLODGatherFormatPropertiesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalMemoryImageCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV => {
                const nn: *const vk.VkExportMemoryAllocateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT => {
                const nn: *const vk.VkValidationFlagsEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT => {
                const nn: *const vk.VkImageViewASTCDecodeModeEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR => {
                const nn: *const vk.VkImportMemoryFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR => {
                const nn: *const vk.VkMemoryFdPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR => {
                const nn: *const vk.VkMemoryGetFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR => {
                const nn: *const vk.VkImportSemaphoreFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkSemaphoreGetFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT => {
                const nn: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT => {
                const nn: *const vk.VkConditionalRenderingBeginInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR => {
                const nn: *const vk.VkPresentRegionsKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportWScalingStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT => {
                const nn: *const vk.VkSurfaceCapabilities2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT => {
                const nn: *const vk.VkDisplayPowerInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT => {
                const nn: *const vk.VkDeviceEventInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT => {
                const nn: *const vk.VkDisplayEventInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT => {
                const nn: *const vk.VkSwapchainCounterCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX => {
                const nn: *const vk.VkMultiviewPerViewAttributesInfoNVX = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HDR_METADATA_EXT => {
                const nn: *const vk.VkHdrMetadataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG => {
                const nn: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR => {
                const nn: *const vk.VkSharedPresentSurfaceCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR => {
                const nn: *const vk.VkImportFenceFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR => {
                const nn: *const vk.VkFenceGetFdInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolPerformanceCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR => {
                const nn: *const vk.VkPerformanceQuerySubmitInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR => {
                const nn: *const vk.VkAcquireProfilingLockInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR => {
                const nn: *const vk.VkPerformanceCounterKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR => {
                const nn: *const vk.VkPerformanceCounterDescriptionKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR => {
                const nn: *const vk.VkPhysicalDeviceSurfaceInfo2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilities2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR => {
                const nn: *const vk.VkSurfaceFormat2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayProperties2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneProperties2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR => {
                const nn: *const vk.VkDisplayModeProperties2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR => {
                const nn: *const vk.VkDisplayPlaneInfo2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR => {
                const nn: *const vk.VkDisplayPlaneCapabilities2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectNameInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsObjectTagInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT => {
                const nn: *const vk.VkDebugUtilsLabelEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCallbackDataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT => {
                const nn: *const vk.VkDebugUtilsMessengerCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD => {
                const nn: *const vk.VkAttachmentSampleCountInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT => {
                const nn: *const vk.VkSampleLocationsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT => {
                const nn: *const vk.VkRenderPassSampleLocationsBeginInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT => {
                const nn: *const vk.VkMultisamplePropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageToColorStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildGeometryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureDeviceAddressInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryAabbsDataKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryInstancesDataKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR => {
                const nn: *const vk.VkAccelerationStructureGeometryKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureVersionInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR => {
                const nn: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR => {
                const nn: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR => {
                const nn: *const vk.VkAccelerationStructureBuildSizesInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR => {
                const nn: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageModulationStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesListEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierListCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkImageDrmFormatModifierPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT => {
                const nn: *const vk.VkDrmFormatModifierPropertiesList2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderModuleValidationCacheCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_NV => {
                const nn: *const vk.VkGeometryNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV => {
                const nn: *const vk.VkGeometryTrianglesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV => {
                const nn: *const vk.VkGeometryAABBNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV => {
                const nn: *const vk.VkBindAccelerationStructureMemoryInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetAccelerationStructureNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT => {
                const nn: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT => {
                const nn: *const vk.VkImportMemoryHostPointerInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT => {
                const nn: *const vk.VkMemoryHostPointerPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD => {
                const nn: *const vk.VkPipelineCompilerControlCreateInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD => {
                const nn: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV => {
                const nn: *const vk.VkCheckpointDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV => {
                const nn: *const vk.VkQueueFamilyCheckpointProperties2NV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV => {
                const nn: *const vk.VkCheckpointData2NV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL => {
                const nn: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL => {
                const nn: *const vk.VkInitializePerformanceApiInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceMarkerInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL => {
                const nn: *const vk.VkPerformanceStreamMarkerInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceOverrideInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL => {
                const nn: *const vk.VkPerformanceConfigurationAcquireInfoINTEL = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT => {
                const nn: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR => {
                const nn: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT => {
                const nn: *const vk.VkMemoryPriorityAllocateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfaceProtectedCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT => {
                const nn: *const vk.VkBufferDeviceAddressCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT => {
                const nn: *const vk.VkValidationFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineCoverageReductionStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV => {
                const nn: *const vk.VkFramebufferMixedSamplesCombinationNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT => {
                const nn: *const vk.VkHeadlessSurfaceCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR => {
                const nn: *const vk.VkPipelineInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR => {
                const nn: *const vk.VkPipelineExecutablePropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR => {
                const nn: *const vk.VkPipelineExecutableInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR => {
                const nn: *const vk.VkPipelineExecutableStatisticKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR => {
                const nn: *const vk.VkPipelineExecutableInternalRepresentationKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT => {
                const nn: *const vk.VkMemoryMapPlacedInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsShaderGroupCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV => {
                const nn: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV => {
                const nn: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTransformBeginInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT => {
                const nn: *const vk.VkDepthBiasInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT => {
                const nn: *const vk.VkDepthBiasRepresentationInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT => {
                const nn: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceMemoryReportCallbackDataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerCustomBorderColorCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineLibraryCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentBarrierNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainPresentBarrierCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeRateControlLayerInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeUsageInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR => {
                const nn: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQualityLevelInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersGetInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV => {
                const nn: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM => {
                const nn: *const vk.VkRenderPassTileShadingCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkPerTileBeginInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM => {
                const nn: *const vk.VkPerTileEndInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM => {
                const nn: *const vk.VkDispatchTileInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV => {
                const nn: *const vk.VkQueryLowLatencySupportNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT => {
                const nn: *const vk.VkDescriptorAddressInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT => {
                const nn: *const vk.VkDescriptorGetInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkBufferCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkImageViewCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkSamplerCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT => {
                const nn: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT => {
                const nn: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT => {
                const nn: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT => {
                const nn: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV => {
                const nn: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV => {
                const nn: *const vk.VkAccelerationStructureMotionInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM => {
                const nn: *const vk.VkCopyCommandTransformInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT => {
                const nn: *const vk.VkImageCompressionControlEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT => {
                const nn: *const vk.VkImageCompressionPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFaultFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT => {
                const nn: *const vk.VkDeviceFaultCountsEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT => {
                const nn: *const vk.VkDeviceFaultInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputBindingDescription2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT => {
                const nn: *const vk.VkVertexInputAttributeDescription2EXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDrmPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT => {
                const nn: *const vk.VkDeviceAddressBindingCallbackDataEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkMemoryGetRemoteAddressInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT => {
                const nn: *const vk.VkPipelinePropertiesIdentifierEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT => {
                const nn: *const vk.VkFrameBoundaryEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT => {
                const nn: *const vk.VkSubpassResolvePerformanceQueryEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT => {
                const nn: *const vk.VkMultisampledRenderToSingleSampledInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineColorWriteCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT => {
                const nn: *const vk.VkMicromapVersionInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT => {
                const nn: *const vk.VkCopyMicromapToMemoryInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT => {
                const nn: *const vk.VkCopyMemoryToMicromapInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT => {
                const nn: *const vk.VkMicromapCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT => {
                const nn: *const vk.VkMicromapBuildSizesInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT => {
                const nn: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT => {
                const nn: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCorePropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT => {
                const nn: *const vk.VkImageViewSlicedCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE => {
                const nn: *const vk.VkDescriptorSetBindingReferenceVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE => {
                const nn: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeBeginInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM => {
                const nn: *const vk.VkRenderPassStripeSubmitInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV => {
                const nn: *const vk.VkComputePipelineIndirectBufferInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV => {
                const nn: *const vk.VkPipelineIndirectDeviceAddressInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV => {
                const nn: *const vk.VkAccelerationStructureGeometrySpheresDataNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM => {
                const nn: *const vk.VkImageViewSampleWeightCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT => {
                const nn: *const vk.VkExternalMemoryAcquireUnmodifiedEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT => {
                const nn: *const vk.VkRenderPassCreationControlEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT => {
                const nn: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingInfoLUNARG = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG => {
                const nn: *const vk.VkDirectDriverLoadingListLUNARG = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM => {
                const nn: *const vk.VkTensorViewCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindTensorMemoryInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM => {
                const nn: *const vk.VkWriteDescriptorSetTensorARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM => {
                const nn: *const vk.VkTensorFormatPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM => {
                const nn: *const vk.VkTensorDescriptionARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkTensorMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM => {
                const nn: *const vk.VkTensorMemoryBarrierARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM => {
                const nn: *const vk.VkDeviceTensorMemoryRequirementsARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM => {
                const nn: *const vk.VkCopyTensorInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_COPY_ARM => {
                const nn: *const vk.VkTensorCopyARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM => {
                const nn: *const vk.VkTensorDependencyInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM => {
                const nn: *const vk.VkMemoryDedicatedAllocateInfoTensorARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceExternalTensorInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkExternalTensorPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM => {
                const nn: *const vk.VkExternalMemoryTensorCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM => {
                const nn: *const vk.VkDescriptorGetTensorInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM => {
                const nn: *const vk.VkTensorViewCaptureDescriptorDataInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM => {
                const nn: *const vk.VkFrameBoundaryTensorsARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT => {
                const nn: *const vk.VkShaderModuleIdentifierEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV => {
                const nn: *const vk.VkOpticalFlowImageFormatPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV => {
                const nn: *const vk.VkOpticalFlowExecuteInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV => {
                const nn: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD => {
                const nn: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD => {
                const nn: *const vk.VkAntiLagDataAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD => {
                const nn: *const vk.VkAntiLagPresentationInfoAMD = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR => {
                const nn: *const vk.VkSurfaceCapabilitiesPresentWait2KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR => {
                const nn: *const vk.VkPresentWait2InfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT => {
                const nn: *const vk.VkShaderCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR => {
                const nn: *const vk.VkPipelineBinaryKeyKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR => {
                const nn: *const vk.VkReleaseCapturedPipelineDataInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryDataInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR => {
                const nn: *const vk.VkPipelineCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR => {
                const nn: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR => {
                const nn: *const vk.VkPipelineBinaryHandlesInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM => {
                const nn: *const vk.VkTilePropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC => {
                const nn: *const vk.VkAmigoProfilingSubmitInfoSEC = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR => {
                const nn: *const vk.VkSurfacePresentModeKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR => {
                const nn: *const vk.VkSurfacePresentScalingCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR => {
                const nn: *const vk.VkSurfacePresentModeCompatibilityKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentFenceInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModesCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentModeInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR => {
                const nn: *const vk.VkSwapchainPresentScalingCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR => {
                const nn: *const vk.VkReleaseSwapchainImagesInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeVectorPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV => {
                const nn: *const vk.VkConvertCooperativeVectorMatrixInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT => {
                const nn: *const vk.VkMutableDescriptorTypeCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT => {
                const nn: *const vk.VkLayerSettingsCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV => {
                const nn: *const vk.VkLatencySleepModeInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV => {
                const nn: *const vk.VkLatencySleepInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkSetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV => {
                const nn: *const vk.VkGetLatencyMarkerInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV => {
                const nn: *const vk.VkLatencyTimingsFrameReportNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV => {
                const nn: *const vk.VkOutOfBandQueueTypeInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV => {
                const nn: *const vk.VkSwapchainLatencyCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV => {
                const nn: *const vk.VkLatencySurfaceCapabilitiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineResourceInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM => {
                const nn: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceDataGraphFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM => {
                const nn: *const vk.VkDataGraphPipelinePropertyQueryResultARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM => {
                const nn: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineDispatchInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM => {
                const nn: *const vk.VkDataGraphProcessingEngineCreateInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM => {
                const nn: *const vk.VkQueueFamilyDataGraphPropertiesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM => {
                const nn: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM => {
                const nn: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM => {
                const nn: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR => {
                const nn: *const vk.VkVideoInlineQueryInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerCubicWeightsCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM => {
                const nn: *const vk.VkBlitImageCubicWeightsInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM => {
                const nn: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT => {
                const nn: *const vk.VkAttachmentFeedbackLoopInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT => {
                const nn: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR => {
                const nn: *const vk.VkCalibratedTimestampInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT => {
                const nn: *const vk.VkSetDescriptorBufferOffsetsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT => {
                const nn: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM => {
                const nn: *const vk.VkTileMemoryRequirementsQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM => {
                const nn: *const vk.VkTileMemoryBindInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM => {
                const nn: *const vk.VkTileMemorySizeInfoQCOM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV => {
                const nn: *const vk.VkDisplaySurfaceStereoCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV => {
                const nn: *const vk.VkDisplayModeStereoPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR => {
                const nn: *const vk.VkVideoReferenceIntraRefreshInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR => {
                const nn: *const vk.VkVideoFormatQuantizationMapPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR => {
                const nn: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueDeviceCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV => {
                const nn: *const vk.VkExternalComputeQueueCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV => {
                const nn: *const vk.VkExternalComputeQueueDataParamsNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV => {
                const nn: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureInputInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV => {
                const nn: *const vk.VkClusterAccelerationStructureCommandsInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV => {
                const nn: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV => {
                const nn: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureInstancesInputNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV => {
                const nn: *const vk.VkBuildPartitionedAccelerationStructureInfoNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV => {
                const nn: *const vk.VkPartitionedAccelerationStructureFlagsNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT => {
                const nn: *const vk.VkIndirectCommandsLayoutTokenEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetPipelineEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT => {
                const nn: *const vk.VkWriteIndirectExecutionSetShaderEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetPipelineInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT => {
                const nn: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsPipelineInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT => {
                const nn: *const vk.VkGeneratedCommandsShaderInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR => {
                const nn: *const vk.VkMemoryBarrierAccessFlags3KHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA => {
                const nn: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA => {
                const nn: *const vk.VkImageAlignmentControlCreateInfoMESA = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT => {
                const nn: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR => {
                const nn: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV => {
                const nn: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceFormatPackFeaturesARM = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE => {
                const nn: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT => {
                const nn: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT => {
                const nn: *const vk.VkRenderingEndInfoEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC => {
                const nn: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = @ptrCast(@alignCast(c));
                size += struct_size(nn);
                current = nn.pNext;
            },
            else => {
                log.warn(@src(), "Unknown struct sType: {d}", .{base_struct.sType});
                current = base_struct.pNext;
            },
        }
    }
    return size;
}
pub fn check_result(result: vk.VkResult) !void {
    switch (result) {
        vk.VK_SUCCESS => return,
        vk.VK_NOT_READY => {
            log.err(@src(), "Vulkan error: VK_NOT_READY", .{});
            return error.VK_NOT_READY;
        },
        vk.VK_TIMEOUT => {
            log.err(@src(), "Vulkan error: VK_TIMEOUT", .{});
            return error.VK_TIMEOUT;
        },
        vk.VK_EVENT_SET => {
            log.err(@src(), "Vulkan error: VK_EVENT_SET", .{});
            return error.VK_EVENT_SET;
        },
        vk.VK_EVENT_RESET => {
            log.err(@src(), "Vulkan error: VK_EVENT_RESET", .{});
            return error.VK_EVENT_RESET;
        },
        vk.VK_INCOMPLETE => {
            log.err(@src(), "Vulkan error: VK_INCOMPLETE", .{});
            return error.VK_INCOMPLETE;
        },
        vk.VK_ERROR_OUT_OF_HOST_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_HOST_MEMORY", .{});
            return error.VK_ERROR_OUT_OF_HOST_MEMORY;
        },
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DEVICE_MEMORY", .{});
            return error.VK_ERROR_OUT_OF_DEVICE_MEMORY;
        },
        vk.VK_ERROR_INITIALIZATION_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_INITIALIZATION_FAILED", .{});
            return error.VK_ERROR_INITIALIZATION_FAILED;
        },
        vk.VK_ERROR_DEVICE_LOST => {
            log.err(@src(), "Vulkan error: VK_ERROR_DEVICE_LOST", .{});
            return error.VK_ERROR_DEVICE_LOST;
        },
        vk.VK_ERROR_MEMORY_MAP_FAILED => {
            log.err(@src(), "Vulkan error: VK_ERROR_MEMORY_MAP_FAILED", .{});
            return error.VK_ERROR_MEMORY_MAP_FAILED;
        },
        vk.VK_ERROR_LAYER_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_LAYER_NOT_PRESENT", .{});
            return error.VK_ERROR_LAYER_NOT_PRESENT;
        },
        vk.VK_ERROR_EXTENSION_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_EXTENSION_NOT_PRESENT", .{});
            return error.VK_ERROR_EXTENSION_NOT_PRESENT;
        },
        vk.VK_ERROR_FEATURE_NOT_PRESENT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FEATURE_NOT_PRESENT", .{});
            return error.VK_ERROR_FEATURE_NOT_PRESENT;
        },
        vk.VK_ERROR_INCOMPATIBLE_DRIVER => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DRIVER", .{});
            return error.VK_ERROR_INCOMPATIBLE_DRIVER;
        },
        vk.VK_ERROR_TOO_MANY_OBJECTS => {
            log.err(@src(), "Vulkan error: VK_ERROR_TOO_MANY_OBJECTS", .{});
            return error.VK_ERROR_TOO_MANY_OBJECTS;
        },
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_FORMAT_NOT_SUPPORTED", .{});
            return error.VK_ERROR_FORMAT_NOT_SUPPORTED;
        },
        vk.VK_ERROR_FRAGMENTED_POOL => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTED_POOL", .{});
            return error.VK_ERROR_FRAGMENTED_POOL;
        },
        vk.VK_ERROR_UNKNOWN => {
            log.err(@src(), "Vulkan error: VK_ERROR_UNKNOWN", .{});
            return error.VK_ERROR_UNKNOWN;
        },
        vk.VK_ERROR_OUT_OF_POOL_MEMORY => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY", .{});
            return error.VK_ERROR_OUT_OF_POOL_MEMORY;
        },
        vk.VK_ERROR_INVALID_EXTERNAL_HANDLE => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE", .{});
            return error.VK_ERROR_INVALID_EXTERNAL_HANDLE;
        },
        vk.VK_ERROR_FRAGMENTATION => {
            log.err(@src(), "Vulkan error: VK_ERROR_FRAGMENTATION", .{});
            return error.VK_ERROR_FRAGMENTATION;
        },
        vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS", .{});
            return error.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
        },
        vk.VK_PIPELINE_COMPILE_REQUIRED => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_COMPILE_REQUIRED", .{});
            return error.VK_PIPELINE_COMPILE_REQUIRED;
        },
        vk.VK_ERROR_NOT_PERMITTED => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_PERMITTED", .{});
            return error.VK_ERROR_NOT_PERMITTED;
        },
        vk.VK_ERROR_SURFACE_LOST_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_SURFACE_LOST_KHR", .{});
            return error.VK_ERROR_SURFACE_LOST_KHR;
        },
        vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR", .{});
            return error.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;
        },
        vk.VK_SUBOPTIMAL_KHR => {
            log.err(@src(), "Vulkan error: VK_SUBOPTIMAL_KHR", .{});
            return error.VK_SUBOPTIMAL_KHR;
        },
        vk.VK_ERROR_OUT_OF_DATE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR", .{});
            return error.VK_ERROR_OUT_OF_DATE_KHR;
        },
        vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR", .{});
            return error.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR;
        },
        vk.VK_ERROR_VALIDATION_FAILED_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_VALIDATION_FAILED_EXT", .{});
            return error.VK_ERROR_VALIDATION_FAILED_EXT;
        },
        vk.VK_ERROR_INVALID_SHADER_NV => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_SHADER_NV", .{});
            return error.VK_ERROR_INVALID_SHADER_NV;
        },
        vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR", .{});
            return error.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR", .{});
            return error.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR", .{});
            return error.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR", .{});
            return error.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR", .{});
            return error.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR", .{});
            return error.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR;
        },
        vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT", .{});
            return error.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT;
        },
        vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT", .{});
            return error.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT;
        },
        vk.VK_THREAD_IDLE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_IDLE_KHR", .{});
            return error.VK_THREAD_IDLE_KHR;
        },
        vk.VK_THREAD_DONE_KHR => {
            log.err(@src(), "Vulkan error: VK_THREAD_DONE_KHR", .{});
            return error.VK_THREAD_DONE_KHR;
        },
        vk.VK_OPERATION_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_DEFERRED_KHR", .{});
            return error.VK_OPERATION_DEFERRED_KHR;
        },
        vk.VK_OPERATION_NOT_DEFERRED_KHR => {
            log.err(@src(), "Vulkan error: VK_OPERATION_NOT_DEFERRED_KHR", .{});
            return error.VK_OPERATION_NOT_DEFERRED_KHR;
        },
        vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR", .{});
            return error.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR;
        },
        vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT => {
            log.err(@src(), "Vulkan error: VK_ERROR_COMPRESSION_EXHAUSTED_EXT", .{});
            return error.VK_ERROR_COMPRESSION_EXHAUSTED_EXT;
        },
        vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT => {
            log.err(@src(), "Vulkan error: VK_INCOMPATIBLE_SHADER_BINARY_EXT", .{});
            return error.VK_INCOMPATIBLE_SHADER_BINARY_EXT;
        },
        vk.VK_PIPELINE_BINARY_MISSING_KHR => {
            log.err(@src(), "Vulkan error: VK_PIPELINE_BINARY_MISSING_KHR", .{});
            return error.VK_PIPELINE_BINARY_MISSING_KHR;
        },
        vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR => {
            log.err(@src(), "Vulkan error: VK_ERROR_NOT_ENOUGH_SPACE_KHR", .{});
            return error.VK_ERROR_NOT_ENOUGH_SPACE_KHR;
        },
        else => {
            log.err(@src(), "Vulkan error: UNKNOWN {}", .{result});
            return error.UNKNOWN;
        },
    }
}
pub const Extensions = struct {
    instance: packed struct(u26) {
        VK_KHR_surface: bool = false,
        VK_KHR_display: bool = false,
        VK_EXT_debug_report: bool = false,
        VK_KHR_get_physical_device_properties2: bool = false,
        VK_EXT_validation_flags: bool = false,
        VK_KHR_device_group_creation: bool = false,
        VK_KHR_external_memory_capabilities: bool = false,
        VK_KHR_external_semaphore_capabilities: bool = false,
        VK_EXT_direct_mode_display: bool = false,
        VK_EXT_display_surface_counter: bool = false,
        VK_EXT_swapchain_colorspace: bool = false,
        VK_KHR_external_fence_capabilities: bool = false,
        VK_KHR_get_surface_capabilities2: bool = false,
        VK_KHR_get_display_properties2: bool = false,
        VK_EXT_debug_utils: bool = false,
        VK_EXT_metal_surface: bool = false,
        VK_KHR_surface_protected_capabilities: bool = false,
        VK_EXT_validation_features: bool = false,
        VK_EXT_headless_surface: bool = false,
        VK_EXT_surface_maintenance1: bool = false,
        VK_EXT_acquire_drm_display: bool = false,
        VK_EXT_directfb_surface: bool = false,
        VK_KHR_portability_enumeration: bool = false,
        VK_EXT_application_parameters: bool = false,
        VK_KHR_surface_maintenance1: bool = false,
        VK_EXT_layer_settings: bool = false,
    } = .{},
    device: packed struct(u260) {
        VK_KHR_swapchain: bool = false,
        VK_KHR_display_swapchain: bool = false,
        VK_EXT_depth_range_unrestricted: bool = false,
        VK_IMG_filter_cubic: bool = false,
        VK_EXT_debug_marker: bool = false,
        VK_KHR_video_queue: bool = false,
        VK_KHR_video_decode_queue: bool = false,
        VK_EXT_transform_feedback: bool = false,
        VK_KHR_video_encode_h264: bool = false,
        VK_KHR_video_encode_h265: bool = false,
        VK_KHR_video_decode_h264: bool = false,
        VK_KHR_dynamic_rendering: bool = false,
        VK_KHR_multiview: bool = false,
        VK_IMG_format_pvrtc: bool = false,
        VK_KHR_device_group: bool = false,
        VK_KHR_shader_draw_parameters: bool = false,
        VK_EXT_shader_subgroup_ballot: bool = false,
        VK_EXT_shader_subgroup_vote: bool = false,
        VK_EXT_texture_compression_astc_hdr: bool = false,
        VK_EXT_astc_decode_mode: bool = false,
        VK_EXT_pipeline_robustness: bool = false,
        VK_KHR_maintenance1: bool = false,
        VK_KHR_external_memory: bool = false,
        VK_KHR_external_memory_fd: bool = false,
        VK_KHR_external_semaphore: bool = false,
        VK_KHR_external_semaphore_fd: bool = false,
        VK_KHR_push_descriptor: bool = false,
        VK_EXT_conditional_rendering: bool = false,
        VK_KHR_shader_float16_int8: bool = false,
        VK_KHR_16bit_storage: bool = false,
        VK_KHR_incremental_present: bool = false,
        VK_KHR_descriptor_update_template: bool = false,
        VK_EXT_display_control: bool = false,
        VK_EXT_discard_rectangles: bool = false,
        VK_EXT_conservative_rasterization: bool = false,
        VK_EXT_depth_clip_enable: bool = false,
        VK_EXT_hdr_metadata: bool = false,
        VK_KHR_imageless_framebuffer: bool = false,
        VK_KHR_create_renderpass2: bool = false,
        VK_IMG_relaxed_line_rasterization: bool = false,
        VK_KHR_shared_presentable_image: bool = false,
        VK_KHR_external_fence: bool = false,
        VK_KHR_external_fence_fd: bool = false,
        VK_KHR_performance_query: bool = false,
        VK_KHR_maintenance2: bool = false,
        VK_KHR_variable_pointers: bool = false,
        VK_EXT_external_memory_dma_buf: bool = false,
        VK_EXT_queue_family_foreign: bool = false,
        VK_KHR_dedicated_allocation: bool = false,
        VK_EXT_sampler_filter_minmax: bool = false,
        VK_KHR_storage_buffer_storage_class: bool = false,
        VK_EXT_inline_uniform_block: bool = false,
        VK_EXT_shader_stencil_export: bool = false,
        VK_KHR_shader_bfloat16: bool = false,
        VK_EXT_sample_locations: bool = false,
        VK_KHR_relaxed_block_layout: bool = false,
        VK_KHR_get_memory_requirements2: bool = false,
        VK_KHR_image_format_list: bool = false,
        VK_EXT_blend_operation_advanced: bool = false,
        VK_KHR_acceleration_structure: bool = false,
        VK_KHR_ray_tracing_pipeline: bool = false,
        VK_KHR_ray_query: bool = false,
        VK_EXT_post_depth_coverage: bool = false,
        VK_KHR_sampler_ycbcr_conversion: bool = false,
        VK_KHR_bind_memory2: bool = false,
        VK_EXT_image_drm_format_modifier: bool = false,
        VK_EXT_validation_cache: bool = false,
        VK_EXT_descriptor_indexing: bool = false,
        VK_EXT_shader_viewport_index_layer: bool = false,
        VK_KHR_portability_subset: bool = false,
        VK_KHR_maintenance3: bool = false,
        VK_KHR_draw_indirect_count: bool = false,
        VK_EXT_filter_cubic: bool = false,
        VK_QCOM_render_pass_shader_resolve: bool = false,
        VK_EXT_global_priority: bool = false,
        VK_KHR_shader_subgroup_extended_types: bool = false,
        VK_KHR_8bit_storage: bool = false,
        VK_EXT_external_memory_host: bool = false,
        VK_KHR_shader_atomic_int64: bool = false,
        VK_KHR_shader_clock: bool = false,
        VK_EXT_calibrated_timestamps: bool = false,
        VK_KHR_video_decode_h265: bool = false,
        VK_KHR_global_priority: bool = false,
        VK_EXT_vertex_attribute_divisor: bool = false,
        VK_EXT_pipeline_creation_feedback: bool = false,
        VK_KHR_driver_properties: bool = false,
        VK_KHR_shader_float_controls: bool = false,
        VK_KHR_depth_stencil_resolve: bool = false,
        VK_KHR_swapchain_mutable_format: bool = false,
        VK_KHR_timeline_semaphore: bool = false,
        VK_INTEL_shader_integer_functions2: bool = false,
        VK_INTEL_performance_query: bool = false,
        VK_KHR_vulkan_memory_model: bool = false,
        VK_EXT_pci_bus_info: bool = false,
        VK_KHR_shader_terminate_invocation: bool = false,
        VK_EXT_fragment_density_map: bool = false,
        VK_EXT_scalar_block_layout: bool = false,
        VK_EXT_subgroup_size_control: bool = false,
        VK_KHR_fragment_shading_rate: bool = false,
        VK_KHR_dynamic_rendering_local_read: bool = false,
        VK_EXT_shader_image_atomic_int64: bool = false,
        VK_KHR_shader_quad_control: bool = false,
        VK_KHR_spirv_1_4: bool = false,
        VK_EXT_memory_budget: bool = false,
        VK_EXT_memory_priority: bool = false,
        VK_KHR_separate_depth_stencil_layouts: bool = false,
        VK_EXT_buffer_device_address: bool = false,
        VK_EXT_tooling_info: bool = false,
        VK_EXT_separate_stencil_usage: bool = false,
        VK_KHR_present_wait: bool = false,
        VK_EXT_fragment_shader_interlock: bool = false,
        VK_EXT_ycbcr_image_arrays: bool = false,
        VK_KHR_uniform_buffer_standard_layout: bool = false,
        VK_EXT_provoking_vertex: bool = false,
        VK_EXT_full_screen_exclusive: bool = false,
        VK_KHR_buffer_device_address: bool = false,
        VK_EXT_line_rasterization: bool = false,
        VK_EXT_shader_atomic_float: bool = false,
        VK_EXT_host_query_reset: bool = false,
        VK_EXT_index_type_uint8: bool = false,
        VK_EXT_extended_dynamic_state: bool = false,
        VK_KHR_deferred_host_operations: bool = false,
        VK_KHR_pipeline_executable_properties: bool = false,
        VK_EXT_host_image_copy: bool = false,
        VK_KHR_map_memory2: bool = false,
        VK_EXT_map_memory_placed: bool = false,
        VK_EXT_shader_atomic_float2: bool = false,
        VK_EXT_swapchain_maintenance1: bool = false,
        VK_EXT_shader_demote_to_helper_invocation: bool = false,
        VK_KHR_shader_integer_dot_product: bool = false,
        VK_EXT_texel_buffer_alignment: bool = false,
        VK_QCOM_render_pass_transform: bool = false,
        VK_EXT_depth_bias_control: bool = false,
        VK_EXT_device_memory_report: bool = false,
        VK_EXT_robustness2: bool = false,
        VK_EXT_custom_border_color: bool = false,
        VK_KHR_pipeline_library: bool = false,
        VK_KHR_shader_non_semantic_info: bool = false,
        VK_KHR_present_id: bool = false,
        VK_EXT_private_data: bool = false,
        VK_EXT_pipeline_creation_cache_control: bool = false,
        VK_KHR_video_encode_queue: bool = false,
        VK_QCOM_render_pass_store_ops: bool = false,
        VK_KHR_object_refresh: bool = false,
        VK_QCOM_tile_shading: bool = false,
        VK_EXT_metal_objects: bool = false,
        VK_KHR_synchronization2: bool = false,
        VK_EXT_descriptor_buffer: bool = false,
        VK_EXT_graphics_pipeline_library: bool = false,
        VK_KHR_fragment_shader_barycentric: bool = false,
        VK_KHR_shader_subgroup_uniform_control_flow: bool = false,
        VK_KHR_zero_initialize_workgroup_memory: bool = false,
        VK_EXT_mesh_shader: bool = false,
        VK_EXT_ycbcr_2plane_444_formats: bool = false,
        VK_EXT_fragment_density_map2: bool = false,
        VK_QCOM_rotated_copy_commands: bool = false,
        VK_EXT_image_robustness: bool = false,
        VK_KHR_workgroup_memory_explicit_layout: bool = false,
        VK_KHR_copy_commands2: bool = false,
        VK_EXT_image_compression_control: bool = false,
        VK_EXT_attachment_feedback_loop_layout: bool = false,
        VK_EXT_4444_formats: bool = false,
        VK_EXT_device_fault: bool = false,
        VK_EXT_rgba10x6_formats: bool = false,
        VK_VALVE_mutable_descriptor_type: bool = false,
        VK_EXT_vertex_input_dynamic_state: bool = false,
        VK_EXT_physical_device_drm: bool = false,
        VK_EXT_device_address_binding_report: bool = false,
        VK_EXT_depth_clip_control: bool = false,
        VK_EXT_primitive_topology_list_restart: bool = false,
        VK_KHR_format_feature_flags2: bool = false,
        VK_EXT_present_mode_fifo_latest_ready: bool = false,
        VK_EXT_pipeline_properties: bool = false,
        VK_EXT_frame_boundary: bool = false,
        VK_EXT_multisampled_render_to_single_sampled: bool = false,
        VK_EXT_extended_dynamic_state2: bool = false,
        VK_EXT_color_write_enable: bool = false,
        VK_EXT_primitives_generated_query: bool = false,
        VK_KHR_ray_tracing_maintenance1: bool = false,
        VK_EXT_global_priority_query: bool = false,
        VK_EXT_image_view_min_lod: bool = false,
        VK_EXT_multi_draw: bool = false,
        VK_EXT_image_2d_view_of_3d: bool = false,
        VK_EXT_shader_tile_image: bool = false,
        VK_EXT_opacity_micromap: bool = false,
        VK_EXT_load_store_op_none: bool = false,
        VK_EXT_border_color_swizzle: bool = false,
        VK_EXT_pageable_device_local_memory: bool = false,
        VK_KHR_maintenance4: bool = false,
        VK_KHR_shader_subgroup_rotate: bool = false,
        VK_EXT_image_sliced_view_of_3d: bool = false,
        VK_VALVE_descriptor_set_host_mapping: bool = false,
        VK_EXT_depth_clamp_zero_one: bool = false,
        VK_EXT_non_seamless_cube_map: bool = false,
        VK_QCOM_fragment_density_map_offset: bool = false,
        VK_KHR_shader_maximal_reconvergence: bool = false,
        VK_EXT_image_compression_control_swapchain: bool = false,
        VK_QCOM_image_processing: bool = false,
        VK_EXT_nested_command_buffer: bool = false,
        VK_EXT_external_memory_acquire_unmodified: bool = false,
        VK_EXT_extended_dynamic_state3: bool = false,
        VK_EXT_subpass_merge_feedback: bool = false,
        VK_EXT_shader_module_identifier: bool = false,
        VK_EXT_rasterization_order_attachment_access: bool = false,
        VK_EXT_legacy_dithering: bool = false,
        VK_EXT_pipeline_protected_access: bool = false,
        VK_KHR_maintenance5: bool = false,
        VK_KHR_present_id2: bool = false,
        VK_KHR_present_wait2: bool = false,
        VK_KHR_ray_tracing_position_fetch: bool = false,
        VK_EXT_shader_object: bool = false,
        VK_KHR_pipeline_binary: bool = false,
        VK_QCOM_tile_properties: bool = false,
        VK_KHR_swapchain_maintenance1: bool = false,
        VK_QCOM_multiview_per_view_viewports: bool = false,
        VK_EXT_mutable_descriptor_type: bool = false,
        VK_EXT_legacy_vertex_attributes: bool = false,
        VK_EXT_pipeline_library_group_handles: bool = false,
        VK_EXT_dynamic_rendering_unused_attachments: bool = false,
        VK_KHR_cooperative_matrix: bool = false,
        VK_QCOM_multiview_per_view_render_areas: bool = false,
        VK_KHR_compute_shader_derivatives: bool = false,
        VK_KHR_video_decode_av1: bool = false,
        VK_KHR_video_encode_av1: bool = false,
        VK_KHR_video_decode_vp9: bool = false,
        VK_KHR_video_maintenance1: bool = false,
        VK_QCOM_image_processing2: bool = false,
        VK_QCOM_filter_cubic_weights: bool = false,
        VK_QCOM_ycbcr_degamma: bool = false,
        VK_QCOM_filter_cubic_clamp: bool = false,
        VK_EXT_attachment_feedback_loop_dynamic_state: bool = false,
        VK_KHR_vertex_attribute_divisor: bool = false,
        VK_KHR_load_store_op_none: bool = false,
        VK_KHR_unified_image_layouts: bool = false,
        VK_KHR_shader_float_controls2: bool = false,
        VK_KHR_index_type_uint8: bool = false,
        VK_KHR_line_rasterization: bool = false,
        VK_KHR_calibrated_timestamps: bool = false,
        VK_KHR_shader_expect_assume: bool = false,
        VK_KHR_maintenance6: bool = false,
        VK_QCOM_tile_memory_heap: bool = false,
        VK_KHR_video_encode_intra_refresh: bool = false,
        VK_KHR_video_encode_quantization_map: bool = false,
        VK_KHR_shader_relaxed_extended_instruction: bool = false,
        VK_KHR_maintenance7: bool = false,
        VK_EXT_shader_replicated_composites: bool = false,
        VK_EXT_shader_float8: bool = false,
        VK_EXT_device_generated_commands: bool = false,
        VK_KHR_maintenance8: bool = false,
        VK_EXT_depth_clamp_control: bool = false,
        VK_KHR_maintenance9: bool = false,
        VK_KHR_video_maintenance2: bool = false,
        VK_EXT_external_memory_metal: bool = false,
        VK_KHR_depth_clamp_zero_one: bool = false,
        VK_EXT_vertex_attribute_robustness: bool = false,
        VK_VALVE_fragment_density_map_layered: bool = false,
        VK_KHR_robustness2: bool = false,
        VK_EXT_fragment_density_map_offset: bool = false,
        VK_EXT_zero_initialize_device_memory: bool = false,
        VK_KHR_present_mode_fifo_latest_ready: bool = false,
    } = .{},

    const Self = @This();

    pub fn init(
        tmp_alloc: Allocator,
        api_version: u32,
        instance_extensions: []const [*c]const u8,
        device_extensions: []const [*c]const u8,
    ) !Self {
        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        var self: Self = .{};
        if (vk.VK_API_VERSION_1_1 <= api_version) {
            self.instance.VK_KHR_get_physical_device_properties2 = true;
            self.instance.VK_KHR_device_group_creation = true;
            self.instance.VK_KHR_external_memory_capabilities = true;
            self.instance.VK_KHR_external_semaphore_capabilities = true;
            self.instance.VK_KHR_external_fence_capabilities = true;
            self.device.VK_KHR_multiview = true;
            self.device.VK_KHR_device_group = true;
            self.device.VK_KHR_shader_draw_parameters = true;
            self.device.VK_KHR_maintenance1 = true;
            self.device.VK_KHR_external_memory = true;
            self.device.VK_KHR_external_semaphore = true;
            self.device.VK_KHR_16bit_storage = true;
            self.device.VK_KHR_descriptor_update_template = true;
            self.device.VK_KHR_external_fence = true;
            self.device.VK_KHR_maintenance2 = true;
            self.device.VK_KHR_variable_pointers = true;
            self.device.VK_KHR_dedicated_allocation = true;
            self.device.VK_KHR_storage_buffer_storage_class = true;
            self.device.VK_KHR_relaxed_block_layout = true;
            self.device.VK_KHR_get_memory_requirements2 = true;
            self.device.VK_KHR_sampler_ycbcr_conversion = true;
            self.device.VK_KHR_bind_memory2 = true;
            self.device.VK_KHR_maintenance3 = true;
        }
        if (vk.VK_API_VERSION_1_2 <= api_version) {
            self.device.VK_KHR_shader_float16_int8 = true;
            self.device.VK_KHR_imageless_framebuffer = true;
            self.device.VK_KHR_create_renderpass2 = true;
            self.device.VK_EXT_sampler_filter_minmax = true;
            self.device.VK_KHR_image_format_list = true;
            self.device.VK_EXT_descriptor_indexing = true;
            self.device.VK_EXT_shader_viewport_index_layer = true;
            self.device.VK_KHR_draw_indirect_count = true;
            self.device.VK_KHR_shader_subgroup_extended_types = true;
            self.device.VK_KHR_8bit_storage = true;
            self.device.VK_KHR_shader_atomic_int64 = true;
            self.device.VK_KHR_driver_properties = true;
            self.device.VK_KHR_shader_float_controls = true;
            self.device.VK_KHR_depth_stencil_resolve = true;
            self.device.VK_KHR_timeline_semaphore = true;
            self.device.VK_KHR_vulkan_memory_model = true;
            self.device.VK_EXT_scalar_block_layout = true;
            self.device.VK_KHR_spirv_1_4 = true;
            self.device.VK_KHR_separate_depth_stencil_layouts = true;
            self.device.VK_EXT_separate_stencil_usage = true;
            self.device.VK_KHR_uniform_buffer_standard_layout = true;
            self.device.VK_KHR_buffer_device_address = true;
            self.device.VK_EXT_host_query_reset = true;
        }
        if (vk.VK_API_VERSION_1_3 <= api_version) {
            self.device.VK_KHR_dynamic_rendering = true;
            self.device.VK_EXT_texture_compression_astc_hdr = true;
            self.device.VK_EXT_inline_uniform_block = true;
            self.device.VK_EXT_pipeline_creation_feedback = true;
            self.device.VK_KHR_shader_terminate_invocation = true;
            self.device.VK_EXT_subgroup_size_control = true;
            self.device.VK_EXT_tooling_info = true;
            self.device.VK_EXT_extended_dynamic_state = true;
            self.device.VK_EXT_shader_demote_to_helper_invocation = true;
            self.device.VK_KHR_shader_integer_dot_product = true;
            self.device.VK_EXT_texel_buffer_alignment = true;
            self.device.VK_KHR_shader_non_semantic_info = true;
            self.device.VK_EXT_private_data = true;
            self.device.VK_EXT_pipeline_creation_cache_control = true;
            self.device.VK_KHR_synchronization2 = true;
            self.device.VK_KHR_zero_initialize_workgroup_memory = true;
            self.device.VK_EXT_ycbcr_2plane_444_formats = true;
            self.device.VK_EXT_image_robustness = true;
            self.device.VK_KHR_copy_commands2 = true;
            self.device.VK_EXT_4444_formats = true;
            self.device.VK_KHR_format_feature_flags2 = true;
            self.device.VK_EXT_extended_dynamic_state2 = true;
            self.device.VK_KHR_maintenance4 = true;
        }
        if (vk.VK_API_VERSION_1_4 <= api_version) {
            self.device.VK_EXT_pipeline_robustness = true;
            self.device.VK_KHR_push_descriptor = true;
            self.device.VK_KHR_global_priority = true;
            self.device.VK_KHR_dynamic_rendering_local_read = true;
            self.device.VK_EXT_host_image_copy = true;
            self.device.VK_KHR_map_memory2 = true;
            self.device.VK_KHR_shader_subgroup_rotate = true;
            self.device.VK_EXT_pipeline_protected_access = true;
            self.device.VK_KHR_maintenance5 = true;
            self.device.VK_KHR_vertex_attribute_divisor = true;
            self.device.VK_KHR_load_store_op_none = true;
            self.device.VK_KHR_shader_float_controls2 = true;
            self.device.VK_KHR_index_type_uint8 = true;
            self.device.VK_KHR_line_rasterization = true;
            self.device.VK_KHR_shader_expect_assume = true;
            self.device.VK_KHR_maintenance6 = true;
        }
        // Instance extensions
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface")) {
                self.instance.VK_KHR_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_report")) {
                self.instance.VK_EXT_debug_report = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_physical_device_properties2")) {
                self.instance.VK_KHR_get_physical_device_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_flags")) {
                self.instance.VK_EXT_validation_flags = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group_creation")) {
                self.instance.VK_KHR_device_group_creation = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_memory_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_semaphore_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_direct_mode_display") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_direct_mode_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_surface_counter") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_display_surface_counter = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_colorspace") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_swapchain_colorspace = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.instance.VK_KHR_external_fence_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_surface_capabilities2") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_get_surface_capabilities2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_display_properties2") and (self.instance.VK_KHR_display)) {
                self.instance.VK_KHR_get_display_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_utils")) {
                self.instance.VK_EXT_debug_utils = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_metal_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_protected_capabilities") and (vk.VK_API_VERSION_1_1 <= api_version and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_protected_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_features")) {
                self.instance.VK_EXT_validation_features = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_headless_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_headless_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_surface_maintenance1") and (self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_EXT_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_acquire_drm_display") and (self.instance.VK_EXT_direct_mode_display)) {
                self.instance.VK_EXT_acquire_drm_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_directfb_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_directfb_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_portability_enumeration")) {
                self.instance.VK_KHR_portability_enumeration = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_application_parameters")) {
                self.instance.VK_EXT_application_parameters = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_maintenance1") and (self.instance.VK_KHR_surface or self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_layer_settings")) {
                self.instance.VK_EXT_layer_settings = true;
                break;
            }
        }
        // Device extensions
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain") and (self.instance.VK_KHR_surface)) {
                self.device.VK_KHR_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display_swapchain") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_display)) {
                self.device.VK_KHR_display_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_range_unrestricted")) {
                self.device.VK_EXT_depth_range_unrestricted = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_filter_cubic")) {
                self.device.VK_IMG_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_marker") and (self.instance.VK_EXT_debug_report)) {
                self.device.VK_EXT_debug_marker = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_queue") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_video_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_decode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_transform_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_transform_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h264") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h265") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h264") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_multiview") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_multiview = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_format_pvrtc")) {
                self.device.VK_IMG_format_pvrtc = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group") and (self.instance.VK_KHR_device_group_creation)) {
                self.device.VK_KHR_device_group = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_draw_parameters")) {
                self.device.VK_KHR_shader_draw_parameters = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_ballot")) {
                self.device.VK_EXT_shader_subgroup_ballot = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_vote")) {
                self.device.VK_EXT_shader_subgroup_vote = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texture_compression_astc_hdr") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texture_compression_astc_hdr = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_astc_decode_mode") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_astc_decode_mode = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance1")) {
                self.device.VK_KHR_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory") and (self.instance.VK_KHR_external_memory_capabilities or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_fd") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_memory_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore") and (self.instance.VK_KHR_external_semaphore_capabilities)) {
                self.device.VK_KHR_external_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_fd") and (self.device.VK_KHR_external_semaphore or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_semaphore_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_push_descriptor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_push_descriptor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conditional_rendering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conditional_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float16_int8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float16_int8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_16bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_16bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_incremental_present") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_incremental_present = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_descriptor_update_template")) {
                self.device.VK_KHR_descriptor_update_template = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_control") and (self.instance.VK_EXT_display_surface_counter and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_display_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_discard_rectangles") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_discard_rectangles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conservative_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_conservative_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_hdr_metadata") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_hdr_metadata = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_imageless_framebuffer") and ((((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_imageless_framebuffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_create_renderpass2") and ((self.device.VK_KHR_multiview and self.device.VK_KHR_maintenance2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_create_renderpass2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_relaxed_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_IMG_relaxed_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shared_presentable_image") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_surface_capabilities2 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_KHR_shared_presentable_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence") and (self.instance.VK_KHR_external_fence_capabilities)) {
                self.device.VK_KHR_external_fence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_fd") and (self.device.VK_KHR_external_fence or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_external_fence_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_performance_query") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_performance_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance2")) {
                self.device.VK_KHR_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_variable_pointers") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_variable_pointers = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_dma_buf") and (self.device.VK_KHR_external_memory_fd)) {
                self.device.VK_EXT_external_memory_dma_buf = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_queue_family_foreign") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_queue_family_foreign = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dedicated_allocation") and (self.device.VK_KHR_get_memory_requirements2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_dedicated_allocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sampler_filter_minmax") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sampler_filter_minmax = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_storage_buffer_storage_class")) {
                self.device.VK_KHR_storage_buffer_storage_class = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_inline_uniform_block") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance1) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_inline_uniform_block = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_stencil_export")) {
                self.device.VK_EXT_shader_stencil_export = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_bfloat16") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_bfloat16 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sample_locations") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_sample_locations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_relaxed_block_layout")) {
                self.device.VK_KHR_relaxed_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_memory_requirements2")) {
                self.device.VK_KHR_get_memory_requirements2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_image_format_list")) {
                self.device.VK_KHR_image_format_list = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_blend_operation_advanced") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_blend_operation_advanced = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_acceleration_structure") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_EXT_descriptor_indexing and self.device.VK_KHR_buffer_device_address) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_deferred_host_operations)) {
                self.device.VK_KHR_acceleration_structure = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_pipeline") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_pipeline = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_query") and ((self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_post_depth_coverage")) {
                self.device.VK_EXT_post_depth_coverage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_sampler_ycbcr_conversion") and ((self.device.VK_KHR_maintenance1 and self.device.VK_KHR_bind_memory2 and self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_sampler_ycbcr_conversion = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_bind_memory2")) {
                self.device.VK_KHR_bind_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_drm_format_modifier") and ((((self.device.VK_KHR_bind_memory2 and self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_sampler_ycbcr_conversion) or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_image_format_list) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_image_drm_format_modifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_cache")) {
                self.device.VK_EXT_validation_cache = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_indexing") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance3) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_descriptor_indexing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_viewport_index_layer")) {
                self.device.VK_EXT_shader_viewport_index_layer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_portability_subset") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_portability_subset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_draw_indirect_count")) {
                self.device.VK_KHR_draw_indirect_count = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_filter_cubic")) {
                self.device.VK_EXT_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_shader_resolve")) {
                self.device.VK_QCOM_render_pass_shader_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority")) {
                self.device.VK_EXT_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_extended_types") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_extended_types = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_8bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_8bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_host") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_host = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_clock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_clock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h265") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_global_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_feedback")) {
                self.device.VK_EXT_pipeline_creation_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_driver_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_driver_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_float_controls = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_stencil_resolve") and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_depth_stencil_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_mutable_format") and (self.device.VK_KHR_swapchain and (self.device.VK_KHR_maintenance2 or vk.VK_API_VERSION_1_1 <= api_version) and (self.device.VK_KHR_image_format_list or vk.VK_API_VERSION_1_2 <= api_version))) {
                self.device.VK_KHR_swapchain_mutable_format = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_timeline_semaphore") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_timeline_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_shader_integer_functions2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_INTEL_shader_integer_functions2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_performance_query")) {
                self.device.VK_INTEL_performance_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vulkan_memory_model") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vulkan_memory_model = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pci_bus_info") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pci_bus_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_terminate_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_terminate_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_density_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_scalar_block_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_scalar_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subgroup_size_control") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subgroup_size_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shading_rate") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_fragment_shading_rate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering_local_read") and (self.device.VK_KHR_dynamic_rendering or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_dynamic_rendering_local_read = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_image_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_image_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_quad_control") and (((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_vulkan_memory_model) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_shader_maximal_reconvergence)) {
                self.device.VK_KHR_shader_quad_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_spirv_1_4") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_spirv_1_4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_budget") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_budget = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_memory_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_separate_depth_stencil_layouts") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_create_renderpass2) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_KHR_separate_depth_stencil_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_buffer_device_address") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_tooling_info")) {
                self.device.VK_EXT_tooling_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_separate_stencil_usage")) {
                self.device.VK_EXT_separate_stencil_usage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait") and (self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id)) {
                self.device.VK_KHR_present_wait = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_shader_interlock") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_fragment_shader_interlock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_image_arrays") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_image_arrays = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_uniform_buffer_standard_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_uniform_buffer_standard_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_provoking_vertex") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_provoking_vertex = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_full_screen_exclusive") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_full_screen_exclusive = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_buffer_device_address") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_device_group) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_atomic_float = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_query_reset") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_host_query_reset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_deferred_host_operations")) {
                self.device.VK_KHR_deferred_host_operations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_executable_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_pipeline_executable_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_image_copy") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_copy_commands2 and self.device.VK_KHR_format_feature_flags2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_host_image_copy = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_map_memory2")) {
                self.device.VK_KHR_map_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_map_memory_placed") and (self.device.VK_KHR_map_memory2 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_EXT_map_memory_placed = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float2") and (self.device.VK_EXT_shader_atomic_float)) {
                self.device.VK_EXT_shader_atomic_float2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_maintenance1") and (self.device.VK_KHR_swapchain and self.instance.VK_EXT_surface_maintenance1 and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_demote_to_helper_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_shader_demote_to_helper_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_integer_dot_product") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_integer_dot_product = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texel_buffer_alignment") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_texel_buffer_alignment = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_transform")) {
                self.device.VK_QCOM_render_pass_transform = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_bias_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_bias_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_memory_report") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_memory_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_custom_border_color") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_custom_border_color = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_library")) {
                self.device.VK_KHR_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_non_semantic_info")) {
                self.device.VK_KHR_shader_non_semantic_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_present_id = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_private_data") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_private_data = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_cache_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_creation_cache_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_store_ops")) {
                self.device.VK_QCOM_render_pass_store_ops = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_object_refresh")) {
                self.device.VK_KHR_object_refresh = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_shading") and (self.device.VK_QCOM_tile_properties or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_QCOM_tile_shading = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_objects")) {
                self.device.VK_EXT_metal_objects = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_synchronization2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_synchronization2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_buffer") and (((((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_buffer_device_address and self.device.VK_EXT_descriptor_indexing) or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_synchronization2) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_descriptor_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_graphics_pipeline_library") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_graphics_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shader_barycentric") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_fragment_shader_barycentric = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_uniform_control_flow") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_subgroup_uniform_control_flow = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_zero_initialize_workgroup_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_zero_initialize_workgroup_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mesh_shader") and (self.device.VK_KHR_spirv_1_4 or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_mesh_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_2plane_444_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_ycbcr_2plane_444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map2") and (self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_EXT_fragment_density_map2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_rotated_copy_commands") and (self.device.VK_KHR_copy_commands2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_rotated_copy_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_workgroup_memory_explicit_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_workgroup_memory_explicit_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_copy_commands2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_copy_commands2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_compression_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_attachment_feedback_loop_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_4444_formats") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_4444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_fault") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_device_fault = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rgba10x6_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rgba10x6_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3)) {
                self.device.VK_VALVE_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_input_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_input_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_physical_device_drm") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_physical_device_drm = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_address_binding_report") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.instance.VK_EXT_debug_utils)) {
                self.device.VK_EXT_device_address_binding_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clip_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitive_topology_list_restart") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_primitive_topology_list_restart = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_format_feature_flags2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_format_feature_flags2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_frame_boundary")) {
                self.device.VK_EXT_frame_boundary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multisampled_render_to_single_sampled") and ((self.device.VK_KHR_create_renderpass2 and self.device.VK_KHR_depth_stencil_resolve) or vk.VK_API_VERSION_1_2 <= api_version)) {
                self.device.VK_EXT_multisampled_render_to_single_sampled = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_color_write_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_color_write_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitives_generated_query") and (self.device.VK_EXT_transform_feedback)) {
                self.device.VK_EXT_primitives_generated_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_maintenance1") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority_query") and (self.device.VK_EXT_global_priority and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version))) {
                self.device.VK_EXT_global_priority_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_view_min_lod") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_view_min_lod = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multi_draw") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_multi_draw = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_2d_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_2d_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_tile_image") and (vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_tile_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_opacity_micromap") and (self.device.VK_KHR_acceleration_structure and (self.device.VK_KHR_synchronization2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_EXT_opacity_micromap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_load_store_op_none")) {
                self.device.VK_EXT_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_border_color_swizzle") and (self.device.VK_EXT_custom_border_color)) {
                self.device.VK_EXT_border_color_swizzle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pageable_device_local_memory") and (self.device.VK_EXT_memory_priority)) {
                self.device.VK_EXT_pageable_device_local_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance4") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_rotate")) {
                self.device.VK_KHR_shader_subgroup_rotate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_sliced_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_image_sliced_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_descriptor_set_host_mapping") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_VALVE_descriptor_set_host_mapping = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_non_seamless_cube_map") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_non_seamless_cube_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_QCOM_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_maximal_reconvergence") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_maximal_reconvergence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control_swapchain") and (self.device.VK_EXT_image_compression_control)) {
                self.device.VK_EXT_image_compression_control_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing") and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_QCOM_image_processing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_nested_command_buffer") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_nested_command_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_acquire_unmodified") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_acquire_unmodified = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state3") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_extended_dynamic_state3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subpass_merge_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_subpass_merge_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_module_identifier") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_pipeline_creation_cache_control) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_module_identifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rasterization_order_attachment_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_rasterization_order_attachment_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_dithering") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_legacy_dithering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_protected_access") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_pipeline_protected_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance5") and ((vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_KHR_maintenance5 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_id2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id2)) {
                self.device.VK_KHR_present_wait2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_position_fetch") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_position_fetch = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_object") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_shader_object = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_binary") and (self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version)) {
                self.device.VK_KHR_pipeline_binary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_maintenance1") and (self.device.VK_KHR_swapchain or self.instance.VK_KHR_surface_maintenance1 or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_KHR_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_viewports") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_multiview_per_view_viewports = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_vertex_attributes") and (self.device.VK_EXT_vertex_input_dynamic_state)) {
                self.device.VK_EXT_legacy_vertex_attributes = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_library_group_handles") and (self.device.VK_KHR_ray_tracing_pipeline and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_pipeline_library_group_handles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_dynamic_rendering_unused_attachments") and (((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_KHR_dynamic_rendering) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_dynamic_rendering_unused_attachments = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_cooperative_matrix") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_cooperative_matrix = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_render_areas")) {
                self.device.VK_QCOM_multiview_per_view_render_areas = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_compute_shader_derivatives") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_compute_shader_derivatives = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_av1") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_av1") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_vp9") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_vp9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance1") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing2") and (self.device.VK_QCOM_image_processing)) {
                self.device.VK_QCOM_image_processing2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_weights") and (self.device.VK_EXT_filter_cubic)) {
                self.device.VK_QCOM_filter_cubic_weights = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_ycbcr_degamma")) {
                self.device.VK_QCOM_ycbcr_degamma = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_clamp") and ((self.device.VK_EXT_filter_cubic) and (vk.VK_API_VERSION_1_2 <= api_version or self.device.VK_EXT_sampler_filter_minmax))) {
                self.device.VK_QCOM_filter_cubic_clamp = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_dynamic_state") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_attachment_feedback_loop_layout)) {
                self.device.VK_EXT_attachment_feedback_loop_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_load_store_op_none")) {
                self.device.VK_KHR_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_unified_image_layouts")) {
                self.device.VK_KHR_unified_image_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls2") and (vk.VK_API_VERSION_1_1 <= api_version and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_shader_float_controls2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_expect_assume") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_shader_expect_assume = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance6") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance6 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_memory_heap") and ((self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_QCOM_tile_memory_heap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_intra_refresh") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_intra_refresh = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_quantization_map") and (self.device.VK_KHR_video_encode_queue and (self.device.VK_KHR_format_feature_flags2 or vk.VK_API_VERSION_1_3 <= api_version))) {
                self.device.VK_KHR_video_encode_quantization_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_relaxed_extended_instruction")) {
                self.device.VK_KHR_shader_relaxed_extended_instruction = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance7") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance7 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_replicated_composites")) {
                self.device.VK_EXT_shader_replicated_composites = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_float8")) {
                self.device.VK_EXT_shader_float8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_generated_commands") and (((self.device.VK_KHR_buffer_device_address or vk.VK_API_VERSION_1_2 <= api_version) and self.device.VK_KHR_maintenance5) or vk.VK_API_VERSION_1_3 <= api_version)) {
                self.device.VK_EXT_device_generated_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance8") and (vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_control") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_depth_clamp_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance9") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_maintenance9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance2") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_metal") and (self.device.VK_KHR_external_memory or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_external_memory_metal = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_vertex_attribute_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_fragment_density_map_layered") and ((self.device.VK_KHR_maintenance5 or vk.VK_API_VERSION_1_4 <= api_version) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_VALVE_fragment_density_map_layered = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_KHR_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version) and self.device.VK_EXT_fragment_density_map and (self.device.VK_KHR_create_renderpass2 or vk.VK_API_VERSION_1_2 <= api_version) and (vk.VK_API_VERSION_1_3 <= api_version or self.device.VK_KHR_dynamic_rendering))) {
                self.device.VK_EXT_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_zero_initialize_device_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or vk.VK_API_VERSION_1_1 <= api_version)) {
                self.device.VK_EXT_zero_initialize_device_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        return self;
    }
};
